---
title:  |  
  ![](../images/R Handbook Logo.png)
author: ""
date: "Produced `r format(Sys.time(), '%A %d %B %Y')`"
output:
  html_document:
    code_folding: show
    highlight: zenburn
    number_sections: no
    theme: sandstone
    toc: yes
    toc_collapse: no
    toc_depth: 3
    toc_float: yes
params:
    run_page_ind: TRUE
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "_outputs_knitted") })
---

```{r, child= '_page_setup.Rmd', eval = params$run_page_ind, include = F}
```


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# ggplot tips {#ggplot_tips .tabset .tabset-fade}  


<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

Embed ggplot cheatsheet

`ggplot2` is the most popular data visualisation package in R, and is generally used instead of base `R` for creating figures. `ggplot2` benefits from a wide variety of supplementary packages that further enhance its functionality. Despite this, ggplot syntax is significantly different from base `R` plotting, and has a learning curve associated with it. Using `ggplot2` generally requires the user to format their data in a way that is highly `tidyverse` compatible, which ultimately makes using these packages together very effective.

Plotting with `ggplot2` is based on defining base attributes to a plot, and adding layers on top. In addition, the user can change various plot attributes like axis settings, colour schemes, and labels with additional objects that are "added" to the plot. While ggplot objects can be highly complex, the basic order of creating a ggplot looks something like this:

1. Define base/default plot attributes and aesthetic swith `ggplot()` function
2. Add geometric objects to the plot - i.e. is the plot a bar graph, a line plot, a scatter plot, or a histogram? Or is it a combination of these? These functions all start with `geom_` as a prefix.
3. Change plot aesthetics e.g. changing the axes, labels, colour scheme, background etc.

In code, this might look like this:

```{r, eval = TRUE}
# read in dataset

# define base plot attributes and dataset
ggplot(data = linelist_cleaned, mapping = aes(x = age)) +
  # add a geometric object with some parameters
  geom_histogram(binwidth = 10, fill = "red", col = "black") +
  # add labels to the axes
  labs(x = "Age in years", y = "Number of cases")
  

```

With this code, the most important things to note are:

  1. When making a ggplot, all objects are combined with a `+` sign.
  2. Understanding the principles behind aesthetic mapping with the `mappping = aes()` argument is essential to using ggplot. This can be done in the `ggplot()` function as well as every geometric object. Mapping with `aes()` is used to define which variables are assigned to each axis (these can be continuous or categorical variables). It is also used to define whether a variable can be used to create different plot aesthetics. This can apply to the:
  
    a. line colour (`col = `)
    b. filled colour (`fill = `)
    c. linetype (e.g. dotted, dashed) (`linetype =`)
    d. size of an object (`size = `)
  
  This list is not exhaustive, but is enough to give a rough overview.
  
  3. Aesthetics of geometric objects can be defined *explicitly* as in the code above - this is different from assigning them to a variable. In cases where this is done, it must be *outside* the `mapping` argument. 
  
```{r, eval = FALSE}
# correct
ggplot(data = linelist_cleaned, mapping = aes(x = age)) +
  geom_histogram(col = "black")

# incorrect
# correct
ggplot(data = linelist_cleaned, mapping = aes(x = age)) +
  geom_histogram(mapping = aes(col = "black"))

```

An example of defining aesthetics with a variable can be seen here:

```{r, eval = TRUE}
# read in dataset

# define base plot attributes and dataset
ggplot(data = linelist_cleaned, mapping = aes(x = age, fill = outcome)) +
  # add a geometric object with some parameters (NO FILL GIVEN)
  geom_histogram(binwidth = 10, col = "black") +
  # add labels to the axes
  labs(x = "Age in years", y = "Number of cases")
```


There are a huge number of different geoms that can be used, and they are all used with similar attribute names. While not exhaustive, some of the shapes that can be used are:

  1. Histograms - `geom_histogram()`
  2. Barcharts - `geom_bar()`
  3. Boxplots - `geom_boxplot()`
  4. Dot plots (for scatterplots or with discrete variables) - `geom_point()`
  5. Line graphs - `geom_line()` or `geom_path()`
  6. Trend lines - `geom_smooth()`

You can also add straight lines to your plot with `geom_hline()` (horizontal), `geom_vline()` (vertical) or `geom_abline()` (with a specified y intercept and slope)

There is much more detail we could show here, but we'll finish with an example that ties these concepts together by plotting the time between onset and hospitalisation by age with a scatterplot
  
```{r, eval = TRUE, cache.vars = TRUE}

# calculate our delay variable

linelist_cleaned <- linelist_cleaned %>%
  mutate(days_onset_to_hosp = date_hospitalisation - date_onset)

# set up the plot and define key variables
# colour is the outcome
delay_plot <- ggplot(data = linelist_cleaned,
                     aes(x = age_years, y = days_onset_to_hosp, col = outcome)) +
  # define aspects of the geom that are NOT included specific to variables
  # other attributes are inherited
  geom_point(size = 1, alpha = 0.5) +
  # add a trend line
  # use a linear method
  geom_smooth(method = "lm") +
  # add nicer labels
  labs(x = "age", y = "onset to hospitalsiation (days)",
       title = "Onset to hospitalisation by age")

delay_plot

```

This looks ok, but we could make the theme a little nicer. `ggplot2` comes with some preset themes that can be used to change the theme of the plot. We can also edit themes of the plot with extreme detail with the `theme()` function. For example, we can update this plot like this:

```{r, eval = TRUE}

delay_plot + 
  # set the theme to classic
  theme_classic() +
  # further edit the theme to move the legend position
  theme(legend.position = "bottom")

```

<!-- ======================================================= -->
## Preparation {.tabset .tabset-fade .tabset-pills}

When preparing data to plot, it is best to make the data adhere to tidyverse standards as much as possible. This is expanded on much more in previous sections. 

Some simple ways we can prepare our data to make it better for plotting can often include making the contents of the data better for display - this does not necessarily mean its better for data manipulation! For example, we can replace `NA` values in a character column with the string "Unknown", or clean some variables so that their "data friendly" with underscores etc are changed to normal text. Here are some examples of this in action:

```{r, eval = FALSE}
linelist_cleaned <- linelist_cleaned %>%
  # make display version of columns with more friendly names
  mutate(
    # f to Male, f to Female, NA to Unknown
    gender_disp = case_when(gender == "m" ~ "Male",
                            gender == "f" ~ "Female",
                            is.na(gender) ~ "Unknown"),
    # replace NA with unknown for outcome
    outcome_disp = replace_na(outcome, "Unknown")
  )


```



As a matter of data structure, we often also want to pivot our data into *longer* formats, which will allow us to use a set of variables as a single variable. For example, if we wanted to show the number of cases with specific symptoms, we are limited by the fact that each symptom is a specific column. We can pivot this to a longer format like this:

```{r, eval = F}

linelist_sym <- linelist_cleaned %>%
  pivot_longer(cols = c("fever", "chills", "cough", "aches", "vomit"),
               names_to = "symptom_name",
               values_to = "symptom_is_present") %>%
  mutate(symptom_is_present = replace_na(symptom_is_present, "unknown"))

```

We could then use new dataframe in an upcoming plot:

```{r, eval = T}

symp_plot <- ggplot(symp_plot, aes(x = symptom_name, fill = symptom_is_present)) +
  # show as a portion of all
  geom_bar(stat = "fill")

symp_plot
```
Note that this format is not very useful for other operations, and should just be used for the plot it was made for. However, users should endeavour to use these practices as much as possible for the base dataset, as they are more tidyverse compliant, and will make working with the data easier.





<!-- ======================================================= -->
### sub-tab 1 {.tabset .tabset-fade .tabset-pills}

Can be used to separate major steps of data preparation. Re-name as needed


<!-- ======================================================= -->
### sub-tab 2 {.tabset .tabset-fade .tabset-pills}

Can be used to separate major steps of data preparation. Re-name as needed.



<!-- ======================================================= -->
## Colour schemes {.tabset .tabset-fade .tabset-pills}

One thing that can initially be difficult to understand with `ggplot2` is control of colour schemes when passing colour or fill as a variable rather than defining them explicitly within a geom. There are a few simple tricks that can be used to achieve this however. Remember that when setting colours, you can use colour names (as long as they are recognised) like `"red"`, or a specific hex colour such as `"#ff0505"`.

One of the most useful tricks is using manual scaling functions to explicity define colours. These are functions with the syntax `scale_xxx_manual()` (e.g. `scale_colour_manual()`). In this function you can explicitly define which colours map to which factor using the `values` argument. You can control the legend title with the `name` argument, and the order of factors with `breaks`. 

If you want predefined palettes, you can use the `scale_xxx_brewer` or `scale_xxx_viridis_y` functions. The brewer functions can draw from colorbrewer.org palettes, and the viridis functions can draw from viridis (colourblind friendly!) palettes. Remember to define if the palette is discrete, continuous, or binned by specifying this at the end of the function (e.g. discrete is `scale_xxx_viridis_d`)

We can see this by using the symptom plot we made in the previous section:
```{r,eval = TRUE} 

symp_plot +
  scale_fill_manual(
    values = c("yes" = "black",
               "no" = "white",
               "unknown" = "grey"),
    breaks = c("yes", "no", "unknown"),
    # legend has no title
    name = ""
  )

symp_plot +
  scale_fill_viridis_d(
    breaks = c("yes", "no", "unknown"),
    name = ""
  )


```
*work with the symptom example*

unnamed variable - pass as a string in aes(), and define colour later



*something about changing order of discrete variables*

<!-- ======================================================= -->
## Highlighting {.tabset .tabset-fade .tabset-pills}

Highlighting specific elements in a chart is a useful way to draw attention to a specific instance of a variable while also providing information on the dispersion of the full dataset. While this is not easily done in base `ggplot2`, there is an external package that can help to do this known as `gghighlight`. This is easy to use within the ggplot syntax.

The `gghighlight` package uses the `gghighlight()` function to achieve this effect. To use this function, supply a logical statement to the function - this can have quite flexible outcomes, but here we'll show an example of the age distribution of cases in our linelist, highlighting them by outcome.

```{r, eval = T}
# load gghighlight
library(gghighlight)


# replace NA values with unknown in the outcome variable
linelist_cleaned <- linelist_cleaned %>%
  mutate(outcome = replace_na(outcome, "Unknown"))

# produce a histogram of all cases by age
ggplot(linelist_cleaned, 
       aes(x = age_years, fill = outcome)) +
  geom_histogram() + 
  # highlight instances where the patient has died.
  gghighlight::gghighlight(outcome == "Death")


```

This also works well with faceting functions - it allows the user to produce facet plots with the background data highlighted that doesn't apply to the facet!

```{r, eval = T}

# produce a histogram of all cases by age
ggplot(linelist_cleaned, 
       aes(x = age_years, fill = outcome)) +
  geom_histogram() + 
  # highlight instances where the patient has died.
  gghighlight::gghighlight() +
  facet_wrap(~outcome)


```


<!-- ======================================================= -->
## Changing the order of discrete variables
Changing the order that discrete variables appear in is often difficult to understand for people who are new to `ggplot2` graphs. It's easy to understand how to do this however once you understand how `ggplot2` handles discrete variables under the hood. Generally speaking, if a discrete varaible is used, it is automatically converted to a `factor` type - which orders factors by alphabetical order by default. To handle this, you simply have to reorder the factor levels to reflect the order you would like them to appear in the chart. For more detailed information on how to reorder `factor` objects, see the factor section of the guide. 

We can look at a common example using age groups - by default the 5-9 age group will be placed in the middle of the age groups (given alphabetical order), but we can move it behind the 0-4 age group of the chart by releveling the factors.

```{r, eval = T}

ggplot(linelist_cleaned,
       # relevel the factor within the ggplot call (can do externally as well)
       aes(x = forcats::fct_relvel(age_cat5, "5-9", after = 1))) +
  geom_histogram() +
  labs(x = "Age group", y = "Number of hospitalisations")


```

<!-- ======================================================= -->
## Smart Labeling {.tabset .tabset-fade .tabset-pills}
ggrepel

<!-- ======================================================= -->
## Time axes {.tabset .tabset-fade .tabset-pills}

Working with time axes in ggplot can seem daunting, but is made very easy with a few key functions. Remember that when working with time or date that you should ensure that the correct variables are formatted as date or datetime class - see the _working with dates_ section for more information on this.

The single most useful set of functions for working with dates in `ggplot2` are the scale functions (`scale_x_date()`, `scale_x_datetime()`, and their cognate y-axis functions). These functions let you define how often you have axis labels, and how to format axis labels. To find out how to format dates, see the _working with dates_ section again! Use the `date_breaks` and `date_labels` arguments to specify how dates should look:


```{r, eval = T}
# make epi curve by date of onset when available
ggplot(linelist_cleaned, aes(x = date_onset)) +
  geom_bar(stat = "count") +
  scale_x_date(
    # 1 break every 1 month
    date_breaks = "1 months",
    # labels should show month then date
    date_labels = "%b %d"
  )

```


<!-- ======================================================= -->
## Dual axes {.tabset .tabset-fade .tabset-pills}

A secondary y-axis is often a requested addition to a `ggplot2` graph. Unfortunately, secondary axes are not well supported in the `ggplot` syntax. For this reason, you're fairly limited in terms of what can be shown with a secondary axis - the second axis has to be a direct transformation of the secondary axis. 

Differences in axis values will be purely cosmetic - if you want to show two different variables on one graph, with different y-axis scales for each variable, this will not work without some work behind the scenes. To obtain this effect, you will have to transform one of your variables in the data, and apply the same transformation *in reverse* when specifying the axis labels. Based on this, you can either specify the transformation explicitly (e.g. variable a is around 10x as large as variable b) or calculate it in the code (e.g. what is the ratio between the maximum values of each dataset).


The syntax for adding a secondary axis is very straightforward! When calling a `scale_xxx_xxx()` function (e.g. `scale_y_continuous()`), use the `sec.axis` argument to call the `sec_axis()` function. The `trans` argument in this function allows you to specify the label transformation for the axis - provide this in standard tidyverse syntax. 

For example, if we want to show the number of positive RDTs in the malaria dataset for facility 1, showing 0-4 year olds and all cases on chart:


```{r, eval = T}
malaria_data <- read_rds(here::here("data", "facility_count_data.rds")) %>%
  filter(location_name == "Facility 1")

# calculate the ratio between malaria_rdt_0-4 and malaria_tot 

tf_ratio <- max(malaria_data$malaria_tot, na.rm = T) / max(malaria_data$`malaria_rdt_0-4`, na.rm = T)

# transform the values in the dataset

malaria_data_f1 <- malaria_data %>%
  mutate(malaria_rdt_0_4_tf = `malaria_rdt_0-4` * tf_ratio) %>%
  

# plot the graph with dual axes

ggplot(malaria_data, aes(x = data_date)) +
  geom_path(aes(x = malaria_tot, col = "Total cases")) +
  geom_path(aes(x = malaria_rdt_0_4_tf, col = "Cases: 0-4 years old")) +
  scale_y_continuous(
    name = "Total cases",
    sec.axis = sec_axis(trans = ~ . / tf_ratio, name = "Cases: 0-4 years old")
  )
  


```

<!-- ======================================================= -->
## Adding shapes {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Animations {.tabset .tabset-fade .tabset-pills}





```{r, child= '_page_closeout.Rmd', eval = params$run_page_ind == F, include = F}
```

