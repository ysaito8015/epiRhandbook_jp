---
title:  |  
  ![](../images/R Handbook Logo.png)
author: ""
date: "Produced `r format(Sys.time(), '%A %d %B %Y')`"
output:
  html_document:
    code_folding: show
    highlight: zenburn
    number_sections: no
    theme: sandstone
    toc: yes
    toc_collapse: no
    toc_depth: 3
    toc_float: yes
params:
    run_page_ind: TRUE
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "_outputs_knitted") })
---

```{r, child= '_page_setup.Rmd', eval = params$run_page_ind, include = F}
# THIS CHUNK RUNS IF PAGE IS KNITTED INDEPENDENTLY OF THE HANDBOOK
# IT SOURCES RMD "_page_setup.Rmd" TO GET SETTINGS, PACKAGES, AND DATASETS
# IF WORKING ON THIS PAGE, RUN "_page_setup.Rmd" FIRST
```


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Epidemic curves {.tabset .tabset-fade}  


<!-- ======================================================= -->
## Overview {.tabset .tabset-fade}



```{r, out.width=c('75%'), echo=F}
# import linelist
pacman::p_load(tidyverse, incidence, lubridate, stringr, here)
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# Create incidence object, data grouped by gender
#################################################

# Classify "gender" column as factor
####################################
# with specific level order and labels, includin for missing values
central_data <- linelist %>% 
  filter(hospital == "Central Hospital") %>% 
  mutate(gender = factor(gender,
                         levels = c(NA, "f", "m"),
                         labels = c("Missing", "Female", "Male"),
                         exclude = NULL))

# Create incidence object, by gender
####################################
gender_outbreak_central <- incidence(central_data$date_onset, 
                                     interval = "week", 
                                     groups = central_data$gender,
                                     na_as_group = TRUE)   # Missing values assigned their own group

# plot epicurve with modifications
##################################
plot(gender_outbreak_central,
     show_cases = TRUE)+                            # show box around each case
     
     ### ggplot commands added to plot
     # scale modifications
     scale_x_date(expand = c(0,0),
                  date_breaks = "6 weeks",
                  date_minor_breaks = "week",
                  date_labels = "%d %b\n%Y")+
  
     # aesthetic themes
     theme_minimal()+                               # simplify plot background
     theme(
       legend.title = element_text(size = 14, face = "bold"),
       axis.title = element_text(face = "bold"))+   # axis title bold
     
      # plot labels
      labs(fill = "Gender",                         # title of legend
           title = "Weekly case incidence, by gender",
           y = "Weekly case incidence",
           x = "Week of symptom onset",
           caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown")))      
``` 



<!-- ======================================================= -->
## Preparation


### Packages  

This code chunk shows the loading of packages required for the analyses. 

```{r epicurve_packages}
pacman::p_load(rio,          # File import
               here,         # File locator
               tidyverse,    # data management + ggplot2 graphics
               aweek,        # working with dates
               lubridate,    # Manipulate dates    
               incidence,    # an option for epicurves of linelist data
               stringr,      # Search and manipulate character strings
               forcats,      # working with factors
               RColorBrewer) # Color palettes from colorbrewer2.org
```


### Load data  

Two example datasets are used in this section:  

* Linelist of individual cases from a simulated Ebola epidemic  
* Aggregated counts by hospital from the same simulated Ebola epidemic  

The dataset is imported using the `import()` function from the *rio* package. See the *page on importing data* for various ways to import data. The linelist and aggregated versions of the data are displayed below.

For most of this document, the *linelist dataset* will be used. The aggregated counts dataset will be used at the end.  

```{r epicurve_load_hide, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the counts data into R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n())
```

```{r epicurve_load_show, eval=F}
# import the linelist
linelist <- rio::import("linelist_cleaned.xlsx")
```

Review the two datasets and notice the differences  

**Case linelist**

The first 50 rows are displayed
```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```

**Case counts aggregated by hospital**  

The first 50 rows are displayed  

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```




### Set parameters

You may want to set certain parameters for production of a report, such as the date for which the data is current (the "data date"). 
You can then reference the `data_date` in the code when applying filters or in captions that auto-update.

```{r set_parameters}
## set the report date for the report
## note: can be set to Sys.Date() for the current date
data_date <- as.Date("2015-05-15")
```



### Verify dates

Verify that each relevant date column is class Date and has an appropriate range of values. This `for` loop prints a histogram for each column.  

```{r verify_dates, out.width = c('50%', '50%', '50%'), fig.show='hold'}
# create character vector of column names 
DateCols <- as.character(tidyselect::vars_select(names(linelist), matches("date|Date|dt")))

# Produce histogram of each date column
for (Col in DateCols) {     # open loop. iterate for each name in vector DateCols
  hist(linelist[, Col],     # print histogram of the column in linelist dataframe
       breaks = 50,         # number of breaks for the histogram
       xlab = Col)          # x-axis label is the name of the column
  }                         # close the loop
```



<!-- ======================================================= -->
## `incidence` package {.tabset .tabset-fade}

Below are tabs on making quick epicurves using the **incidence** package  

<span style="color: orange;">**_CAUTION:_** Epicontacts expects data to be in a "linelist" format of one row per case (not aggregated). If your data is aggregated counts, look to the ggplot epicurves tab.</span>

<span style="color: darkgreen;">**_TIP:_** The documentation for plotting an **incidence** object can be accessed by entering `?plot.incidence` in your R console.</span>

https://cran.r-project.org/web/packages/incidence/vignettes/customize_plot.html#example-data-simulated-ebola-outbreak   




<!-- ======================================================= -->
### Incidence intro {.tabset .tabset-fade}

**2 steps are requires to plot an epicurve with the *incidence* package:**  

1) **Create** an *incidence object* (using the function `incidence()`)  
    + Provide the case linelist  
    + Specify the *time interval* into which the cases should be aggregated (daily, weekly, monthly..)  
    + Specify any sub-groups  
2) **Plot** the incidence object  
    + Specify labels, aesthetic themes, etc.  


**A simple example** - an epicurve of daily cases:  

```{r}
# load incidence package
library(incidence)

# create the incidence object using data by day
epi_day   <- incidence(linelist$date_onset,  # the linelist data
                       interval = "day")     # the time interval

# plot the incidence object
plot(epi_day)
```

**Change time interval of case aggregation (bars)**  

The `interval` argument defines how the observations are grouped. Available options include all the options from the package **aweek**, including but not limited to:  

* "week" (Monday start day is default)  
* "2 weeks" (or 3, 4, 5...)  
* "Sunday week"  
* "2 Sunday weeks" (or 3, 4, 5...)  
* "MMWRweek" (starts on Sunday - see US CDC)  
* "month" (1st of month)  
* "quarter" (1st of month of quarter)
* "2 months" (or 3, 4, 5...)  
* "year" (1st day of calendar year)  

Below are examples of how different intervals look when applied to the linelist.  
Format and frequency of the date *labels* on the x-axis are the defaults for the specified interval.  

```{r incidence, out.width=c('50%', '50%', '50%', '50%'), fig.show='hold'}
# Create the incidence objects (with different intervals)
##############################
# Weekly (Monday week by default)
epi_wk      <- incidence(linelist$date_onset, interval = "Monday week")

# Sunday week
epi_Sun_wk  <- incidence(linelist$date_onset, interval = "Sunday week")

# Three weeks (Monday weeks by default)
epi_3wk     <- incidence(linelist$date_onset, interval = "3 weeks")

# Monthly
epi_month   <- incidence(linelist$date_onset, interval = "month")

# Plot the incidence objects (+ titles for clarity)
############################
plot(epi_wk)+     labs(title = "Monday weeks")
plot(epi_Sun_wk)+ labs(title = "Sunday weeks")
plot(epi_3wk)+    labs(title = "Every 3 Monday weeks")
plot(epi_month)+  labs(title = "Months")
```


<!-- ======================================================= -->
### Incidence modifications {.tabset .tabset-fade}

The **incidence** package enables modifications in the following ways:  

* Arguments of `plot()` (e.g. `show_cases`, `col_pal`, `alpha`...)  
* `scale_x_incidence()` and `make_labels()`  
* `ggplot()` additions via the `+` operator  

Read details in the Help files by entering `?scale_x_incidence` and `?plot.incidence` in the R console. Online vignettes are listed in the resources tab.  




#### `plot()` modifications  

A incidence plot can be modified in the following ways. Type `?plot.incidence` in the R console for more details.  

* `show_cases = `  If TRUE, each case is shows as a box. Best on smaller outbreaks.  
* `color = `       Color of case bars/boxes  
* `border = `      Color of line around boxes, if `show_cases = TRUE`  
* `alpha = `       Transparency of case bars/boxes (1 is fully opaque, 0 is fully transparent)  
* `xlab = `        Title of x-axis (axis labels can also be applied using `labs()` from ggplot)  
* `ylab = `        Title of y-axis; defaults to user-defined incidence time interval  
* `labels_week = ` Logical, indicate whether x-axis labels are in week or date format, absent other modifications
* `n_breaks = `    Number of x-axis label breaks, absent other modifications  
* `first_date`, `last_date` Dates used to trim the plot  

See examples of these arguments in the subsequent tabs.  


#### Filtered data

**To plot the epicurve of a subset of data:**  

1) Filter the linelist data  
2) Feed the subset to the `incidence()` command  

The example below uses data filtered to show only cases at Central Hospital.  

```{r incidence_filtered}
# filter the dataset
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object using subset of data
central_outbreak <- incidence(central_data$date_onset, interval = "week")

# plot
plot(central_outbreak) + labs(title = "Weekly case incidence at Central Hospital")
```


#### Adjust date-axis labels/format/gridlines {.tabset .tabset-fade} 

<span style="color: darkgreen;">**_TIP:_** Remember that date-axis **labels** are independent from the aggregation of the data into bars</span>


**Modify the bars**  
The aggregation of data into bars occurs when you set the `interval =` when creating the incidence object. The options for `interval` come from the package **aweek** and include options like "day", "Monday week", "Sunday week", "month", "2 weeks", etc. See the incidence intro tab for more information. 


**Modify date-axis labels (frequency & format)**  

If working with the **incidence** package, you have several options to make these modifications. Some utilize the **incidence** package functions `scale_x_date()` and `make_breaks()`, others use the **ggplot2** function `scale_x_date()`, and others use a combination.  

<span style="color: red;">**_DANGER:_** Be cautious setting the y-axis scale breaks (e.g. 0 to 30 by 5: `seq(0, 30, 5)`). Static numbers can cut-off your data if the data changes!.</span>


##### Option 1: `scale_x_incidence()` only  
1) Add `scale_x_incidence()` from the **incidence** package:  
    + Why use this approach?  
      + **Advantages**: Short code. Auto-adjusts weekly labels to interval of incidence object (Monday, Sunday weeks, etc.)  
      + **Disadvantages**: Cannot make fine adjustments to label format or minor vertical gridlines between labels  
    + Provide the name of the incidence object to ensure labels align with specified `interval` (e.g. Sundays or Mondays)
    + *optional:* `n_breaks` specify number of date labels, which start from the *interval* of the first case.  
      + for breaks every nth week, use `n_breaks = nrow(i)/n` ("i" is the incidence object name and "n" is a number)  
    + *optional:* `labels_week` labels formatted as either weeks (YYYY-Www) or dates (YYYY-MM-DD)  
    + One vertical gridline will appear per date label  

Other notes:  

* Type `?scale_x_incidence` into the R console to see more information.  
* If incidence interval is "month", n_breaks and labels_week will behave differently  
* Adding `scale_x_date()` to the plot will remove labels created by `scale_x_incidence`  
* *Note in plot below that the first label is 27 April 2014, the Sunday before the first case (May 1), aligning with Sunday weeks of the incidence object.*

```{r}
# create weekly incidence object (Sunday weeks)
i <- incidence(central_data$date_onset, interval = "Sunday week")

plot(i)+
  scale_x_incidence(i,                    # name of incidence object
                    labels_week = F,      # show dates instead of weeks
                    n_breaks = nrow(i)/8) # breaks every 8 weeks from week of first case
```
 
##### Option 2: `scale_x_date()` and `make_breaks()`  

2) Add `scale_x_date()` from **ggplot2**, but also leverage `make_breaks()` from **incidence**:  
    + Why use this approach?  
      + **Advantages**: Best of both worlds: weekly labels auto-aligned to incidence interval, *and* you can make detailed adjustments to label format
      + **Disadvantages**: *If* minor gridlines between Sunday-week date labels are desired, they are not auto-aligned  
    + After creating the incidence object, use `make_breaks()` to define date label breaks  
      + `make_breaks()` is similar to `scale_x_incidence()` (described above). Provide the incidence object name and optionally `n_breaks` as described before.
    + Add `scale_x_date()` to the plot:  
      + `breaks =` provide the breaks vector you created with `make_breaks()`, followed by `$breaks` (see example below)
      + `date_labels =` provide a format for the date labels (e.g. "%d %b") (use "\n" for new line)  

```{r}
# Break modification using scale_x_date() and make_breaks()
###########################################################
# make incidence object
i <- incidence(central_data$date_onset, interval = "Monday week")

# make breaks
i_labels <-  make_breaks(i, n_breaks = nrow(i)/6) # using interval from i, breaks every 6 weeks

# plot
plot(i)+
  scale_x_date(breaks      = i_labels$breaks, # call the breaks
               date_labels = "%d\n%b '%y",    # date format
               date_minor_breaks = "weeks")   # gridlines each week (aligns with Sundays only)  
```

##### Option 3: Use `scale_x_date()` only  

3) **Use `scale_x_date()` only** 
    + **Advantages**: Complete control over breaks, labels, gridlines, and plot width  
    + **Disadvantages**: More code required, more opportunity to make mistakes.  
    + If your incidence *intervals* are days or **Monday weeks**, (easy!):  
      + Provide interval to `date_breaks = ` (e.g. "day", "week", "2 weeks", "month", "year")
      + Provide interval to `date_minor_breaks = ` for vertical lines between date labels  
    + If your incidence *intervals* are **Sunday weeks**, it is more complex - see the tab for a Sunday week example  
      + Provide a sequence of Sunday dates to `breaks = ` and to `minor_breaks = `  
    + Use `date_labels = ` for formatting (see Dates page for tips)  
    + Add the argument `expand = c(0,0)` to start labels at the first incidence bar. Otherwise, first label will shift depending on your specified label interval.   
 
*Note: if using aggregated counts (for example an epiweek x-axis) your x-axis may not be Date class and may require use `scale_x_discrete()` instead of `scale_x_date()` - see ggplot tips page for more details.  


```{r}
# Break modification using scale_x_date() only
##############################################
# make incidence object
i <- incidence(central_data$date_onset, interval = "Monday week")

# plot
plot(i)+
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")  # date labels format 

```



##### A Sunday week example  

If you want a plot of Sunday weeks and also finely-adjusted label formats, you might find a code example helpful.  
Here is an example of producing a weekly epicurve using **incidence** for Sunday weeks, with finely-adjusted date labels through `scale_x_date()`:  

```{r}
# load packages
pacman::p_load(tidyverse,  # for ggplot
               incidence,  # for epicurve
               lubridate)  # for floor_date() and ceiling_date()

# create incidence object (specifying SUNDAY weeks)
central_outbreak <- incidence(central_data$date_onset, interval = "Sunday week") # equivalent to "MMWRweek" (see US CDC)

# plot() the incidence object
plot(central_outbreak)+                  
  
  ### ggplot() commands added to the plot
  # scale modifications 
  scale_x_date(
    expand = c(0,0),                 # remove excess x-axis space below and after case bars
    
    # sequence by 3 weeks, from Sunday before first case to Sunday after last case
    breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                      to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                      by   = "3 weeks"),
    
    # sequence by week, from Sunday before first case to Sunday after last case
    minor_breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                            to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                            by   = "7 days"),
    # date labels
    date_labels = "%d\n%b'%y")+       # adjust how dates are displayed
  
  scale_y_continuous(
    expand = c(0,0),                  # remove excess space under x-axis
    breaks = seq(0, 30, 5))+          # adjust y-axis intervals
  
  # Aesthetic themes
  theme_minimal()+                    # simplify background
  theme(
    axis.title = element_text(size = 12, face = "bold"),       # axis titles formatting
    plot.caption = element_text(face = "italic", hjust = 0))+  # caption formatting, left-aligned
  
  # Plot labels
  labs(x = "Week of symptom onset (Sunday weeks)", 
       y = "Weekly case incidence", 
       title = "Weekly case incidence at Central Hospital",
       #subtitle = "",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```


#### Show individual cases

**To show boxes around each individual case, use the argument `show_cases = TRUE` in the `plot()` function.**  

Boxes around each case can be more reader-friendly, if the outbreak is of a small size. Boxes can be applied when the interval is days, weeks, or any other time period.  The code below creates the *weekly* epicurve for a smaller outbreak (only cases from Central Hospital), with boxes around each case.  

```{r}
# create filtered dataset for Central Hospital
central_data  <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object (weekly)
central_outbreak <- incidence(central_data$date_onset, interval = "Monday week")

# plot outbreak
plot(central_outbreak,
     show_cases = T)                 # show boxes around individual cases
```

The same epicurve showing individual cases, but with other aesthetic modifications:  

```{r}
# add plot() arguments and ggplot() commands
plot(central_outbreak,
     show_cases = T,                 # show boxes around each individual case
     color = "lightblue",            # color inside boxes
     border = "darkblue",            # color of border around boxes
     alpha = 0.5)+                    # transparency
  
  ### ggplot() commands added to the plot
  # scale modifications
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "4 weeks",      # labels appear every 4 Monday weeks
    date_minor_breaks = "week",         # vertical lines appear every Monday week
    date_labels       = "%d\n%b'%y")+   # date labels format 
  
  scale_y_continuous(
    expand = c(0,0),              # remove excess space under x-axis
    breaks = seq(0, 35, 5))+      # adjust y-axis intervals
  
  # aesthetic themes
  theme_minimal()+                                                 # simplify background
  
  theme(
    axis.title = element_text(size = 12, face = "bold"),       # axis title format
    plot.caption = element_text(face = "italic", hjust = 0))+  # caption format and left-align
  
  # plot labels
  labs(x = "Week of symptom onset (Monday weeks)", 
       y = "Weekly reported cases", 
       title = "Weekly case incidence at Central Hospital",
       #subtitle = "",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```




#### Color by value

To color the cases by value, provide the column to the `groups =` argument in the `incidence()` command. In the example below the cases are colored by their age category. Note the use of `incidence()` argument `na_as_group = `. If TRUE (by default) missing values (`NA`) will form their own group.  

```{r }
# Create incidence object, with data grouped by age category
age_outbreak <- incidence(linelist$date_onset,            # date of onset for x-axis
                               interval = "week",         # weekly aggregation of cases
                               groups = linelist$age_cat, # color by age_cat value
                               na_as_group = TRUE)        # missing values assigned their own group


# plot the epicurve
plot(age_outbreak) 
```

**Adjusting order**  

To adjust the order of group appearance (on plot and in legend), the group column must be class Factor. Adjust the order by adjusting the order of the levels (including `NA`). Below is an example with gender groups using data from Central Hospital only.  

* First, the dataset is defined and gender is re-defined as a factor  
* The order of levels of gender are defined with `NA` first, so it appears on the top of the bars  
* More appropriate labels are defined for each factor level - these appear in the legend  
* The argument `exclude = NULL` in `factor()` is necessary to adjust the order of `NA`, which is excluded by default.  
* Title of legend adjusted using `fill = ` in `labs()`

You can read more about factors in their page (LINK)  

```{r}
# Create incidence object, data grouped by gender
#################################################

# Classify "gender" column as factor
####################################
# with specific level order and labels, includin for missing values
central_data <- linelist %>% 
  filter(hospital == "Central Hospital") %>% 
  mutate(gender = factor(gender,
                         levels = c(NA, "f", "m"),
                         labels = c("Missing", "Female", "Male"),
                         exclude = NULL))

# Create incidence object, by gender
####################################
gender_outbreak_central <- incidence(central_data$date_onset, 
                                     interval = "week", 
                                     groups = central_data$gender,
                                     na_as_group = TRUE)   # Missing values assigned their own group

# plot epicurve with modifications
##################################
plot(gender_outbreak_central,
     show_cases = TRUE)+                            # show box around each case
     
     ### ggplot commands added to plot
     # scale modifications
     scale_x_date(expand = c(0,0),
                  date_breaks = "6 weeks",
                  date_minor_breaks = "week",
                  date_labels = "%d %b\n%Y")+
  
     # aesthetic themes
     theme_minimal()+                               # simplify plot background
     theme(
       legend.title = element_text(size = 14, face = "bold"),
       axis.title = element_text(face = "bold"))+   # axis title bold
     
      # plot labels
      labs(fill = "Gender",                         # title of legend
           title = "Show case boxes, with modifications",
           y = "Weekly case incidence",
           x = "Week of symptom onset")      
```

#### Changing colors and legend  

**To change the legend**  
Use `ggplot()` commands such as:  

* `theme(legend.position = "top")` (or "bottom", "left", "right")
* `theme(legend.direction = "horizontal")`  
* `theme(legend.title = element_blank())` to have no title  
See the page of ggplot() tips for more details.  


**To specify colors manually**, provide the name of the color or a character vector of multiple colors to the argument `color = `. Note to function properly the number of colors listed must equal the number of groups (be aware of missing values as a group)  

```{r out.width = c('50%', '50%'), fig.show='hold'}
# weekly outbreak by hospital
hosp_outbreak <- incidence(linelist$date_onset, 
                               interval = "week", 
                               groups = linelist$hospital,
                               na_as_group = FALSE)   # Missing values not assigned their own group
# default colors
plot(hosp_outbreak)

# manual colors
plot(hosp_outbreak, color = c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange"))

```

          
**To change the color palette**  
Use the argument `col_pal` in `plot()` to change the color palette to one of the default **base** R palettes (do *not* put the name of the palette in quotes).  

Other palettes include TO DO add page with palette names... To DO

```{r out.width = c('50%', '50%'), fig.show='hold'}
# Create incidence object, with data grouped by age category
age_outbreak <- incidence(linelist$date_onset,            # date of onset for x-axis
                               interval = "week",         # weekly aggregation of cases
                               groups = linelist$age_cat, # color by age_cat value
                               na_as_group = TRUE)        # missing values assigned their own group

# plot the epicurve
plot(age_outbreak)

# plot with different color palette
plot(age_outbreak, col_pal = rainbow)
```



#### Facets/small multiples  

To facet the plot by a variable (make "small multiples"), see the tab on epicurves with `ggplot()` 




<!-- ======================================================= -->
## `ggplot2` {.tabset .tabset-fade}

Below are tabs on using "ggplot2" package to produce epicurves

Unlike using **incidence** package, you must manually control the aggregation of the data (into weeks, months, etc) *and* the labels on the date axis. If not carefully managed, this can lead to many headaches.  


<!-- ======================================================= -->
### Simple epicurves from linelist {.tabset .tabset-fade}

Assume you begin with a linelist dataset, as shown in the Preparation tab. 

Below is perhaps the most simple code to produce daily epicurve with `ggplot()`.  

``` {r ggplot_simple,  out.width = c('50%', '50%'), fig.show='hold'}
# Daily case counts 
###################
ggplot(data = central_data, aes(x = date_onset)) +  # x column must be class Date
  geom_histogram(binwidth = 1)+                  # date values binned by 1 day 
  labs(title = "Daily")

# weekly
ggplot(data = central_data, aes(x = date_onset)) +                 # x column must be class Date
  geom_histogram(binwidth = 7, color = "black", fill = "white")+    # date values binned by 1 day 
  labs(title = "Weekly")
```

Below is `ggplot()` code to produce weekly epicurves for Monday and Sunday weeks, starting from linelist-format data.  
See the tab on Modifications (axes) to learn the nuances of date-axis management.  

**Monday weeks**  

The below code creates a histogram of the rows, by a date column as the x-axis. Of note:  

* The break points of the histogram's bins are specified manually to begin the Monday before the earliest case (`floor_date()` with `week_start = 1`) and to end the Monday after the last case (`ceiling_date()`).  
* Date labels on the date axis (remember, independent from the bins) utilize the `date_breaks`, `date_minor_breaks` (vertical lines), and `date_labels` arguments of `scale_x_date()`. These arguments use weeks starting on Mondays (by default and difficult to change). Depending on the distance between date labels, the location of the last label may vary.  
* Adding `expand = c(0,0)` to the x and y scales removes excess space on each side of the plot, which also ensures the labels begin at the first bar.  


```{r}
# TOTAL MONDAY WEEK ALIGNMENT
#############################
ggplot(central_data, aes(x = date_onset)) + 
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1)),
                      to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1)),
                      by   = "7 days"), # bins are 7-days
    color = "darkblue",   # color of lines around bars
    fill = "lightblue") + # color of fill within bars
  
  # x-axis labels
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+             # remove excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases (Monday weeks)",
       subtitle = "Subtitle: Note alignment of bars, vertical lines, and axis labels on Mondays",
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

**Sunday weeks**  

The below code creates a histogram of the rows, using a date column as the x-axis. Of note:  

* The break points of the histogram's bins are specified manually to begin the Sunday before the earliest case (`floor_date()` with `week_start = 7`) and to end the Sunday after the last case (`ceiling_date()`). Depending on the distance between date labels, the location of the last label may vary.  
* Date *labels* on the date axis (remember, independent from the bins) are also manually specified using similar syntax as the break points. You *cannot* use the `scale_x_date()` arguments of `date_breaks` and `date_minor_breaks` as these use Monday weeks.  
* Adding `expand = c(0,0)` to the x and y scales removes excess space on each side of the plot, which also ensures the labels begin at the first bar.  


```{r}
# TOTAL SUNDAY WEEK ALIGNMENT
#############################
ggplot(central_data, aes(x = date_onset)) + 
  
  # For histogram, manually specify bin break points: starts the Sunday before first case, end Sunday after last case
  geom_histogram(                    
    breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                      to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                      by   = "7 days"), # bins are 7-days
    color = "darkblue",   # color of lines around bars
    fill = "lightblue") + # color of fill within bars
  
  # The labels on the x-axis
  scale_x_date(expand = c(0,0),
               breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                                 to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                                 by   = "3 weeks"),
               minor_breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                                       to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                                       by   = "7 days"),
               date_labels = "%d\n%b\n'%y")+             # day, above month abbrev., above 2-digit year
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                   # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases (Sunday weeks)",
       subtitle = "Subtitle: Note alignment of bars, vertical lines, and axis labels on Sundays",
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```



<!-- ======================================================= -->
### Modifications {.tabset .tabset-fade}


#### Modify axes  

<span style="color: darkgreen;">**_TIP:_** Remember that date-axis **labels** are independent from the aggregation of the data into bars</span>

To **modify the aggregation of data into bins/bars**, do one of the following:  

* Specify a `binwidth =` within `geom_histogram()` - for a column of class Date, the given number is interpreted in days.  
* Specify the sequence of bin break-points manually by providing a sequence of dates to `breaks = `. Note, for histogram bins this is within the `geom_histogram()`, not within `scale_x_date()` as discussed below for labels.  
* Group the rows into aggregated counts (by week, month, etc.) and feed the aggregated counts to `ggplot()`. See the tab on aggregated counts for more information.  


To **modify the date labels**, use `scale_x_date()` in one of these ways:  

* If your histogram bins are days, Monday weeks, months, or years:  
  * Use `date_breaks = ` to specify label frequency (e.g. "day", "week", "3 weeks", "month", or "year")
  * Use `date_minor_breaks = ` to specify frequency of minor vertical gridlines between date labels  
  * Add `expand = c(0,0)` to begin the labels at the first bar (otherwise, first label will shift forward depending on specified frequency)  
  * Use `date_labels = ` to specify format of date labels - see the Dates page for tips (use `\n` for a new line)  
* If your histogram bins are Sunday weeks:  
  * Use `breaks = ` and `minor_breaks = ` by providing a sequence of dates for breaks
  * You can still use `date_labels = ` for formatting as described above  


If using aggregated counts (for example an epiweek x-axis) your x-axis may not be Date class and may require use `scale_x_discrete()` instead of `scale_x_date()` - see ggplot tips page for more details.  

Set maximum and minimum date values using `limits = c()` within `scale_x_date()`. E.g. `scale_x_date(limits = c(as.Date("2014-04-01), NA))` sets a minimum but leaves the maximum open.  

<span style="color: orange;">**_CAUTION:_** Caution using limits! They remove all data outside the limits, which can impact y-axis max/min, modeling, and other statistics. Strongly consider instead using limits by adding `coord_cartesian()` to your plot, which acts as a "zoom" without removing data. </span>

<span style="color: red;">**_DANGER:_** Be cautious setting the y-axis scale breaks (e.g. 0 to 30 by 5: `seq(0, 30, 5)`). Static numbers can cut-off your data if the data changes!.</span>

https://rdrr.io/r/base/strptime.html     ----- see all % shortcuts


```{r out.width = c('50%', '50%', '50%', '50%', '50%', '50%', '50%'), fig.show='hold'}
# Auto everything
#################
ggplot(central_data, aes(x = date_onset)) + # x column must be class Date
  geom_histogram() +            
  labs(title = "All defaults",
       subtitle = "! caution: number of days per bin not specified")


# 7-day binwidth and colors specified, axes flush with labels
#################
ggplot(central_data, aes(x = date_onset)) + # x column must be class Date
  geom_histogram(binwidth = 7,                       # 7 days per bin
                 color = "darkblue",                 # color of lines around bars
                 fill = "lightblue") +               # color of bar fill
  scale_x_date(expand = c(0,0))+                     # remove excess space earlier and later than case bars
  scale_y_continuous(expand = c(0,0))+               # remove excess space between axes and labels
  labs(title = "Specified 7-days per bin, colors added, axes excess space removed",
       subtitle = "! caution: 7-day bins begin at first case (Thurs 1 May)\ndefault date_breaks and minor_break vertical lines")


# specify date_breaks 3 WEEKS
#############################
ggplot(central_data, aes(x = date_onset)) +
  geom_histogram(binwidth = 7,
                 color = "darkblue",
                 fill = "lightblue") +
  scale_x_date(expand = c(0,0),
                date_breaks = "3 weeks",       # note: Monday weeks by default
                date_minor_breaks = "week",
                date_labels = "%d\n%b\n'%y")+
  scale_y_continuous(expand = c(0,0))+
  labs(title = "date_labels = '3 weeks' (Mondays), labels formated, with weekly vertical lines",
       subtitle = "! caution: 7-day bins begin at first case (Thurs 1 May)...\n...while 3-weekly date_breaks and weekly minor_break lines show as Mondays (note mis-alignment of bar/axis tick")


# specify date_breaks 4 WEEKS
#############################
ggplot(central_data, aes(x = date_onset)) +
  geom_histogram(binwidth = 7,
                 color = "darkblue",
                 fill = "lightblue") +
  scale_x_date(expand = c(0,0),
                date_breaks = "4 weeks",
                date_minor_breaks = "week",
                date_labels = "%d\n%b\n'%y")+
  scale_y_continuous(expand = c(0,0))+
  labs(title = "date_labels = '4 weeks'",
       subtitle = "! caution: 7-day bins begin at first case (Thursday 1 May)\nwhile 4-weekly date_breaks and weekly minor_break lines show as Mondays\nAlso note shift of first date label")


# specify date_breaks MONTHS (note each bin begins 1st of month)
################################################################
ggplot(central_data, aes(x = date_onset)) +
  geom_histogram(binwidth = 7,
                 color = "darkblue",
                 fill = "lightblue") +
  scale_x_date(expand = c(0,0),
                date_breaks = "months",
                date_minor_breaks = "week",
                date_labels = "%d\n%b\n'%y")+
  scale_y_continuous(expand = c(0,0))+
  labs(title = "date labels = 'months'",
       subtitle = "! caution: 7-day bins begin at first case (Thursday 1 May)...\n...while date_breaks = 'months' shows as 1st of each month...\n...and weekly minor_break lines default to Mondays (note axis ticks don't align with bars and uneven line spacing)")


# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays
#################################################################
ggplot(central_data, aes(x = date_onset)) + 
  geom_histogram(breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1)),
                                   to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1)),
                                   by   = "7 days"),
                 color = "darkblue",
                 fill = "lightblue") + 
  scale_x_date(expand = c(0,0),
               date_breaks = "3 weeks",
               date_minor_breaks = "week",
               date_labels = "%d\n%b\n'%y")+
  labs(title = "Total Monday alignment: 7-day bins manually set to begin the Monday before first case (28 Apr)",
       subtitle = "date_labels and minor_break lines are Monday weeks by default")


# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays
############################################################################
ggplot(central_data, aes(x = date_onset)) + 
  geom_histogram(breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                                   to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                                   by   = "7 days"),
                 color = "darkblue",
                 fill = "lightblue") + 
  scale_x_date(expand = c(0,0),
               breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                                   to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                                   by   = "3 weeks"),
               minor_breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7)),
                                   to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7)),
                                   by   = "7 days"),
               date_labels = "%d\n%b\n'%y")+
  labs(title = "Total Sunday alignment: 7-day bins manually set to begin the Sunday before first case (27 Apr)",
       subtitle = "Lines and date labels manually set to Sunday weeks")



# Check values of bars by creating dataframe of grouped values
# central_tab <- central_data %>% 
#   mutate(week = aweek::date2week(date_onset, floor_day = TRUE, factor = TRUE)) %>% 
#   group_by(week, .drop=F) %>%
#   summarize(n = n()) %>% 
#   mutate(groups_3wk = 1:(nrow(central_tab)+1) %/% 3) %>% 
#   group_by(groups_3wk) %>% 
#   summarize(n = n())

```



#### Color by groups

**Designate a column containing groups**  

In any of the code template (Sunday weeks, Monday weeks), make the following changes:  

* Add the *aesthetics* argument `aes()` within the `geom_histogram()` (don't forget comma afterward) 
* Within `aes()`, provide the `group = ` and `fill = ` arguments with column names (no quotes needed). The values in these respective columns will be the grouping for the stacked bars and their colors.  
* Remove any `fill =` argument outside of the `aes()`, as it will override the one inside  

```
geom_histogram(
    aes(group = gender, fill = gender))
```

**Adjust colors**:  

* To manually adjust the colors of each group value, use `scale_fill_manual()` (note `scale_color_manual()` is different!).
  * Use the `values = ` argument to apply a vector of colors.  
  * Use `na.value = ` to specify a color for missing values.  
  * ! While you *can* use the `labels = ` argument in `scale_fill_manual()` change the legend text labels - it is easy to accidentally give labels in the incorrect order and have an incorrect legend! It is recommended to instead convert the group column to class Factor and designate factor `labels` and order, as explained below.  
* To adjust the colors via a **color scale**, see the page on ggplot tips
  

**Adjust the stacking order and Legend**  

Stacking order, and the labels for each group in the legend, is best adjusted by classifying the group column as class Factor. You can then designate the levels and their labels, and the order (which is reflected in stack order).  

Step 1: Convert the `group` column to class Factor using `factor()` from **base** R.  
For example, with a column "gender" with values "m" and "f" and `NA`, this can be put in a `mutate()` command as:  
```
dataset <- dataset %>% 
  mutate(gender = factor(gender,
                    levels = c(NA, "f", "m"),
                    labels = c("Missing", "Female", "Male"),
                    exclude = NULL))
```
The above code establishes the levels, in the ordering that missing values are "first" (and will appear on top). Then the labels that will show are given in the same order. Lastly, the exclude statement ensure that `NA` is included in the ordering (by default `factor()` ignores `NA` from the leveling).  

Read more about factors in their dedicated handbook page (LINK).  

**Adjusting the legend**  

Read more about legends in the ggplot tips page. Here are a few highlights:  

* Adjust the value labels as described above, using Factor labels and order  
* To adjust the order of legend labels independently of the stacking order, use 
* Adjust the legend Title using `fill = ` within `labs()`. To remove the title completely do not specify fill and instead add `legend.title = element_blank()` within `theme()`.  


These steps are shown in the example below:  

```{r}
########################
# bin break points for histogram defined here for clarity
# starts the Monday before first case, end Monday after last case
bin_breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1)),
                      to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1)),
                      by   = "7 days") # bins are 7-days

# Set gender as factor and missing values as first level (to show on top)
central_data <- central_data %>% 
  mutate(gender = factor(gender,
                         levels = c(NA, "f", "m"),
                         labels = c("Missing", "Female", "Male"),
                         exclude = NULL))  

# make plot
###########
ggplot(central_data, aes(x = date_onset)) + 
    geom_histogram(
        aes(group = gender, fill = gender),    # arguments inside aes() apply by group
        color = "black",                       # arguments outside aes() apply to all data
        breaks = bin_breaks)+                  # see breaks defined above
                      
  
  # The labels on the x-axis
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                   # removes excess y-axis space between bottom of bars and the labels
  
  #scale of colors and legend labels
  scale_fill_manual(values = c("grey", "orange", "purple"))+ # specify fill colors ("values") - attention to order!

  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases, by gender",
       subtitle = "Subtitle",
       fill     = "Gender",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```
**Display bars side-by-side**  

Side-by-side display of group bars (as opposed to stacked) is specified within `geom_histogram()` with `position = "dodge"`.  
If there are more than two value groups, these can become difficult to read. Consider instead using a faceted plot (small multiples) (see tab). To improve readability in this example, missing gender values are removed.  

```{r}
########################
# bin break points for histogram defined here for clarity
# starts the Monday before first case, end Monday after last case
bin_breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1)),
                      to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1)),
                      by   = "7 days") # bins are 7-days

# New dataset without rows missing gender
central_data_dodge <- central_data %>%
  filter(!is.na(gender)) %>%                            # remove rows missing gender
  mutate(gender = factor(gender,                        # factor now has only two levels (missing not included)
                         levels = c("f", "m"),
                         labels = c("Female", "Male")))  

# make plot
###########
ggplot(central_data_dodge, aes(x = date_onset)) + 
    geom_histogram(
        aes(group = gender, fill = gender),    # arguments inside aes() apply by group
        color = "black",                       # arguments outside aes() apply to all data
        breaks = bin_breaks,
        position = "dodge")+                  # see breaks defined above
                      
  
  # The labels on the x-axis
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                   # removes excess y-axis space between bottom of bars and the labels
  
  #scale of colors and legend labels
  scale_fill_manual(values = c("pink", "lightblue"))+     # specify fill colors ("values") - attention to order!

  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases, by gender",
       subtitle = "Subtitle",
       fill     = "Gender",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```


#### Faceting/small-multiples

```{r}
########################
# bin break points for histogram defined here for clarity
# starts the Monday before first case, end Monday after last case
bin_breaks = seq.Date(from = as.Date(floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1)),
                      to   = as.Date(ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1)),
                      by   = "7 days") # bins are 7-days

# Set gender as factor and missing values as first level (to show on top)
central_data <- linelist %>% 
  filter(hospital == "Central Hospital") %>%  
  mutate(gender = factor(gender,
                         levels = c(NA, "f", "m"),
                         labels = c("Missing", "Female", "Male"),
                         exclude = NULL))  

# make plot
###########
ggplot(central_data, aes(x = date_onset)) + 
    geom_histogram(
        aes(group = gender, fill = gender),    # arguments inside aes() apply by group
        color = "black",                       # arguments outside aes() apply to all data
        breaks = bin_breaks)+                  # see breaks defined above
                      
  
  # The labels on the x-axis
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                   # removes excess y-axis space between bottom of bars and the labels
  
  #scale of colors and legend labels
  scale_fill_manual(values = c("grey", "orange", "purple"))+ # specify fill colors ("values") - attention to order!

  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases, by gender",
       subtitle = "Subtitle",
       fill     = "Gender",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

#### Moving average

#### Add rectangle for tentative reporting  

#### Dual axis

#### Multi-level date labels  

Years under months  
1) Faceting
2) ...  

https://stackoverflow.com/questions/44616530/axis-labels-on-two-lines-with-nested-x-variables-year-below-months
https://stackoverflow.com/questions/20571306/multi-row-x-axis-labels-in-ggplot-line-chart

#### transform and display as aggregate counts  

Best is to use the **aweek** package to create a new column, then group_by and summarize, 

**Get weeks, then plot** *use **aweek** to convert dates to weeks, then plot the weekly counts*  
To aggregate into weeks and show ALL weeks (even ones with no cases), do these two things:  
1) use floor_date = T and factor = T in the date2week() command, and  
2) use .drop = F in the group_by() command

like this:  
```
central_tab <- central_data %>% 
  mutate(week = aweek::date2week(date_onset, floor_day = TRUE, factor = TRUE)) %>% 
  group_by(week, .drop=F) %>%
  summarize(n = n())
```

```{r}
linelist <- linelist %>% 
  mutate(week = aweek::date2week(date_onset, floor_day = T))

linelist %>% 
  group_by(week, .drop = F) %>% 
  summarise(n = n())
  
```


``` {r ggplot_aesthetics}
# Preparation
#############
# Create epiweek variable. Factor argument automatically includes all weeks in span. Numeric shows just the week number.
linelist$epiweek <- aweek::date2week(linelist$date_onset, factor = TRUE, numeric = TRUE)

# Calculate maximum number of cases in an epiweek, to get the maximum y-axis height (also helps with uniformity in multiple plots)
ymax <- max(summary(factor(linelist$epiweek), maxsum = length(linelist$epiweek)))

# Weekly case counts 
###################
plot_weekly <- ggplot(linelist, aes(x = date_onset)) + 
  
  # stacked bars, bined by week (7 days)
  stat_bin(binwidth = 7, position = "stack", fill = "grey", color = "black") +
  
  # X-axis 21-day labels
  scale_x_date( 
    # Sets date label breaks as every 3 weeks from Monday before the first case
    breaks = function(x) seq.Date(from = min(linelist$date_onset, na.rm = T), to = max(linelist$date_onset, na.rm=T), by = "3 weeks"),
    
    # axis limits determined by max/min + buffer
    limits = c((min(linelist$date_onset, na.rm = T) - 8), (max(linelist$date_onset, na.rm = T) + 8)), 
    
    # displays as date number, then abbreviated month (e.g. 12 Oct)
    date_labels = "%d-%b",   
    
    # sets origin at (0,0)
    expand = c(0,0)) +                                
  
  # Y-axis breaks every 5 cases
  scale_y_continuous(breaks = seq(0, ymax, 25),
                     limits = c(0, ymax),
                     expand = c(0, 0)) +
  
  # Theme specifications (axis, text, etc.)
  theme(# title
        plot.title = element_text(size=20, hjust= 0, face="bold"),   # title size, font, bold
        # axes
        axis.text.x = element_text(angle=90, vjust=0.5, hjust=1),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14, face="bold"),
        axis.line = element_line(colour="black"),
        # background
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        # caption (italics, on right side)
        plot.caption = element_text(hjust = 0, face = "italic")
        ) +
  
  guides(fill = guide_legend(reverse = TRUE,                   # Orders Non-active zones at end of legend
                             override.aes = list(size = 0.2),
                             ncol = 2)) +                        # Number of legend columns
  
  labs(x = "Week of illness onset", 
       y = "Number of cases",
       subtitle = "subtitle here")
  
  ggtitle("Epidemic curve")


# print
print(plot_weekly)


```

<!-- ======================================================= -->
### By category {.tabset .tabset-fade}

Colored by a category

``` {r colored_by }
# Setup
########
# Two known classes (select colors from colorbrewer2.org)
colors_overall = c("#d95f02",  # 
                   "#1b9e77",
                   "#7570b3")  #    

# Order sex variable by reverse # of cases, so plot stacks with smallest # of cases at top
linelist$gender <- factor(linelist$gender, 
                         levels = levels(fct_rev(fct_infreq(linelist$gender))))

# Calculates maximum yaxis height for uniformity between the two graphs
ymax <- max(summary(factor(linelist$epiweek), maxsum = length(linelist$epiweek)))

# Number missing onset_date and cannot be graphed
missing_onset <- nrow(linelist[is.na(linelist$date_onset),])



# PLOT - BY ONSET DATE
######################
plot_defined_cats <- ggplot(linelist, aes(x = date_onset, fill = gender)) + 
  
  # stacked bars, width of 7 days
  stat_bin(binwidth = 7, position = "stack") +
  
  # Colors and labels of confirmed/probable
  scale_fill_manual(values = rev(colors_overall),
                    labels = str_to_sentence(levels(factor(linelist$gender)))) +
  
  # X-axis scale labels (not aggregation, just the labels)
  scale_x_date(# Sets date label breaks as every week
    breaks = function(x) seq.Date(from = min(linelist$date_onset, na.rm = T), to = max(linelist$date_onset, na.rm = T), by = "3 weeks"),
    limits = c((min(linelist$date_onset, na.rm=T)), (max(linelist$date_onset, na.rm = T))), # axis limits determined by max/min + buffer
    date_labels = "%d-%b",   # displays as date # then abbreviated month (e.g. 12 Oct)
    expand = c(0, 0)) +                                # sets origin at (0,0)
  
  # Y-scale in breaks, up to the ymax previously defined
  scale_y_continuous(breaks = seq(0, 500, 25), limits = c(0, ymax), expand=c(0, 0)) +
  
  # Themes for axes, titles, background, etc.
  theme(plot.title       = element_text(size=20, hjust=0.5, face="bold"),
        axis.text        = element_text(size=12),
        axis.title       = element_text(size=14, face="bold"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line        = element_line(colour = "black"),
        axis.text.x      = element_text(angle=90, vjust=0.5, hjust=1)) +
  
  # Legend specifications
  theme(legend.title           = element_blank(),
        legend.justification   = c(0, 1), 
        legend.position        = c(0.09, 0.98),
        legend.background      = element_blank(),
        legend.text            = element_text(size = 12)) +
  guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2))) +
  
  # Axis and caption labels
  labs(x = "Week of illness onset",
       y = "Number of Cases") +
  
  # Title
  ggtitle("Cases by week of illness onset")

# print
print(plot_defined_cats)

```

<!-- ======================================================= -->
### By active area {.tabset .tabset-fade}


``` {r, eval=F}
# PARAMETERS
#############

# Maximum y-value for epiweek (this will be larger than necessary because of missing onset dates)
ymax <- max(table(linelist$epiweek))

# Number missing onset_date and cannot be graphed
missing_onset <- nrow(filter(linelist, is.na(date_onset)))


# SETUP - ACTIVE/NON-ACTIVE ZONES
#################################
# List of "active" zones with a case in the date range
active_zones <- unique(linelist$province[which(linelist$date_onset > (data_date - 90))])
active_zones

# Table of active zones and their overall number of cases (for ordering their stacked appearance)
order_table <- linelist %>%
  filter(province %in% active_zones) %>%
  group_by(province) %>%
  summarise(cases = n())
order_table

# Create TRUE/FALSE variable for "active" health zones
linelist$active_zone <- ifelse(linelist$province %in% active_zones, TRUE, FALSE)

# Create list of non-active HZ names for bottom of plot
other_zone_names <- unique(sort(linelist$province[linelist$active_zone == FALSE]))

# Make variable for graph categories, including a level for "non-active" zones
linelist$graph_zone <- factor(case_when(
  
  # Value assignments
  # Non-active zones
  linelist$active_zone == FALSE    ~ "Non-active zones",
  # All others are assigned their names, capitalized
  TRUE  ~ stringr::str_to_title(linelist$province)),
  
  # Order of variable levels
  levels = c(
    # "Non-active zones" is first level
    "Non-active zones",  
    
    # Orders active zones by their frequency in linelist, reversed, so most-affected zones are on the BOTTOM of plot
    str_to_title(rev(levels(fct_infreq(as.factor(linelist$province[linelist$active_zone == TRUE])))))))  


table(linelist$graph_zone, useNA = "ifany")


# COLORS
########
# Number of unique values in graph_zone variable, minus 1 (for non-active, which is added later as grey (#cccccc))
colors_needed <- length(unique(linelist$graph_zone, na.rm=T)) - 1 

# List of possible colors (see colorbrewer2.com, qualitative scheme)
colors_linelist = c(#"#cccccc", # first = non-active grey color
                "#1b9e77", # turquoise green
                "#ff7f00", # orange
                "#ffff33", # yellow
                "#6a3d9a", # purple
                "#b15928", # brown
                "#1f78b4", # blue
                "#e31a1c", # red,
                "#fb9a99", # pink
                "#b2df8a", # light green 
                "#cab2d6", # light purple
                "#a6cee3", # light blue
                "#fdbf6f", # beige
                "#33a02c"  # green
)

# Reduce number of colors to only the number needed
colors_linelist <- c("#cccccc", rev(colors_linelist[1:colors_needed]))


# MAKE GRAPH
#############
plot_overall <- ggplot(linelist, aes(x = date_onset, fill = graph_zone)) + 
  
  # stacked bars, bined by week (7 days)
  stat_bin(binwidth = 7, position = "stack") +
  
  # Fill of bars
  scale_fill_manual(values = colors_linelist, 
                    labels = str_to_sentence(levels(factor(linelist$graph_zone)))) +
  
  # X-axis 21-day labels
  scale_x_date( # Sets date label breaks as every 3 weeks from Monday before the first case
    breaks = function(x) seq.Date(from = min(linelist$date_onset, na.rm = T), to = max(linelist$date_onset, na.rm = T), by = "3 weeks"),
    limits = c((min(linelist$date_onset, na.rm = T) - 8), (max(linelist$date_onset, na.rm = T) + 8)), # axis limits determined by max/min + buffer
    date_labels = "%d-%b",   # displays as date number, then abbreviated month (e.g. 12 Oct)
    expand = c(0,0)) +                                # sets origin at (0,0)
  
  # Y-axis breaks every 5 cases
  scale_y_continuous(breaks = seq(0, ymax, 25),
                     limits = c(0, ymax),
                     expand = c(0, 0)) +
  
  # Theme specifications (axis, text, etc.)
  theme(plot.title = element_text(size = 20, hjust = 0, face = "bold"),   # title size, font, bold
        axis.text.x = element_text(angle=90, vjust=0.5, hjust=1),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14, face="bold"),
        axis.line = element_line(colour="black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        plot.caption = element_text(hjust = 0, face = "italic")
        ) +
  
  # Legend specifications
  theme(legend.title = element_blank(),                        # No legend title
        legend.position = c(0.20, 0.85),                         # placement of legend
        legend.background = element_blank(),                     # legend background   
        legend.text = element_text(size=12)) +                 # legend text size
  
  guides(fill = guide_legend(reverse = TRUE,                   # Orders Non-active zones at end of legend
                             override.aes = list(size = 0.2),
                             ncol = 2)) +                        # Number of legend columns
  
  labs(x = "Week of illness onset", 
       y = "Number of cases",
       subtitle = "Health zones with cases in the last 42 days specified by color",
       caption = paste0(nrow(linelist),
                        " confirmed and probable cases, reported as of ", data_date, ". ",
                        missing_onset, " cases missing date of onset and not shown.",
                        "\nNon-active zones include: ", str_to_title(toString(unique(linelist$province[linelist$active_zone == FALSE]))))) +
  
  ggtitle("Epidemic curve by active health zones")


# print
plot_overall



```


<!-- ======================================================= -->
### By grouped areas {.tabset .tabset-fade}

``` {r ggplot_health_area, eval=F}

#SETUP
#############
# Filter to health zone of interest
zone_data <- linelist

# Number missing onset_date and cannot be graphed
missing_onset <- nrow(filter(linelist, is.na(date_onset)))

# Assign health area groups (individual for HAs of interest, groups others together)
linelist$graph_areas <- factor(case_when(
  linelist$province == "Shanghai"    ~ "Shanghai",
  linelist$province == "Jiangsu"     ~ "Jiangsu",
  linelist$province == "Zhejiang"    ~ "Zhejiang",
  TRUE                                ~ "Other (10)"
),
# Levels part of the factor function assigns order of appearance
levels = c(                         
  "Other (10)",
  "Shanghai",
  "Jiangsu",
  "Zhejiang"
)
)

# checks
table(linelist$graph_areas, useNA = "ifany")

# Color assignments
colors_needed <- length(unique(linelist$graph_areas, na.rm=T)) - 1 # number of colors needed

# list of colors
colors_aire = c("#a6cee3", 
                           "#1f78b4",
                           "#b2df8a", 
                           "#33a02c",
                           "#fb9a99",
                           "#e31a1c",
                           "#fdbf6f",
                           "#ff7f00",
                           "#cab2d6",
                           "#6a3d9a",
                           "#ffff99",
                           "#b15928"
                           )

# Reduce number of colors to only the number needed
colors_aire <- c("#cccccc", rev(colors_aire[1:colors_needed]))


# Plot of province
#####################################
plot <- ggplot(linelist, aes(x = date_onset, fill = graph_areas)) + 
  
  stat_bin(binwidth = 7, position="stack") +
  
  scale_fill_manual(values = colors_aire, labels = str_to_sentence(levels(factor(linelist$graph_areas)))) +
  
  scale_x_date(date_breaks = "1 week", date_labels = "%d-%b", limits = c((min(linelist$date_onset, na.rm = T) - 8), (max(linelist$date_onset, na.rm = T) + 8)), expand=c(0,0)) + # I used the date onset variable here so x axes will be the same
  
  scale_y_continuous(breaks = seq(0, 500, 5), limits = c(0, 35), expand = c(0, 0)) +
  
  theme(plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
        plot.caption = element_text(hjust = 0, face = "italic"),
        
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        
        
        axis.line = element_line(colour = "black"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        axis.title = element_text(size = 14, face = "bold"),
        
        legend.title = element_blank(),
        legend.justification = c(0,1), 
        legend.position = c(0.05, 1),
        legend.background = element_blank(),
        legend.text = element_text(size = 12)) +
  
  guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2), ncol = 4)) +
  
  labs(x="Week of illness onset", 
       y="Number of cases",
       subtitle = "",
       caption = paste0(nrow(zone_data), " confirmed and probable cases, as of ", data_date, ". \n", missing_onset, " cases excluded due to missing date of onset.")) +
  
  ggtitle("Cases of influenza, by province")

plot


```



<!-- ======================================================= -->
### Faceting {.tabset .tabset-fade}



<!-- ======================================================= -->
### By "wave" in time {.tabset .tabset-fade}


``` {r waves, eval=F}
# Define the waves
##################
# zone_data <- filter(linelist, zone_de_sante == "mabalako")
# 
# zone_data$wave <- case_when(
#   zone_data$date_onset >= as.Date("2018-03-01") &
#     zone_data$date_onset < as.Date("2018-10-25")     ~ "Wave 1",
#   
#   zone_data$date_onset >= as.Date("2018-10-25") &
#     zone_data$date_onset < as.Date("2019-02-01")     ~ "Wave 2",
#   
#   zone_data$date_onset >= as.Date("2019-02-01") &
#     zone_data$date_onset < as.Date("2019-09-15")     ~ "Wave 3",
#   
#   zone_data$date_onset >= as.Date("2019-09-15")      ~ "Wave 4",
#   
#   TRUE ~ NA_character_
# )
# 
# table(is.na(zone_data$date_onset))
# table(zone_data$wave, useNA = "always")
# 
# 
# # Color assignments
# colors_needed <- length(unique(zone_data$wave, na.rm=T)) # number of colors needed
# 
# # list of colors
# colors_aire = c("#a6cee3", 
#                            "#1f78b4",
#                            "#b2df8a", 
#                            "#33a02c",
#                            "#fb9a99",
#                            "#e31a1c",
#                            "#fdbf6f",
#                            "#ff7f00",
#                            "#cab2d6",
#                            "#6a3d9a",
#                            "#ffff99",
#                            "#b15928"
#                            )
# 
# # Reduce number of colors to only the number needed
# colors_aire <- c(rev(colors_aire[1:colors_needed]))
# 
# 
# # Plot of health zone colored by wave
# #####################################
# plot_Mabalako <- ggplot(zone_data, aes(x = date_onset, fill = wave)) + 
#   
#   stat_bin(binwidth = 7, position = "stack") +
#   
#   scale_fill_manual(values = rev(colors_aire), labels = str_to_sentence(levels(factor(zone_data$wave)))) +
#   
#   scale_x_date(date_breaks = "21 days", date_labels = "%d-%b",
#                limits = c((min(zone_data$date_onset, na.rm = T) - 8), (max(zone_data$date_report, na.rm = T) + 8)), expand = c(0,0)) +
#   
#   scale_y_continuous(breaks = seq(0, 500, 5), limits = c(0, 35), expand = c(0, 0)) +
#   
#   theme(text = element_text(family = "Segoe Condensed"),
#         axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
#         axis.text = element_text(size = 12),
#         axis.title = element_text(size = 14, face = "bold"),
#         axis.line = element_line(colour = "black"),
#         
#         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
#         plot.caption = element_text(hjust = 0, face = "italic"),
#         
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.background = element_blank(),
#         
#         legend.title = element_blank(),
#         legend.justification = c(0,1), 
#         legend.position = c(0.75, 0.98),
#         legend.background = element_blank(),
#         legend.text = element_text(size=12)) +
#   
#   guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2), ncol = 1)) +
#   
#   labs(x="Week of illness onset", 
#        y="Number of cases",
#        subtitle = "",
#        caption = paste0(nrow(zone_data), " confirmed and probable cases, as of ", data_date, ". \n", missing_onset, " cases excluded due to missing date of onset and 16 excluded due to uncertain health zone of report.")) +
#   
#   ggtitle("Four waves of EVD in Mabalako health zone")
# 
# plot_Mabalako
# 
# 
# # Produce table describing each wave
# ####################################
# table <- zone_data %>%
#   select("aire_de_sante", "wave", "community_death", "date_onset", "cte_date", "epicasedef", "community_death", "contact_registered", "contact_surveilled") %>%
#   group_by(wave) %>%
#   summarise(first_onset       = min(date_onset, na.rm = T),
#             last_admission    = max(cte_date, na.rm = T),
#             n                 = n(),
#             confirmed         = sum(epicasedef == "confirmed"),
#             community_deaths  = paste0(sum(community_death    == 1), 
#                                        " (", round(100*sum(community_death == 1)/confirmed),"%)"),
#             reg_contacts      = paste0(sum(contact_registered == "yes"),
#                                        " (", round(100*sum(contact_registered == "yes")/confirmed),"%)"),
#             surv_contacts     = paste0(sum(contact_surveilled == "yes"),
#                                        " (", round(100*sum(contact_surveilled == "yes")/confirmed),"%)"),
#             top               = paste(toupper(names(sort(table(aire_de_sante),decreasing=TRUE)[1:3])), collapse=", ",
#                                       round(100*(sort(table(aire_de_sante),decreasing=TRUE)[1:3]/confirmed)), "%"),
#             health_areas      = paste(toupper(unique(aire_de_sante)), collapse=', ') 
#             )
# 
# kable(table)

```


<!-- ======================================================= -->
## Aggregated data {.tabset .tabset-fade}


<!-- ======================================================= -->
### Situation  

Often you do not have linelist data, but instead daily case counts from facilities, districts, etc. You can plot these in an epidemiological curve, but the code will be slightly different.

This section will utilize the counts_data dataset that was imported earlier, in the data preparation section.

Note: The incidence package does not support aggregate data


<!-- ======================================================= -->
### Clean dates  

As before, we must ensure date variables are correctly classified.

```{r aggregated_dates}
# Convert Date variable to Date class
class(count_data$date_hospitalisation)
count_data$date_hospitalisation <- as.Date(count_data$date_hospitalisation)
```



<!-- ======================================================= -->
### Create weeks  

```{r aggregated_epiweek}
# Create epiweek variable
# aweek weeks are also stored as dates, facilitating better display manipulation
count_data$epiweek <- aweek::date2week(count_data$date_hospitalisation,      # use the Date variable
                                        week_start = "Monday", # epiweek begins on Monday
                                        floor_day = TRUE,      # only display year and week #
                                        factor = TRUE)         # expand to include all possible weeks


```



<!-- ======================================================= -->
### Clean dates  

```{r aggregated_plot}
ggplot(data = count_data, aes(x = as.Date(epiweek), y = n_cases, group = hospital, fill = hospital))+
     geom_bar(stat = "identity")+
     
     # LABELS for x-axis
     scale_x_date(date_breaks = "1 month",  # displays by month
                  date_labels = '%b%d\n%Y')+  #labeled by month with year below
     
     # Choose color palette (uses RColorBrewer package)
     scale_fill_brewer(palette = "Pastel1")+      
     
     # Theme specifications (axis, text, etc.)
     theme(
          # title
          plot.title = element_text(size=20, hjust= 0, face="bold"),   # title size, font, bold
          # axes
          axis.text.x = element_text(angle=0, vjust=0.5, hjust=1),
          axis.text = element_text(size=12),
          axis.title = element_text(size=14, face="bold"),
          axis.line = element_line(colour="black"),
          # background
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          # caption (italics, on right side)
          plot.caption = element_text(hjust = 0, face = "italic"))+
     
     # labels
     labs(x = "Week of report", 
          y = "Number of cases",
          subtitle = "Cases aggregated by week and shown by hospital",
          caption = "Data source: XXXXX")+
     
     ggtitle("Epidemic curve of disease X in fictional location")
```


<!-- ======================================================= -->
## Dual-axis {.tabset .tabset-fade}  

Although there are fierce discussions about the validity of this within the data visualization community, many supervisors want to see an epicurve or similar chart with a percent overlaid with a second axis.

In ggplot it is very difficult to do this, except for the case where you are showing a line reflecting the proportion of a category shown in the bars below.


<!-- ======================================================= -->
### Second axis  
This uses the linelist dataset

TODO not complete yet

```{r sec_axis, eval=F}
library(reshape2)
# group the data by week, summarize counts by group (gender)
linelist_week <- linelist %>%
     mutate(onset_epiweek = aweek::date2week(date_onset, floor_day = TRUE, factor = TRUE)) %>%
     group_by(onset_epiweek) %>%
     summarize(num_male = sum(gender == "m"),
               num_female = sum(gender == "f"),
               pct_male = round(100*(num_male / n())),
               med_age  = median(as.numeric(age), na.rm=T)
               ) 
# remove pct and melt
linelist_week_melted <- linelist_week %>%
     select(-c("pct_male", "med_age")) %>%
     melt(id.vars = c("onset_epiweek"))

# merge together (multiple of the same values in week will attach to melted)
linelist_week_melted <- merge(linelist_week_melted,
                              linelist_week,
                              by = "onset_epiweek")

second_axis <- ggplot(linelist_week_melted,
                      aes(x = as.Date(onset_epiweek),
                          y = value, group = variable,
                          fill = variable)) + 
  
  # bars
  geom_bar(stat = "identity")+
  
  # Colors and labels of confirmed/probable
  scale_fill_manual(values = c("blue", "red"),
                    labels = str_to_sentence(levels(factor(linelist_week_melted$variable)))) +
  
  geom_line(mapping = aes(y = pct_male, color = "% male"), size = 0.5) +
     
  scale_color_manual(values = "black")+
     
  scale_y_continuous(sec.axis = sec_axis(~(./sum(linelist_week_melted$value, na.rm = T)*100), name = "name here", breaks = seq(0, 100, 20)))+


  # X-axis scale labels (not aggregation, just the labels)
  scale_x_date(# Sets date label breaks as every week
    breaks = function(x) seq.Date(from = min(linelist$date_onset, na.rm = T), to = max(linelist$date_onset, na.rm = T), by = "1 week"),
    limits = c((min(linelist$date_onset, na.rm=T)), (max(linelist$date_onset, na.rm = T))), # axis limits determined by max/min + buffer
    date_labels = "%d-%b",   # displays as date # then abbreviated month (e.g. 12 Oct)
    expand = c(0, 0)) +                                # sets origin at (0,0)
  
  # Y-scale in breaks, up to the ymax previously defined
  scale_y_continuous(breaks = seq(0, 500, 5), limits = c(0, ymax), expand=c(0, 0)) +
  
  # Themes for axes, titles, background, etc.
  theme(plot.title       = element_text(size=20, hjust=0.5, face="bold"),
        axis.text        = element_text(size=12),
        axis.title       = element_text(size=14, face="bold"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line        = element_line(colour = "black"),
        axis.text.x      = element_text(angle=90, vjust=0.5, hjust=1)) +
  
  # Legend specifications
  theme(legend.title           = element_blank(),
        legend.justification   = c(0, 1), 
        legend.position        = c(0.09, 0.98),
        legend.background      = element_blank(),
        legend.text            = element_text(size = 12)) +
  guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2))) +
  
  # Axis and caption labels
  labs(x = "Week of illness onset",
       y = "Number of Cases",
       caption = paste(missing_onset,"cases were missing onset date and are not included in the onset graph")) +
  
  # Title
  ggtitle("Cases by week of illness onset")

second_axis

# print
print(plot_defined_cats)


```



<!-- ======================================================= -->
## Resources {.tabset .tabset-fade}

This tab should stay with the name "Resources".
Links to other online tutorials or resources.






```{r, child= '_page_closeout.Rmd', eval = params$run_page_ind == F, include = F}
```
