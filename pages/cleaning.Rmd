---
title:  |  
  ![](../images/R Handbook Logo.png)
author: ""
date: "Produced `r format(Sys.time(), '%A %d %B %Y')`"
output:
  html_document:
    code_folding: show
    highlight: zenburn
    number_sections: no
    theme: sandstone
    toc: yes
    toc_collapse: no
    toc_depth: 3
    toc_float: yes
params:
    run_page_ind: TRUE
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "_outputs_knitted") })
---

```{r, child = '_page_setup.Rmd', eval = params$run_page_ind, include = F}
```


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Cleaning data {#cleaning .tabset .tabset-fade}


<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}  

This page demonstrates common steps necessary to clean a dataset. It uses a simulated Ebola case linelist, which is used throughout the handbook.  

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dataset_snip.png"))
```

**HOW TO READ:** To emphasize the **tidyverse** coding approach, each cleaning step is explained individually and then incorporated into a **"cleaning pipeline"** - a series of cleaning actions linked together sequentially through pipes (LINK TO PIPES). The pipe begins with the "raw" data (`linelist_raw`) and ends with a "clean" dataset (`linelist`).  

The cleaning steps demonstrated include:  

* Loading the data  
* column name cleaning  
* column selection  
* Designating column classes  
* Filtering rows  
* Re-coding values  
* Creating groups (`case_when()`)
* Dealing with character case (upper, lower, title, etc.)
* Factor columns  

replace missing with
dealing with cases (all lower, etc)
case_when()
factors


<!-- ======================================================= -->
## Preparation

### Load packages  

```{r, clean_packages}
pacman::p_load(tidyverse,  # data manipulation and visualization
               janitor,    # data cleaning
               epitrix,    # data cleaning
               )
```

### Load data  

Import the raw dataset using the `import()` function from the package **rio**.  (LINK HERE TO IMPORT PAGE)  

```{r, echo=F}
# actually load the data
linelist_raw <- rio::import(here::here("data", "ebola_simulated.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("ebola_simulated.xlsx")
```

You can view the original **raw** dataset below: 

```{r message=FALSE}
# display the linelist data as a table
DT::datatable(linelist_raw, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```





<!-- ======================================================= -->
## A cleaning pipeline

As explained in the section on **dplyr** and tidyverse coding style (LINK HERE), a chain of 'verb' functions operate on a dataset through 'pipes' (`%>%`), passing the output from one verb to the next. 

order is important

TO DO

<!-- ======================================================= -->
## Column names  

column names are used so often, it is best that they have "clean" syntax. We suggest the following:  

* short
* no spaces (replaced with underscores (_), 
* no unusual characters (&, #...)  
* similar nomenclature (e.g. all dates like date_onset, date_report, date_death)  

The names of `linelist_raw` are below. We can see that there are some with spaces. We also have different naming patterns for dates ('date onset' and 'infection date').  

```{r}
names(linelist_raw)
```

```
Note: To use a column names that include spaces, surround the name with back-ticks, for example: linelist$`infection date` 
On a keyboard, the back-tick (`) is different from the single quotation mark ('), and is sometimes on the same key as the tilde (~).
```

#### Automatic syntax cleaning  

The function `clean_names()` from the package **janitor** standardizes column names by transliterating to unique ASCII names by doing the following:  

* Converts all names to consist of only underscores, numbers, and letters  
* Accented characters are transliterated to ASCII (e.g. german o with umlaut becomes "o", spanish "enye" becomes "n")  
* Capitalization preference can be specified using the `case = ` argument ("snake" is default, alternatives include "sentence", "title", "small_camel"...)  
* You can designate specific replacements with the `replace = ` argument (e.g. replace = c(onset = "date_of_onset"))  
* Here is an online [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning)  

```{r clean_names}
# send the dataset through the function clean_names()
linelist <- linelist_raw %>% 
  janitor::clean_names()

# see the new names
names(linelist)
```

#### Manual column name cleaning  

Re-naming columns manually is often necessary. Below, re-naming is performed using the `rename()` function from the **dplyr** package, as part of a pipe chain. `rename()` uses the style "NEW = OLD", the new column name is given before the old column name.  

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```

Now you can see that the columns names have been changed:  

```{r message=FALSE}
# display the linelist data as a table
DT::datatable(linelist, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```



<!-- ======================================================= -->
## Select columns

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>


Often the first step of cleaning data is selecting the columns you want to work with, and to set their order in the dataframe. In a **dplyr** chain of verbs, this is done with `select()`. *Note that in these examples we modify linelist with select(), but do not assign/overwrite. We just display the resulting new column names, for purpose of example.*   

**Here are all the column names in the linelist:**

```{r}
names(linelist)
```

### With `select()` you can do the following:  

**Select only the columns you want to remain, *and their order of appearance***  

```{r}
# linelist dataset is piped through select() command, and names() prints just the column names
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names() # display the column names
```
 


**Indicate which columns to remove** by placing a minus symbol "-" in front of the column name (e.g. `select(-outcome)`), or a vector of column names (as below). All other columns will be retained.  
Inside `select()` you can use normal operators such as `c()` to list several columns, `:` for consecutive columns, `!` for opposite, `&` for AND, and `|` for OR.  

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # remove onset and all symptom columns
  names()
```

**Re-order the columns** - use `everything()` to signify all other columns not specified in the `select()` command:  

```{r}
# move case_id, date_onset, date_hospitalisation, and gender to beginning
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, gender, everything()) %>% 
  names()
```

As well as `everything()` there are several special functions that work *within* `select()`, namely:  

* `everything()`  - all other columns not mentioned  
* `last_col()`    - the last column  
* `starts_with()` - matches to a specified prefix. Example: `select(starts_with("date"))`
* `ends_with()`   - matches to a specified suffix. Example: `select(ends_with("_end"))`  
* `contains()`    - columns containing a character string. Example: `select(contains("time"))` 
* `matches()`     - to apply a regular expression (regex). Example: `select(contains("[pt]al"))`  
* `num_range()`   - 
* `any_of()`      - matches if column is named. Useful if name might not exist. Example: `select(any_of(date_onset, date_death, cardiac_arrest))`  
* `where()`       - applies a function to all columns and selects those which are TRUE  


### Adding `select()`to the cleaning pipe chain:  

In the linelist, there is one column we do not need: `row_num`. Remove it by adding a `select()` command to the cleaning pipe chain:  

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-row_num)
```


### `select()` as a stand-alone command

Select can also be used as an independent command (not in a pipe chain). In this case, the first argument is the original dataframe to be operated upon.  

```{r}
# Create a new linelist with only three columns
linelist_age <- select(linelist, case_id, age, age_unit)
```

<!-- ======================================================= -->
## Fix classes {.tabset .tabset-fade .tabset-pills #Classes}

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>

See section on [object classes](#objectclasses)   

Here we want to ensure that the class of each column is appropriate. First we run some checks on the classes of important columns.  

The class of the "age" column is character. To perform analysis, we need those numbers to be recognized as numeric! 

```{r}
class(linelist$age)
```

The class of the "date_onset" column is also character! To perform analysis, these dates must be recognized as dates! 
 
```{r}
class(linelist$date_onset)
```

Use `table()` or another method to see all the values, can see that we see that one date was entered in a different format (15 April 2014) than all the others!  

```{r, echo=F}
head(table(linelist$date_onset))
```

This means before we can classify "date_onset" as a date, this value must be fixed to be the same format as the others. You can fix the date in the source data. Or, we can do this using `mutate()` and `recode()` in our cleaning pipe chain, *before* the commands to convert to class Date. LINK TO CLASSIFYING column AS DATE. 

The new mutate line can be read as: mutate date_onset to equal date_onset recoded so that OLD VALUE is changed to NEW VALUE. Note that this pattern (OLD = NEW) is the opposite of most R patterns. The R development community is working on revising this.

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
  
    # remove column
    select(-row_num) %>% 

# ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
  ###################################################
  # fix incorrect values                 # old value       # new value
  mutate(date_onset = recode(date_onset, "15 April 2014" = "2014-04-15")) %>% 
  
  # correct the class of the columns
  mutate(age           = as.numeric(age),
         date_onset    = as.Date(date_onset, format = "%Y-%m-%d"))

```

Especially after converting to class date, check your data visually or with `table()` to confirm that they were converted correctly! For `as.Date()`, the `format = ` argument is often a source of errors.  

#### Fix class for multiple columns at once

```{r}
class(linelist$date_infection)
head(linelist$date_infection)
```

You can use The **dplyr** function `across()` with `mutate()` to convert several columns at once to a new class. `across()` allows you to specify which columns you want a function to apply to. Below, we want to mutate the columns where `is.POSIXct()` (a type of date/time class that shows unnecessary timestamps) is `TRUE`, and apply the function `is.Date()` to them, in order to convert them to class "date".   

* Note that within `across()` we also use the function `where()`.  
* Note that is.POSIXct is from the package **lubridate**. Other similar functions (`is.character()`, `is.numeric()`, and `is.logical()`) are from **base R**  
* Note that the functions in `across()` are written *without* the empty parentheses ()  


```{r}
linelist <- linelist %>% 
  mutate(across(where(lubridate::is.POSIXct), as.Date))
```


<!-- ======================================================= -->
## Filter rows {.tabset .tabset-fade .tabset-pills}

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>

After selecting columns, a typical cleaning step is to filter the dataframe for specific rows using the **dplyr** verb `filter()`. Within `filter()`, give the logic that must be `TRUE` for a row in the dataset to be kept. A simple example below filters to keep only the rows where `case_id` is not missing (three rows are removed):

```{r}
linelist <- linelist %>% 
  filter(!is.na(case_id))  # keep only rows where case_id is not missing
```

A more complex example:  

Run a simple histogram of onset dates to see that a second smaller outbreak from 2012-2013 is also included in this dataset. **For our analyses, we want to remove entries from this earlier outbreak.**  

```{r}
hist(linelist$date_onset, breaks = 50)
```

If we simply filter `linelist` by date of onset (after June 2013) we may make a mistake! Applying `filter(date_onset > as.Date("2013-06-01")))` would accidentally remove any rows in the later epidemic with a missing date of onset!   

<span style="color: red;">**_DANGER:_** Filtering to greater than (>) or less than (<) a date can remove any rows with missing date values (`NA`)! This is because `NA` is treated as infinitely large and small.</span>

We also know that this first epidemic occurred at Hospital A, Hospital B, and there were 10 cases at Connaught Hospital.  Hospitals A & B did *not* have cases in the second epidemic, but Connaught Hospital had many. This is a complex filter to apply - it is wise to tabulate these columns to know exactly how many rows we expect should be removed.  

Let's examine a cross-tabulation to make sure we exclude only the correct rows:  

```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of the date_onset
      useNA     = "always")                              # show missing values
```

We want to exclude only the `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))` rows from 2012 and 2013 at those three hospitals (A, B, and Connaught), including the 2 from Hospitals A & B with missing onset dates, but not any others with missing onset dates. We start with a linelist of `nrow(linelist)`. Here is our statement:  

```{r}
linelist <- linelist %>% 
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

When we re-make the cross-tabulation, we see that Hospitals A & B are removed completely, the 10 Connaught Hospital cases from 2012 & 2013 are removed, and all other values are the same - just as we wanted.  
 
```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of the date_onset
      useNA     = "always")                              # show missing values
```

Multiple filter statements can be separated by commas, or you can always pipe to a separate filter() statement for clarity. Adding these filter statements to the cleaning pipe chain now looks like this:  

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
  
    # remove column
    select(-row_num) %>% 

    # fix incorrect values                 # old value       # new value
    mutate(date_onset = recode(date_onset, "15 April 2014" = "2014-04-15")) %>% 
    
    # correct the class of the columns
    mutate(age           = as.numeric(age),
           date_onset    = as.Date(date_onset, format = "%Y-%m-%d")) %>% 
    
  # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    filter(!is.na(case_id),  # keep only rows where case_id is not missing
           date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B"))
           ) # close filter

```

### Standalone command
filter(dataset, criteria) OR subset like:
dataset_new <- dataset[criteria,criteria]

nrow(linelist %>% filter())


<!-- ======================================================= -->
## Creating and modifying columns {#mutate .tabset .tabset-fade .tabset-pills}

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>

We advise creating new columns with **dplyr** functions as part of a chain of such verb functions (e.g. filter, mutate, etc.)  
If in need of a stand-alone command, you can use **plyr** or also the **base** R style to create a new column.  


<!-- ======================================================= -->
### Using `mutate()` (**dplyr**)

**The verb `mutate()` is used to add a new column or modify an existing one.** Below are some example of creating new columns with `mutate()`. The syntax is: new_column_name = value or function. It is best practice to separate each new column with a comma and new line.  

```{r}
linelist <- linelist %>%                   # creating new, or modifying old dataset
  mutate(new_var_dup    = case_id,                  # new column = duplicate/copy another column
         new_var_static = 7,                   # new column = all values the same
         new_var_static = new_var_static + 5,  # you can overwrite a column, and can modify a column multiple times
         new_var_calc   = (age / 12),          # new column = a calculation
         new_var_paste  = paste0(hospital, " (", date_hospitalisation, ")") # new column = pasting together values from other columns
         ) 
```


***Scroll to the right to see the new columns:***  

```{r message=FALSE}
# display the linelist data as a table
DT::datatable(linelist, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```

<span style="color: darkgreen;">**_TIP:_** The verb `transmute()` adds new columns just like `mutate()` but also drops/removes all other columns that you do not mention.</span>

```{r, echo=F}
# remove new demo columns
linelist <- linelist %>% 
  select(-contains("new_var"))
```


<!-- ======================================================= -->
### Simple recoding of values  

To recode the values in a column, `mutate()` is also used.  

For example, in the linelist we need to clean the values in the column "hospital". There are several incorrect spelling, and many missing values.

```{r}
table(linelist$hospital, useNA = "always")
```

To change spellings one-by-one, you can use the `recode()` function *within the mutate function*. The code is saying that the column "hospital" should be defined as the current column "hospital" but with certain changes (syntax is OLD = NEW). **Don't forget commas!**  

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                           # OLD = NEW
                           "Mitylira Hopital"  = "Military Hospital",
                           "Mitylira Hospital" = "Military Hospital",
                           "Military Hopital"  = "Military Hospital",
                           "Connaught Hopital" = "Connaught Hospital",
                           "Rokupa Hopital"    = "Rokupa Hospital",
                           "other"             = "Other",
                           "Princess Christian Maternity Hopital (PCMH)" = "Princess Christian Maternity Hospital (PCMH)"
                           ))

table(linelist$hospital, useNA = "always")
```

<span style="color: darkgreen;">**_TIP:_** The number of spaces before and after an equals sign does not matter. Make your code easier to read by aligning the = for all or most rows. Also, consider adding a hashed comment row to clarify for future readers which side is OLD and which side is NEW. </span>  

<span style="color: darkgreen;">**_TIP:_** Sometimes a *blank* character value exists in a dataset (not recognized as R's value for missing - `NA`). You can reference this value with two quotation marks with no space inbetween ("").</span>  



<!-- ======================================================= -->
### Special recoding functions  

To change missing values to a character value, such as "Missing", use the function `replace_na()` in the same manner as `recode` above:  

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

Likewise you can quickly convert character values to `NA` using `na_if()`, as below:

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

#### logical re-coding

Intro
For simple cases you can use `ifelse()` or `if_else()`. In most cases it is better to use `case_when()`.  

ifelse() and if_else():  
These commands are simplified versions of an `if` and `else` statement. The general syntax is ifelse(**condition**, **value if TRUE**, **value if FALSE**). `if_else()` is a special version from **dplyr** that handles dates.

Stringing together ifelse statements - NOT ADVISED!! Difficult to read and keep track of.

IMAGE of ifelse string with X across is. 

Use case-when() instead. 


You can reference other columns with the `ifelse()` function within `mutate()`:  

```{r}
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

```{r}
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```



Missing if... `na_if()`
lead(), lag()
cumsum(), cummean(), cummin(), cummax(), cumany(), cumall(),  

coalesce()

 if_else(), ifelse()

recode
CLEANING MISSPELLINGS HOSPITAL NAME

Replace


<!-- ======================================================= -->
### Using cleaning dictionaries

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>

```{r, eval=F}
## load cleaning rules and only keep columns in mll
mll_cleaning_rules <- import(here("dictionaries/mll_cleaning_rules.xlsx")) %>%
  filter(column %in% c(names(mll_raw), ".global"))

## define columns that are not cleand
unchanged <- c(
  "epilink_relationship",
  "narratives",
  "epilink_relationship_detail"
)

mll_clean <- mll_raw %>%
  ## convert to tibble
  as_tibble() %>%
  ## clean columns using cleaning rules
  clean_data(
    wordlists = mll_cleaning_rules,
    protect = names(.) %in% unchanged
  )

```


<!-- ======================================================= -->
### Mutating grouped data

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>

Using mutate on GROUPED dataframes
https://dplyr.tidyverse.org/reference/mutate.html

Taken from website above:
```
Because mutating expressions are computed within groups, they may yield different results on grouped tibbles. This will be the case as soon as an aggregating, lagging, or ranking function is involved. Compare this ungrouped mutate:

starwars %>%
  select(name, mass, species) %>%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
With the grouped equivalent:

starwars %>%
  select(name, mass, species) %>%
  group_by(species) %>%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
The former normalises mass by the global average whereas the latter normalises by the averages within species levels.
```

<!-- ======================================================= -->
### Using **base** R  

If you need to write a stand-alone command using **base R** (e.g. not part of a chain of **dplyr** verbs), then you can create a new column by assigning it a value. In the command below, the column `new_var` does not exist until after the command is executed. In this simple example the column is assigned the static value "new value", so for all rows the value will be "new value".  


```{r, eval=F}
linelist_raw$new_var <- "new value"
```

You can also give the new column a dyanmic value as shown below, or using the `case_when()` command explained in the next tab.

```{r, eval=F}
# mathematical operators on another column
linelist_raw$new_var <- linelist_raw$OLD_var * 4
```



<!-- ======================================================= -->
## Groups by condition (`case_when()`) {#casewhen}


<!-- ======================================================= -->
### Recoding with logic using `case_when()`

If you need to use logic statements to recode values, or want to use operators like `%in%`, use **dplyr**'s `case_when()` instead. **If you use `case_when()` please read the thorough explanation HERE LINK, as there are important differences from `recode()` in syntax and logic order!**   

```{r}
linelist <- linelist %>% 
  mutate(hospital = case_when(hospital == "Connaught Hopital"                           ~ "Connaught Hospital",
                              hospital == "Rokupa Hopital"                              ~ "Rokupa Hospital", 
                              hospital %in% c("Mitylira Hopital", 
                                             "Mitylira Hospital",
                                             "Mitylira Hospital",
                                             "Military Hopital")                        ~ "Military Hospital",
                              is.na(hospital)                                           ~ "Missing",
                              hospital == "Princess Christian Maternity Hopital (PCMH)" ~ "Princess Christian Maternity Hospital (PCMH)",
                              TRUE                                                      ~  hospital) 
)
table(linelist$hospital, useNA = "always")

```

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>

TODO tutorial on using case_when()

<!-- ======================================================= -->
### Numeric groups  

For example, creating age groups
`cut()`

`case_when()`

`age_categories()` (R4Epis package)

by percentile



WHAT TO DO IF AGE IS SPREAD ACROSS TWO VARAIBLES (e.g. numeric age + unit)


<!-- ======================================================= -->
### Highest in hierarchy

<span style="color: orange;">**_CAUTION:_** This tab may follow from previous tabs.</span>

Within a group, indicate/convert to the highest value in the group

Santa Clara County example - COVID contact tracing data - classification of multiple phone call records from same person into the highest category. (classify all as the highest of the group)



```{r echo=F}
# EXPORT CLEANED LINELIST FILE TO "DATA" FOLDER
rio::export(linelist, here::here("data", "linelist_cleaned.xlsx"))
rio::export(linelist, here::here("data", "linelist_cleaned.rds"))

```

```{r, child= '_page_closeout.Rmd', eval = params$run_page_ind == F, include = F}
```
