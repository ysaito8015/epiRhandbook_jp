---
title:  |  
  ![](images/R Handbook Logo.png)
author: "Version 1.0.0"
date: "Produced `r format(Sys.time(), '%A %d %B %Y')`"
output:
  html_document:
    code_folding: show
    highlight: zenburn
    number_sections: no
    theme: sandstone
    toc: yes
    toc_collapse: no
    toc_depth: 3
    toc_float: yes
    #css: !expr here::here('css', 'style.css')
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      collapse = TRUE,
                      fig.width = 8,
                      fig.height = 6,
                      dpi = 150,
                      warning = FALSE,
                      message = FALSE)
```


```{r klippy, echo=FALSE, include=TRUE}
#Enables "copy to clipboard" icons   https://rlesur.github.io/klippy/articles/klippy.html
klippy::klippy(position = c('top', 'right'))
```

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Introduction {.tabset .tabset-fade}


<!-- ======================================================= -->
## About this handbook
<h2> About this handbook </h2>

**Purpose**  

**This "handbook" will serve as a reference guide specifically for epidemiologists using R, providing step-by-step examples of how to complete common epi tasks and outputs, with clear instructions and code.**

The problem:

* Field epidemiologists often work in low internet-connectivity environments and have limited technical support from HQ  
* Epis learning or new to R often must Google and skim dozens of forum pages to complete common data manipulation and visualization epi tasks  
* Most online R help resources are not task-centered nor epidemiology-focused

  
**How to read this handbook:**  

* *This handbook in an HTML file. It is not online, you are only using your web browser to view this local file.*  

* *This handbook is ***best viewed with Google Chrome***. Some functions may not work in other browsers.*  

* *Use tabs on the right to hide/view code. See 'Copy to clipboard' icon in the upper-right of each code section*  


**Version**  
The latest version of this handbook can be found at this [github repository](https://github.com/nsbatra/R_epi_handbook).  


**Style**

* In many cases, code in this handbook explicitly names the package for a function (e.g. `dplyr::mutate()`). Most times, the code will run without the package being called (without `dplyr::`), but we do this just to be clear to the reader which package is being used.  
* Generally, package names are in bold (e.g. **dplyr**) and functions are in code text (e.g. `mutate()`).  


**Note types**

```
FOR EXAMPLE: This is a boxed example

```

> **_TIP:_**  This could also be a note.


<span style="color: black;">**_NOTE:_** This is a note</span>



<span style="color: darkgreen;">**_TIP:_** This is a tip.</span>



<span style="color: orange;">**_CAUTION:_** This is a cautionary note.</span>



<span style="color: red;">**_DANGER:_** This is a warning.</span>

<!-- ======================================================= -->
## Datasets used {#datasets}
<h2> Datasets used </h2>

Here the datasets used in this handbook will be described and will be "downloadable" via link (the files will be stored within the HTML, so available offline as well)

* Linelist (...)  Linelist for the 2013 (first wave) H7N9 outbreak in China ([source](https://datadryad.org/stash/dataset/doi:10.5061/dryad.2g43n))
* Aggregated case counts (...)  
* GIS coordinates (...)  
* GIS shapefile (...)  
* modeling dataset? (...)

```{r handbook_packages_silent, echo = F}
pacman::p_load(tidyverse, rio, here, apyramid, linelist)


# remotes::install_github("rlesur/klippy")
# remotes::install_github("reconhub/epicontacts@ttree")
# remotes::install_github("reconhub/linelist")


```


```{r datasets_import_silent, echo = F, cache=T}

# import linelist
linelist_raw <- import(here("data", "fluH7N9_China_2013.csv"))
  
  
linelist <- linelist_raw %>% 
  mutate(age = as.numeric(age))

# import aggregated case counts of disease X
count_data <- rio::import(here::here("data", "aggregated_counts_diseaseX.xlsx"))  

# import ...

```


<!-- ======================================================= -->
## Contributors
<h2> Contributors </h2>

**Maintainer:** Neale Batra (neale.batra@gmail.com)

**Code contributors:** ...

**Data contributors:** *outbreaks* package

Content provided by these people.... a...b...c...d...  

Review provided by these people...   

Some of this material comes from the R4Epis website, which was also made by some of the same people...

RECON

Photo credits (logo): CDC Public Image gallery; R Graph Gallery


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# R Basics {#rbasics .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview

This section is **not** meant as a comprehensive "how to learn R" tutorial. However, it does cover some of the fundamentals that can be good to reference or refresh. 

More comprehensive tutorials are available online:  
* Here  
* and Here  
* and even Here  
* Oh yea and Here too (there's a lot of them)  


<!-- ======================================================= -->
## Why use R?
<h2> Why use R? </h2>

* Reproducibility  
* Fewer errors  
* Collaboration  
* Free

<!-- ======================================================= -->
## Installation {#install .tabset .tabset-fade .tabset-pills}
<h2> Installation </h2>

How to install R


How to install R Studio


Other things you may need to install:  
* TinyTeX  
* Pandoc  
* RTools  

<!-- ======================================================= -->
## RStudio {#rstudio .tabset .tabset-fade .tabset-pills}
<h2> RStudio </h2>


### RStudio Orientation
**First, open RStudio.** As their icons can look very similar, be sure you are opening *RStudio* and not R.  


For RStudio to function you must also have R installed on the computer (see [this section](#install) for installation instructions).  

**RStudio** is an interface (GUI) for easier use of **R**. You can think of R as being the engine of a vehicle, doing the crucial work, and RStudio as the body of the vehicle (with seats, accessories, etc.) that helps you actually use the engine to move forward!  

By default RStudio displays four rectangle panes. 

```{r basics_RStudio, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```


<span style="color: black;">**_TIP:_** If your RStudio displays only one left pane it is because you have no scripts open yet.</span>


**The R Console Pane**  

The R Console, by default the left or lower-left pane in R Studio, is the home of the R "engine". This is where the commands are actually run and non-graphic outputs and error/warning messages appear. You can directly enter and run commands in the R Console, but realize that these commands are not saved as they are when running commands from a script.  

If you are familiar with Stata, the R Console is like the Command Window and also the Results Window.

**The Source Pane**  
This pane, by default in the upper-left, is space to edit and run your scripts. This pane can also display datasets (data frames) for viewing.  

For Stata users, this pane is similar to your Do-file and Data Editor windows.


**The Environment Pane**  
This pane, by default the upper-right, is most often used to see brief summaries of objects in the R Environment in the current session. These [objects](#objects) could include imported, modified, or created datasets, parameters you have defined (e.g. a specific epi week for the analysis), or vectors or lists you have defined during analysis (e.g. names of regions). Click on the arrow next to a dataframe name to see its variables.  

In Stata, this is most similar to Variables Manager window.


**Plots, Packages, and Help Pane**  
The lower-right pane includes several tabs including plots (display of graphics including maps), help, a file library, and available R packages (including installation/update options).  

This pane contains the Stata equivalents of the Plots Manager and Project Manager windows.

### RStudio settings  

Change RStudio settings and appearance in the Tools drop-down menu, by selecting Global Options


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Scripts {#scripts .tabset .tabset-fade .tabset-pills}
<h2> Scripts </h2>

<!-- ======================================================= -->
### Why use a script {#rmd .tabset .tabset-fade .tabset-pills}

R scripts (vs. typing in the console)  
* Advantages (reproducability)
* General sequence (into, load packages, load data, clean data, conduct analysis, save results)
* Commenting

<!-- ======================================================= -->
### Rmarkdown {#rmd .tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
### R notebooks {#rnotebooks .tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
### RShiny {#shinyscripts .tabset .tabset-fade .tabset-pills}



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Working directory {#workingdirectory}
<h2> Working directory </h2>

These tabs cover how to use R working directories, and how this changes when you are working within an R project. 
**The working directory is the root file location used by R for your work.**  
By default, it will save new files and outputs to this location, and will look for files to import (e.g. datasets) here as well.  

```
NOTE: If using an [R project](#rproject), the working directory will default to the R project root folder **IF** you open RStudio by clicking open the R project (the file with .rproj extension))

```

<!-- ======================================================= -->
### Set by Command

Use the command `setwd()` with the filepath in quotations, for example: `setwd("C:/Documents/R Files")`


<span style="color: orange;">**_CAUTION:_** If using an RMarkdown script be aware of the following:</span>

In an [R Markdown](#rmarkdown) script, the default working directory is the folder the Rmarkdown file (`.Rmd`) is saved to. If you want to change this, you can use `setwd()` as above, but know the change will only apply to that specific code chunk.  

To change the working directory for all code chunks in an R markdown, edit the setup chunk to add the `root.dir = ` parameter, such as below:

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/filepath/here')
```

<!-- ======================================================= -->
### Set Manually

Setting your working directory manually (point-and-click)  

From RStudio click: Session / Set Working Directory / Choose Directory (you will have to do this each time you open RStudio)


<!-- ======================================================= -->
### In an R project

How things change in an R project




<h2> Objects </h2>
<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Objects {#objects .tabset .tabset-fade .tabset-pills}

Everything in R is an object. These sections will explain:  

* How to create objects (`<-`) 
* Types of objects (e.g. data frames, vectors..)  
* How to access subparts of objects (e.g. variables in a dataset)  
* Classes of objects (e.g. numeric, character, factor)  



<!-- ======================================================= -->
### Everything is an object 

Everything you store in R - datasets, variables, a list of village names, a total population number, even outputs such as graphs - are **objects** which are **assigned a name** and **can be referenced** in later commands.  

An object exists when you have assigned it a value (see the assignment section below). When it is assigned a value, the object appears in the Environment (see the upper right pane of RStudio). It can then be operated upon, manipulated, changed, and re-defined.

### Creating objects (`<-`)

**Create objects *by assigning them a value* with the <- operator.**  
You can think of the assignment operator `<-` as the words "is defined as". Assignment commands generally follow a standard order:
 
**object_name**  <-  **value** (or process/calculation that produce a value)

> **EXAMPLE:** You may want to record the current epidemiological reporting week as an object for reference in later code. In this example, the object `reporting_week` is created when it is assigned the character value `"2018-W10"` (the quote marks make these a character value).  
The object `reporting_week` will then appear in the RStudio Environment pane (upper-right) and can be referenced in later commands.  


See the R commands and their output in the boxes below. 

```{r basics_objects_assignment}
reporting_week <- "2018-W10"   # this command creates the object reporting_week by assigning it a value
reporting_week                 # this command prints the current value of reporting_week object in the console
```

<span style="color: black;">**_NOTE:_** Note the `[1]` in the R console output is simply indicating that you are viewing the first item of the output</span>


<span style="color: orange;">**_CAUTION:_** **An object's value can be over-written** at any time by running an assignment command to re-define its value. Thus, the **order of the commands run is very important**.</span>

The following command will re-define the value of `reporting_week`: 

```{r basics_objects_reassignment}
reporting_week <- "2018-W51"   # assigns a NEW value to the object reporting_week
reporting_week                 # prints the current value of reporting_week in the console
```

**Datasets are also objects and must be assigned names when they are imported.**  

In the code below, the object `linelist_raw` is created and assigned the value of a CSV file imported with the **rio** package.  

```{r basics_objects_dataframes, eval=FALSE}
# linelist_raw is created and assigned the value of the imported CSV file
linelist <- rio::import("my_linelist.csv")
```

You can read more about importing and exporting datasets with the section on [importing data](#importdata).

<span style="color: orange;">**_CAUTION:_** A quick note on naming of objects:</span>

  * Object names must not contain spaces, but you should use underscore (_) or a period (.) instead of a space.  
  * Object names are case-sensitive (meaning that Dataset_A is different from dataset_A). 
  * Object names must begin with a letter (cannot begin with a number like 1, 2 or 3). 

 

<!-- ======================================================= -->
### Object Structure {#objectstructure}  

**Objects can be a single piece of data (e.g. `my_number <- 24`), or they can consist of structured data.**  

The graphic below, sourced from [this online R tutorial](http://venus.ifca.unican.es/Rintro/dataStruct.html) shows some common data structures and their names. Not included in this image is spatial data, which is discussed in the [GIS section](#gis).  


```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```  

In epidemiology (and particularly field epidemiology), you will *most commonly* encounter data frames and vectors:  


Common structure | Explanation | Example from templates
------------------- | ------------------------------------ | ------------------------  
Vectors | A container for a sequence of singular objects, all of the same class (e.g. numeric, character). | **"Variables" (columns) in data frames are vectors** (e.g. the variable `age_years`).  
Data Frames | Vectors (e.g. columns) that are bound together that all have the same number of rows. | `linelist_raw` and `linelist_cleaned` are both data frames.  

Note that to create a vector that "stands alone", or is not part of a data frame (such as a list of location names), the function `c()` is often used:  
`list_of_names <- c("Ruhengeri", "Gisenyi", "Kigali", "Butare")`  

<!-- ======================================================= -->
### Variables (`$`) {#dollarsign}  

**Vectors within a data frame (variables in a dataset) can be called, referenced, or created using the `$` symbol.** The `$` symbol connects the name of the column to the name of its data frame. The `$` symbol must be used, otherwise R will not know where to look for or create the column.  

```{r basics_objects_call, eval=F}
# Retrieve the length of the vector age_years
length(linelist$age) # (age is a variable in the linelist data frame)

```

By typing the name of the data frame followed by `$` you will also see a list of all variables in the data frame. You can scroll through them using your arrow key, select one with your Enter key, and avoid spelling mistakes!  

```{r basics_objects_callGIF, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```  


<!-- ======================================================= -->
### Object Classes  {#objectclasses}

All the objects stored in R have a *class* which tells R how to handle the object. There are many possible classes, but common ones include:

Class |	Explanation | Examples
------ | ------------------------------------------ |  -----------------------------
Character	| These are text/words/sentences **"within quotation marks"**. Math cannot be done on these objects.	| "Character objects are in quotation marks"  
Numeric	| These are numbers and **can include decimals**. If within quotation marks the will be considered character. | 23.1 or 14  
Integer | Numbers that are **whole only** (no decimals) | -5, 14, or 2000  
Factor | These are vectors that have a **specified order** or hierarchy of values | Variable `msf_involvement` with ordered values N, S, SUB, and U.  
Date | **Once R is told that certain data are Dates**, these data can be manipulated and displayed in special ways. See the page on Dates for more information. | 2018-04-12 or 15/3/1954 or Wed 4 Jan 1980  
Logical | Values must be one of the two special values TRUE or FALSE (note these are **not** "TRUE" and "FALSE" in quotation marks) | TRUE or FALSE  
data.frame | A data frame is how R stores a **typical dataset**. It consists of vectors (columns) of data bound together, that all have the same number of observations (rows). | The example AJS dataset named `linelist_raw` contains 68 variables with 300 observations (rows) each.  

**You can test the class of an object by feeding it to the function `class()`**. Note: you can reference a specific column within a dataset using the `$` notation to separate the name of the dataset and the name of the column.

```{r basics_objects_class, echo=TRUE, eval=T}
class(linelist$age)     # class should be numeric

class(linelist$gender)  # class should be character
```

**Often, you will need to convert objects or variables to another class.**

Function | Action  
----------------- | --------------------------------------------------------------    
`as.character()` | Converts to character class  
`as.numeric()` | Converts to numeric class  
`as.integer()` | Converts to integer class
`as.Date()` | Converts to Date class - Note: see section on [dates](#dates) for details  
`as.factor()` | Converts to factor - Note: re-defining order of value levels requires extra arguments

Here is [more online material on classes and data structures in R](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/).




<h2> Functions </h2>
<!-- ======================================================= -->
## Functions {#functions .tabset .tabset-fade .tabset-pills}

This section on functions explains:  
* What a function is and how they work  
* What arguments are  
* What packages are  
* How to get help understanding a function  


<!-- ======================================================= -->
### Simple Functions  

**A function is like a machine that receives inputs, does some action with those inputs, and produces an output.**  
What the output is depends on the function.    

**Functions typically operate upon some object placed within the function's parentheses**. 
For example, the function `sqrt()` calculates the square root of a number:  

```{r basics_function_sqrt}
sqrt(49)
```

Functions can also be applied to variables in a dataset. For example, when the function `summary()` is applied to the numeric variable `age` in the dataset `linelist` ([what's the `$` symbol?](#objects)), the output is a summary of the variable's numeric and missing values.

```{r basics_functions_summary}
summary(linelist$age)
```

<span style="color: black;">**_NOTE:_** Behind the scenes, a function represents complex additional code that has been wrapped up for the user into one easy command.</span>



<!-- ======================================================= -->
### Functions with Multiple Arguments  

Functions often ask for several inputs, called ***arguments***, located within the parentheses of the function, usually separated by commas. 

* Some arguments are required for the function to work correctly, others are optional.  
* Optional arguments have default settings if they are not specified.
* Arguments can take character, numeric, logical (TRUE/FALSE), and other inputs.  


```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```


>**For example**, this `age_pyramid()` command produces an age pyramid graphic based on defined age groups and a binary split variable, such as `gender`. The function is given three arguments within the parentheses, separated by commas. The values supplied to the arguments establish `linelist` as the data frame to use, `age_group` as the variable to count, and `gender` as the binary variable to use for splitting the pyramid by color.

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE, eval=T}
## create an age group variable by specifying categorical breaks
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

<span style="color: black;">**_NOTE:_** For this example, in the background we have created a new variable called "age_group". To learn how to create new variable see [that section of this handbook](#newvars) </span>


```{r basics_functions_pyramid, message=FALSE, warning=FALSE, eval=T, out.width = "75%", out.height="75%"}
# Creates an age pyramid by specifying the dataframe, age group variable, and a variable to split the pyramid
apyramid::age_pyramid(data = linelist, age_group = "age_group", split_by = "gender")
```

> The first half of an argument assignment (e.g. `data = `) does not need to be specified if the arguments are written in a specific order (specified in the function's documentation). The below code produces the exact same pyramid as above, because the function expects the argument order: data frame, `age_group` variable, `split_by` variable.  

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# This command will produce the exact same graphic as above
apyramid::age_pyramid(linelist, "age_group", "gender")
```

**A more complex `age_pyramid()` command might include the *optional* arguments to:**  

* Show proportions instead of counts (set `proportional = TRUE` when the default is `FALSE`)  
* Specify the two colors to use (`pal = ` is short for "palette" and is supplied with a vector of two color names. See the [objects](#objectstructure) page for how the function `c()` makes a vector)  


<span style="color: black;">**_NOTE:_** For arguments specified with an equals symbol (e.g. `coltotals = ...`), their order among the arguments is not important (must still be within the parentheses and separated by commas).</span>


```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
age_pyramid(linelist, "age_group", "gender", proportional = TRUE, pal = c("orange", "purple"))
```

<!-- ======================================================= -->
### Packages {#packages}  

**Packages contain functions.**  

On installation, R contains "base" functions that perform common elementary tasks. But many R users create specialized functions, which are verified by the R community and which you can download as a **package** for your own use.  

One of the more challenging aspects of R is that there are often many functions or packages to choose from to complete a given task.  

*Functions* are contained within **packages** which can be downloaded ("installed") to your computer from the internet. Once a package is downloaded, you access its functions by loading the package with the `library()` command at the beginning of each R session.

```{r basics_packages_load, eval=F}
# this loads the package "tidyverse" for use in the current R session
library(tidyverse)
```

<span style="color: black;">**_NOTE:_** While you only have to install a package once, you must load it at the beginning of every R session using `library()` command, or an alternative like **pacman**'s `p_load()` function.</span>

Think of R as your personal library: When you download a package your library gains a book of functions, but each time you want to use a function in that book, you must borrow that book from your library.  

For clarity in this handbook, functions are usually preceeded by the name of their package using the `::` symbol in the following way:  

`package_name::function_name()`  

Once a package is loaded for a session, this explicit style is not necessary. One can just use `function_name()`. However giving the package name is useful when a function name is common and may exist in multiple packages (e.g. `plot()`).  
Using the package name will also load the package if it is not already loaded.
 
```{r eval=FALSE}
# This command uses the package "rio" and its function "import()" to import a dataset
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```

**Dependencies**  
Packages often depend on other packages, and these are called "dependencies". When a package is installed from CRAN, it will typically also install its dependenices.  



<!-- ======================================================= -->
### Function Help  

To read more about a function, you can try searching online for resources OR search in the Help tab of the lower-right RStudio pane.  


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
<h2>Piping</h2>
## Piping (`%>%`) {#piping .tabset .tabset-fade}

**Two general approaches to R coding are:**  

1) **Tidyverse - *piping* an object from function to function**  
2) **defining intermediate objects** (and older method, still worth knowing about) 

<!-- ======================================================= -->
### **Piping** 

**Simply explained, the pipe operator (`%>%`) passes an intermediate output from one function to the next.**  
You can think of it as saying "then". Many functions can be linked together with `%>%`.  

* Piping emphasizes a sequence of actions, not the object the actions are being performed on  
* Best when a sequence of actions must be performed on one object  

* from **magrittr**. Included in **dplyr** and **tidyverse**
* Makes code more clean and easier to read, intuitive
* express a sequence of operations  
* the object is altered and then passed on to the next function  

Example:

```{r piping_example_pipe, eval=F}
# A fake example of how to bake a care using piping syntax

cake <- flour %>%       # to define cake, start with flour, and then...
  left_join(eggs) %>%   # add eggs
  left_join(oil) %>%    # add oil
  left_join(water) %>%  # add water
  mix_together(utensil = spoon, minutes = 2) %>%                # mix together
  bake(degrees = 350, system = "fahrenheit", minutes = 35) %>%  # bake
  let_cool()            # let it cool down
```

https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations.

Piping is not a base function. To use piping, the **dplyr** package must be installed and loaded. Near the top of every template script is a code chunk that installs and loads the necessary packages, including **dplyr**. You can [read more about piping in the documentation](https://magrittr.tidyverse.org/).

<span style="color: orange;">**_CAUTION:_** Remember that even when using piping to link functions, if the assignment operator (`<-`) is present, the object to the left will still be over-written (re-defined) by the right side.</span>

TODO
%<>% shortcut for re-defining the object and piping

<!-- ======================================================= -->
### **Intermediate objects**

Better if:  
* You need to manipulate multiple objects  
* There are intermediate steps that are meaningful and deserve separate object names

as changes are made - 
still handy to know

Risks: creating new objects for each step - lots of objects. If you use the wrong one you might not know.
naming can be confusing,
errors not easily detectable

either name each intermediate object, or overwrite the original, or combine all the functions together. all come with risks

https://style.tidyverse.org/pipes.html

```{r piping_example_redefine, eval=F}
# a fake example of how to bake a cake using this method (defining intermediate objects)
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

Combine all functions together - also difficult to read
```{r piping_example_wide, eval=F}
# an example of combining/nesting mutliple functions together - difficult to read
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
<h2> Operators </h2>
## Operators {#operators .tabset .tabset-fade .tabset-pills}

This section details operators in R, such as:  
* Relational operators (less than, equal too..)  
* Logical operators (and, or...)  
* Missingness  
* Mathematical operators (+, -, /...)
* The `%in%` operator


<!-- ======================================================= -->
### Relational and logical operators  

**Relational operators compare values** and are often used when defining new variables and subsets of datasets. Here are the common relational operators in R:  

Function                |Operator     |Example       |Example Result
------------------------|-------------|--------------|---------------------------
Equal to                |`==`         |`"A" == "a"`  |`FALSE` (because R is case sensitive) *Note that == (double equals) is different from = (single equals), which acts like the assignment operator `<-`*
Not equal to            |`!=`         |`2 != 0`      |`TRUE`
Greater than            |`>`          |`4 > 2`       |`TRUE`
Less than               |`<`          |`4 < 2`       |`FALSE`
Greater than or equal to|`>=`         |`6 >= 4`      |`TRUE`
Less than or equal to   |`<=`         |`6 <= 4`      |`FALSE`
Value is missing        |`is.na()`    |`is.na(7)`    |`FALSE` (see section on missing values)
Value is not missing    |`!is.na()`   |`!is.na(7)`   |`TRUE`

**Logical operators, such as AND and OR, are often used to connect relational operators and create more complicated criteria**. Complex statements might require parentheses ( ) for grouping and order of application.  

Function   |Operator
-----------|------------------------
AND        |`&`
OR         |`|` (vertical bar)
Parentheses|`( )` Used to group criteria together and clarify order


For example, below, we have a linelist with two variables we want to use to create our case definition, `hep_e_rdt`, a test result and `other_cases_in_hh`, which will tell us if there are other cases in the household. The command below uses the function `case_when()` to create the new variable `case_def` such that:

```{r basics_operators_casewhen, eval=FALSE}
linelist_cleaned <- linelist_cleaned %>%
  mutate(case_def = case_when(
    is.na(hep_e_rdt) & is.na(other_cases_in_hh)           ~ NA_character_,
    hep_e_rdt == "Positive"                               ~ "Confirmed",
    hep_e_rdt != "Positive" & other_cases_in_hh == "Yes"  ~ "Probable",
    TRUE                                                  ~ "Suspected"
  ))
```

Criteria in example above               | Resulting value in new variable "case_def"
----------------------------------------|-------------------------------------
If the value for variables `hep_e_rdt` and `other_cases_in_hh` are missing | `NA` (missing)  
If the value in `hep_e_rdt` is "Positive" | "Confirmed"  
If the value in `hep_e_rdt` is NOT "Positive" AND the value in `other_cases_in_hh` is "Yes" | "Probable"  
If one of the above criteria are not met | "Suspected"  


{{% notice tip %}}
Note that R is case-sensitive, so "Positive" is different than "positive"...
{{% /notice %}}
 
<!-- ======================================================= -->
### Missing Values

**In R, missing values are represented by the special value `NA`** (capital letters N and A - not in quotation marks). If you import data that records missing data in another way (e.g. 99, "Missing", or .), you may want to re-code those values to `NA`.
  
**To test whether a value is `NA`, use the special function `is.na()`**, which returns `TRUE` or `FALSE`.

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # two positive cases, one suspected, and one unknown
is.na(rdt_result)  # Tests whether the value of rdt_result is NA
```

<!-- ======================================================= -->
### Mathematical operators  

Mathematical operators are often used to perform addition, division, to create new columns, etc. Below are common mathematical operators in R. Whether you put spaces around the operators is not important.  

Objective          |Example in R
-------------------|-------------
addition           | 2 + 3
subtraction        | 2 - 3
multiplication     | 2 * 3
division           | 30 / 5
exponent           | 2^3
order of operations| ( )


<!-- ======================================================= -->
### `%in%`  



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
<h2>Loading Packages </h2>
## Loading Packages {.tabset .tabset-fade .tabset-pills}


This section describes the several ways to install a package:  
* Via the online package repository (CRAN)  
* From a ZIP file  
* From Github  


<!-- ======================================================= -->
### CRAN {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
### ZIP files {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
### Github {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
<h2>Errors & Warnings</h2>
## Errors & Warnings {.tabset .tabset-fade .tabset-pills}

This section explains:  
* General syntax for writing R code  
* Code assists  
* the difference between errors and warnings 

Common errors and warnings and their solutions can be found in X section (TODO).

<!-- ======================================================= -->
### General Syntax

A few things to remember when writing commands in R, to avoid errors and warnings:  

* Always close parentheses - tip: count the number of opening "(" and closing parentheses ")" for each code chunk
* Avoid spaces in column and object names. Use underscore ( _ ) or periods ( . ) instead
* Keep track of and remember to separate a function's arguments with commas
* R is case-sensitive, meaning `Variable_A` is *different* from `variable_A`

<!-- ======================================================= -->
### Code assists  

Any script (RMarkdown or otherwise) will give clues when you have made a mistake. For example, if you forgot to write a comma where it is needed, or to close a parentheses, RStudio will raise a flag on that line, on the right side of the script, to warn you.  

(/images/Warnings_and_Errors.png)

<!-- ======================================================= -->
### Errors and Warnings  

When a command is run, the R Console may show you warning or error messages in red text.  

* A **warning** means that R has completed your command, but had to take additional steps or produced unusual output that you should be aware of.  

* An **error** means that R was not able to complete your command.  

Look for clues: 

* The error/warning message will often include a line number for the problem.  

* If an object "is unknown" or "not found", perhaps you spelled it incorrectly, forgot to call a package with library(), or forgot to re-run your script after making changes.  

If all else fails, copy the error message into Google along with some key terms - chances are that someone else has worked through this already!


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
<h2>Recommended training</h2>
## Recommended training {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
### Cheatsheets

<!-- ======================================================= -->
### Courses



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Importing data {#importdata .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview


Introduction to importing data


<!-- ======================================================= -->
## Packages {.tabset .tabset-fade .tabset-pills}  

The key package we recommend for importing data is: **rio**. **rio** offers the useful function `import()` which can import many types of files into R.  

The alternative to using **rio** would be to use functions from several other packages that are specific to a type of file (e.g. `read.csv()`, `read.xlsx()`, etc.). While these alternatives can be difficult to remember, always using `rio::import()` is relatively easy. 

Optionally, the package **here** can be used in conjunction with **rio**. It locates files on your computer via *relative pathways*, usually within the context of an [R project](#rprojects).  Relative pathways are relative from a designated folder location, so that pathways listed in R code will not break when the script is run on a different computer.

This code chunk shows the loading of packages for importing data. 

```{r import_packages}
# Checks if package is installed, installs if necessary, and loads package for current session
pacman::p_load(rio, here)

```

<!-- ======================================================= -->
## `import()` {.tabset .tabset-fade .tabset-pills}

When you import a dataset, you are doing the following:  

1. Creating a new, named data frame object in your R environment  
2. *Defining the new object* **as** *the imported dataset*  

The function `import()` from the package **rio** makes it easy to import many types of data files.

```{r, eval=F}
# An example:
#############
library(rio)                                                     # ensure package rio is loaded for use

# New object is defined as the imported data
my_csv_data <- import("linelist.csv")                            # importing a csv file

my_Excel_data <- import("observations.xlsx", which = "February") # import an Excel file
```

`import()` uses the file’s extension (e.g. .xlsx, .csv, .dta, etc.) to appropriately import the file. Any optional arguments specific to the filetype can be supplied as well.  

You can read more about the **rio** package [in this online vignette](https://rdrr.io/cran/rio/f/vignettes/rio.Rmd)

<span style="color: orange;">**_CAUTION:_** In the example above, the datasets are assumed to be located in the *working directory*, or the same folder as the script.</span>  


<!-- ======================================================= -->
## Import from filepath {.tabset .tabset-fade .tabset-pills}  

A filepath can be provided in full (as below) or as a *relative filepath* (see next tab). Providing a full filepath can be fast and may be the best if referencing files from a shared/network drive).  

The function `import()` (from the package **rio**) accepts a filepath in quotes. A few things to note:  

* Slashes must be forward slashes, as in the code shown. This is *NOT* the default for Windows filepaths.  
* Filepaths that begin with double slashes (e.g. "//...") will likely **not be recognized by R** and will produce an error. Consider moving these files to a "named" or "lettered" drive that begins with a letter (e.g. "J:" or "C:"). See the section on using Network Drive for more details on this issue.

```{r import_filepath, eval=F}
# A demonstration showing how to import a specific Excel sheet
my_data <- rio::import("C:/Users/Neale/Documents/my_excel_file.xlsx")
```

<!-- ======================================================= -->
## Import Excel sheet {.tabset .tabset-fade .tabset-pills}

If importing a specific **sheet** from an Excel file, include the sheet name in the `which = ` argument of `import()`. For example:  

```{r import_sheet, eval=F}
# A demonstration showing how to import a specific Excel sheet
my_data <- rio::import("my_excel_file.xlsx", which = "Sheetname")
```

If using the `here()` method to provide a relative pathway to `import()`, you can still indicate a specific sheet by adding the `which = ` argument after the closing parenthese of the `here()` function.  

```{r import_sheet_here, eval=F}
# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package
linelist_raw <- import(here("data", "linelists", "linelist.xlsx"), which = "Sheet1")`  
```

<!-- ======================================================= -->
## Select file manually {.tabset .tabset-fade .tabset-pills}

You can import data manually via one of these methods:  

* Environment RStudio Pane, click "Import Dataset", and select the type of data 
* Click File / Import Dataset / (select the type of data)  
* To hard-code manual selection, use the *base R* command `file.choose()` (leaving the parentheses empty) to trigger appearance of a **pop-up window** that allows the user to manually select the file from their computer. For example:  

```{r import_choose, eval=F}
# A demonstration showing manual selection of a file. When this command is run, a POP-UP window should appear. 
# The filepath of the selected file will be supplied to the import() command.

my_data <- rio::import(file.choose())
```

<span style="color: darkgreen;">**_TIP:_** The **pop-up window** may appear BEHIND your RStudio window.</span>


<!-- ======================================================= -->
## Relative filepaths (`here()`) {#here .tabset .tabset-fade .tabset-pills}

*Relative filepaths* differ from static filepaths in that they are *relative from a [R project](#rproject) root directory*. For example:  

* A static filepath: `import("C:/Users/nsbatra/My Documents/R files/epiproject/data/linelists/ebola_linelist.xlsx")`  
  * Specific fixed path
  * Useful if multiple users are running a script hosted on a network drive
* A relative filepath: `import(here("data", "linelists", "ebola_linelist.xlsx"))`  
  * Path is given in relation to a root directory (typically the root folder of an R project)  
  * Best if working within an R project, or planning to zip and share entire project with others  
  
The package **here** and it's function `here()` facilitate relative pathways.

`here()` works best within [R projects](#rprojects). When the **here** package is first loaded (`library(here)`), it automatically considers the top-level folder of your R project as “here” - a **benchmark** for all other files in the project.  

Thus, in your script, if you want to import or reference a file saved in your R project’s folders, you use the function `here()` to tell R where the file is ***in relation to that benchmark***.

If you are unsure where “here” is set to, run the function `here()` with the empty brackets:

```{r import_here, eval=F}
# This command tells you the folder path that "here" is set to 
here::here()
```

Below is an example of importing the file “fluH7N9_China_2013.csv” which is located in the benchmark “here” folder. All you have to do is provide the name of the file in quotes (with the appropriate ending).

```{r import_here_one, eval=F}
linelist <- import(here("fluH7N9_China_2013.csv"))
```

If the file is within a subfolder - let’s say a “data” folder - write these folder names in quotes, separated by commas, as below:
```{r import_here_mutiple, eval=F}
linelist <- import(here("data", "fluH7N9_China_2013.csv"))
```

Using the `here()` command produces a character filepath, which can then processed by the `import()` function.

```{r import_here_path, eval=F}
# the filepath
here("data", "fluH7N9_China_2013.csv")

# the filepath is given to the import() function
linelist <- import(here("data", "fluH7N9_China_2013.csv"))
```


<span style="color: black;">**_NOTE:_** You can still import a specific sheet of an excel file as noted in the Excel tab. The `here()` command only supplies the filepath.</span>



<!-- ======================================================= -->
## Manual data entry {.tabset .tabset-fade .tabset-pills}

### Entry by columns
Since a data frame is a combination of vertical vectors (columns), R by default expects manual entry of data to also be in vertical vectors (columns). 

```{r import_manual_col}
# define each vector (vertical column) separately, each with its own name
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```
<span style="color: orange;">**_CAUTION:_** All vectors must be the same length (same number of values).</span>

The vectors can then be bound together using the function `data.frame()`:  

```{r}
# combine the columns into a data frame, by referencing the vector names
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

And now we display the new dataset:  

```{r import_manual_colShow}
# display the new dataset
DT::datatable(manual_entry_cols)
```


### Entry by rows
Use the `tribble` function from the **tibble** package from the tidverse ([onlinetibble reference](https://tibble.tidyverse.org/reference/tribble.html)).  
  
Note how column headers start with a *tilde* (`~`).  Also note that each column must contain only one class of data (character, numeric, etc.).  
You can use tabs, spacing, and new rows to make the data entry more intuitive and readable. For example:  

```{r import_manual_row}
# create the dataset manually by row
manual_entry_rows <- tibble::tribble(
                        ~colA, ~colB,
                        "a",   1,
                        "b",   2,
                        "c",   3
                      )
```

And now we display the new dataset:  

```{r import_manual_rowShow}
# display the new dataset
DT::datatable(manual_entry_rows)
```


### Pasting from clipboard  

If you copy data from elsewhere and have it on your clipboard, you can try the following command to convert those data into an R data frame:  

```{r, eval=F}
manual_entry_clipboard <- read.table(file = "clipboard",
                                     sep = "t",           # separator could be tab, or commas, etc.
                                     header=TRUE)         # if there is a header row
```





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Working with Dates {#dates .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview

* It is important to make R recognize when a variable contains dates.  
* Dates are an object class and can be tricky to work with.  
* Here we present several ways to convert date variables to Date class.  


<!-- ======================================================= -->
## Packages

The following packages are recommended for working with dates:  

```{r dates_packages}
# Checks if package is installed, installs if necessary, and loads package for current session

pacman::p_load(aweek,      # flexibly converts dates to weeks, and vis-versa
               lubridate,  # for conversions to months, years, etc.
               linelist,   # function to guess messy dates
               ISOweek)    # another option for creating weeks
```



<!-- ======================================================= -->
## `as.Date()`  

The standard, **base** R function to convert an object or variable to class Date is `as.Date()` (note capitalization).  

`as.Date()` requires that the user *specify the ***existing*** format of the date*, so it can understand, convert, and store each element (day, month, year, etc.) correctly. [Read more online about `as.Date()`](https://www.stat.berkeley.edu/~s133/dates.html).  

**If used on a variable, `as.Date()` therefore requires that all the character date values be in the same format before converting.** If your data are messy, try cleaning them or consider using `guess_dates()` from the **linelist** package.  

It can be easiest to first convert the variable to character class, and then convert to date class:  

  1. Turn the variable into character values using the function `as.character()`
```{r eval=F}
linelist_cleaned$date_of_onset <- as.character(linelist_cleaned$date_of_onset)
```
  2. Convert the variable from character values into date values, using the function `as.Date()`  
  (note the capital "D")  
  + Within the `as.Date()` function, you must use the `format=` argument to tell R the *current* format of the date components - which characters refer to the month, the day, and the year, and how they are separated. If your values are already in one of R's standard date formats (YYYY-MM-DD or YYYY/MM/DD) the `format=` argument is not necessary.  
    
    + The codes are:  
         %d = Day # (of the month e.g. 16, 17, 18...)  
         %a = abbreviated weekday (Mon, Tues, Wed, etc.)  
         %A = full weekday (Monday, Tuesday, etc.)  
         %m = # of month (e.g. 01, 02, 03, 04)  
         %b = abbreviated month (Jan, Feb, etc.)  
         %B = Full Month (January, February, etc.)  
         %y = 2-digit year  (e.g. 89)  
         %Y = 4-digit year  (e.g. 1989)  

For example, if your character dates are in the format DD/MM/YYYY, like "24/04/1968", then your command to turn the values into dates will be as below. **Putting the format in quotation marks is necessary.**  
```{r eval=F}
linelist_cleaned$date_of_onset <- as.Date(linelist_cleaned$date_of_onset, format = "%d/%m/%Y")
```
<span style="color: darkgreen;">**_TIP:_** The `format=` argument is *not* telling R the format you want the dates to be, but rather how to identify the date parts as they are *before* you run the command.</span>  

<span style="color: darkgreen;">**_TIP:_**Be sure that in the `format=` argument you use the *date-part separator* (e.g. /, -, or space) that is present in your dates.</span>  


The `as.character()` and `as.Date()` commands can optionally be combined as:  

```{r eval=F}
linelist_cleaned$date_of_onset <- as.Date(as.character(linelist_cleaned$date_of_onset), format = "%d/%m/%Y")
```

If using [piping](#piping) and the tidyverse, the above command might look like this:  

```{r, eval=F}
linelist_cleaned <- linelist_cleaned %>%
  mutate(date_of_onset = as.character(date_of_onset),
         date_of_onset = as.Date(date_of_onset, format = "%d/%m/%Y"))
```

Once complete, you can run a command to verify the class of the variable
```{r, eval=F}
# Check the class of the variable
class(linelist_cleaned$date_of_onset)  
```

Once the values are in class Date, R will by default display them in the standard format, which is YYYY-MM-DD.


<!-- ======================================================= -->
## lubridate  

Section on using lubridate
(Henry)


<!-- ======================================================= -->
## `guess_dates()` 

**The function `guess_dates()` attempts to read a "messy" date variable containing dates in many different formats and convert the dates to a standard format.** You can [read more online about `guess_dates()`](https://www.repidemicsconsortium.org/linelist/reference/guess_dates.html), which is in the **linelist** package.

>**For example:** `guess_dates` would see the following dates "03 Jan 2018", "07/03/1982", and "08/20/85" and convert them in the class Date to: 2018-01-03, 1982-03-07, and 1985-08-20.  

```{r, eval=F}
linelist::guess_dates(c("03 Jan 2018", "07/03/1982", "08/20/85")) # guess_dates() not yet available on CRAN for R 4.0.2
                                                                  # try install via devtools::install_github("reconhub/linelist")
```

*Some optional arguments for `guess_dates()` that you might include are:*  

* `error_tolerance` - The proportion of entries which cannot be identified as dates to be tolerated (defaults to 0.1 or 10%)
* `last_date` - the last valid date (defaults to current date)  
* `first_date` - the first valid date. Defaults to fifty years before the last_date.


```{r eval=FALSE}
# An example using guess_dates on the variable dtdeath
data_cleaned <- data %>% 
  mutate(dtdeath = linelist::guess_dates(dtdeath, error_tolerance = 0.1, first_date = "2016-01-01")
```


<!-- ======================================================= -->
## Excel Dates

Excel stores dates as the number of days since December 30, 1899. If the dataset you imported from Excel shows dates as numbers or characters like "41369"... use the `as.Date()` function to convert, but **instead of supplying a format as above, supply an origin date**.  

<span style="color: black;">**_NOTE:_** You should provide the origin date in R's default date format (`"YYYY-MM-DD"`).</span>


```{r, eval=FALSE}
# An example of providing the Excel 'origin date' when converting Excel number dates
data_cleaned <- data %>% 
  mutate(date_of_onset = as.Date(date_of_onset, origin = "1899-12-30"))
```


<!-- ======================================================= -->
## How dates are displayed  

Once dates are the correct class, you often want them to display differently (e.g. in a plot, graph, or table). For example, to display as "Monday 05 Jan" instead of 2018-01-05. You can do this with the function `format()`, which works in a similar way as `as.Date()`. Read more [in this online tutorial](https://www.statmethods.net/input/dates.html)  

%d = Day # (of the month e.g. 16, 17, 18...)
%a = abbreviated weekday (Mon, Tues, Wed, etc.)  
%A = full weekday (Monday, Tuesday, etc.)  
%m = # of month (e.g. 01, 02, 03, 04)  
%b = abbreviated month (Jan, Feb, etc.)  
%B = Full Month (January, February, etc.)  
%y = 2-digit year  (e.g. 89)  
%Y = 4-digit year  (e.g. 1989)  
%h = hours (24-hr clock)  
%m = minutes  
%s = seconds
%z = offset from GMT  
%Z = Time zone (character)

An example of formatting today's date:  

```{r}
# today's date, with formatting
format(Sys.Date(), format="%d %B %Y")

# easy way to get full date and time (no formatting)
date()

# formatted date, time, and time zone (using paste0() function)
paste0(format(Sys.Date(), format= "%A, %b %d '%y, %z  %Z, "), format(Sys.time(), format = "%H:%M:%S"))
```

<!-- ======================================================= -->
## Calculating distance between dates

The difference between dates can be calculated by:  
  
  
1. Correctly formating *both* date variable as class date (see instructions above)  
2. Creating a new variable that is defined as one date variable subtracted from the other
3. Converting the result to numeric class (default is class "datediff"). This ensures that subsequent mathematical calculations can be performed.  


<!-- ======================================================= -->
## Converting dates/time zones

TODO

<!-- ======================================================= -->
## Epidemiological weeks  

The templates use the very flexible package **aweek** to set epidemiological weeks. You can read more about it [on the RECON website](https://www.repidemicsconsortium.org/aweek/)


<!-- ======================================================= -->
## Dates in Epicurves 

See the section on [epicurves](#epicurves).

<!-- ======================================================= -->
## Dates miscellaneous  

* `Sys.Date( )` returns the current date of your computer  
* `Sys.Time()` returns the current time of your computer
* `date()` returns the current date and time.  


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Cleaning data {#cleaning .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}  

Text about cleaning data, approaches, etc.
renaming
replace missing with
dealing with cases (all lower, etc)
case_when()
factors


<!-- ======================================================= -->
## Packages {.tabset .tabset-fade .tabset-pills}

```{r, clean_packages}
pacman::p_load(tidyverse, janitor, epitrix)
```

<!-- ======================================================= -->
## Clean Variable Names {.tabset .tabset-fade .tabset-pills}

Variable names are used so often, it is best to have them be "clean" (no spaces, no unusual characters, etc.)  

The function `clean_names()` from the package **janitor** is very useful. 

https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning


```{r clean_names}
linelist <- linelist_raw %>% 
  janitor::clean_names()
```

<!-- ======================================================= -->
## Classes {.tabset .tabset-fade .tabset-pills #Classes}

See section on [object classes](#objectclasses)   

```{r}
linelist <- linelist_raw %>% 
  mutate(age           = as.numeric(age),
         outcome       = as.character(outcome),
         date_of_onset = as.Date(date_of_onset, format = "%d/%m/%Y"),
         outcome       = factor(outcome, levels = c("Recover", "Death"))
         )
```

<!-- ======================================================= -->
## Creating new variables {#newvars .tabset .tabset-fade .tabset-pills}

**base R** method 
```{r, eval=F}
linelist$new_var <- "new value"
```


Using **dplyr**
`mutate()`
transmute()


```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_var_dup    = id,                  # new variable - replicate another variable
         new_var_static = 7,                   # new variable - all values the same
         new_var_static = new_var_static + 5   # you can modify a variable multiple times
         new_var_calc   = (age / 12) + months  # new variable - calculation
         new_var_paste  = paste0(district, "(", province, ")") # new variable - pasting together values
```


<!-- ======================================================= -->
## Groups by condition (`case_when()`) {#casewhen}

TODO tutorial on using case_when()

<!-- ======================================================= -->
### Numeric groups  

For example, creating age groups
`cut()`

`case_when()`

`age_categories()` (R4Epis package)

by percentile


<!-- ======================================================= -->
## Modifying existing values {.tabset .tabset-fade .tabset-pills}

Missing if... `na_if()`

Replace


<!-- ======================================================= -->
### Highest in hierarchy

Within a group, indicate/convert to the highest value in the group

Santa Clara County example - COVID contact tracing data - classification of multiple phone call records from same person into the highest category. (classify all as the highest of the group)



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Missing Data {#transformation .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

dealing with missing data
percent missing over time
etc.

<!-- ======================================================= -->
## Percent missing over time {.tabset .tabset-fade .tabset-pills}

Or change in percent of anything (X) over time, really.  

```{r}
lines <- linelist %>%
  mutate(date_of_onset = as.Date(date_of_onset, format = "%d/%m/%Y"),
         week = aweek::week2date(aweek::date2week(date_of_onset))) %>% 
  group_by(week) %>% 
  summarize(n_obs = n(),
            dt_hosp_missing = sum(date_of_hospitalisation == "" | is.na(date_of_hospitalisation)),
            dt_hosp_p_miss = dt_hosp_missing / n_obs,
            
            outcome_missing = sum(outcome == "" | is.na(outcome)),
            outcome_p_miss = outcome_missing / n_obs) %>%
  reshape2::melt(id.vars = c("week")) %>%
  filter(grepl("_p_", variable)) %>% 
  
  ggplot()+
    geom_line(aes(x = week, y = value, group = variable, color = variable), size = 1, stat = "identity")+
    labs(title = "Missingness in variables, as proportion of ",
         #subtitle = str_glue("As of {format(report_date, '%d %b')}"), 
         x = "Week",
         y = "Proportion missing",
         fill = "CalREDIE Variable") + 
    scale_color_discrete(name = "Variable", labels = c("Date of Hospitalization Missing", "Outcome Missing"))+
    scale_y_continuous(breaks = c(seq(0,1,0.1)))
    #theme_cowplot()#+
    #theme(legend.position = element_text("none"))

lines
```

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Transforming data {#transformation .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

(pivoting/melting etc.)
Transforming datasets from wide-to-long, or long-to-wide...  


<!-- ======================================================= -->
## Filtering {#filter .tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Wide-to-long {#widetolong .tabset .tabset-fade .tabset-pills}

Transforming a dataset from wide to long

<!-- ======================================================= -->
### Data

We start with data that is in a wide format, e.g. our [linelist](#datasets).  

```{r}
DT::datatable(linelist, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```

<!-- ======================================================= -->
### `pivot_longer()`

```{r}
#tidyr::pivot_longer(linelist, dplyr::vars(-age, -date_of_hospitalisation), names_to = "variable", values_to = "value" )
```

<!-- ======================================================= -->
### Result



<!-- ======================================================= -->
## Long-to-wide {#longtowide .tabset .tabset-fade .tabset-pills}

**dplyr**
`pivot_wider()`


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Grouping/aggregating data {#grouping .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}
Tidyverse - grouping by values

.drop=F in `group_by()` command

<!-- ======================================================= -->
## `group_by()` {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## `aggregate()` {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Descriptive analyses {#descriptive .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

This section includes:  
* Basic descriptive statistics on numeric variables  
* ...  
* ...  



<!-- ======================================================= -->
## Summary Statistics {#summarystats}

### **Summary of *numeric* variable**
```{r descriptive_summary}
summary(linelist$age)
```



### **Mean**
Note the argument na.rm=T, which removes missing values from the calculation.  
If missing values are not excluded, the returned value will be NA (missing).
```{r descriptive_mean}
mean(linelist$age)
mean(linelist$age, na.rm=TRUE)  # with the na.rm= argument set to TRUE
```


### **Median**
Note the argument na.rm=T, which removes missing values from the calculation.  
If missing values are not excluded, the returned value will be NA (missing).
```{r descriptive_median}
median(linelist$age)
median(linelist$age, na.rm=TRUE)  # with the na.rm= argument set to TRUE
```


### **Range**
Note the argument na.rm=T, which removes missing values from the calculation.  
If missing values are not excluded, the returned value will be NA (missing).
```{r descriptive_range}
range(linelist$age)
range(linelist$age, na.rm=TRUE)  # with the na.rm= argument set to TRUE
```



### **Standard Deviation**
Note the argument na.rm=T, which removes missing values from the calculation.  
If missing values are not excluded, the returned value will be NA (missing).
```{r descriptive_std}
sd(linelist$age)
sd(linelist$age, na.rm=TRUE)  # with the na.rm= argument set to TRUE
```


### **Percentile**
Note the argument na.rm=T, which removes missing values from the calculation.  
If missing values are not excluded, the returned value will be NA (missing).
```{r descriptive_pctile}
stats::quantile(linelist$age, na.rm=TRUE)  # default %iles
stats::quantile(linelist$age, probs = c(.05, 0.5, 0.75, 0.98), na.rm=TRUE) # percentiles specified
```

<!-- ======================================================= -->
## Frequency and cross-tables {#crosstabs}

Frequency table of 1 and 2 categorical variables
```{r}
table(linelist$province)

x <- table(linelist$province, linelist$gender)
#janitor::adorn_totals(x)

```

A table with 3 variables
```{r}
table_3vars <- table(linelist$province, linelist$gender, linelist$outcome)

ftable(table_3vars)
```

<!-- ======================================================= -->
## Summary by group {#summary}

```{r eval=F}
count_data %>% 
  group_by(District) %>% 
  summarise(n_obs = n(), # number of observations
            range_date = max(Date, na.rm=T) - min(Date, na.rm=T)
            )

```


<!-- ======================================================= -->
## Correlations {#correlations}


<!-- ======================================================= -->
## T-tests {#ttests}



<!-- ======================================================= -->
# Visualization tips {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

https://cfss.uchicago.edu/notes/grammar-of-graphics/

https://www.data-to-viz.com/


<!-- ======================================================= -->
# Scatterplots {#scatterplot .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## base R {.tabset .tabset-fade .tabset-pills}

```{r}
plot(linelist$age)
```

<!-- ======================================================= -->
# Boxplots {#boxplot .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

Boxplots can be created with:  

* the `boxplot()` function from the **graphics** package (installed automatically with **base R**), or  
* the `ggplot()` function from the **ggplot2** package  

```{r out.width=c('50%', '50%'), fig.show='hold'}
# with the boxplot() function
graphics::boxplot(age ~ outcome*gender,
                  data = linelist,
                  col = c("gold", "darkgreen"),
                  main = "Made using boxplot()")


# with ggplot2 
ggplot(data = linelist,
       mapping = aes(y = age, x = outcome, fill = outcome))+
  geom_boxplot()+
  ggtitle("Made using ggplot()")+
  facet_wrap(~gender)
```

<!-- ======================================================= -->
## `boxplot()`

Some options with `boxplot()` shown below are:  

* boxplots by group (color specification optional)  
* violin plots  
* boxplot width proportional to sample size  
* Horizontal  


```{r, out.width=c('50%', '50%'), fig.show='hold'}
# boxplot of one numeric variable
boxplot(linelist$age,                 # numeric variable
        main="boxplot",               # main title
        xlab="Suppliment and Dose")   # x-axis label


# by group (formula style)
boxplot(age ~ gender, data=linelist, notch=TRUE, main="boxplot", xlab="Suppliment and Dose")
```

You can have multiple levels of group (e.g. age by outcome AND gender)  
Notched "violin plots" are possible. 
The notch represents the median and X around it (TODO)

```{r, out.width=c('33%', '33%', '33%'), fig.show='hold'}
# By subgroup (age by outcome AND gender)
boxplot(age ~ outcome * gender,
        data=linelist,
        col=c("gold","darkgreen"),            # colors, in a vector
        main="Boxplot by Outcome and Gender", # main title
        xlab="Suppliment and Dose")           # x-axis label

# Notched (violin plot), and varying width
boxplot(age ~ outcome * gender,
        data=linelist,
        notch=TRUE,      # notch at median
        varwidth = TRUE, # width varying by sample size
        col=(c("gold","darkgreen")),
        main="Notched boxplot, width varying by sample size",
        xlab="Suppliment and Dose")

# Horizontal
boxplot(age~outcome,
        data=linelist,
        horizontal=TRUE,  # flip to horizontal
        col=(c("gold","darkgreen")),
        main="Horizontal boxplot",
        xlab="Suppliment and Dose")
```

<!-- ======================================================= -->
## `ggplot()` 


Some options with `ggplot()` shown below are:  

* boxplots by group (color specification optional)  
* violin plots  
* boxplot width proportional to sample size  
* Horizontal  


```{r, out.width=c('33%', '33%', '33%'), fig.show='hold'}
# Simple boxplot of one numeric variable
ggplot(data = linelist, aes(y = age))+  # only y variable given (no x variable)
  geom_boxplot()+
  ggtitle("Simple ggplot() boxplot")

# By group
ggplot(data = linelist, aes(y = age,         # numeric variable
                            x = outcome,      # group variable
                            fill = outcome))+ # fill variable (color of boxes)
  geom_boxplot()+                            # create the boxplot
  ggtitle("ggplot() boxplot by gender")      # main title

# Removing missing values, and add color
ggplot(data = linelist %>% filter(!is.na(outcome)), # dataset piped through a filter to retain rows where gender is not missing
       aes(y = age, x = outcome, fill= outcome))+    # boxes filled according to gender value
  geom_boxplot()+
  ggtitle("ggplot() boxplot by gender (missing excluded)")
```

To examine by subgroups, use *facet_wrap()* (for more see section on [ggplot tips](#ggplottips)).  

```{r}
# By subgroup
ggplot(data = linelist %>% filter(!is.na(gender)), # dataset piped through a filter to retain rows where gender is not missing
       aes(y = age, x = outcome, fill=outcome))+
  geom_boxplot()+
  ggtitle("A ggplot() boxplot")+
  facet_wrap(~gender)
```

"Violin plots" can be made simply or very complex: 

```{r out.width=c('33%', '33%', '33%'), fig.show='hold'}
# Violin plots
ggplot(linelist, aes(x=age, y=outcome, fill = outcome)) + 
  geom_violin(trim=FALSE)


# Vertical violin plot
ggplot(linelist, aes(x=age, y=outcome, fill = outcome)) + 
  geom_violin(trim=FALSE)+
  coord_flip()


# Add jittered points
ggplot(linelist, aes(x=age, y=outcome, fill = outcome)) + 
  geom_violin(trim=FALSE)+
  coord_flip()+ 
  geom_jitter(shape=16,                      # points
              position=position_jitter(0.2)) # jitter permissible to avoid point overlap
```

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Simple Statistical Tests {#stat_tests .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

quant/quant, quant/cat, cat/cat
t-tests
odds ratios, mantel-haensel, etc.

<!-- ======================================================= -->
## T-tests {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Chi-Square {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Odds Ratios {.tabset .tabset-fade .tabset-pills}



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Epidemic Curves {#epicurves .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

* Overview of epidemic curves...  
* Online resources and standards  
* Common pitfalls or mistakes...
TODO



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Preparation {.tabset .tabset-fade .tabset-pills}

Below are the Preparation tabs:  


<!-- ======================================================= -->
### Methods

The data preparation involves the following steps, detailed in the following tabs:


* **Load packages**: installs and load the packages required for the scripts  

* **Load data**: imports datasets

* **Clean data**: this section contains *ad hoc* data cleaning, i.e. which is
  not used in other reports (otherwise cleaning should be done in a dedicated
  report); this section is also used to create new variables used in the
  analyses


<!-- ======================================================= -->
### Load packages

This code chunk shows the loading of packages required for the analyses. 

```{r epicurve_packages}
# Create vector of names of required packages:
packages_epicurve <- c("rio",          # File import
                       "here",         # File locator
                       "tidyverse",    # data manipulation
                       "ggplot2",      # Produce plots and graphs
                       "aweek",        # working with dates
                       "lubridate",    # Manipulate dates    
                       "incidence",    # an option for epicurves of linelist data
                       "stringr",      # Search and manipulate character strings
                       "forcats",      # working with factors
                       "RColorBrewer", # Color palettes from colorbrewer2.org
                       "DT"            # produce tables for this html handbook
                       )               ### close vector of packages

# Checks if package is installed, installs if necessary, and loads package for current session
pacman::p_load(packages_epicurve, character.only=TRUE)
```



<!-- ======================================================= -->
### Load data

Two example datasets are used in this section:  

* Linelist of individual data from an H7N9 outbreak in 2013  
* Aggregated case counts of a fictional disease in 2019

If viewing in Google Chrome, you can access these datasets in Microsoft Excel by clicking HERE and HERE. TODO.  

The datasets are imported using the `import()` function from the *rio* package. See the *page on importing data* for various ways to import data. Each data set is displayed below as a table for viewing.

For most of this document, the *linelist dataset* will be used. The aggregated counts dataset will be used at the end.  


```{r epicurve_load_hide, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "fluH7N9_china_2013.csv"))


# import the counts data into R
count_data <- rio::import(here::here("data", "aggregated_counts_diseaseX.xlsx"))

```


```{r epicruve_load_show, eval=F}
# import the linelist into R
linelist <- rio::import("fluH7N9_china_2013.csv")


# import the counts data into R
count_data <- rio::import("aggregated_counts_diseaseX.xlsx")

```

<!-- ======================================================= -->
### Review data

Review the two datasets and notice the differences  

Linelist dataset


```{r epicurve_viewdata_line, message=FALSE}
# display the linelist data as a table
DT::datatable(linelist, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```


Aggregated counts dataset

```{r epicurve_viewdata_agg, message=FALSE}
# display the linelist data as a table
DT::datatable(count_data, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```




<!-- ======================================================= -->
### Set parameters

You may want to set certain parameters for production of a report, such as the date for which the data is current (the "data date"). In this case, we set this date as 27 July 2013.

Now we can reference the object data_date into the code and have it reference that date.

```{r set_parameters}
## set the report date for the report
## note: can be set to Sys.Date() for the current date
data_date <- as.Date("2013-07-27")
```



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Clean data {.tabset .tabset-fade .tabset-pills}

Dates are essential to epidemiological curves. You must ensure that R knows which variables contain dates and that they are recognized correctly. 

<!-- ======================================================= -->
### Identify date variables

Optionally, it can be nice to identify all the date variables and store their names in a vector. This can be done by individually naming them, or by searching for them by looking for keywords.  

Method 1
```{r date_vars}
# Method 1. Define date variables explicitly in a vector
DateVars <- c("date_of_onset",
              "date_of_hospitalisation",
              "date_of_outcome"
              )
DateVars
```

Method 2
```{r}
# Method 2: Search for date columns
DateVars <- as.character(tidyselect::vars_select(names(linelist), matches("date|Date|dt")))
DateVars

#Note: other search tool options within vars_select include contains() ends_with(), starts_with(), or one_of()
```



<!-- ======================================================= -->
### Convert to date class

Convert the date variables to class "date". There are a few options that use different packages. Each is explained in the code chunk. 

```{r date_class}
# Method 1. Manually convert each variable (allows flexibility in format)
linelist$date_of_onset <- as.Date(linelist$date_of_onset, format = "%m/%d/%Y")
linelist$date_of_hospitalisation <- as.Date(linelist$date_of_hospitalisation, format = "%m/%d/%Y")
linelist$date_of_outcome <- as.Date(linelist$date_of_outcome, format = "%m/%d/%Y")

# Method 2. Use clean_dates() on the dataset to clean date variables 
#linelist <- linelist %>% 
#        linelist::clean_dates(error_tolerance = 0.1)

# Note: Use guess_dates() function from the linelist package addresses messy dates (different formats within a variable)
```



<!-- ======================================================= -->
### Verify

Verify that each variable was successfully converted to date class by printing statistics and a quick histogram for each one.


```{r verify_dates, out.width = c('50%', '50%', '50%'), fig.show='hold'}
# To verify successful conversion of date variables

# Creates list of column numbers of date variables 
varNums <- c()
for (varName in DateVars) {
  varNum <- match(varName, names(linelist))
  varNums <- c(varNums, varNum)
}

# Produce output for each date variable converted
for (varNum in varNums) {
  varName <- names(linelist)[varNum]         # get name of variable
  class <- class(linelist[, varNum])                  # get class
  missing <- sum(is.na(linelist[, varNum]))  # get number missing values
  hist(linelist[, varNum],                   # histogram
       breaks = 50,
       main = paste0("Histogram of: ", varName, ", Class: ", class, ", Missing: ", missing),
       xlab = varName)  
  }
```



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Epicurves using "incidence" package {.tabset .tabset-fade .tabset-pills}

Below are tabs on using the "incidence" package

<!-- ======================================================= -->
### Outline 

This section shows variations on the epicurve using the **incidence** package

```{r number_missing}
#Determine the number of observations that are missing a date of onset

# Number of observations
n_linelist <- nrow(linelist)
n_linelist

# number missing onset_date and cannot be graphed
missing_onset <- nrow(linelist[is.na(linelist$date_of_onset),])
missing_onset
```

<!-- ======================================================= -->
### Simple

These are simple epicurves using the incidence package. The epicurve is assigned to the object "epicurve", which is then plotted. Remember that incidence::plot() is different to base::plot()


The interval defines how the observations are grouped. Options are all those in the package *aweek*, including but are not limited to:  
* "Monday week"
* "2 Monday weeks"
* "Sunday week"  
* "MMWRweek" (starts on Sunday)  
* "Month"  
* "Quarter"  
* "Year"

First date and last date can also be specified.  

```{r incidence, out.width=c('50%', '50%', '50%', '50%'), fig.show='hold'}
# incidence object is created, with data aggregated at one day intervals
epicurve_daily   <- incidence::incidence(linelist$date_of_onset, interval = "day")

# If weekly, you can specific the start day
epicurve_weekly  <- incidence::incidence(linelist$date_of_onset, interval = "Monday week")
epicurve_3weekly  <- incidence::incidence(linelist$date_of_onset, interval = "3 weeks")

# Monthly
epicurve_monthly <- incidence::incidence(linelist$date_of_onset, interval = "month")

# Plot the incidence object
plot(epicurve_daily)
plot(epicurve_weekly)
plot(epicurve_3weekly)
plot(epicurve_monthly)


```

<!-- ======================================================= -->
### Aesthetics

Behind the scenes, incidence is using ggplot(), so you can add aesthetic themes and other lines using the ggplot syntax.

```{r Incidence_aesthetics,  out.width = c('50%', '50%'), fig.show='hold'}
# Set theme elements using ggplot syntax
epicurve_theme <- ggplot2::theme(
  axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
  legend.title = element_blank(),
  panel.grid.major.x = element_line(color = "grey60", linetype = 3),
  panel.grid.major.y = element_line(color = "grey60", linetype = 3)
)

# Sets labels using ggplot syntax
epicurve_labels <- labs(x = "Week", 
                        y = "Cases (n)", 
                        title = "H5N7 cases by week of onset",
                        caption = paste0("Source: Linelist data from: ", data_date, "; ", missing_onset, " are missing date of onset and not shown."))
                       


# plot the epicurve with aesthetics
nice_plot <- plot(epicurve_weekly, show_cases = TRUE, border = "black", n_breaks = nrow(epicurve_weekly)) + 
  scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
  # add labels
  epicurve_labels +
  # add theme
  epicurve_theme
nice_plot

# Modify nice_plot to show only 6 breaks in the x-axis 
nice_plot + scale_x_incidence(epicurve_weekly, n_breaks = 6)

```

<!-- ======================================================= -->
### By descriptor

Now differentiating the cases by gender, using the groups = argument in the incidence command

```{r by_gender}
# Create epiweek object, with counts grouped by gender
epicurve_weekly_gender <- incidence(linelist$date_of_onset, 
                               interval = "week", 
                               groups = linelist$gender,
                               na_as_group = FALSE)   # Prevents missing values from being assigned their own group


# Plot the epicurve
# Note: Remove the boxes around each case as it makes gender colours hard to see! (show_cases = FALSE)
nice_plot <- plot(epicurve_weekly_gender, show_cases = FALSE, border = "black", n_breaks = nrow(epicurve_weekly_gender)) + 
  
  # add labels (defined in previous section)
  epicurve_labels +
  
  # add theme elements
  epicurve_theme

nice_plot

```



### Filtered

To filter data, This version is filtered to only show data from a specific province.

```{r incidence_filtered}
# filter the dataset and pass it to the incidence() function
Zhejiang_data <- filter(linelist, province == "Zhejiang")

epicurve_Zhejiang <- incidence(Zhejiang_data$date_of_onset,
                                interval = "week",
                                groups = Zhejiang_data$gender)


# Re-sets labels, changing title to reflect subset
epicurve_labels <- labs(x = "Week", 
                        y = "Cases", 
                        title = "H5N7 cases by week of onset in Zhejiang",
                        caption = paste0("Source: Linelist data from: ", data_date, "; ", missing_onset, " are missing date of onset and not shown."))
                       

# plot as before
plot(epicurve_Zhejiang, show_cases = TRUE, border = "grey") +
     
  # add labels (defined in previous section)
  epicurve_labels +
  
  # add theme elements
  epicurve_theme

```





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Using "ggplot2" package {.tabset .tabset-fade .tabset-pills}

Below are tabs on using "ggplot2" package

### Daily and Weekly
``` {r ggplot_simple,  out.width = c('50%', '50%'), fig.show='hold'}

# Daily case counts 
###################
plot_daily <- ggplot(linelist, aes(x = date_of_onset)) + 
  
  # stacked bars, bined by day (1 days)
  stat_bin(binwidth = 1, position="stack") 

print(plot_daily)


# Weekly case counts 
###################
plot_weekly <- ggplot(linelist, aes(x = date_of_onset)) + 
  
  # stacked bars, bined by week (7 days)
  stat_bin(binwidth = 7, position="stack", fill = "brown") 

print(plot_weekly)
```
  
  
### With aesthetics
``` {r ggplot_aesthetics}
# Preparation
#############
# Create epiweek variable. Factor argument automatically includes all weeks in span. Numeric shows just the week number.
linelist$epiweek <- aweek::date2week(linelist$date_of_onset, factor = TRUE, numeric = TRUE)

# Calculate maximum number of cases in an epiweek, to get the maximum y-axis height (also helps with uniformity in multiple plots)
ymax <- max(summary(factor(linelist$epiweek), maxsum = length(linelist$epiweek)))

# Weekly case counts 
###################
plot_weekly <- ggplot(linelist, aes(x = date_of_onset)) + 
  
  # stacked bars, bined by week (7 days)
  stat_bin(binwidth = 7, position = "stack", fill = "grey", color = "black") +
  
  # X-axis 21-day labels
  scale_x_date( 
    # Sets date label breaks as every 3 weeks from Monday before the first case
    breaks = function(x) seq.Date(from = min(linelist$date_of_onset, na.rm = T), to = max(linelist$date_of_onset, na.rm=T), by = "1 week"),
    
    # axis limits determined by max/min + buffer
    limits = c((min(linelist$date_of_onset, na.rm = T) - 8), (max(linelist$date_of_onset, na.rm = T) + 8)), 
    
    # displays as date number, then abbreviated month (e.g. 12 Oct)
    date_labels = "%d-%b",   
    
    # sets origin at (0,0)
    expand = c(0,0)) +                                
  
  # Y-axis breaks every 5 cases
  scale_y_continuous(breaks = seq(0, ymax, 5),
                     limits = c(0, ymax),
                     expand = c(0, 0)) +
  
  # Theme specifications (axis, text, etc.)
  theme(# title
        plot.title = element_text(size=20, hjust= 0, face="bold"),   # title size, font, bold
        # axes
        axis.text.x = element_text(angle=90, vjust=0.5, hjust=1),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14, face="bold"),
        axis.line = element_line(colour="black"),
        # background
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        # caption (italics, on right side)
        plot.caption = element_text(hjust = 0, face = "italic")
        ) +
  
  guides(fill = guide_legend(reverse = TRUE,                   # Orders Non-active zones at end of legend
                             override.aes = list(size = 0.2),
                             ncol = 2)) +                        # Number of legend columns
  
  labs(x = "Week of illness onset", 
       y = "Number of cases",
       subtitle = "subtitle here",
       caption = paste0(nrow(linelist),
                        " confirmed and probable cases, reported as of ", data_date, ". ",
                        missing_onset, " cases missing date of onset and not shown.")) +
  
  ggtitle("Epidemic curve")


# print
print(plot_weekly)


```


<!-- ======================================================= -->
### Colored by category
Colored by a category

``` {r colored_by }
# Setup
########
# Two known classes (select colors from colorbrewer2.org)
colors_overall = c("#d95f02",  # 
                   "#1b9e77",
                   "#7570b3")  #    

# Order sex variable by reverse # of cases, so plot stacks with smallest # of cases at top
linelist$gender <- factor(linelist$gender, 
                         levels = levels(fct_rev(fct_infreq(linelist$gender))))

# Calculates maximum yaxis height for uniformity between the two graphs
ymax <- max(summary(factor(linelist$epiweek), maxsum = length(linelist$epiweek)))

# Number missing onset_date and cannot be graphed
missing_onset <- nrow(linelist[is.na(linelist$date_of_onset),])



# PLOT - BY ONSET DATE
######################
plot_defined_cats <- ggplot(linelist, aes(x = date_of_onset, fill = gender)) + 
  
  # stacked bars, width of 7 days
  stat_bin(binwidth = 7, position = "stack") +
  
  # Colors and labels of confirmed/probable
  scale_fill_manual(values = rev(colors_overall),
                    labels = str_to_sentence(levels(factor(linelist$gender)))) +
  
  # X-axis scale labels (not aggregation, just the labels)
  scale_x_date(# Sets date label breaks as every week
    breaks = function(x) seq.Date(from = min(linelist$date_of_onset, na.rm = T), to = max(linelist$date_of_onset, na.rm = T), by = "1 week"),
    limits = c((min(linelist$date_of_onset, na.rm=T)), (max(linelist$date_of_onset, na.rm = T))), # axis limits determined by max/min + buffer
    date_labels = "%d-%b",   # displays as date # then abbreviated month (e.g. 12 Oct)
    expand = c(0, 0)) +                                # sets origin at (0,0)
  
  # Y-scale in breaks, up to the ymax previously defined
  scale_y_continuous(breaks = seq(0, 500, 5), limits = c(0, ymax), expand=c(0, 0)) +
  
  # Themes for axes, titles, background, etc.
  theme(plot.title       = element_text(size=20, hjust=0.5, face="bold"),
        axis.text        = element_text(size=12),
        axis.title       = element_text(size=14, face="bold"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line        = element_line(colour = "black"),
        axis.text.x      = element_text(angle=90, vjust=0.5, hjust=1)) +
  
  # Legend specifications
  theme(legend.title           = element_blank(),
        legend.justification   = c(0, 1), 
        legend.position        = c(0.09, 0.98),
        legend.background      = element_blank(),
        legend.text            = element_text(size = 12)) +
  guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2))) +
  
  # Axis and caption labels
  labs(x = "Week of illness onset",
       y = "Number of Cases",
       caption = paste(missing_onset,"cases were missing onset date and are not included in the onset graph")) +
  
  # Title
  ggtitle("Cases by week of illness onset")

# print
print(plot_defined_cats)





```

<!-- ======================================================= -->
### By "active" areas

This code creates an epicurve with the following specifications:

* Shows geographic units by color  
* Lumps several into one category


``` {r setup_plot}
# PARAMETERS
#############

# Maximum y-value for epiweek (this will be larger than necessary because of missing onset dates)
ymax <- max(table(linelist$epiweek))

# Number missing onset_date and cannot be graphed
missing_onset <- nrow(filter(linelist, is.na(date_of_onset)))


# SETUP - ACTIVE/NON-ACTIVE ZONES
#################################
# List of "active" zones with a case in the date range
active_zones <- unique(linelist$province[which(linelist$date_of_onset > (data_date - 90))])
active_zones

# Table of active zones and their overall number of cases (for ordering their stacked appearance)
order_table <- linelist %>%
  filter(province %in% active_zones) %>%
  group_by(province) %>%
  summarise(cases = n())
order_table

# Create TRUE/FALSE variable for "active" health zones
linelist$active_zone <- ifelse(linelist$province %in% active_zones, TRUE, FALSE)

# Create list of non-active HZ names for bottom of plot
other_zone_names <- unique(sort(linelist$province[linelist$active_zone == FALSE]))

# Make variable for graph categories, including a level for "non-active" zones
linelist$graph_zone <- factor(case_when(
  
  # Value assignments
  # Non-active zones
  linelist$active_zone == FALSE    ~ "Non-active zones",
  # All others are assigned their names, capitalized
  TRUE  ~ stringr::str_to_title(linelist$province)),
  
  # Order of variable levels
  levels = c(
    # "Non-active zones" is first level
    "Non-active zones",  
    
    # Orders active zones by their frequency in linelist, reversed, so most-affected zones are on the BOTTOM of plot
    str_to_title(rev(levels(fct_infreq(as.factor(linelist$province[linelist$active_zone == TRUE])))))))  


table(linelist$graph_zone, useNA = "ifany")


# COLORS
########
# Number of unique values in graph_zone variable, minus 1 (for non-active, which is added later as grey (#cccccc))
colors_needed <- length(unique(linelist$graph_zone, na.rm=T)) - 1 

# List of possible colors (see colorbrewer2.com, qualitative scheme)
colors_linelist = c(#"#cccccc", # first = non-active grey color
                "#1b9e77", # turquoise green
                "#ff7f00", # orange
                "#ffff33", # yellow
                "#6a3d9a", # purple
                "#b15928", # brown
                "#1f78b4", # blue
                "#e31a1c", # red,
                "#fb9a99", # pink
                "#b2df8a", # light green 
                "#cab2d6", # light purple
                "#a6cee3", # light blue
                "#fdbf6f", # beige
                "#33a02c"  # green
)

# Reduce number of colors to only the number needed
colors_linelist <- c("#cccccc", rev(colors_linelist[1:colors_needed]))


# MAKE GRAPH
#############
plot_overall <- ggplot(linelist, aes(x = date_of_onset, fill = graph_zone)) + 
  
  # stacked bars, bined by week (7 days)
  stat_bin(binwidth = 7, position = "stack") +
  
  # Fill of bars
  scale_fill_manual(values = colors_linelist, 
                    labels = str_to_sentence(levels(factor(linelist$graph_zone)))) +
  
  # X-axis 21-day labels
  scale_x_date( # Sets date label breaks as every 3 weeks from Monday before the first case
    breaks = function(x) seq.Date(from = min(linelist$date_of_onset, na.rm = T), to = max(linelist$date_of_onset, na.rm = T), by = "1 week"),
    limits = c((min(linelist$date_of_onset, na.rm = T) - 8), (max(linelist$date_of_onset, na.rm = T) + 8)), # axis limits determined by max/min + buffer
    date_labels = "%d-%b",   # displays as date number, then abbreviated month (e.g. 12 Oct)
    expand = c(0,0)) +                                # sets origin at (0,0)
  
  # Y-axis breaks every 5 cases
  scale_y_continuous(breaks = seq(0, ymax, 5),
                     limits = c(0, ymax),
                     expand = c(0, 0)) +
  
  # Theme specifications (axis, text, etc.)
  theme(plot.title = element_text(size = 20, hjust = 0, face = "bold"),   # title size, font, bold
        axis.text.x = element_text(angle=90, vjust=0.5, hjust=1),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14, face="bold"),
        axis.line = element_line(colour="black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        plot.caption = element_text(hjust = 0, face = "italic")
        ) +
  
  # Legend specifications
  theme(legend.title = element_blank(),                        # No legend title
        legend.position = c(0.20, 0.85),                         # placement of legend
        legend.background = element_blank(),                     # legend background   
        legend.text = element_text(size=12)) +                 # legend text size
  
  guides(fill = guide_legend(reverse = TRUE,                   # Orders Non-active zones at end of legend
                             override.aes = list(size = 0.2),
                             ncol = 2)) +                        # Number of legend columns
  
  labs(x = "Week of illness onset", 
       y = "Number of cases",
       subtitle = "Health zones with cases in the last 42 days specified by color",
       caption = paste0(nrow(linelist),
                        " confirmed and probable cases, reported as of ", data_date, ". ",
                        missing_onset, " cases missing date of onset and not shown.",
                        "\nNon-active zones include: ", str_to_title(toString(unique(linelist$province[linelist$active_zone == FALSE]))))) +
  
  ggtitle("Epidemic curve by active health zones")


# print
plot_overall



```




<!-- ======================================================= -->
### By pre-defined areas grouped

``` {r ggplot_health_area}

#SETUP
#############
# Filter to health zone of interest
zone_data <- linelist

# Number missing onset_date and cannot be graphed
missing_onset <- nrow(filter(linelist, is.na(date_of_onset)))

# Assign health area groups (individual for HAs of interest, groups others together)
linelist$graph_areas <- factor(case_when(
  linelist$province == "Shanghai"    ~ "Shanghai",
  linelist$province == "Jiangsu"     ~ "Jiangsu",
  linelist$province == "Zhejiang"    ~ "Zhejiang",
  TRUE                                ~ "Other (10)"
),
# Levels part of the factor function assigns order of appearance
levels = c(                         
  "Other (10)",
  "Shanghai",
  "Jiangsu",
  "Zhejiang"
)
)

# checks
table(linelist$graph_areas, useNA = "ifany")

# Color assignments
colors_needed <- length(unique(linelist$graph_areas, na.rm=T)) - 1 # number of colors needed

# list of colors
colors_aire = c("#a6cee3", 
                           "#1f78b4",
                           "#b2df8a", 
                           "#33a02c",
                           "#fb9a99",
                           "#e31a1c",
                           "#fdbf6f",
                           "#ff7f00",
                           "#cab2d6",
                           "#6a3d9a",
                           "#ffff99",
                           "#b15928"
                           )

# Reduce number of colors to only the number needed
colors_aire <- c("#cccccc", rev(colors_aire[1:colors_needed]))


# Plot of province
#####################################
plot <- ggplot(linelist, aes(x = date_of_onset, fill = graph_areas)) + 
  
  stat_bin(binwidth = 7, position="stack") +
  
  scale_fill_manual(values = colors_aire, labels = str_to_sentence(levels(factor(linelist$graph_areas)))) +
  
  scale_x_date(date_breaks = "1 week", date_labels = "%d-%b", limits = c((min(linelist$date_of_onset, na.rm = T) - 8), (max(linelist$date_of_onset, na.rm = T) + 8)), expand=c(0,0)) + # I used the date onset variable here so x axes will be the same
  
  scale_y_continuous(breaks = seq(0, 500, 5), limits = c(0, 35), expand = c(0, 0)) +
  
  theme(plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
        plot.caption = element_text(hjust = 0, face = "italic"),
        
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        
        
        axis.line = element_line(colour = "black"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        axis.title = element_text(size = 14, face = "bold"),
        
        legend.title = element_blank(),
        legend.justification = c(0,1), 
        legend.position = c(0.05, 1),
        legend.background = element_blank(),
        legend.text = element_text(size = 12)) +
  
  guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2), ncol = 4)) +
  
  labs(x="Week of illness onset", 
       y="Number of cases",
       subtitle = "",
       caption = paste0(nrow(zone_data), " confirmed and probable cases, as of ", data_date, ". \n", missing_onset, " cases excluded due to missing date of onset.")) +
  
  ggtitle("Cases of influenza, by province")

plot


```


<!-- ======================================================= -->
### By "wave"

``` {r waves}
# Define the waves
##################
# zone_data <- filter(linelist, zone_de_sante == "mabalako")
# 
# zone_data$wave <- case_when(
#   zone_data$date_onset >= as.Date("2018-03-01") &
#     zone_data$date_onset < as.Date("2018-10-25")     ~ "Wave 1",
#   
#   zone_data$date_onset >= as.Date("2018-10-25") &
#     zone_data$date_onset < as.Date("2019-02-01")     ~ "Wave 2",
#   
#   zone_data$date_onset >= as.Date("2019-02-01") &
#     zone_data$date_onset < as.Date("2019-09-15")     ~ "Wave 3",
#   
#   zone_data$date_onset >= as.Date("2019-09-15")      ~ "Wave 4",
#   
#   TRUE ~ NA_character_
# )
# 
# table(is.na(zone_data$date_onset))
# table(zone_data$wave, useNA = "always")
# 
# 
# # Color assignments
# colors_needed <- length(unique(zone_data$wave, na.rm=T)) # number of colors needed
# 
# # list of colors
# colors_aire = c("#a6cee3", 
#                            "#1f78b4",
#                            "#b2df8a", 
#                            "#33a02c",
#                            "#fb9a99",
#                            "#e31a1c",
#                            "#fdbf6f",
#                            "#ff7f00",
#                            "#cab2d6",
#                            "#6a3d9a",
#                            "#ffff99",
#                            "#b15928"
#                            )
# 
# # Reduce number of colors to only the number needed
# colors_aire <- c(rev(colors_aire[1:colors_needed]))
# 
# 
# # Plot of health zone colored by wave
# #####################################
# plot_Mabalako <- ggplot(zone_data, aes(x = date_onset, fill = wave)) + 
#   
#   stat_bin(binwidth = 7, position = "stack") +
#   
#   scale_fill_manual(values = rev(colors_aire), labels = str_to_sentence(levels(factor(zone_data$wave)))) +
#   
#   scale_x_date(date_breaks = "21 days", date_labels = "%d-%b",
#                limits = c((min(zone_data$date_onset, na.rm = T) - 8), (max(zone_data$date_report, na.rm = T) + 8)), expand = c(0,0)) +
#   
#   scale_y_continuous(breaks = seq(0, 500, 5), limits = c(0, 35), expand = c(0, 0)) +
#   
#   theme(text = element_text(family = "Segoe Condensed"),
#         axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
#         axis.text = element_text(size = 12),
#         axis.title = element_text(size = 14, face = "bold"),
#         axis.line = element_line(colour = "black"),
#         
#         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
#         plot.caption = element_text(hjust = 0, face = "italic"),
#         
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.background = element_blank(),
#         
#         legend.title = element_blank(),
#         legend.justification = c(0,1), 
#         legend.position = c(0.75, 0.98),
#         legend.background = element_blank(),
#         legend.text = element_text(size=12)) +
#   
#   guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2), ncol = 1)) +
#   
#   labs(x="Week of illness onset", 
#        y="Number of cases",
#        subtitle = "",
#        caption = paste0(nrow(zone_data), " confirmed and probable cases, as of ", data_date, ". \n", missing_onset, " cases excluded due to missing date of onset and 16 excluded due to uncertain health zone of report.")) +
#   
#   ggtitle("Four waves of EVD in Mabalako health zone")
# 
# plot_Mabalako
# 
# 
# # Produce table describing each wave
# ####################################
# table <- zone_data %>%
#   select("aire_de_sante", "wave", "community_death", "date_onset", "cte_date", "epicasedef", "community_death", "contact_registered", "contact_surveilled") %>%
#   group_by(wave) %>%
#   summarise(first_onset       = min(date_onset, na.rm = T),
#             last_admission    = max(cte_date, na.rm = T),
#             n                 = n(),
#             confirmed         = sum(epicasedef == "confirmed"),
#             community_deaths  = paste0(sum(community_death    == 1), 
#                                        " (", round(100*sum(community_death == 1)/confirmed),"%)"),
#             reg_contacts      = paste0(sum(contact_registered == "yes"),
#                                        " (", round(100*sum(contact_registered == "yes")/confirmed),"%)"),
#             surv_contacts     = paste0(sum(contact_surveilled == "yes"),
#                                        " (", round(100*sum(contact_surveilled == "yes")/confirmed),"%)"),
#             top               = paste(toupper(names(sort(table(aire_de_sante),decreasing=TRUE)[1:3])), collapse=", ",
#                                       round(100*(sort(table(aire_de_sante),decreasing=TRUE)[1:3]/confirmed)), "%"),
#             health_areas      = paste(toupper(unique(aire_de_sante)), collapse=', ') 
#             )
# 
# kable(table)

```




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Aggregated data {.tabset .tabset-fade .tabset-pills}



<!-- ======================================================= -->
### Situation  

Often you do not have linelist data, but instead daily case counts from facilities, districts, etc. You can plot these in an epidemiological curve, but the code will be slightly different.

This section will utilize the counts_data dataset that was imported earlier, in the data preparation section.

Note: The incidence package does not support aggregate data

<!-- ======================================================= -->
### Clean dates  

As before, we must ensure date variables are correctly classified.

```{r aggregated_dates}
# Convert Date variable to Date class
count_data$Date <- as.Date(count_data$Date, format = "%d/%m/%Y")
```



<!-- ======================================================= -->
### Create weeks  

```{r aggregated_epiweek}
# Create epiweek variable
# aweek weeks are also stored as dates, facilitating better display manipulation
count_data$epiweek <- aweek::date2week(count_data$Date,      # use the Date variable
                                        week_start = "Monday", # epiweek begins on Monday
                                        floor_day = TRUE,      # only display year and week #
                                        factor = TRUE)         # expand to include all possible weeks


```



<!-- ======================================================= -->
### Clean dates  

```{r aggregated_plot}
ggplot(data = count_data, aes(x = as.Date(epiweek), y = Cases, group = District, fill = District))+
     geom_bar(stat = "identity")+
     
     # LABELS for x-axis
     scale_x_date(date_breaks = "1 month",  # displays by month
                  date_labels = '%b%d\n%Y')+  #labeled by month with year below
     
     # Choose color palette (uses RColorBrewer package)
     scale_fill_brewer(palette = "Pastel1")+      
     
     # Theme specifications (axis, text, etc.)
     theme(
          # title
          plot.title = element_text(size=20, hjust= 0, face="bold"),   # title size, font, bold
          # axes
          axis.text.x = element_text(angle=0, vjust=0.5, hjust=1),
          axis.text = element_text(size=12),
          axis.title = element_text(size=14, face="bold"),
          axis.line = element_line(colour="black"),
          # background
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          # caption (italics, on right side)
          plot.caption = element_text(hjust = 0, face = "italic"))+
     
     # labels
     labs(x = "Week of report", 
          y = "Number of cases",
          subtitle = "Cases aggregated by week and shown by district",
          caption = "Data source: XXXXX")+
     
     ggtitle("Epidemic curve of disease X in fictional location")
```





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Dual-axis {.tabset .tabset-fade .tabset-pills}
Although there are fierce discussions about the validity of this within the data visualization community, many supervisors want to see an epicurve or similar chart with a percent overlaid with a second axis.

In ggplot it is very difficult to do this, except for the case where you are showing a line reflecting the proportion of a category shown in the bars below.


<!-- ======================================================= -->
### Second axis  
This uses the linelist dataset

TODO not complete yet

```{r sec_axis, eval=F}
library(reshape2)
# group the data by week, summarize counts by group (gender)
linelist_week <- linelist %>%
     mutate(onset_epiweek = aweek::date2week(date_of_onset, floor_day = TRUE, factor = TRUE)) %>%
     group_by(onset_epiweek) %>%
     summarize(num_male = sum(gender == "m"),
               num_female = sum(gender == "f"),
               pct_male = round(100*(num_male / n())),
               med_age  = median(as.numeric(age), na.rm=T)
               ) 
# remove pct and melt
linelist_week_melted <- linelist_week %>%
     select(-c("pct_male", "med_age")) %>%
     melt(id.vars = c("onset_epiweek"))

# merge together (multiple of the same values in week will attach to melted)
linelist_week_melted <- merge(linelist_week_melted,
                              linelist_week,
                              by = "onset_epiweek")

second_axis <- ggplot(linelist_week_melted,
                      aes(x = as.Date(onset_epiweek),
                          y = value, group = variable,
                          fill = variable)) + 
  
  # bars
  geom_bar(stat = "identity")+
  
  # Colors and labels of confirmed/probable
  scale_fill_manual(values = c("blue", "red"),
                    labels = str_to_sentence(levels(factor(linelist_week_melted$variable)))) +
  
  geom_line(mapping = aes(y = pct_male, color = "% male"), size = 0.5) +
     
  scale_color_manual(values = "black")+
     
  scale_y_continuous(sec.axis = sec_axis(~(./sum(linelist_week_melted$value, na.rm = T)*100), name = "name here", breaks = seq(0, 100, 20)))+


  # X-axis scale labels (not aggregation, just the labels)
  scale_x_date(# Sets date label breaks as every week
    breaks = function(x) seq.Date(from = min(linelist$date_of_onset, na.rm = T), to = max(linelist$date_of_onset, na.rm = T), by = "1 week"),
    limits = c((min(linelist$date_of_onset, na.rm=T)), (max(linelist$date_of_onset, na.rm = T))), # axis limits determined by max/min + buffer
    date_labels = "%d-%b",   # displays as date # then abbreviated month (e.g. 12 Oct)
    expand = c(0, 0)) +                                # sets origin at (0,0)
  
  # Y-scale in breaks, up to the ymax previously defined
  scale_y_continuous(breaks = seq(0, 500, 5), limits = c(0, ymax), expand=c(0, 0)) +
  
  # Themes for axes, titles, background, etc.
  theme(plot.title       = element_text(size=20, hjust=0.5, face="bold"),
        axis.text        = element_text(size=12),
        axis.title       = element_text(size=14, face="bold"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line        = element_line(colour = "black"),
        axis.text.x      = element_text(angle=90, vjust=0.5, hjust=1)) +
  
  # Legend specifications
  theme(legend.title           = element_blank(),
        legend.justification   = c(0, 1), 
        legend.position        = c(0.09, 0.98),
        legend.background      = element_blank(),
        legend.text            = element_text(size = 12)) +
  guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 0.2))) +
  
  # Axis and caption labels
  labs(x = "Week of illness onset",
       y = "Number of Cases",
       caption = paste(missing_onset,"cases were missing onset date and are not included in the onset graph")) +
  
  # Title
  ggtitle("Cases by week of illness onset")

second_axis

# print
print(plot_defined_cats)


```

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Resources {.tabset .tabset-fade .tabset-pills}



<!-- ======================================================= -->
### Online resources

Here are links to good online resources


<!-- ======================================================= -->
### Internal links

Other resources






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Combination Analysis {#combinations .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

This analysis plots the frequency of different **combinations** of values/responses. In this example, we plot the frequency of symptom combinations.  

This analysis is often called:  
**Multiple response analysis**
**Sets analysis**
**Combinations analysis**

The first method shown uses the package **ggupset**, an the second using the package **UpSetR**. 

```
An example plot is below. Five symptoms are shown. Below each vertical bar is a line and dots indicating the combination of symptoms reflected by the bar above. To the right, horizontal bars reflect the frequency of each individual symptom.
```

```{r echo=F, out.width= "75%"}
# Adds new symptom variables to the linelist, with random "yes" or "no" values 
linelist_sym <- linelist %>% 
  mutate(fever  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.80, 0.20)),
         chills = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.20, 0.80)),
         cough  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.9, 0.15)),
         aches  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.10, 0.90)),
         shortness_of_breath = sample(c("yes", "no"), nrow(linelist), replace = T))

# produced the plot (just for show)
linelist_sym_2 <- linelist_sym %>% 
  mutate(fever = case_when(fever == "yes" ~ 1,          # if old value is "yes", new value is "fever"
                           TRUE           ~ 0),   # if old value is anything other than "yes", the new value is 
         chills = case_when(chills == "yes" ~ 1,
                           TRUE           ~ 0),
         cough = case_when(cough == "yes" ~ 1,
                           TRUE           ~ 0),
         aches = case_when(aches == "yes" ~ 1,
                           TRUE           ~ 0),
         shortness_of_breath = case_when(shortness_of_breath == "yes" ~ 1,
                           TRUE           ~ 0))
# Make the plot
UpSetR::upset(
  select(linelist_sym_2, fever, chills, cough, aches, shortness_of_breath),
  sets = c("fever", "chills", "cough", "aches", "shortness_of_breath"),
  order.by = "freq",
  sets.bar.color = c("blue", "red", "yellow", "darkgreen", "orange"), # optional colors
  empty.intersections = "on",
  # nsets = 3,
  number.angles = 0,
  point.size = 3.5,
  line.size = 2,
  text.scale = 1.5,
  mainbar.y.label = "Symptoms Combinations",
  sets.x.label = "Patients with Symptom")

```


<!-- ======================================================= -->
## View the data  

This linelist includes five "yes/no" variables on reported symptoms. We will need to transform these variables a bit to use the **ggupset** package to make our plot.  

View the data (scroll to the right to see the symptoms variables)

```{r}
DT::datatable(linelist_sym, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T))
```

<!-- ======================================================= -->
## Re-format values  

We convert the "yes" and "no the the actual symptom name. If "no", we set the value as blank. 

```{r}
# create column with the symptoms named, separated by semicolons
linelist_sym_1 <- linelist_sym %>% 
  
  # convert the "yes" and "no" values into the symptom name itself
  mutate(fever = case_when(fever == "yes" ~ "fever",          # if old value is "yes", new value is "fever"
                           TRUE           ~ NA_character_),   # if old value is anything other than "yes", the new value is NA
         
         chills = case_when(chills == "yes" ~ "chills",
                           TRUE           ~ NA_character_),
         
         cough = case_when(cough == "yes" ~ "cough",
                           TRUE           ~ NA_character_),
         
         aches = case_when(aches == "yes" ~ "aches",
                           TRUE           ~ NA_character_),
         
         shortness_of_breath = case_when(shortness_of_breath == "yes" ~ "shortness_of_breath",
                           TRUE           ~ NA_character_))
```

Now we make two final variables:  
1. Pasting together all the symptoms of the patient (character variable)  
2. Convert the above to class *list*, so it can be accepted by **ggupset** to make the plot  

```{r}
linelist_sym_1 <- linelist_sym_1 %>% 
  mutate(
         # combine the variables into one, using paste() with a semicolon separating any values
         all_symptoms = paste(fever, chills, cough, aches, shortness_of_breath, sep = "; "),
         
         # make a copy of all_symptoms variable, but of class "list" (which is required to use ggupset() in next step)
         all_symptoms_list = as.list(strsplit(all_symptoms, "; "))
         )
```

View the new data. Note the two columns at the end - the pasted combined values, and the list

```{r}
DT::datatable(linelist_sym, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T))
```

<!-- ======================================================= -->
## Create the plot  

Load required package to make the plot (**ggupset**)

```{r}
pacman::p_load(ggupset)
```


Create the plot:

```{r}
ggplot(linelist_sym_1,
       aes(x=all_symptoms_list)) +
geom_bar() +
scale_x_upset(reverse = FALSE,
              n_intersections = 10,
              sets = c("fever", "chills", "cough", "aches", "shortness_of_breath")
              )+
  labs(title = "Signs & symptoms",
       subtitle = "10 most frequent combinations of signs and symptoms",
       caption = "Caption here.",
       x = "Symptom combination",
       y = "Frequency in dataset")

```
  
More information on **ggupset** can be found [online](https://rdrr.io/cran/ggupset/man/scale_x_upset.html) or offline in the package documentation in your RStudio Help tab.  

<!-- ======================================================= -->
## **UpSetR** method

The **UpSetR** package allows more customization, but it more difficult to execute:

https://github.com/hms-dbmi/UpSetR  *read this*
https://gehlenborglab.shinyapps.io/upsetr/ *Shiny App version - you can upload your own data*
https://cran.r-project.org/web/packages/UpSetR/UpSetR.pdf *documentation - difficult to interpret*


```{r}
pacman::p_load(UpSetR)
```

Convert symptoms variables to 1/0. 

```{r}
# Make using upSetR

linelist_sym_2 <- linelist_sym %>% 
  
  # convert the "yes" and "no" values into the symptom name itself
  mutate(fever = case_when(fever == "yes" ~ 1,          # if old value is "yes", new value is "fever"
                           TRUE           ~ 0),   # if old value is anything other than "yes", the new value is NA
         
         chills = case_when(chills == "yes" ~ 1,
                           TRUE           ~ 0),
         
         cough = case_when(cough == "yes" ~ 1,
                           TRUE           ~ 0),
         
         aches = case_when(aches == "yes" ~ 1,
                           TRUE           ~ 0),
         
         shortness_of_breath = case_when(shortness_of_breath == "yes" ~ 1,
                           TRUE           ~ 0))
```

Now make the plot, using only the symptom variables. Must designate which "sets" to compare (the names of the symptom variables).  
Alternatively use `nsets =` and `order.by = "freq"` to only show the top X combinations.  

```{r}

# Make the plot
UpSetR::upset(
  select(linelist_sym_2, fever, chills, cough, aches, shortness_of_breath),
  sets = c("fever", "chills", "cough", "aches", "shortness_of_breath"),
  order.by = "freq",
  sets.bar.color = c("blue", "red", "yellow", "darkgreen", "orange"), # optional colors
  empty.intersections = "on",
  # nsets = 3,
  number.angles = 0,
  point.size = 3.5,
  line.size = 2, 
  mainbar.y.label = "Symptoms Combinations",
  sets.x.label = "Patients with Symptom")

```




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Heatmaps {#heatmap .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

Nice to use when tracking metrics at many facilities/regions over time

For example:  

```{r echo=F}
count_data <- rio::import("data/count_data.csv")

agg_weeks <- count_data %>% 
  mutate(week = as.Date(aweek::week2date(aweek::date2week(data_date, floor_day = T)))) %>% 
  group_by(location_name, week) %>% 
  summarize(n_days = 7,
            n_reports = n(),
            malaria_tot = sum(malaria_tot, na.rm = T),
            n_days_reported = length(unique(data_date)),
            p_days_reported = round(100*(n_days_reported / n_days))) %>% 
  filter(week < as.Date("2019-06-10"))

ggplot(agg_weeks, aes(x=week, y=location_name, fill= p_days_reported))+
  geom_tile(colour="white",size=0.2)+
  guides(fill=guide_legend(title="Reporting\nperformance (%)"))+
  labs(x="Week (date of data)",
       y="Facility name",
       title="Percent of days per week that facility reported data",
       subtitle = "52 health facilities, April-May 2019",
       caption = "7-day weeks beginning on Mondays.")+
  scale_fill_gradient(low = "yellow", high = "darkgreen", na.value = "grey80")+
  theme_light()+
  theme(legend.position="right",legend.direction="vertical",
        legend.title=element_text(size=12, face="bold"),
        legend.margin=margin(grid::unit(0,"cm")),
        legend.text=element_text(size=10,face="bold"),
        legend.key.height=grid::unit(0.8,"cm"),
        legend.key.width=grid::unit(0.2,"cm"),
        axis.text.x=element_text(size=12),
        axis.text.y=element_text(vjust=0.2),
        axis.ticks=element_line(size=0.4),
        axis.title=element_text(size=12, face="bold"),
        plot.background=element_blank(),
        panel.border=element_blank(),
        plot.margin=margin(0.7,0.4,0.1,0.2,"cm"),
        plot.title=element_text(hjust=0,size=14,face="bold"))

```

<!-- ======================================================= -->
## Tracking performance {.tabset .tabset-fade .tabset-pills}

```{r}
count_data <- rio::import("data/count_data.csv")

DT::datatable(count_data, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T))

```

Group the data by week and location, and then make summary calculations:  


```{r}
# Get number & percent of days data reported for, by week
agg_weeks <- count_data %>% 
  mutate(week = as.Date(aweek::week2date(aweek::date2week(data_date, floor_day = T)))) %>% 
  group_by(location_name, week) %>% 
  summarize(n_days = 7,
            n_reports = n(),
            malaria_tot = sum(malaria_tot, na.rm = T),
            n_days_reported = length(unique(data_date)),
            p_days_reported = round(100*(n_days_reported / n_days))) %>% 
  filter(week < as.Date("2019-06-10"))

### Days
agg_days <- count_data %>% 
  
  filter(data_date < as.Date("2019-06-10"))
  
```

Then we make the plot:  

```{r}
ggplot(agg_weeks, aes(x=week, y=location_name, fill= p_days_reported))+
  geom_tile(colour="white",size=0.2)+
  guides(fill=guide_legend(title="Reporting\nperformance (%)"))+
  labs(x="Week (date of data)",
       y="Facility name",
       title="Percent of days per week that facility reported data",
       subtitle = "52 health facilities, April-May 2019",
       caption = "7-day weeks beginning on Mondays.")+
  scale_fill_gradient(low = "yellow", high = "darkgreen", na.value = "grey80")+
  theme_light()+
  theme(legend.position="right",legend.direction="vertical",
        legend.title=element_text(size=12, face="bold"),
        legend.margin=margin(grid::unit(0,"cm")),
        legend.text=element_text(size=10,face="bold"),
        legend.key.height=grid::unit(0.8,"cm"),
        legend.key.width=grid::unit(0.2,"cm"),
        axis.text.x=element_text(size=12),
        axis.text.y=element_text(vjust=0.2),
        axis.ticks=element_line(size=0.4),
        axis.title=element_text(size=12, face="bold"),
        plot.background=element_blank(),
        panel.border=element_blank(),
        plot.margin=margin(0.7,0.4,0.1,0.2,"cm"),
        plot.title=element_text(hjust=0,size=14,face="bold"))



```


Also, 3d?






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Age pyramids {#agepyramid .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

via ggplot and via R4Epis methods   TODO

```{r echo=F}

linelist$age <- as.numeric(linelist$age)


linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))

apyramid::age_pyramid(data = linelist, age_group = "age_group", split_by = "gender")
```

<!-- ======================================================= -->
## **apyramid** package {.tabset .tabset-fade .tabset-pills}

```{r}

linelist$age <- as.numeric(linelist$age)


linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))


apyramid::age_pyramid(data = linelist, age_group = "age_group", split_by = "gender")
```

<!-- ======================================================= -->
## `ggplot()` {.tabset .tabset-fade .tabset-pills}

with ggplot is more complex, but is done in this way...  TODO



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Diagrams {#diagrams .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

List of different diagrams in these tabs...


<!-- ======================================================= -->
## Patient flow {.tabset .tabset-fade .tabset-pills}

E.g. EVD patient "pathways" to outcome (via clinic or not, etc.)

HIV care continuum datasets? PreP datasets?


<!-- ======================================================= -->
## Alluvial {.tabset .tabset-fade .tabset-pills}

Sankey plots - show transitions among cohort over time, interrelatedness of groups
Liza Coyer TODO


<!-- ======================================================= -->
## Clinical trials {.tabset .tabset-fade .tabset-pills}

Or papers in meta-analysis


<!-- ======================================================= -->
## Event timelines {.tabset .tabset-fade .tabset-pills}
E.g. border closures during COVID




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Age-standardization {.tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}
Why
How
When
etc.

<!-- ======================================================= -->
## **PHEindicatormethods** package {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## **DSR** package {.tabset .tabset-fade .tabset-pills}








<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Making nice tables {#tables .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

Many audiences and reasons for the tables...

<!-- ======================================================= -->
## Manually {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## From data frame {.tabset .tabset-fade .tabset-pills}

knitr::kable
DT

<!-- ======================================================= -->
## Summarizing dataframe {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## From modelresults {.tabset .tabset-fade .tabset-pills}

For publication

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}
quickly changing the denominator (per 100,000, etc.)





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Transmission Chains {#transmissionchains .tabset .tabset-fade}


<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

The primary tool to visualize and analyze transmission chains is the package **epicontacts**, developed by the folks at RECON.  

```{r out.width=c('50%', '50%'), fig.show='hold', echo=F}
library(epicontacts)
library(outbreaks)

links <- epicontacts::make_epicontacts(linelist = mers_korea_2015$linelist,
                                       contacts = mers_korea_2015$contacts, 
                                       directed = TRUE)
# plot without time
plot(links,
     selector = FALSE,
     height = 700,
     width = 700)

# plot with date of onset as x-axis
plot(sim,
     x_axis = 'onset',
     height = 700,
     width = 700,
)
```




<!-- ======================================================= -->
## Visualization {.tabset .tabset-fade .tabset-pills}

```{r}

links <- epicontacts::make_epicontacts(linelist = mers_korea_2015$linelist,
                                       contacts = mers_korea_2015$contacts, 
                                       directed = TRUE)
# plot without time
plot(links,
     selector = FALSE,
     height = 700,
     width = 700)

```

And in a transmission tree, with *date of onset on the x-axis*:  

Note: this currently requires installing a development version of **epicontacts** from github... @ttree 

```{r}

# plot with date of onset as x-axis
plot(sim,
     x_axis = 'onset',
     height = 700,
     width = 700,
)

```

<!-- ======================================================= -->
## Analysis {.tabset .tabset-fade .tabset-pills}

```{r}
summary(links)
```







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Survey analysis {#surveys .tabset .tabset-fade}


<!-- ======================================================= -->
## From data frame {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Weighting {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Random selection {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Time series analysis {#timeseries .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Rmarkdowns {#rmarkdown .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## PDFs {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## PPTs {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## HTML {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Microsoft Word {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}

Embed Rmarkdown cheatsheet
Table issues
HTML candies
Making tables, cheatsheet contained in HTML handbook?







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Abberation Detection {.tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}

Endemic corridor analysis
Detecting spikes in syndromic/routine surveillance







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# GIS Basics {#gis .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Plotting coordinates {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## polygons and shapefiles {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Simple analyses {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Distance to nearest X (HCF) {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}








<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Character manipulation/search {#characters .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Syntax / Regex {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## splitting string variables {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## search ICD & chief complaints
 {.tabset .tabset-fade .tabset-pills}
stringr,  gsub,

<!-- ======================================================= -->
## occupation classification code {.tabset .tabset-fade .tabset-pills}

  









<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Matching/Merging datasets {#merging .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Joins {.tabset .tabset-fade .tabset-pills}  

antijoins, etc
dplyr

<!-- ======================================================= -->
## Probabilistic matching {.tabset .tabset-fade .tabset-pills}

rowmatcher
Other methods







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Deduplicating {#dedup .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview

<!-- ======================================================= -->
## Record elimination

Identifying and getting rid of duplicates

<!-- ======================================================= -->
## "Rolling-up" values

Combining the values of multiple records into one record







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Moving averages {#movingaverage .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}  


<!-- ======================================================= -->
## Calculating {.tabset .tabset-fade .tabset-pills}  


<!-- ======================================================= -->
## Visualizing {.tabset .tabset-fade .tabset-pills}  









<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Epidemic modeling {#epidemics .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## R(t) estimatation {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Doubling time {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Epidemic projections {.tabset .tabset-fade .tabset-pills}






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Advanced R Studio {.tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}
.Rprofile





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# R projects {#rprojects .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}
overview

<!-- ======================================================= -->
## Here package {.tabset .tabset-fade .tabset-pills}
here package





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Writing functions {#writefunctions .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Missing Data {#missing .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}  


How to quickly exclude or include in tables, charts, analysis, 
exclude whole line if any is missing, all missing, etc.

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}  







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# if/else/loops  {#ifelse .tabset .tabset-fade}  


<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}  


<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}  



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# ggplot2 tips {#ggplottips .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

Embed ggplot cheatsheet

<!-- ======================================================= -->
## Highlighting {.tabset .tabset-fade .tabset-pills}
gghighlight

<!-- ======================================================= -->
## Smart Labeling {.tabset .tabset-fade .tabset-pills}
ggrepel

<!-- ======================================================= -->
## Time axes {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Dual axes {.tabset .tabset-fade .tabset-pills}

Cowplot
Complicated method (% 100 * ...)

<!-- ======================================================= -->
## Adding shapes {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Animations {.tabset .tabset-fade .tabset-pills}









<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Modeling {#modeling .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}
Tidymodels

<!-- ======================================================= -->
## Logistic Regression {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Multi-level modeling Regression {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Survival analysis {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Multi-stage Markov models {.tabset .tabset-fade .tabset-pills}

Liza Coyer TODO this, logitudinal 


<!-- ======================================================= -->
## Tables of model results {.tabset .tabset-fade .tabset-pills}


<!-- ======================================================= -->
## Causal diagrams {.tabset .tabset-fade .tabset-pills}







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# R with interactive console {#console .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# sapply, lapply {#apply .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Shiny basics {#shiny .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

Flexdashboard  

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Connecting with relational databases {#databases .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# R on network/company drives {#networkdrive .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}
Troubleshooting tips, common errors, etc.

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Report Factories {#reportfactory .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Implementation {.tabset .tabset-fade .tabset-pills}




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Github and R {#github .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Implementation {.tabset .tabset-fade .tabset-pills}




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Interactive plots {#plotly .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}
plotly

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Overwriting files with R {.tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Common error messages {#errors .tabset .tabset-fade}

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

<!-- ======================================================= -->
## Other {.tabset .tabset-fade .tabset-pills}




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Gallery {#errors .tabset .tabset-fade}

If there is sufficient file space, this will be a gallery of visualizations, tables, etc. with internal links to the relevant Handbook sections. 