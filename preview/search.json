[{"path":"index.html","id":"section","chapter":"","heading":"","text":"DRAFT.REVIEWING BOOK, PLEASE PROVIDE FEEDBACK PAGE LINK","code":""},{"path":"index.html","id":"about-this-handbook","chapter":"","heading":"About this handbook","text":"open-access R reference manual applied epidemiologists public health practitioners.book strives :Serve quick R code reference manualProvide task-centered examples addressing common epidemiological problemsAssist epidemiologists transitioning R SAS, STATA, SPSS, ExcelBe accessible settings low internet-connectivity via offline version ([instructions ][Download book data])different R books?written epidemiologists, epidemiologists - leveraging experience local, national, academic, emergency settingsIt provides examples epidemic curves, transmission chains, epidemic modeling projections, age sex pyramids standardization, record matching, outbreak detection, survey analysis, causal diagrams, survival analysis, GIS basics, phylogenetic trees, automated reports, etc…","code":""},{"path":"index.html","id":"how-to-read-this-handbook","chapter":"","heading":"How to read this handbook","text":"Online versionSearch via search box Table ContentsClick “copy” icons copy codeSee “Resources” section page resourcesTo download data “follow-along”, see [Download book data] pageOffline versionTo download offline version, follow step--step instructions [Download book data] page.LanguagesWe actively seeking translate book languages English. can help, please contact us epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"edit-or-contribute","chapter":"","heading":"Edit or contribute","text":"Want share use book? Want offer fix addition?\r\nEmail us epiRhandbook@gmail.com. welcome comments suggestions.can also submit issue pull request Github repository, provide structured feedback via Google survey.","code":""},{"path":"index.html","id":"acknowledgements","chapter":"","heading":"Acknowledgements","text":"","code":""},{"path":"index.html","id":"contributors","chapter":"","heading":"Contributors","text":"book produced collaboration epidemiologists around world, drawing upon experiences organizations including local/state/provincial/national health departments ministries, World Health Organization (), MSF (Médecins Sans Frontières / Doctors without Borders), hospital systems, academic institutions.Editor--Chief: Neale BatraCore team: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuthors: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonny Polonski, Yurie Izawa, Daniel Molling, Sara Hollis, Isha Berry, Wen LinReviewers:","code":""},{"path":"index.html","id":"funding-and-programmatic-support","chapter":"","heading":"Funding and programmatic support","text":"handbook approved product specific organization. Although strive accuracy, provide guarantee content book.handbook project received funding via COVID-19 emergency capacity-building grant Training Programs Epidemiology Public Health Interventions Network (TEPHINET). handbook supported Cooperative Agreement number NU2GGH001873, funded Centers Disease Control Prevention TEPHINET, program Task Force Global Health. contents solely responsibility authors necessarily represent official views Centers Disease Control Prevention, Department Health Human Services, Task Force Global Health, Inc. TEPHINET.Programmatic support provided EPIET Alumni Network (EAN) also MSF’s Manson Unit.","code":""},{"path":"index.html","id":"inspiration","chapter":"","heading":"Inspiration","text":"multitude tutorials vignettes provided knowledge development handbook content credited within respective pages.generally, following sources provided inspiration laid groundwork handbook:“R4Epis” project (collaboration MSF RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"image-credits","chapter":"","heading":"Image credits","text":"Images logo (US CDC Public Health Image Library):2013 Yemen looking mosquito breeding sitesEbola virusSurvey Rajasthan","code":""},{"path":"index.html","id":"terms-of-use-and-license","chapter":"","heading":"Terms of Use and License","text":"work licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.","code":""},{"path":"iteration-and-loops.html","id":"iteration-and-loops","chapter":"1 Iteration and loops","heading":"1 Iteration and loops","text":"PAGE CURRENTLY CONSTRUCTIONThis page introduce two approaches iterative operations - using loops using package purrr. Iterative operations help perform repetitive tasks, reduce chances error, reduce code length, maximize efficiency.purrr facilitates “mapping” function across many inputs (columns, datasets, etc.)purrr facilitates “mapping” function across many inputs (columns, datasets, etc.)loops also iterate code across series inputs, less common R programming languages R can wrap processes functionsfor loops also iterate code across series inputs, less common R programming languages R can wrap processes functions","code":""},{"path":"iteration-and-loops.html","id":"preparation","chapter":"1 Iteration and loops","heading":"1.1 Preparation","text":"","code":""},{"path":"iteration-and-loops.html","id":"load-packages","chapter":"1 Iteration and loops","heading":"Load packages","text":"code chunk shows loading packages required analyses. handbook emphasize p_load() pacman, installs package necessary loads use. can also load packages library() base R. See page [R basics] information R packages.","code":"\npacman::p_load(\n     rio,         # import/export\n     here,        # file locator\n     purrr,       # iteration\n     tidyverse    # data management and visualization\n)"},{"path":"iteration-and-loops.html","id":"import-data","chapter":"1 Iteration and loops","heading":"Import data","text":"import dataset cases simulated Ebola epidemic. want download data follow step--step, see instructions [Download book data] page. dataset imported using import() function rio package. See page [Import export] various ways import data.first 50 rows linelist displayed .","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"iteration-and-loops.html","id":"purrr","chapter":"1 Iteration and loops","heading":"1.2 purrr","text":"One approach iterative operations purrr package. faced performing task several times, probably worth creating generalised solution can use across many inputs. example, producing plots multiple jurisdictions, importing combining many files.using loop, can probably cleanly purrr!","code":""},{"path":"iteration-and-loops.html","id":"load-packages-1","chapter":"1 Iteration and loops","heading":"Load packages","text":"purrr part tidyverse, need install/load separate package.","code":"\npacman::p_load(\n  rio,            # import/export\n  here,           # relative filepaths\n  tidyverse,      # data mgmt and viz\n  writexl,        # write Excel file with multiple sheets\n  readxl          # import Excel with multiple sheets\n  )"},{"path":"iteration-and-loops.html","id":"map","chapter":"1 Iteration and loops","heading":"map()","text":"One core purrr function map(), “maps” (applies) function input element provide.\r\nbasic syntax map(.x = SEQUENCE, .f = FUNCTION, ARGUMENTS). bit detail:.x = inputs upon .f function iteratively applied - e.g. vector jurisdiction names, columns data frame, list data frames.f = function apply element .x input - function define. written tilde ~.notes syntax:.f needs arguments specified, can written parentheses (e.g. map(.x, ~mean))provide arguments value iteration, provide outside .f function map(.x ~mean, na.rm=T)value argument change iteration, value .x , provide within .f function parentheses\r\ncan use .x (simply .) within .f function placeholder .x value iteration\r\ncan use .x (simply .) within .f function placeholder .x value iterationLet’s demonstrate common epidemiologist task: want import Excel workbook case data, data split across different named sheets workbook. efficiently import combine sheets one data frame?Let’s say sent Excel workbook. sheet contains cases given hospital.one approach uses map():map() function import() Excel sheetCombine data frames one using bind_rows()Along way, preserve sheet name origin case, storing new column data frameFirst, need extract sheet names save . provide Excel workbook’s file path function excel_sheets() package readxl, extracts sheet names. store character vector called sheet_names.names:Now vector names, map() can provide one--one function import(). example, sheet_names .x import() function .f.Recall [Import export] page used Excel workbooks, import() can accept argument = specifying sheet import. Within .f function (import()), provide = .x, whose value change iteration vector sheet_names - first “Central Hospital”, “Military Hospital”, etc.note - used map(), data Excel sheet saved R separate data frame within List. want list elements (data frames) name, pass sheet_names map() pass set_names(), ensures list elements gets appropriate name.save output List combined.inspect combined List output, see data Excel sheet saved named data frames within List. good, quite finished.Lastly, use function bind_rows() (dplyr) accepts list data frames combines one data frame. create column list element names, use argument .id = provide desired name new column.whole sequence commands:variations map() aware . example - map_dfr() returns data frame, list. Thus, used task bind rows. able capture sheet (hospital) case came .variations include map_chr(), map_dbl(), map_if(). - EXPLANATION","code":"\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\nsheet_names## [1] \"Central Hospital\"              \"Military Hospital\"             \"Missing\"                       \"Other\"                         \"Port Hospital\"                \r\n## [6] \"St. Mark's Maternity Hospital\"\ncombined <- sheet_names %>% \n  set_names() %>% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined <- sheet_names %>% \n  set_names() %>% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %>% \n  bind_rows(.id = \"origin_sheet\")"},{"path":"iteration-and-loops.html","id":"mapping-a-function-across-columns","chapter":"1 Iteration and loops","heading":"Mapping a function across columns","text":"Another common use-case map function across many columns. , map() function t.test() across numeric columns data frame linelist, comparing numeric values gender.Recall page [Simple statistical tests] t.test() can take inputs formula format, t.test(numeric column ~ binary column). example, following:numeric columns interest selected linelist - become .x inputs map()function t.test() supplied .f function, applied numeric columnWithin parentheses t.test():\r\nfirst ~ preceedes .f map iterate .x\r\n.x represents current column supplied function t.test()\r\nsecond ~ part t-test equation described \r\nt.test() function expects binary column right-hand side equation. supply vector linelist$gender independently statically (note included select()).\r\nfirst ~ preceedes .f map iterate .xthe .x represents current column supplied function t.test()second ~ part t-test equation described abovethe t.test() function expects binary column right-hand side equation. supply vector linelist$gender independently statically (note included select()).map() returns List, output list t-test results - one list element numeric column analysed.list t.test_results looks like opened (Viewed) RStudio. highlighted parts important examples page.can see top whole list named t.test_results five elements. five elements named age, wt_km, ht_cm, ct_blood, temp variable used t-test gender linelist.five elements lists, elements within p.value conf.int. elements like p.value single numbers, whereas estimate consist two elements (mean group f mean group m).Note:\r\nRemember want apply function certain columns data frame, can also use mutate() across(), explained [Cleaning data core functions] page. example applying .character() “age” columns. Note placement parentheses commas.","code":"\n# Results are saved as a list\nt.test_results <- linelist %>% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # keep only the numeric columns to map across\n  map(.f = ~t.test(.x ~ linelist$gender))        # t.test function, with equation NUMERIC ~ CATEGORICAL\n# convert columns with column name containing \"age\" to class Character\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  "},{"path":"iteration-and-loops.html","id":"extract-from-list","chapter":"1 Iteration and loops","heading":"Extract from list","text":"map() produces output class List, spend time discussing extract data lists using accompanying purrr functions. demonstrate , use list t.test_results previous section. list 5 lists - 5 lists contains results t-test column linelist data frame binary column gender. See image section visual list structure.","code":""},{"path":"iteration-and-loops.html","id":"names-of-elements","chapter":"1 Iteration and loops","heading":"Names of elements","text":"extract names elements , simply use names() base R. case, use names() t.test_results return names sub-list, names 5 variables t-tests performed.","code":"\nnames(t.test_results)## [1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\""},{"path":"iteration-and-loops.html","id":"elements-by-name-or-position","chapter":"1 Iteration and loops","heading":"Elements by name or position","text":"extract list elements name position can use brackets [[ ]] described [R Basics] page. use double brackets index list t.tests_results display first element results t-test age.However, use purrr functions map() pluck() achieve outcomes.pluck() pulls elements name positionFor example - extract t-test results age, can use pluck() like :Index deeper levels specifying levels commas. extracts element named “p.value” list age within list t.test_results.can extract inner elements first-level elements using map() run pluck() function across first-level element. example, code extracts “p.value” elements lists within t.test_results.another alternative, map() offers shorthand can write element name quotes, pluck . use map() output List, whereas use map_chr() named character vector use map_dbl() named numeric vector.","code":"\nt.test_results[[1]] # first element by position## \r\n##  Welch Two Sample t-test\r\n## \r\n## data:  .x by linelist$gender\r\n## t = -21, df = 4903, p-value <2e-16\r\n## alternative hypothesis: true difference in means is not equal to 0\r\n## 95 percent confidence interval:\r\n##  -7.54 -6.27\r\n## sample estimates:\r\n## mean in group f mean in group m \r\n##            12.7            19.6\nt.test_results[[1]][\"p.value\"] # return element named \"p.value\" from first element  ## $p.value\r\n## [1] 2.35e-96\nt.test_results %>% \n  pluck(\"age\")        # alternatively, use pluck(1)## \r\n##  Welch Two Sample t-test\r\n## \r\n## data:  .x by linelist$gender\r\n## t = -21, df = 4903, p-value <2e-16\r\n## alternative hypothesis: true difference in means is not equal to 0\r\n## 95 percent confidence interval:\r\n##  -7.54 -6.27\r\n## sample estimates:\r\n## mean in group f mean in group m \r\n##            12.7            19.6\nt.test_results %>% \n  pluck(\"age\", \"p.value\")## [1] 2.35e-96\nt.test_results %>%\n  map(pluck, \"p.value\")   # return every p-value## $age\r\n## [1] 2.35e-96\r\n## \r\n## $wt_kg\r\n## [1] 2.66e-182\r\n## \r\n## $ht_cm\r\n## [1] 3.52e-144\r\n## \r\n## $ct_blood\r\n## [1] 0.447\r\n## \r\n## $temp\r\n## [1] 0.574\nt.test_results %>% \n  map_dbl(\"p.value\")   # return p-values as a named numeric vector##       age     wt_kg     ht_cm  ct_blood      temp \r\n##  2.35e-96 2.66e-182 3.52e-144  4.47e-01  5.74e-01"},{"path":"iteration-and-loops.html","id":"convert-list-to-data-frame","chapter":"1 Iteration and loops","heading":"Convert list to data frame","text":"complicated topic - see Resources section complete tutorials. Nevertheless, demonstrate converting list t-test results data frame. create data frame columns variable, p-value, means two groups (male female).new approaches functions used:function tibble() used create tibble (like data frame)\r\nsurround tibble() function curly brackets { } prevent entire t.test_results stored first tibble column\r\nsurround tibble() function curly brackets { } prevent entire t.test_results stored first tibble columnWithin tibble(), column created explicitly, similar syntax mutate():\r\n. represents t.test_results\r\ncreate column variable names (list names) use names() described \r\ncreate column p-values use map_dbl() described pull p.value elements convert numeric vector\r\n. represents t.test_resultsTo create column variable names (list names) use names() described aboveTo create column p-values use map_dbl() described pull p.value elements convert numeric vectorBut now let’s say want add columns containing means group (males females). need extract element estimate, actually contains two elements within (mean group f mean group m). simplified vector map_chr() map_dbl(). Instead, use map(), create column class List within tibble! Yes, possible!list column, several tidyr functions (part tidyverse) help “rectangle” “un-nest” “nested list” columns. Read , running vignette(\"rectangle\"). brief:unnest_wider() - gives element list-column columnunnest_longer() - gives element list-column rowhoist() - acts like unnest_wider() specify elements unnestBelow, pass tibble unnest_wider() specifying means column (nested list). result means replaced two new columns, reflecting two elements previously means cell.can read pluck() ’s purrr documentation. sibling function chuck() return error instead NULL element exist.","code":"\nt.test_results %>% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }## # A tibble: 5 x 2\r\n##   variables         p\r\n##   <chr>         <dbl>\r\n## 1 age       2.35e- 96\r\n## 2 wt_kg     2.66e-182\r\n## 3 ht_cm     3.52e-144\r\n## 4 ct_blood  4.47e-  1\r\n## 5 temp      5.74e-  1\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}## # A tibble: 5 x 3\r\n##   variables         p means       \r\n##   <chr>         <dbl> <named list>\r\n## 1 age       2.35e- 96 <dbl [2]>   \r\n## 2 wt_kg     2.66e-182 <dbl [2]>   \r\n## 3 ht_cm     3.52e-144 <dbl [2]>   \r\n## 4 ct_blood  4.47e-  1 <dbl [2]>   \r\n## 5 temp      5.74e-  1 <dbl [2]>\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %>% \n  unnest_wider(means)## # A tibble: 5 x 4\r\n##   variables         p `mean in group f` `mean in group m`\r\n##   <chr>         <dbl>             <dbl>             <dbl>\r\n## 1 age       2.35e- 96              12.7              19.6\r\n## 2 wt_kg     2.66e-182              45.8              59.6\r\n## 3 ht_cm     3.52e-144             109.              142. \r\n## 4 ct_blood  4.47e-  1              21.2              21.2\r\n## 5 temp      5.74e-  1              38.6              38.6"},{"path":"iteration-and-loops.html","id":"custom-functions","chapter":"1 Iteration and loops","heading":"Custom functions","text":"often want create function provide map(). One example making purely custom plotting function provide map() shown .Let’s say want create epidemic curves hospital’s cases. using purrr, .f function can ggplot() extensions + usual. output map() always list, plots stored list. can extracted plotted ggarrange() function ggpubr package (documentation).code style looks messy, can achieve result saving specific ggplot() command custom user-defined function, example can name make_epicurve()). function used within map(). .x iteratively replaced hospital name, used hosp_name make_epicurve() function. See page [Writing functions].","code":"\n# load package for plotting elements from list\npacman::p_load(ggpubr)\n\n# map across the vector of 6 hospital \"names\" (created earlier)\n# use the ggplot function specified\n# output is a list with 6 ggplots\n\nhospital_names <- unique(linelist$hospital)\n\nmy_plots <- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %>% filter(hospital == .x))+\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\nmake_epicurve <- function(hosp_name){\n  \n  ggplot(data = linelist %>% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n# mapping\nmy_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)"},{"path":"iteration-and-loops.html","id":"split-datasets","chapter":"1 Iteration and loops","heading":"Split datasets","text":"","code":""},{"path":"iteration-and-loops.html","id":"split-dataset-and-export-csv-files","chapter":"1 Iteration and loops","heading":"Split dataset and export CSV files","text":"complex purrr map() example involves splitting dataset mapping functions part.Let’s say complete case linelist data frame, now want create separate linelist hospital export separate CSV file. , following steps:Use group_split() (dplyr) split linelist data frame unique values column hospital. output List containing one data frame per hospital subset.can View(linelsit_split) see list contains 6 data frames, representing cases one hospital.However, note data frames list names default! want name, use name saving CSV file., use pull() (purrr) extract hospital column data frame list. , safe, convert values character use unique() get name particular dataset. steps applied data frame via map()can now see list elements name. names can accessed via names(linelist_split).Lastly, export data frame .csv file, name specific hospital. use map(): take vector list element names (shown ) use map() iterate , applying export() (rio package, see [Import export] page) data frame list linelist_split name. also use name create unique file name. works:begin vector character names, passed map() .xThe .f function export() , requires data frame file path write toThe input .x (hospital name) used within .f extract/index specific element linelist_split list. results one data frame time provided export().\r\nexample, map() iterates “Military Hospital”, linelist_split[[.x]] actually linelist_split[[\"Military Hospital\"]], thus returning second element linelist_split - cases Military Hospital.\r\nexample, map() iterates “Military Hospital”, linelist_split[[.x]] actually linelist_split[[\"Military Hospital\"]], thus returning second element linelist_split - cases Military Hospital.file path provided export() dynamic via use str_glue() (see [Characters strings] page):\r\n() used get base file path specify “data” folder (note single quotes interrupt str_glue() double quotes)\r\nslash /, .x prints current hospital name make file identifiable\r\nFinally extension “.csv” export() uses create CSV file\r\n() used get base file path specify “data” folder (note single quotes interrupt str_glue() double quotes)slash /, .x prints current hospital name make file identifiableFinally extension “.csv” export() uses create CSV fileNow can see file saved “data” folder R Project “Epi_R_handbook”!","code":"\nlinelist_split <- linelist %>% \n  group_split(hospital)\nnames(linelist_split) <- linelist_split %>%   # Assign the names of each data frame in the list linelist_split \n                                              # Extract the names by doing the following to each data frame: \n  map(.f = ~pull(.x, hospital)) %>%             # Pull out hospital column\n  map(.f = ~as.character(.x)) %>%               # Convert to character\n  map(.f = ~unique(.x))                         # Take the unique hospital name\nnames(linelist_split)## [1] \"Central Hospital\"                     \"Military Hospital\"                    \"Missing\"                              \"Other\"                               \r\n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\nnames(linelist_split) %>%\n  map(.f = ~export(linelist_split[[.x]], file= str_glue(\"{here('data')}/{.x}.csv\")))"},{"path":"iteration-and-loops.html","id":"split-dataset-and-export-as-excel-sheets","chapter":"1 Iteration and loops","heading":"Split dataset and export as Excel sheets","text":"export hospital linelists Excel workbook one linelist per sheet, can just provide named list linelist_split write_xlsx() function writexl package. ability save one Excel workbook multiple sheets. list element names automatically applied sheet names.can now open Excel file see hospital sheet.","code":"\nlinelist_split %>% \n  writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))"},{"path":"iteration-and-loops.html","id":"more-than-one-group_split-column","chapter":"1 Iteration and loops","heading":"More than one group_split() column","text":"wanted split linelist one grouping column, produce subset linelist intersection hospital gender, need different approach naming list elements. involves collecting unique “group keys” using group_keys() dplyr - returned data frame. can combine group keys values unite() shown , assign conglomerate names linelist_split.Now combine groupings together, separated dashes, assign names list elements linelist_split. takes extra lines replace NA “Missing”, use unite() dplyr combine column values together (separated dashes), convert un-named vector can used names linelist_split.","code":"\n# split linelist by unique hospital-gender combinations\nlinelist_split <- linelist %>% \n  group_split(hospital, gender)\n\n# extract group_keys() as a dataframe\ngroupings <- linelist %>% \n  group_by(hospital, gender) %>%       \n  group_keys()\n\ngroupings      # show unique groupings ## # A tibble: 18 x 2\r\n##    hospital                             gender\r\n##    <chr>                                <chr> \r\n##  1 Central Hospital                     f     \r\n##  2 Central Hospital                     m     \r\n##  3 Central Hospital                     <NA>  \r\n##  4 Military Hospital                    f     \r\n##  5 Military Hospital                    m     \r\n##  6 Military Hospital                    <NA>  \r\n##  7 Missing                              f     \r\n##  8 Missing                              m     \r\n##  9 Missing                              <NA>  \r\n## 10 Other                                f     \r\n## 11 Other                                m     \r\n## 12 Other                                <NA>  \r\n## 13 Port Hospital                        f     \r\n## 14 Port Hospital                        m     \r\n## 15 Port Hospital                        <NA>  \r\n## 16 St. Mark's Maternity Hospital (SMMH) f     \r\n## 17 St. Mark's Maternity Hospital (SMMH) m     \r\n## 18 St. Mark's Maternity Hospital (SMMH) <NA>\n# Combine into one name value \nnames(linelist_split) <- groupings %>% \n  mutate(across(everything(), replace_na, \"Missing\")) %>%  # replace NA with \"Missing\" in all columns\n  unite(\"combined\", sep = \"-\") %>%                         # Unite all column values into one\n  setNames(NULL) %>% \n  as_vector() %>% \n  as.list()"},{"path":"iteration-and-loops.html","id":"pmap","chapter":"1 Iteration and loops","heading":"pmap()","text":"SECTION CONSTRUCTION","code":""},{"path":"iteration-and-loops.html","id":"for-loops","chapter":"1 Iteration and loops","heading":"1.3 for loops","text":"epidemiologist, common need repeat analyses sub-groups (e.g. jurisdictions sub-populations). Iterating loop one method automate process.loop three core parts:container results (optional)sequence items iterate throughThe operations conduct per item sequenceThe basic syntax : (item sequence) {operations using item}. Note parentheses curly brackets. results printed console, stored container R object.","code":""},{"path":"iteration-and-loops.html","id":"container","chapter":"1 Iteration and loops","heading":"Container","text":"Sometimes results loop printed console Plots pane. times, want store outputs container later use. container vector, data frame, even list.efficient create container results even beginning loop. practice, means creating empty vector, data frame, list. can created functions vector() vectors lists, matrix() data.frame() data frame.Empty vector\r\nSay want store median delay--admission hospital new vector. Use vector() specify class either “double” (hold numbers), “character”, “logical”. case use “double” set length number expected outputs (length sequence, case number unique hospitals data set).Empty data frameYou can make empty data frame specifying number rows columns like :Empty listSay want store plots created loop list. actually initialize container using vector() command , mode = \"list\". Specify length however wish.","code":"\ndelays <- vector(mode = \"double\",\n                 length = length(unique(linelist$hospital))) # this is the number of unique hospitals in the dataset\ndelays <- data.frame(matrix(ncol = 2, nrow = 3))\nplots <- vector(mode = \"list\", length = 16)"},{"path":"iteration-and-loops.html","id":"sequence","chapter":"1 Iteration and loops","heading":"Sequence","text":"“” part loop - operations run item sequence. sequence can series character values (e.g. jurisdictions, diseases, etc), R object names (e.g. column names list element names), sequence can series consecutive numbers (e.g. 1,2,3,4,5). approach utilities, described .Sequence character valuesIn case, loop applied value character vector.value “item”, whose value changes iteration loop, proceeds value character vector. example, term hosp represents value vector hospital_names. first iteration loop value “Port Hospital”. TFor second loop “St. Mark’s Maternity Hospital (SMMH)”. …Sequence namesThis variation character sequence , names existing R object extracted become character vector. example, column names data frame. useful know names exact matches column names thus can used index R object within loop., sequence names() (column names) linelist. Inside loop, column names used index (subset) linelist one---time. example, demonstrate conditional statement part operations code within loop. column interest class Numeric, mean column printed console. column class Numeric another statement printed console.note indexing column names - whenever referencing column (e.g. within mean()) just write “col”! col just character column name! refer entire column use column name index* linelist via linelist[[col]].Sequence numbersUse approach plan complicated operations store results loop. approach, sequence series consecutive numbers. Thus, value “item” character value (e.g. “Central Hospital” “date_onset”) number. useful looping data frames, can use numeric item inside loop index dataframe row number.example, let’s say want loop every row data frame extract certain information. “items” numeric row numbers. process explained “every item sequence numbers 1 total number rows data frame, X”. first iteration loop, 1. second iteration, 2, etc.Whew, mouthful words! looks like code: (seq_len(nrow(linelist)) {} represents item seq_len() produces sequence consecutive numbers 1 number rows linelist. using approach named vector (data frame), use seq_along(), like (seq_along(hospital_names) {}.code actually returns numbers, become value respective loop.","code":"\n# make vector of the hospital names\nhospital_names <- unique(linelist$hospital)\nhospital_names # print## [1] \"Other\"                                \"Missing\"                              \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \r\n## [5] \"Military Hospital\"                    \"Central Hospital\"\n# 'for loop'\nfor (hosp in hospital_names){       # sequence\n  \n  # OPERATIONS HERE\n  \n}\nfor (col in names(linelist)){ \n  \n  # if column is class Numeric, print the mean value\n  if(is.numeric(linelist[[col]])) {\n    print(mean(linelist[[col]], na.rm=T))     # don't forget to index with [[col]]\n    } else {        \n    print(\"Column not numeric\")            # if column is not numeric, print this\n  }\n  \n}## [1] \"Column not numeric\"\r\n## [1] 16.6\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] 16.1\r\n## [1] \"Column not numeric\"\r\n## [1] 16\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] -13.2\r\n## [1] 8.47\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] 52.6\r\n## [1] 125\r\n## [1] 21.2\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] \"Column not numeric\"\r\n## [1] 38.6\r\n## [1] \"Column not numeric\"\r\n## [1] 46.9\r\n## [1] 2.06for (i in seq_len(nrow(linelist)) {  # use on a data frame\r\n  # OPERATIONS HERE\r\n}  \nseq_along(hospital_names)  # use on a named vector## [1] 1 2 3 4 5 6"},{"path":"iteration-and-loops.html","id":"operations","chapter":"1 Iteration and loops","heading":"Operations","text":"code within loop. want run item sequence. Therefore, careful every part code changes item correctly coded changes! Remember use [[ ]] indexing. example,, use seq_len() linelist. gender age row pasted together stored container character vector cases_demographics.","code":"\n# create container to store results - a character vector\ncases_demographics <- vector(mode = \"character\", length = nrow(linelist))\n\n# the for loop\nfor (i in seq_len(nrow(linelist))){\n  \n  # OPERATIONS\n  # extract values from linelist for i using indexing\n  row_gender  <- linelist$gender[[i]]\n  row_age     <- linelist$age_years[[i]]    # don't forget to index!\n  \n  # store the gender-age in container at indexed location\n  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = \", \") \n\n}  # end for loop\n\n# display first 10 rows of container\nhead(cases_demographics, 10)##  [1] \"m, 2\"  \"f, 3\"  \"m, 56\" \"f, 18\" \"m, 3\"  \"f, 16\" \"f, 16\" \"f, 0\"  \"m, 61\" \"f, 27\""},{"path":"iteration-and-loops.html","id":"printing","chapter":"1 Iteration and loops","heading":"Printing","text":"Note print within loop likely need explicitly wrap function print().example , sequence explicit character vector, used subset linelist hospital.results stored container, rather print console print() function.","code":"\nfor (hosp in hospital_names){ \n  hospital_cases <- linelist %>% filter(hospital == hosp)\n  print(nrow(hospital_cases))\n}## [1] 885\r\n## [1] 1469\r\n## [1] 422\r\n## [1] 1762\r\n## [1] 896\r\n## [1] 454"},{"path":"iteration-and-loops.html","id":"testing-your-for-loop","chapter":"1 Iteration and loops","heading":"Testing your for loop","text":"test loop, can make temporarily assignment item, <- 10 hosp <- \"Central Hospital\" run operations code see expected results produced.","code":""},{"path":"iteration-and-loops.html","id":"looping-plots","chapter":"1 Iteration and loops","heading":"Looping plots","text":"put three components together (container, sequence, operations) let’s try plot epicurve hospital (see page [Epidemic curves].course, can make epicurve cases using incidence2 package :produce separate plot hospital’s cases, can put epicurve code within loop.First, save named vector unique hospital names, hospital_names. loop run names ((hosp hospital_names)). iteration loop, current hospital name vector represented “hosp” use within loop.Within loop, can write R code normal, use item (hosp case) knowing value changing. Within loop:filter() applied linelist, column hospital must equal current value hospThe incidence object created filtered linelistThe plot current hospital created, auto-adjusting titleThe plot current hospital temporarily saved printedThe loop moves onward repeat next hospital hospital_names","code":"\n# create 'incidence' object\noutbreak <- incidence2::incidence(   \n     x = linelist,                   # dataframe - complete linelist\n     date_index = date_onset,        # date column\n     interval = \"week\",              # aggregate counts weekly\n     groups = gender,                # group values by gender\n     na_as_group = TRUE)             # missing gender is own group\n\n# plot epi curve\nplot(outbreak,                       # name of incidence object\n     fill = \"gender\",                # color bars by gender\n     color = \"black\",                # outline color of bars\n     title = \"Outbreak of ALL cases\" # title\n     )\n# make vector of the hospital names\nhospital_names <- unique(linelist$hospital)\n\n# for each name (\"hosp\") in hospital_names, create and print the epi curve\nfor (hosp in hospital_names) {\n     \n     # create incidence object specific to the current hospital\n     outbreak_hosp <- incidence2::incidence(\n                    x = linelist %>% filter(hospital == hosp),   # linelist is filtered to the current hospital\n                    date_index = date_onset,\n                    interval = \"week\", \n                    groups = gender,\n                    na_as_group = TRUE\n     )\n     \n     # Create and save the plot. Title automatically adjusts to the current hospital\n     plot_hosp <- plot(outbreak_hosp,\n                       fill = \"gender\",\n                       color = \"black\",\n                       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n                       )\n     \n     # print the plot for the current hospital\n     print(plot_hosp)\n\n} # end the for loop when it has been run for every hospital in hospital_names "},{"path":"iteration-and-loops.html","id":"tracking-progress-of-a-loop","chapter":"1 Iteration and loops","heading":"Tracking progress of a loop","text":"loop many iterations can run many minutes even hours. Thus, can helpful print progress R console. code can placed within loop print every 100th number.","code":"# loop with code to print progress every 100 iterations\r\nfor (row in 1:nrow(linelist)){\r\n\r\n  # print progress\r\n  if(row %% 100==0){    # The %% operator is the remainder\r\n    print(row)\r\n\r\n}"},{"path":"iteration-and-loops.html","id":"resources","chapter":"1 Iteration and loops","heading":"1.4 Resources","text":"loops Data CarpentryThe R Data Science page iterationVignette write/read Excel filesA purrr tutorial jennybcAnother purrr tutorial Rebecca BarterA purrr tutorial map, pmap, imappurrr cheatsheetTO \r\ngroup_split\r\ncollapse\r\npluckset_names()\r\nvars = linelist %>%\r\nselect_if(.numeric) %>%\r\nselect(-cyl, - year) %>%\r\nnames() %>%\r\nset_names()","code":""}]
