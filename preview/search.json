[{"path":"index.html","id":"section","chapter":"","heading":"","text":"DRAFT. REVIEWERS GIVE FEEDBACK LINK.LIKE HANDBOOK? SOMETHING CHANGED? PLEASE TELL US!","code":""},{"path":"index.html","id":"r-for-applied-epi-and-public-health","chapter":"","heading":"R for applied ‘epi’ and public health","text":"handbook strives :Serve quick R code reference manualProvide task-centered examples addressing common epidemiologic problemsAssist epidemiologists transitioning R SAS, STATA, SPSS, ExcelBe accessible settings low internet-connectivity via offline version ([instructions ][Download handbook data])different R books?community-driven - written epidemiologists epidemiologists spare time leveraging experience local, national, academic, emergency settingsIt uses practical epi examples - cleaning case linelists, transmission chains, epidemic curves, automated reports dashboards, modeling incidence making projections, demographic pyramids rate standardization, record matching, outbreak detection, survey analysis, survival analysis, GIS basics, contact tracing, phylogenetic trees…","code":""},{"path":"index.html","id":"how-to-read-this-handbook","chapter":"","heading":"How to read this handbook","text":"Online versionSearch via search box Table ContentsClick “copy” icons copy codeSee “Resources” section page resources“Follow-along” [downloading example data][Download handbook data]Adjust font size browser zoom settingsOffline versionSee instructions download offline version handbook [Download book data] page.LanguagesWe seeking translate book languages English. can help, please contact us.","code":""},{"path":"index.html","id":"contact-us","chapter":"","heading":"Contact us","text":"Structured feedback formEmail us epiRhandbook@gmail.comSubmit issues pull requests Github repositoryTwitter handle @epiRhandbook","code":""},{"path":"index.html","id":"acknowledgements","chapter":"","heading":"Acknowledgements","text":"handbook produced collaboration epidemiologists around world spare time, drawing upon experiences organizations including local, state/provincial, national health agencies, World Health Organization (), MSF (Médecins Sans Frontières / Doctors without Borders), hospital systems, academic institutions.handbook approved product specific organization. Although strive accuracy, provide guarantee content book.","code":""},{"path":"index.html","id":"contributors","chapter":"","heading":"Contributors","text":"Editor--Chief: Neale BatraProject core team: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuthors: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinReviewers: Pat Keating, Mathilde Mousset, Annick Lenglet, Margot Charette, Isha Berry, Paula Blomquist, Natalie Fischer, Daniely Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Daniel Molling, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Wayne Enanoria, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Manual Albela Miranda, Molly Mantus, Priscilla Spencer, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIllustrations: Calder Fong","code":""},{"path":"index.html","id":"funding-and-support","chapter":"","heading":"Funding and support","text":"handbook project received supportive funding via COVID-19 emergency capacity-building grant Training Programs Epidemiology Public Health Interventions Network (TEPHINET). handbook supported Cooperative Agreement number NU2GGH001873, funded Centers Disease Control Prevention TEPHINET, program Task Force Global Health. contents solely responsibility authors necessarily represent official views Centers Disease Control Prevention, Department Health Human Services, Task Force Global Health, Inc. TEPHINET.Administrative support provided EPIET Alumni Network (EAN), special thanks Annika Wendland. EPIET European Programme Intervention Epidemiology Training.","code":""},{"path":"index.html","id":"inspiration","chapter":"","heading":"Inspiration","text":"multitude tutorials vignettes provided knowledge development handbook content credited within respective pages.generally, following sources provided inspiration handbook:“R4Epis” project (collaboration MSF RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"terms-of-use-and-license","chapter":"","heading":"Terms of Use and License","text":"work licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Universities academic courses welcome use handbook students. questions intended use, email epirhandbook@gmail.com.Contributor code","code":""},{"path":"survey-analysis.html","id":"survey-analysis","chapter":"1 Survey analysis","heading":"1 Survey analysis","text":"","code":""},{"path":"survey-analysis.html","id":"overview","chapter":"1 Survey analysis","heading":"1.1 Overview","text":"page demonstrates use several packages survey analysis.survey R packages rely survey package\r\nweighted analysis.\r\nuse survey well srvyr\r\n(wrapper survey allowing tidyverse-style coding) \r\ngtsummary\r\n(wrapper survey allowing publication ready tables).\r\noriginal survey package allow tidyverse-style coding,\r\nadded benefit allowing survey-weighted generalised linear\r\nmodels (added page later date).\r\nalso demonstrate using function sitrep\r\npackage create sampling weights (n.b package currently yet CRAN,\r\ncan installed github).page based work done “R4Epis” project;\r\ndetailed code R-markdown templates see “R4Epis” github page.\r\nsurvey package based code based early versions \r\nEPIET case studies.current page address sample size calculations sampling.\r\nsimple use sample size calculator see OpenEpi.\r\nGIS basics page handbook\r\neventually section spatial random sampling, page \r\neventually section sampling frames well sample size calculations.Survey dataObservation timeWeightingSurvey design objectsDescriptive analysisWeighted proportionsWeighted rates","code":""},{"path":"survey-analysis.html","id":"preparation","chapter":"1 Survey analysis","heading":"1.2 Preparation","text":"","code":""},{"path":"survey-analysis.html","id":"packages","chapter":"1 Survey analysis","heading":"Packages","text":"code chunk shows loading packages required analyses. handbook emphasize p_load() pacman, installs package necessary loads use. can also load packages library() base R. See page [R basics] information R packages.\r\nalso demonstrate using p_load_gh() function pacman install load package github yet published CRAN.","code":"\n## load packages from CRAN\npacman::p_load(rio,          # File import\n               here,         # File locator\n               tidyverse,    # data management + ggplot2 graphics\n               tsibble,      # handle time series datasets\n               survey,       # for survey functions\n               srvyr,        # dplyr wrapper for survey package\n               gtsummary,    # wrapper for survey package to produce tables\n               apyramid,     # a package dedicated to creating age pyramids\n               patchwork,    # for combining ggplots \n               ggforce       # for alluvial/sankey plots\n               )\n\n## load packages from github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # for observation time / weighting functions\n)"},{"path":"survey-analysis.html","id":"load-data","chapter":"1 Survey analysis","heading":"Load data","text":"example dataset used section:fictional mortality survey data.fictional population counts survey area.data dictionary fictional mortality survey data.based MSF OCA ethical review board pre-approved survey. \r\nfictional dataset produced part “R4Epis” project.\r\nbased data collected using KoboToolbox,\r\ndata collection software based Open Data Kit.Kobo allows export collected data, well data dictionary\r\ndataset. strongly recommend simplifies data cleaning\r\nuseful looking variables/questions.TIP: Kobo data dictionary variable\r\nnames “name” column survey sheet.\r\nPossible values variable specified choices sheet.\r\nchoices tab, “name” shortened value “label::english” \r\n“label::french” columns appropriate long versions.\r\nUsing epidict package msf_dict_survey() function import Kobo\r\ndictionary excel file re-format can used easily recode. CAUTION: example dataset \r\nexport (Kobo export different questionnaire levels individually)\r\n- see survey data section merge different levels.dataset imported using import() function rio package. See page Import export various ways import data.first 10 rows survey displayed .also want import data sampling population can produce\r\nappropriate weights. data can different formats, however \r\nsuggest seen (can just typed excel).first 10 rows survey displayed .cluster surveys may want add survey weights cluster level.\r\nread data .\r\nAlternatively counts, entered \r\ntibble.\r\ncase need one column cluster identifier \r\nmatches survey data, another column number households \r\ncluster.","code":"\n# import the survey data\nsurvey_data <- rio::import(\"survey_data.xlsx\")\n\n# import the dictionary into R\nsurvey_dict <- rio::import(\"survey_dict.xlsx\") \n# import the population data\npopulation <- rio::import(\"population.xlsx\")\n## define the number of households in each cluster\ncluster_counts <- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))"},{"path":"survey-analysis.html","id":"clean-data","chapter":"1 Survey analysis","heading":"Clean data","text":"makes sure date column appropriate format.\r\nseveral ways (see Working dates\r\npage details), however using dictionary define dates quick easy.also create age group variable using age_categories() function \r\nepikit - see cleaning data\r\nhandbook section details.\r\naddition, create character variable defining district various clusters\r\n.Finally, recode yes/variables TRUE/FALSE variables - otherwise\r\ncant used survey proportion functions.","code":"\n## select the date variable names from the dictionary \nDATEVARS <- survey_dict %>% \n  filter(type == \"date\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select date vars\n  \n## change to dates \nsurvey_data <- survey_data %>%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## define age group variable\nsurvey_data <- survey_data %>% \n     mutate(age_group = age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## create a character variable based off groups of a different variable \nsurvey_data <- survey_data %>% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## select the yes/no variable names from the dictionary \nYNVARS <- survey_dict %>% \n  filter(type == \"yn\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select yn vars\n  \n## change to dates \nsurvey_data <- survey_data %>%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))"},{"path":"survey-analysis.html","id":"survey-data","chapter":"1 Survey analysis","heading":"1.3 Survey data","text":"numerous different sampling designs can used surveys. \r\ndemonstrate code :\r\n- Stratified\r\n- Cluster\r\n- Stratified clusterAs described (depending design questionnaire) data \r\nlevel exported separate dataset Kobo. example \r\none level households one level individuals within households.two levels linked unique identifier.\r\nKobo dataset variable \"_index\" household level, \r\nmatches \"_parent_index\" individual level.\r\ncreate new rows household matching individual,\r\nsee handbook section joining\r\ndetails.","code":"\n## join the individual and household data to form a complete data set\nsurvey_data <- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## create a unique identifier by combining indeces of the two levels \nsurvey_data <- survey_data %>% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))"},{"path":"survey-analysis.html","id":"observation-time","chapter":"1 Survey analysis","heading":"1.4 Observation time","text":"mortality surveys want now long individual present \r\nlocation able calculate appropriate mortality rate period\r\ninterest. relevant surveys, particularly mortality\r\nsurveys important conducted frequently among mobile displaced\r\npopulations.first define time period interest, also known recall\r\nperiod (.e. time participants asked report answering\r\nquestions).\r\ncan use period set inappropriate dates missing, .e. deaths\r\nreported outside period interest.can use date variables define start end dates individual.\r\ncan use find_start_date() function sitrep* fine causes \r\ndates use calculate difference days (person-time).start date:\r\nEarliest appropriate arrival event within recall period\r\nEither beginning recall period (define advance), \r\ndate start recall applicable (e.g. arrivals births)end date:\r\nEarliest appropriate departure event within recall period\r\nEither end recall period, date end recall\r\napplicable (e.g. departures, deaths)","code":"\n## set the start/end of recall period\n## can be changed to date variables from dataset \n## (e.g. arrival date & date questionnaire)\nsurvey_data <- survey_data %>% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# set inappropriate dates to NA based on rules \n## e.g. arrivals before start, departures departures after end\nsurvey_data <- survey_data %>%\n      mutate(\n           arrived_date = if_else(arrived_date < recall_start, \n                                 as.Date(NA),\n                                 arrived_date),\n           birthday_date = if_else(birthday_date < recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date > recall_end,\n                              as.Date(NA),\n                              left_date),\n           death_date = if_else(death_date > recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n## create new variables for start and end dates/causes\nsurvey_data <- survey_data %>% \n     ## choose earliest date entered in survey\n     ## from births, household arrivals, and camp arrivals \n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %>%\n     ## choose earliest date entered in survey\n     ## from camp departures, death and end of the study\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               ) %>%\n     ## label those that were present at the start/end (except births/deaths)\n     mutate(startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause)) %>%\n     mutate(endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Define observation time in days\nsurvey_data <- survey_data %>% \n  mutate(obstime = as.numeric(enddate - startdate))"},{"path":"survey-analysis.html","id":"weighting","chapter":"1 Survey analysis","heading":"1.5 Weighting","text":"important drop erroneous observations adding survey weights.\r\nexample observations negative observation time, need\r\ncheck .\r\nAnother thing want drop empty rows (e.g. filter(!.na(uid)))\r\nremove duplicates (see handbook section de-duplication\r\ndetails).\r\nwithout consent need dropped .example filter cases want drop store separate\r\ndata frame - way can describe excluded survey.\r\nuse anti_join() function dplyr remove dropped cases\r\nsurvey data.mentioned demonstrate add weights three different study\r\ndesigns (stratified, cluster stratified cluster). require information\r\nsource population /clusters surveyed.\r\nuse stratified cluster code example, use whichever \r\nappropriate study design.","code":"\n## store the cases that you drop so you can describe them (e.g. non-consenting \n## or wrong village/cluster)\ndropped <- survey_data %>% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## use the dropped cases to remove the unused rows from the survey data set  \nsurvey_data <- anti_join(survey_data, dropped, by = names(dropped))\n# stratified ------------------------------------------------------------------\n# create a variable called \"surv_weight_strata\"\n# contains weights for each individual - by age group, sex and health district\nsurvey_data <- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## cluster ---------------------------------------------------------------------\n\n# get the number of people of individuals interviewed per household\n# adds a variable with counts of the household (parent) index variable\nsurvey_data <- survey_data %>%\n  add_count(index, name = \"interviewed\")\n\n\n## create cluster weights\nsurvey_data <- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n# \n# # stratified and cluster ------------------------------------------------------\n# # create a survey weight for cluster and strata\n# survey_data <- survey_data %>%\n#   mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)\n# \n# \n# ## TODO DELETE THIS \n# \n# ## drop those that are missing weights \n# # \n# survey_data <- survey_data %>%\n#   filter(!is.na(surv_weight_cluster_strata))"},{"path":"survey-analysis.html","id":"survey-design-objects","chapter":"1 Survey analysis","heading":"1.6 Survey design objects","text":"Create survey object according study design.\r\nUsed way data frames calculate weight proportions etc.\r\nMake sure necessary variables created .four options, comment use:\r\n- Simple random\r\n- Stratified\r\n- Cluster\r\n- Stratified clusterFor template - pretend cluster surveys two separate\r\nstrata (health districts B).\r\nget overall estimates need combined cluster strata weights.mentioned previously, two packages available . \r\nclassic one survey wrapper package called srvyr\r\nmakes tidyverse-friendly objects functions. demonstrate ,\r\nnote code chapter use srvyr based objects.\r\none exception gtsummary package accepts survey objects.","code":""},{"path":"survey-analysis.html","id":"survey-package","chapter":"1 Survey analysis","heading":"1.6.1 Survey package","text":"survey package effectively uses base R coding, \r\npossible use pipes (%>%) dplyr syntax.\r\nsurvey package use svydesign() function define survey\r\nobject appropriate clusters, weights strata.NOTE: need use tilde (~) front variables, package uses base R syntax assigning variables based formulae. ","code":"\n# simple random ---------------------------------------------------------------\nbase_survey_design_simple <- svydesign(ids = ~1, # 1 for no cluster ids\n                   weights = NULL,               # No weight added\n                   strata = NULL,                # sampling was simple (no strata)\n                   data = survey_data            # have to specify the dataset\n                  )\n\n## stratified ------------------------------------------------------------------\nbase_survey_design_strata <- svydesign(ids = ~1,  # 1 for no cluster ids\n                   weights = ~surv_weight_strata, # weight variable created above\n                   strata = ~health_district,     # sampling was stratified by district\n                   data = survey_data             # have to specify the dataset\n                  )\n\n# cluster ---------------------------------------------------------------------\nbase_survey_design_cluster <- svydesign(ids = ~village_name, # cluster ids\n                   weights = ~surv_weight_cluster, # weight variable created above\n                   strata = ~NULL,                 # sampling was simple (no strata)\n                   data = survey_data              # have to specify the dataset\n                  )\n\n# stratified cluster ----------------------------------------------------------\nbase_survey_design <- svydesign(ids = ~village_name,      # cluster ids\n                   weights = ~surv_weight_cluster_strata, # weight variable created above\n                   strata = ~health_district,             # sampling was stratified by district\n                   data = survey_data                     # have to specify the dataset\n                  )"},{"path":"survey-analysis.html","id":"srvyr-package","chapter":"1 Survey analysis","heading":"1.6.2 Srvyr package","text":"srvyr package can use as_survey_design() function, \r\narguments allows pipes (%>%), \r\nneed use tilde (~).","code":"\n## simple random ---------------------------------------------------------------\nsurvey_design_simple <- survey_data %>% \n  as_survey_design(ids = 1, # 1 for no cluster ids \n                   weights = NULL, # No weight added\n                   strata = NULL # sampling was simple (no strata)\n                  )\n# ## stratified ------------------------------------------------------------------\n# survey_design_strata <- survey_data %>% \n#   as_survey_design(ids = 1, # 1 for no cluster ids \n#                    weights = surv_weight_strata, # weight variable created above \n#                    strata = health_district # sampling was stratified by district\n#                   )\n# ## cluster ---------------------------------------------------------------------\n# survey_design_cluster <- survey_data %>% \n#   as_survey_design(ids = village_name, # cluster ids \n#                    weights = surv_weight_cluster, # weight variable created above \n#                    strata = NULL # sampling was simple (no strata)\n#                   )\n# \n# ## stratified cluster ----------------------------------------------------------\n# survey_design <- survey_data %>% \n#   as_survey_design(ids = village_name, # cluster ids \n#                    weights = surv_weight_cluster_strata, # weight variable created above \n#                    strata = health_district # sampling was stratified by district\n#                   )"},{"path":"survey-analysis.html","id":"descriptive-analysis","chapter":"1 Survey analysis","heading":"1.7 Descriptive analysis","text":"Basic descriptive analysis visualisation covered extensively \r\nchapters handbook, dwell .\r\ndetails see chapters descriptive tables,\r\nstatistical tests,\r\ntables presentation,\r\nggplot basics \r\nR markdown reports.section focus investigate bias sample visualise .\r\nalso look visualising population flow survey setting using\r\nalluvial/sankey diagrams.general, consider including following descriptive analyses:Final number clusters, households individuals includedNumber excluded individuals reasons exclusionMedian (range) number households per cluster individuals per household","code":""},{"path":"survey-analysis.html","id":"sampling-bias","chapter":"1 Survey analysis","heading":"1.7.1 Sampling bias","text":"Compare proportions age group sample \r\nsource population.\r\nimportant able highlight potential sampling bias.\r\nsimilarly repeat looking distributions sex.Note p-values just indicative, descriptive discussion (\r\nvisualisation age-pyramids ) distributions study sample\r\ncompared source population important binomial test .\r\nincreasing sample size often lead \r\ndifferences may irrelevant weighting data.","code":"\n## counts and props of the study population\nag <- survey_data %>% \n  group_by(age_group) %>% \n  filter(!is.na(age_group)) %>% \n  tally() %>% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## counts and props of the source population\npropcount <- population %>% \n  group_by(age_group) %>%\n    tally(population) %>%\n    mutate(proportion = n / sum(n))\n\n## bind together the columns of two tables, group by age, and perform a \n## binomial test to see if n/total is significantly different from population\n## proportion.\n  ## suffix here adds to text to the end of columns in each of the two datasets\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %>%\n  group_by(age_group) %>%\n  ## broom::tidy(binom.test()) makes a data frame out of the binomial test and\n  ## will add the variables p.value, parameter, conf.low, conf.high, method, and\n  ## alternative. We will only use p.value here. You can include other\n  ## columns if you want to report confidence intervals\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%\n  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %>%\n  ## Adjusting the p-values to correct for false positives \n  ## (because testing multiple age groups). This will only make \n  ## a difference if you have many age categories\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %>%\n                      \n  ## Only show p-values over 0.001 (those under report as <0.001)\n  mutate(p.value = ifelse(p.value < 0.001, \n                          \"<0.001\", \n                          as.character(round(p.value, 3)))) %>% \n  \n  ## rename the columns appropriately\n  select(\n    \"Age group\" = age_group,\n    \"Study population (n)\" = n,\n    \"Study population (%)\" = proportion,\n    \"Source population (n)\" = n_pop,\n    \"Source population (%)\" = proportion_pop,\n    \"P-value\" = p.value\n  )"},{"path":"survey-analysis.html","id":"demographic-pyramids","chapter":"1 Survey analysis","heading":"1.7.2 Demographic pyramids","text":"Demographic (age-sex) pyramids easy way visualising distribution\r\nsurvey population. also worth considering creating\r\ndescriptive tables age\r\nsex survey strata.\r\ndemonstrate using apyramid package allows weighted\r\nproportions using survey design object created . options creating\r\ndemographic pyramids\r\ncovered extensively chapter handbook. also use \r\nwrapper function sitrep called plot_age_pyramid() saves lines\r\ncoding producing plot proportions.formal binomial test difference, seen sampling bias\r\nsection, interested visualising whether sampled population\r\nsubstantially different source population whether weighting corrects\r\ndifference. use patchwork package show \r\nggplot visualisations side--side; details see section \r\ncombining plots ggplot tips\r\nchapter handbook.\r\nvisualise source population, un-weighted survey population \r\nweighted survey population.\r\nmay also consider visualising strata survey - example\r\nusing argument stack_by  = \"health_district\"\r\n(see ?plot_age_pyramid details).NOTE: x y axes flipped pyramids ","code":"\n## define x-axis limits and labels ---------------------------------------------\n## (update these numbers to be the values for your graph)\nmax_prop <- 35      # choose the highest proportion you want to show \nstep <- 5           # choose the space you want beween labels \n\n## this part defines vector using the above numbers with axis breaks\nbreaks <- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## this part defines vector using the above numbers with axis limits\nlimits <- c(max_prop/100 * -1, max_prop/100)\n\n## this part defines vector using the above numbers with axis labels\nlabels <-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## create plots individually  --------------------------------------------------\n\n## plot the source population \n## nb: this needs to be collapsed for the overall population (i.e. removing health districts)\nsource_population <- population %>%\n  ## ensure that age and sex are factors\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %>% \n  group_by(age_group, sex) %>% \n  ## add the counts for each health district together \n  summarise(population = sum(population)) %>% \n  ## remove the grouping so can calculate overall proportion\n  ungroup() %>% \n  mutate(proportion = population / sum(population)) %>% \n  ## plot pyramid \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## only show the y axis label (otherwise repeated in all three plots)\n  labs(title = \"Source population\", \n       y = \"\", \n       x = \"Age group (years)\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## plot the unweighted sample population \nsample_population <- plot_age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Unweighted sample population\", \n       y = \"Proportion (%)\", \n       x = \"\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## plot the weighted sample population \nweighted_population <- survey_design %>% \n  ## make sure the variables are factors\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %>%\n  plot_age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Weighted sample population\", \n       y = \"\", \n       x = \"\")  + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## combine all three plots  ----------------------------------------------------\n## combine three plots next to eachother using + \nsource_population + sample_population + weighted_population + \n  ## only show one legend and define theme \n  ## note the use of & for combining theme with plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # move legend to bottom\n        legend.title = element_blank(),                # remove title\n        text = element_text(size = 18),                # change text size\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # turn x-axis text\n       )"},{"path":"survey-analysis.html","id":"alluvialsankey-diagram","chapter":"1 Survey analysis","heading":"1.7.3 Alluvial/sankey diagram","text":"Visualising starting points outcomes individuals can helpful \r\nget overview. quite obvious application mobile populations,\r\nhowever numerous applications cohorts situation\r\ntransitions states individuals. diagrams several\r\ndifferent names including alluvial, sankey parallel sets - details \r\nhandbook chapter diagrams charts.","code":"\n## summarize data\nflow_table <- survey_data %>%\n  count(startcause, endcause, sex) %>%  # get counts \n  gather_set_data(x = c(\"startcause\", \"endcause\")) %>%     # change format for plotting\n  mutate(x = fct_relevel(x, c(\"startcause\", \"endcause\")),  # set startcause as first level\n         x = fct_recode(x, \n                        \"Start \\n cause\" = \"startcause\",   # add line break (\\n) after start\n                        \"End \\n cause\"   = \"endcause\")\n        )\n\n\n## plot your dataset \n  ## on the x axis is the start and end causes\n  ## gather_set_data generates an ID for each possible combination\n  ## splitting by y gives the possible start/end combos\n  ## value as n gives it as counts (could also be changed to proportion)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ## colour lines by sex \n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## fill in the label boxes grey\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## change text colour and angle (needs to be adjusted)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## adjusted y and x axes (probably needs more vertical space)\n  scale_x_discrete(name = NULL, expand = c(0, 0.2)) + \n  ## remove axis labels\n  theme(\n    title = element_text(size = 26),\n    text = element_text(size = 26),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.y = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\",                    # move legend to bottom\n    legend.title = element_blank(),                # remove title\n  )"},{"path":"survey-analysis.html","id":"weighted-proportions","chapter":"1 Survey analysis","heading":"1.8 Weighted proportions","text":"section detail produce tables weighted counts proportions,\r\nassociated confidence intervals design effect.\r\nfour different options using functions following packages:\r\nsurvey, srvyr, sitrep gtsummary.\r\nminimal coding produce standard epidemiology style table, \r\nrecommend sitrep function - wrapper srvyr code; note\r\nhowever yet CRAN may change future.\r\nOtherwise, survey code likely stable long-term, whereas\r\nsrvyr fit nicely within tidyverse work-flows. gtsummary\r\nfunctions hold lot potential, appear experimental incomplete\r\ntime writing.","code":""},{"path":"survey-analysis.html","id":"survey-package-1","chapter":"1 Survey analysis","heading":"1.8.1 Survey package","text":"can use svyciprop() function survey get weighted proportions\r\naccompanying 95% confidence intervals. appropriate design effect can \r\nextracted using svymean() rather svyprop() function.\r\nworth noting svyprop() appears accept variables 0 \r\n1 (TRUE/FALSE), categorical variables work.NOTE: Functions survey also accept srvyr design objects, used survey design object just consistency can combine functions survey shown function \r\ndefine , called svy_prop; can use function\r\ntogether map() purrr package iterate several variables\r\ncreate table. See handbook iteration\r\nchapter details purrr.","code":"\n## produce weighted counts \nsvytable(~died, base_survey_design)\n\n## produce weighted proportions\nsvyciprop(~died, base_survey_design, na.rm = T)\n\n## get the design effect \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %>% \n  deff()\n# Define function to calculate weighted counts, proportions, CI and design effect\n# x is the variable in quotation marks \n# design is your survey design object\n\nsvy_prop <- function(design, x) {\n  \n  ## put the variable of interest in a formula \n  form <- as.formula(paste0( \"~\" , x))\n  ## only keep the TRUE column of counts from svytable\n  weighted_counts <- svytable(form, design)[[2]]\n  ## calculate proportions (multiply by 100 to get percentages)\n  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100\n  ## extract the confidence intervals and multiply to get percentages\n  weighted_confint <- confint(weighted_props) * 100\n  ## use svymean to calculate design effect and only keep the TRUE column\n  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## combine in to one data frame\n  full_table <- cbind(\n    \"Variable\"        = x,\n    \"Count\"           = weighted_counts,\n    \"Proportion\"      = weighted_props,\n    weighted_confint, \n    \"Design effect\"   = design_eff\n    )\n  \n  ## return table as a dataframe\n  full_table <- data.frame(full_table, \n             ## remove the variable names from rows (is a separate column now)\n             row.names = NULL)\n  \n  ## change numerics back to numeric\n  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])\n  \n  ## return dataframe\n  full_table\n}\n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  svy_prop, design = base_survey_design) %>% \n  ## collapse list in to a single data frame\n  bind_rows() %>% \n  ## round \n  mutate(across(where(is.numeric), round, digits = 1))"},{"path":"survey-analysis.html","id":"srvyr-package-1","chapter":"1 Survey analysis","heading":"1.8.2 Srvyr package","text":"srvyr can use dplyr syntax create table. Note \r\nsurvey_mean() function used proportion argument specified, \r\nalso function used calculate design effect. \r\nsrvyr wraps around survey package functions svyciprop() \r\nsvymean(), used section.NOTE: seem possible get proportions categorical variables using srvyr either, need check section using sitrep write function iterate multiple variables using\r\npurrr package.\r\nSee handbook iteration\r\nchapter details purrr.","code":"\n## use the srvyr design object\nsurvey_design %>% \n  summarise(\n    ## produce the weighted counts \n    counts = survey_total(died), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(died, deff = TRUE)) %>% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(counts, props, props_low, props_upp, deff_deff)\n# Define function to calculate weighted counts, proportions, CI and design effect\n# design is your survey design object\n# x is the variable in quotation marks \n\n\nsrvyr_prop <- function(design, x) {\n  \n  summarise(\n    ## using the survey design object\n    design, \n    ## produce the weighted counts \n    counts = survey_total(.data[[x]]), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(.data[[x]], deff = TRUE)) %>% \n  ## add in the variable name\n  mutate(variable = x) %>% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  ~srvyr_prop(.x, design = survey_design)) %>% \n  ## collapse list in to a single data frame\n  bind_rows()"},{"path":"survey-analysis.html","id":"sitrep-package","chapter":"1 Survey analysis","heading":"1.8.3 Sitrep package","text":"tab_survey() function sitrep wrapper srvyr, allowing\r\ncreate weighted tables minimal coding. also allows calculate\r\nweighted proportions categorical variables.","code":"\n## using the survey design object\nsurvey_design %>% \n  ## pass the names of variables of interest unquoted\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # calculate the design effect\n             pretty = TRUE  # merge the proportion and 95%CI\n             )"},{"path":"survey-analysis.html","id":"gtsummary-package","chapter":"1 Survey analysis","heading":"1.8.4 Gtsummary package","text":"gtsummary seem inbuilt functions yet add confidence\r\nintervals design effect.\r\n\r\nshow ","code":"\nconfidence_intervals <- function(data, variable, by, ...) {\n  \n  ## extract the confidence intervals and multiply to get percentages\n  props <- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## extract the confidence intervals \n  as.numeric(confint(props) * 100) %>% ## make numeric and multiply for percentage\n    round(., digits = 1) %>%           ## round to one digit\n    c(.) %>%                           ## extract the numbers from matrix\n    paste0(., collapse = \"-\")          ## combine to single character\n}\n\n## using the survey package design object\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## define variables want to include\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %>% ## define stats of interest\n  add_n() %>%  ## add the weighted total \n  add_stat(fns = everything() ~ confidence_intervals) %>% ## add CIs\n  ## modify the column headers\n  modify_header(\n    list(\n      n ~ \"**Weighted total (N)**\",\n      stat_0 ~ \"**Weighted Count**\",\n      add_stat_1 ~ \"**95%CI**\"\n    )\n    )"},{"path":"survey-analysis.html","id":"weighted-ratios","chapter":"1 Survey analysis","heading":"1.9 Weighted ratios","text":"Similarly weighted ratios (mortality ratios) can use \r\nsurvey srvyr package.\r\nsimilarly write functions (similar ) iterate \r\nseveral variables. also create function gtsummary \r\ncurrently inbuilt functionality.","code":""},{"path":"survey-analysis.html","id":"survey-package-2","chapter":"1 Survey analysis","heading":"1.9.1 Survey package","text":"","code":"\nratio <- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci <- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)"},{"path":"survey-analysis.html","id":"srvyr-package-2","chapter":"1 Survey analysis","heading":"1.9.2 Srvyr package","text":"","code":"\nsurvey_design %>% \n  ## survey ratio used to account for observation time \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )"},{"path":"survey-analysis.html","id":"resources","chapter":"1 Survey analysis","heading":"1.10 Resources","text":"UCLA stats pageAnalyze survey data freesrvyr packgegtsummary packageEPIET survey case studies","code":""}]
