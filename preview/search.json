[{"path":"index.html","id":"section","chapter":"","heading":"","text":"DRAFT. REVIEWERS GIVE FEEDBACK LINK.LIKE HANDBOOK? SOMETHING CHANGED? PLEASE TELL US!","code":""},{"path":"index.html","id":"about-this-handbook","chapter":"","heading":"About this handbook","text":"Epi R Handbook R reference manual applied epidemiology public health.book strives :Serve quick R code reference manualProvide task-centered examples addressing common epidemiologic problemsAssist epidemiologists transitioning R SAS, STATA, SPSS, ExcelBe accessible settings low internet-connectivity via offline version ([instructions ][Download handbook data])different R books?written epidemiologists, epidemiologists - leveraging experience local, national, academic, emergency settingsIt provides examples epidemic curves, transmission chains, automated reports dashboards, epidemic modeling projections, demographic pyramids standardization, record matching, outbreak detection, survey analysis, causal diagrams, survival analysis, GIS basics, phylogenetic trees, etc…","code":""},{"path":"index.html","id":"how-to-read-this-handbook","chapter":"","heading":"How to read this handbook","text":"Online versionSearch via search box Table ContentsClick “copy” icons copy codeSee “Resources” section page resources“Follow-along” [downloading example data][Download handbook data]Adjust font size browser zoom settingsOffline versionSee instructions download offline version handbook [Download book data] page.LanguagesWe seeking translate book languages English. can help, please contact us.","code":""},{"path":"index.html","id":"edit-or-contribute","chapter":"","heading":"Edit or contribute","text":"welcome comments suggestions feedback link, email epiRhandbook@gmail.com via issue/pull request Github repository.","code":""},{"path":"index.html","id":"acknowledgements","chapter":"","heading":"Acknowledgements","text":"handbook produced collaboration epidemiologists around world spare time, drawing upon experiences organizations including local, state/provincial, national health agencies, World Health Organization (), MSF (Médecins Sans Frontières / Doctors without Borders), hospital systems, academic institutions.handbook approved product specific organization. Although strive accuracy, provide guarantee content book.","code":""},{"path":"index.html","id":"contributors","chapter":"","heading":"Contributors","text":"Editor--Chief: Neale BatraProject core team: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuthors: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Daniel Molling, Isha Berry, Chris Bailey, Emma Buajitti, Wen Lin, Sara HollisReviewers: Pat Keating, Mathilde Mousset, Annick Lenglet, Margot Charette, Isha Berry, Paula Blomquist, Natalie Fischer, Daniely Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Daniel Molling, Kate Kelsey, Wayne Enanoria, John Rossow, Berhe Etsay, Mackenzie Zendt, James Wright, Flavio Finger, Tim Taylor, Tim Lee, Brianna Bradley, Manual Albela Miranda, Priscilla Spencer, Pattama Ulrich, Joseph Timothy, Olivia Varsaneux, Nienke Meeuwissen, Molly Mantus, Adam Vaughan, Lionel Monteiro, Joao Muianga","code":""},{"path":"index.html","id":"funding-and-support","chapter":"","heading":"Funding and support","text":"handbook project received supportive funding via COVID-19 emergency capacity-building grant Training Programs Epidemiology Public Health Interventions Network (TEPHINET). handbook supported Cooperative Agreement number NU2GGH001873, funded Centers Disease Control Prevention TEPHINET, program Task Force Global Health. contents solely responsibility authors necessarily represent official views Centers Disease Control Prevention, Department Health Human Services, Task Force Global Health, Inc. TEPHINET.Administrative support provided EPIET Alumni Network (EAN), special thanks Annika Wendland. EPIET European Programme Intervention Epidemiology Training.","code":""},{"path":"index.html","id":"inspiration","chapter":"","heading":"Inspiration","text":"multitude tutorials vignettes provided knowledge development handbook content credited within respective pages.generally, following sources provided inspiration laid groundwork handbook:“R4Epis” project (collaboration MSF RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"image-credits","chapter":"","heading":"Image credits","text":"Images logo US CDC Public Health Image Library) include 2013 Yemen looking mosquito breeding sites, Ebola virus, Survey Rajasthan.","code":""},{"path":"index.html","id":"terms-of-use-and-license","chapter":"","heading":"Terms of Use and License","text":"work licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Universities academic courses welcome use handbook students. questions intended use, email epirhandbook@gmail.com.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"cleaning-data-and-core-functions","chapter":"1 Cleaning data and core functions","heading":"1 Cleaning data and core functions","text":"page demonstrates common steps necessary clean dataset, starting importing raw data demonstrating “pipe chain” cleaning steps. use simulated Ebola case linelist, referenced often handbook.page also explains use many core functions used data management, including:want see functions compare Stata SAS, see page [Transition R].handbook emphasizes use functions tidyverse R package data management. However, may encounter alternative framework data.table R package. approach syntax briefly explained [Data Table] page.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"cleaning-pipeline","chapter":"1 Cleaning data and core functions","heading":"1.1 Cleaning pipeline","text":"page proceeds typical cleaning steps, adding sequentially cleaning pipe chain.epidemiological analysis data processing, cleaning steps often performed linked together, sequentially. R often manifests cleaning “pipeline”, raw dataset passed “piped” one cleaning step another.chain utilize dplyr “verb” functions magrittr pipe operator %>%. pipe begins “raw” data (“linelist_raw.xlsx”) ends “clean” R data frame (linelist).cleaning pipeline order steps important. Cleaning steps might include:Importing dataColumn names cleaned changedDe-duplicationColumn creation transformation (e.g. re-coding cleaning values)Rows filtered added","code":""},{"path":"cleaning-data-and-core-functions.html","id":"load-packages","chapter":"1 Cleaning data and core functions","heading":"1.2 Load packages","text":"code chunk shows loading packages required analyses. handbook emphasize p_load() pacman, installs package necessary loads use. can also load installed packages library() base R. See page [R basics] information R packages.","code":"\npacman::p_load(\n  rio,        # importing data  \n  here,       # relative file pathways  \n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # age_categories() function\n  tidyverse   # data manipulation and visualization\n)"},{"path":"cleaning-data-and-core-functions.html","id":"import-data","chapter":"1 Cleaning data and core functions","heading":"1.3 Import data","text":"","code":""},{"path":"cleaning-data-and-core-functions.html","id":"import","chapter":"1 Cleaning data and core functions","heading":"Import","text":"import raw .xlsx case linelist using import() function package rio, save data frame linelist_raw. want download data follow step--step, see instructions [Download handbook data] page.dataset large takes long time import, can useful import command separate pipe chain “raw” saved distinct file. also allows easy comparison original cleaned versions.See page [Import export] details unusual situations, including:Skipping import certain rowsDealing second row data dictionaryImporting Google sheetsBelow import raw .xlsx file. assume located working directory sub-folders specified filepath.can view first 50 rows original “raw” dataset . can use base R function head(n) view just first n lines console.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\")"},{"path":"cleaning-data-and-core-functions.html","id":"review","chapter":"1 Cleaning data and core functions","heading":"Review","text":"can use function skim() package skimr get overview entire dataframe (see page [Descriptive tables] info). Columns summarised class (character, numeric, POSIXct - type date class).\r\nTable 1.1: Data summary\r\nVariable type: characterVariable type: numericVariable type: POSIXct","code":"\nskimr::skim(linelist_raw)"},{"path":"cleaning-data-and-core-functions.html","id":"column-names","chapter":"1 Cleaning data and core functions","heading":"1.4 Column names","text":"Column names used often, must “clean” syntax. suggest following:Short namesNo spaces (replace underscores _ )unusual characters (&, #, <, >, …)Similar style nomenclature (e.g. date columns named like date_onset, date_report, date_death…)columns names linelist_raw printed using names() base R. can see initially:names contain spaces (e.g. infection date)Different naming patterns used dates (date onset vs. infection date)must merged header across two last columns .xlsx. know name two merged columns (“merged_header”) applied first one, second column assigned placeholder name “…28”, empty 28th column.NOTE: reference column name include spaces, surround name back-ticks, example: linelist$`infection date`. note keyboard, back-tick (`) different single quotation mark (’).","code":"\nnames(linelist_raw)##  [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"      \"hosp date\"      \r\n##  [6] \"date_of_outcome\" \"outcome\"         \"gender\"          \"hospital\"        \"lon\"            \r\n## [11] \"lat\"             \"infector\"        \"source\"          \"age\"             \"age_unit\"       \r\n## [16] \"row_num\"         \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \r\n## [21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"           \"temp\"           \r\n## [26] \"time_admission\"  \"merged_header\"   \"...28\""},{"path":"cleaning-data-and-core-functions.html","id":"automatic-cleaning","chapter":"1 Cleaning data and core functions","heading":"Automatic cleaning","text":"function clean_names() package janitor standardizes column names makes unique following:Converts names consist underscores, numbers, lettersAccented characters transliterated ASCII (e.g. german o umlaut becomes “o”, spanish “enye” becomes “n”)Capitalization preference can specified using case = argument (“snake” default, alternatives include “sentence”, “title”, “small_camel”…)can specify name replacements replace = argument (e.g. replace = c(onset = \"date_of_onset\"))online vignetteBelow, cleaning pipeline begins using clean_names() raw linelist.NOTE: last column name “…28” changed “x28”.","code":"\n# send the dataset through the function clean_names()\nlinelist <- linelist_raw %>% \n  janitor::clean_names()\n\n# see the new names\nnames(linelist)##  [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"      \"hosp_date\"      \r\n##  [6] \"date_of_outcome\" \"outcome\"         \"gender\"          \"hospital\"        \"lon\"            \r\n## [11] \"lat\"             \"infector\"        \"source\"          \"age\"             \"age_unit\"       \r\n## [16] \"row_num\"         \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \r\n## [21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"           \"temp\"           \r\n## [26] \"time_admission\"  \"merged_header\"   \"x28\""},{"path":"cleaning-data-and-core-functions.html","id":"manual-name-cleaning","chapter":"1 Cleaning data and core functions","heading":"Manual name cleaning","text":"Re-naming columns manually often necessary, even standardization step . , re-naming performed using rename() function dplyr package, part pipe chain. rename() uses style “NEW = OLD”, new column name given old column name., re-name command added cleaning pipeline:Now can see columns names changed:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"          \r\n##  [5] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"              \"gender\"              \r\n##  [9] \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"            \r\n## [13] \"source\"               \"age\"                  \"age_unit\"             \"row_num\"             \r\n## [17] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"               \r\n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"               \r\n## [25] \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"cleaning-data-and-core-functions.html","id":"rename-by-column-position","chapter":"1 Cleaning data and core functions","heading":"Rename by column position","text":"can also rename column position, instead column name, example:","code":"\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)"},{"path":"cleaning-data-and-core-functions.html","id":"rename-via-select","chapter":"1 Cleaning data and core functions","heading":"Rename via select()","text":"can also rename columns within dplyr select() function, used retain certain columns (covered later page). approach also uses format new_name = old_name. example:","code":"\nlinelist_raw %>% \n  select(# NEW name             # OLD name\n         date_infection       = `infection date`,    # rename and KEEP ONLY these columns\n         date_hospitalisation = `hosp date`)"},{"path":"cleaning-data-and-core-functions.html","id":"other-challenges","chapter":"1 Cleaning data and core functions","heading":"Other challenges","text":"","code":""},{"path":"cleaning-data-and-core-functions.html","id":"empty-excel-column-names","chapter":"1 Cleaning data and core functions","heading":"Empty Excel column names","text":"R dataset columns column names (headers). , import Excel dataset data column headers, R fill-headers names like “…1” “…2”. number represents column number (e.g. 4th column dataset header, R name “..4”).can clean names manually referencing position number (see example ), assigned name (linelist_raw$...1).","code":""},{"path":"cleaning-data-and-core-functions.html","id":"merged-excel-column-names-and-cells","chapter":"1 Cleaning data and core functions","heading":"Merged Excel column names and cells","text":"Merged cells Excel file common occurrence receiving data operational teams. Merged cells can nice human reading data, cause many problems machine reading data. R accommodate merged cells.Remind people data entry human-readable data machine-readable data. Strive train users principles tidy data. possible, try change procedures data arrive tidy format without merged cells.variable must column.observation must row.value must cell.using rio’s import() function, value merged cell assigned first cell subsequent cells empty.One solution deal merged cells import data function readWorkbook() package openxlsx. Set argument fillMergedCells = TRUE. gives value merged cell cells within merge range.DANGER: column names merged readWorkbook(), end duplicate column names, need fix manually - R work well duplicate column names! can re-name referencing position (e.g. column 5), explained section manual column name cleaning..","code":"\nlinelist_raw <- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)"},{"path":"cleaning-data-and-core-functions.html","id":"select-or-re-order-columns","chapter":"1 Cleaning data and core functions","heading":"1.5 Select or re-order columns","text":"Use select() dplyr select columns want retain, specify order data frame.CAUTION: examples , linelist data frame modified select() displayed, saved. demonstration purposes. modified column names printed piping data frame names().column names linelist point cleaning pipe chain:","code":"\nnames(linelist)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"          \r\n##  [5] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"              \"gender\"              \r\n##  [9] \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"            \r\n## [13] \"source\"               \"age\"                  \"age_unit\"             \"row_num\"             \r\n## [17] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"               \r\n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"               \r\n## [25] \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"cleaning-data-and-core-functions.html","id":"keep-columns","chapter":"1 Cleaning data and core functions","heading":"Keep columns","text":"Select columns want remainPut names select() command, quotation marks. appear data frame order provide. Note include column exist, R return error (see use any_of() want error situation).","code":"\n# linelist dataset is piped through select() command, and names() prints just the column names\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, fever) %>% \n  names()  # display the column names## [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\" \"fever\""},{"path":"cleaning-data-and-core-functions.html","id":"tidyselect-helper-functions","chapter":"1 Cleaning data and core functions","heading":"“tidyselect” helper functions","text":"helper functions operators exist make easy specify columns keep discard. package tidyselect, included tidyverse underlies columns selected dplyr functions.example, want re-order columns, everything() useful signify “columns yet mentioned”. command pulls columns date_onset date_hospitalisation beginning, keeps others afterward:“tidyselect” helpers functions work within select():everything() - columns mentionedlast_col() - last columnwhere() - applies function columns selects TRUEstarts_with() - matches specified prefix\r\nexample: select(starts_with(\"date\"))\r\nexample: select(starts_with(\"date\"))ends_with() - matches specified suffix\r\nexample: select(ends_with(\"_end\"))\r\nexample: select(ends_with(\"_end\"))contains() - columns containing character string\r\nexample: select(contains(\"time\"))\r\nexample: select(contains(\"time\"))matches() - apply regular expression (regex)\r\nexample: select(contains(\"[pt]al\"))\r\nexample: select(contains(\"[pt]al\"))num_range() - numerical range like x01, x02, x03any_of() - matches column exists returns error found\r\nexample: select(any_of(date_onset, date_death, cardiac_arrest))\r\nexample: select(any_of(date_onset, date_death, cardiac_arrest))addition, use normal operators c() list several columns, : consecutive columns, ! opposite, & , | .Use () specify logical criteria columns. providing function inside (), include empty parentheses. command selects columns class Numeric.Use contains() select columns column name contains string. ends_with() starts_with() provide nuance.function matches() works similarly contains() can provided regular expression (see page [Characters strings]), multiple strings separated bars within parentheses:CAUTION: column name specifically provide exist data, can return error stop code. Consider using any_of() cite columns may may exist, especially useful negative (remove) selections.one columns exists, error produced code continues.","code":"\n# move date_onset and date_hospitalisation to beginning\nlinelist %>% \n  select(date_onset, date_hospitalisation, everything()) %>% \n  names()##  [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"              \"generation\"          \r\n##  [5] \"date_infection\"       \"date_outcome\"         \"outcome\"              \"gender\"              \r\n##  [9] \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"            \r\n## [13] \"source\"               \"age\"                  \"age_unit\"             \"row_num\"             \r\n## [17] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"               \r\n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"               \r\n## [25] \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\"\n# select columns that are class Numeric\nlinelist %>% \n  select(where(is.numeric)) %>% \n  names()## [1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"      \"ht_cm\"      \"ct_blood\"   \"temp\"\n# select columns containing certain characters\nlinelist %>% \n  select(contains(\"date\")) %>% \n  names()## [1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"\n# searched for multiple character matches\nlinelist %>% \n  select(matches(\"onset|hosp|fev\")) %>%   # note the OR symbol \"|\"\n  names()## [1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"             \"fever\"\nlinelist %>% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %>% \n  names()## [1] \"date_onset\""},{"path":"cleaning-data-and-core-functions.html","id":"remove-columns","chapter":"1 Cleaning data and core functions","heading":"Remove columns","text":"Indicate columns remove placing minus symbol “-” front column name (e.g. select(-outcome)), vector column names (). columns retained.can also remove column using base R defining NULL. example:","code":"\nlinelist %>% \n  select(-c(date_onset, fever:vomit)) %>% # remove onset and all cols from fever to vomit\n  names()##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_hospitalisation\"\r\n##  [5] \"date_outcome\"         \"outcome\"              \"gender\"               \"hospital\"            \r\n##  [9] \"lon\"                  \"lat\"                  \"infector\"             \"source\"              \r\n## [13] \"age\"                  \"age_unit\"             \"row_num\"              \"wt_kg\"               \r\n## [17] \"ht_cm\"                \"ct_blood\"             \"temp\"                 \"time_admission\"      \r\n## [21] \"merged_header\"        \"x28\"\nlinelist$date_onset <- NULL   # deletes column with base R syntax "},{"path":"cleaning-data-and-core-functions.html","id":"standalone","chapter":"1 Cleaning data and core functions","heading":"Standalone","text":"select() can also used independent command (pipe chain). case, first argument original dataframe operated upon.","code":"\n# Create a new linelist with id and age-related columns\nlinelist_age <- select(linelist, case_id, contains(\"age\"))\n\n# display the column names\nnames(linelist_age)## [1] \"case_id\"  \"age\"      \"age_unit\""},{"path":"cleaning-data-and-core-functions.html","id":"add-to-the-pipe-chain","chapter":"1 Cleaning data and core functions","heading":"Add to the pipe chain","text":"linelist_raw, columns need: row_num, merged_header, x28. remove select() command cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n\n    # remove column\n    select(-c(row_num, merged_header, x28))"},{"path":"cleaning-data-and-core-functions.html","id":"deduplication","chapter":"1 Cleaning data and core functions","heading":"1.6 Deduplication","text":"See handbook page [De-duplication] extensive options de-duplicate data. simple row de-duplication example presented .package dplyr offers distinct() function. function examines every row reduce data frame unique rows. , removes rows 100% duplicates.evaluating duplicate rows, takes account range columns - default considers columns. shown de-duplication page, can adjust column range uniqueness rows evaluated regards certain columns.simple example, just add empty command distinct() pipe chain. ensures rows 100% duplicates rows (evaluated across columns).begin 6611 rows linelist.de-duplication 6608 rows. removed rows 100% duplicates rows., distinct() command added cleaning pipe chain:","code":"\nlinelist <- linelist %>% \n  distinct()\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n    \n    # de-duplicate\n    distinct()"},{"path":"cleaning-data-and-core-functions.html","id":"column-creation-and-transformation","chapter":"1 Cleaning data and core functions","heading":"1.7 Column creation and transformation","text":"recommend using dplyr function mutate() add new column, modify existing one.example creating new column mutate(). syntax : mutate(new_column_name = value transformation)Stata, similar command generate, R’s mutate() can also used modify existing column.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"new-columns","chapter":"1 Cleaning data and core functions","heading":"New columns","text":"basic mutate() command create new column might look like . creates new column new_col value every row 10.can also reference values columns, perform calculations. example new column bmi created hold Body Mass Index (BMI) case - calculated using formula BMI = kg/m^2, using column ht_cm column wt_kg.creating multiple new columns, separate comma new line. , examples new columns, including pasting together values columns using str_glue() stringr package (see page [Characters strings].Scroll right see new columns added (first 50 rows shown):TIP: variation mutate() function transmute(). function adds new column just like mutate(), also drops/removes columns mention within parentheses.","code":"\nlinelist <- linelist %>% \n  mutate(new_col = 10)\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\nlinelist <- linelist %>%                       \n  mutate(\n    new_var_dup    = case_id,             # new column = duplicate/copy another existing column\n    new_var_static = 7,                   # new column = all values the same\n    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # new column = pasting together values from other columns\n    ) "},{"path":"cleaning-data-and-core-functions.html","id":"convert-column-class","chapter":"1 Cleaning data and core functions","heading":"Convert column class","text":"Often need set correct class column. ways set column class import commands, often often cumbersome. See section object classes learn converting class objects, including columns.First, run checks important columns see correct class:Currently, class “age” column character. perform quantitative analyses, need numbers recognized numeric!class “date_onset” column also character! perform analyses, dates must recognized dates!case, use mutate() define column , converted different class. basic example, converting ensuring column age class Numeric:similar way, can use .character(), .double(), .logical().convert class Factor, can use factor() base R as_factor() forcats. Read [Factors] page.Converting class date must take care. Several methods explained page [Working dates]. Typically, raw date values must format conversion work correctly (e.g “MM/DD/YYYY”, “DD MM YYYY”). converting class Date, check data visually cross-table confirm value converted correctly.","code":"\nclass(linelist$age)## [1] \"character\"\nclass(linelist$date_onset)## [1] \"character\"\nlinelist <- linelist %>% \n  mutate(age = as.numeric(age))"},{"path":"cleaning-data-and-core-functions.html","id":"grouped-data","chapter":"1 Cleaning data and core functions","heading":"Grouped data","text":"dataframe already grouped (see page [Grouping data]), mutate() may behave differently dataframe grouped. summarizing functions, like mean(), median(), max(), etc. based grouped rows, rows.Read using mutate grouped dataframes tidyverse mutate documentation.","code":"\n# age normalized to mean of ALL rows\nlinelist %>% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# age normalized to mean of hospital group\nlinelist %>% \n  group_by(hospital) %>% \n  mutate(age_norm = age / mean(age, na.rm=T))"},{"path":"cleaning-data-and-core-functions.html","id":"transform-multiple-columns","chapter":"1 Cleaning data and core functions","heading":"Transform multiple columns","text":"Often write concise code want apply transformation multiple columns . transformation can applied multiple columns using across() function package dplyr (also contained within tidyverse package). across() can used dplyr function, commonly select(), mutate(), filter(), summarise(). See applied summarise() page [Descriptive tables].specify columns .cols = function(s) .fns. additional arguments provide function can included comma, still within across().","code":""},{"path":"cleaning-data-and-core-functions.html","id":"across-column-selection","chapter":"1 Cleaning data and core functions","heading":"across() column selection","text":"Specify columns argument .cols = - can name individually, use helper functions. Specify function .fns =. Note using function mode demonstrated , function written without parentheses ( ).transformation .character() applied specific columns named within across().helpers available assist specifying columns:everything() - columns mentionedlast_col() - last columnwhere() - applies function columns selects TRUEstarts_with() - matches specified prefix\r\nexample: across(starts_with(\"date\"))\r\nexample: across(starts_with(\"date\"))ends_with() - matches specified suffix\r\nexample: across(ends_with(\"_end\"))\r\nexample: across(ends_with(\"_end\"))contains() - columns containing character string\r\nexample: across(contains(\"time\"))\r\nexample: across(contains(\"time\"))matches() - apply regular expression (regex)\r\nexample: across(contains(\"[pt]al\"))\r\nexample: across(contains(\"[pt]al\"))num_range() -any_of() - matches column named. Useful name might exist\r\nexample: across(any_of(date_onset, date_death, cardiac_arrest))\r\nexample: across(any_of(date_onset, date_death, cardiac_arrest))example one change columns character class:Columns name contains string “date” (note placement commas parentheses):, want mutate columns class POSIXct (datetime class shows timestamps) - words, function .POSIXct() evaluates TRUE. want apply function .Date() columns convert normal class Date.Note within across() also use function ()Note .POSIXct() package lubridate. similar functions (.character(), .numeric(), .logical()) base R","code":"\nlinelist <- linelist %>% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(.cols = everything(), .fns = as.character))\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\nlinelist <- linelist %>% \n  mutate(across(.cols = where(lubridate::is.POSIXct), .fns = as.Date))"},{"path":"cleaning-data-and-core-functions.html","id":"across-functions","chapter":"1 Cleaning data and core functions","heading":"across() functions","text":"can read documentation ?across details provide functions across(). summary points: several ways specify function(s) perform column can even define functions:can provide function name alone (e.g. mean .character)can provide function purrr-style (e.g. ~ mean(.x, na.rm = TRUE))can specify multiple functions providing list (e.g. list(mean = mean, n_miss = ~ sum(.na(.x))).\r\nprovide multiple functions, multiple transformed columns returned unique names (e.g. col_fn). can adjust new columns named .names = argument using glue syntax (see page [Characters strings]) {.col} {.fn} shorthand column function.\r\nprovide multiple functions, multiple transformed columns returned unique names (e.g. col_fn). can adjust new columns named .names = argument using glue syntax (see page [Characters strings]) {.col} {.fn} shorthand column function.online resources using across(): creator Hadley Wickham’s thoughts/rationale","code":""},{"path":"cleaning-data-and-core-functions.html","id":"coalesce","chapter":"1 Cleaning data and core functions","heading":"coalesce()","text":"dplyr function finds first non-missing value position.Say two vectors/columns, one village detection another village residence. can use coalesce pick first non-missing value index:works provide data frame columns: row, function assign new column value first non-missing value columns provided (order provided).complicated row-wise calculations, see section Row-wise calculations.","code":"\nvillage_detection <- c(\"a\", \"b\", NA,  NA)\nvillage_residence <- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage <- coalesce(village_detection, village_residence)\nvillage    # print## [1] \"a\" \"b\" \"a\" \"d\"\nlinelist <- linelist %>% \n  mutate(village = coalesce(village_detection, village_residence))"},{"path":"cleaning-data-and-core-functions.html","id":"cumulative-math","chapter":"1 Cleaning data and core functions","heading":"Cumulative math","text":"want column reflect cumulative sum/mean/min/max etc assessed rows dataframe, use following functions:cumsum() returns cumulative sum, shown :can used dataframe making new column. example, calculate cumulative number cases per day outbreak, consider code like :first 10 rows:See page [Epidemic curves] plot cumulative incidence epicurve.See also:\r\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()","code":"\nsum(c(2,4,15,10))     # returns only one number## [1] 31\ncumsum(c(2,4,15,10))  # returns the cumulative sum at each step## [1]  2  6 21 31\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>%                 # count of rows per day   \n  mutate(cumulative_cases = cumsum(n))  # new column of the cumulative sum at that row\nhead(cumulative_case_counts, 10)##    date_onset n cumulative_cases\r\n## 1  2012-04-15 1                1\r\n## 2  2012-05-05 1                2\r\n## 3  2012-05-08 1                3\r\n## 4  2012-05-31 1                4\r\n## 5  2012-06-02 1                5\r\n## 6  2012-06-07 1                6\r\n## 7  2012-06-14 1                7\r\n## 8  2012-06-21 1                8\r\n## 9  2012-06-24 1                9\r\n## 10 2012-06-25 1               10"},{"path":"cleaning-data-and-core-functions.html","id":"using-base-r","chapter":"1 Cleaning data and core functions","heading":"Using base R","text":"define new column (re-define column) using base R, write name data frame new column (column modified). Use assignment operator <- define new value(s). Remember using base R must specify data frame name column name every time (e.g. dataframe$column). example creating bmi column using base R:","code":"linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)"},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":", new column added pipe chain classes converted.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    # add new column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% \n  \n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) "},{"path":"cleaning-data-and-core-functions.html","id":"re-code-values","chapter":"1 Cleaning data and core functions","heading":"1.8 Re-code values","text":"scenarios need re-code (change) values:edit one specific value (e.g. one date incorrect year format)reconcile values spelled sameto create new column categoriesto create new column numeric categories (e.g. age categories)","code":""},{"path":"cleaning-data-and-core-functions.html","id":"specific-values","chapter":"1 Cleaning data and core functions","heading":"Specific values","text":"change values manually can use recode() function within mutate() function.Imagine nonsensical date data (e.g. “2014-14-15”): fix date source data, , write change cleaning pipeline via mutate() recode().mutate() line can read : “mutate column date_onset equal column date_onset re-coded OLD VALUE changed NEW VALUE”. Note pattern (OLD = NEW) recode() opposite R patterns (new = old). R development community working revising .another example re-coding multiple values within one column.linelist values column “hospital” must cleaned. several different spellings many missing values.recode() command re-defines column “hospital” current column “hospital”, specified recode changes. Don’t forget commas !Now see spellings hospital column corrected consolidated:TIP: number spaces equals sign matter. Make code easier read aligning = rows. Also, consider adding hashed comment row clarify future readers side OLD side NEW. TIP: Sometimes blank character value exists dataset (recognized R’s value missing - NA). can reference value two quotation marks space inbetween (\"\").","code":"\n# fix incorrect values                   # old value       # new value\nlinelist <- linelist %>% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\ntable(linelist$hospital, useNA = \"always\")## \r\n##                      Central Hopital                     Central Hospital \r\n##                                   11                                  457 \r\n##                           Hospital A                           Hospital B \r\n##                                  290                                  289 \r\n##                     Military Hopital                    Military Hospital \r\n##                                   32                                  798 \r\n##                     Mitylira Hopital                    Mitylira Hospital \r\n##                                    1                                   79 \r\n##                                Other                         Port Hopital \r\n##                                  907                                   48 \r\n##                        Port Hospital St. Mark's Maternity Hospital (SMMH) \r\n##                                 1756                                  417 \r\n##   St. Marks Maternity Hopital (SMMH)                                 <NA> \r\n##                                   11                                 1512\nlinelist <- linelist %>% \n  mutate(hospital = recode(hospital,\n                      #    reference: OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\ntable(linelist$hospital, useNA = \"always\")## \r\n##                     Central Hospital                           Hospital A \r\n##                                  468                                  290 \r\n##                           Hospital B                    Military Hospital \r\n##                                  289                                  910 \r\n##                                Other                        Port Hospital \r\n##                                  907                                 1804 \r\n## St. Mark's Maternity Hospital (SMMH)                                 <NA> \r\n##                                  428                                 1512"},{"path":"cleaning-data-and-core-functions.html","id":"missing-values","chapter":"1 Cleaning data and core functions","heading":"Missing values","text":"See page [Missing data] detailed tips identifying handling missing values. example, .na() function logically tests missingness.dplyr offers two special functions handling missing values context data cleaning:replace_na()change missing values (NA) specific value, “Missing”, use function replace_na() within mutate(). Note used manner recode - name variable must repeated within replace_na().na_if()convert specific value NA, use na_if(). command performs opposite operation replace_na(). example , values “Missing” column hospital converted NA.Note: na_if() used logic criteria (e.g. “values > 99”) - use replace() case_when() :","code":"\nlinelist <- linelist %>% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\nlinelist <- linelist %>% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n# Convert temperatures above 40 to NA \nlinelist <- linelist %>% \n  mutate(temp = replace(temp, temp > 40, NA))\n\n# Convert onset dates earlier than 2000 to missing\nlinelist <- linelist %>% \n  mutate(date_onset = replace(date_onset, date_onset > as.Date(\"2000-01-01\"), NA))"},{"path":"cleaning-data-and-core-functions.html","id":"by-logic","chapter":"1 Cleaning data and core functions","heading":"By logic","text":"demonstrated re-code values column using logic conditions:Using replace(), ifelse() if_else() simple logicUsing case_when() complex logic","code":""},{"path":"cleaning-data-and-core-functions.html","id":"simple-logic","chapter":"1 Cleaning data and core functions","heading":"Simple logic","text":"","code":""},{"path":"cleaning-data-and-core-functions.html","id":"replace","chapter":"1 Cleaning data and core functions","heading":"replace()","text":"re-code simple logical criteria, can use replace() within mutate(). replace() function base R. Use logic condition specify rows change . general syntax :mutate(col_to_change = replace(col_to_change, criteria rows, new value)).One common situation changing just one value one row, using unique row identifier. , gender changed “Female” row column case_id “2195”.equivalent command using base R syntax indexing brackets [ ] . reads “Change value dataframe linelist‘s column gender (rows linelist’s column case_id value ’2195’) ‘Female’”.","code":"# Example: change gender of one specific observation to \"Female\" \r\nlinelist <- linelist %>% \r\n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\")\nlinelist$gender[linelist$case_id == \"2195\"] <- \"Female\""},{"path":"cleaning-data-and-core-functions.html","id":"ifelse-and-if_else","chapter":"1 Cleaning data and core functions","heading":"ifelse() and if_else()","text":"Another tool simple logical re-coding ifelse() partner if_else(). However, cases better use case_when() (clarity).commands simplified versions else programming statement. general syntax :ifelse(condition, value return condition evaluates TRUE, value return condition evaluates FALSE), column source_known defined (re-defined). value given row set “known” row’s value column source missing. value source missing, value source_known set “unknown”.if_else() special version dplyr handles dates. Note ‘true’ value date, ‘false’ value must also qualify date, hence using special character NA_real_ instead just NA.Avoid stringing together many ifelse commands… use case_when() instead! case_when() much easier read ’ll make fewer errors.Outside context data frame, want object used code switch value, consider using switch() base R. See section using switch() page [Interactive console].","code":"\nlinelist <- linelist %>% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n# Create a date of death column, which is NA if patient has not died.\nlinelist <- linelist %>% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))"},{"path":"cleaning-data-and-core-functions.html","id":"complex-logic","chapter":"1 Cleaning data and core functions","heading":"Complex logic","text":"Use dplyr’s case_when() need use complex logic statements re-code values. important differences recode() syntax logic order!case_when() commands Right-Hand Side (RHS) Left-Hand Side (LHS) separated “tilde” ~. logic criteria LHS pursuant value RHS. Statements separated commas. important note :Statements evaluated order written - top--bottom. Thus best write specific criteria first, general last.End TRUE LHS, signifies row value meet previous criteriaThe values RHS must class - either numeric, character, logical, etc.\r\nassign NA, may need use special values NA_character_, NA_real_ (numeric POSIX), .Date(NA)\r\nassign NA, may need use special values NA_character_, NA_real_ (numeric POSIX), .Date(NA)utilize columns age age_unit create column age_years:","code":"\nlinelist <- linelist %>% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # if age is given in years\n            age_unit == \"months\" ~ age/12,    # if age is given in months\n            is.na(age_unit)      ~ age,       # if age unit is missing, assume years\n            TRUE                 ~ NA_real_)) # any other circumstance assign missing"},{"path":"cleaning-data-and-core-functions.html","id":"cleaning-dictionary","chapter":"1 Cleaning data and core functions","heading":"Cleaning dictionary","text":"Use package linelist clean linelist cleaning dictionary.Import cleaning dictionary 3 columns:\r\n“” column (incorrect value)\r\n“” column (correct value)\r\ncolumn specifying column changes applied (“.global” apply columns)\r\n“” column (incorrect value)“” column (correct value)column specifying column changes applied (“.global” apply columns)Store names columns want “protect” changes. must provided clean_data() numeric logical vector, see use names(.) command (dot means dataframe).Run clean_data(), specifying cleaning dictionaryScroll see values changed - particularly gender (lowercase uppercase), symptoms columns transformed yes/1/0.CAUTION: clean_data() linelist package also clean values data unless columns protected - may encounter changes columns dashes “-” .Note column names cleaning dictionary must correspond names point cleaning script. clean_data() also implements column name cleaning function similar clean_names() janitor standardizes column names prior applying dictionary.See online reference linelist package details.","code":"\ncleaning_dict <- import(\"cleaning_dict.csv\")\nprotected_cols <- c(\"case_id\", \"source\")\nlinelist <- linelist %>% \n  linelist::clean_data(\n    wordlists = cleaning_dict,\n    spelling_vars = \"col\",       # dict column containing column names, defaults to 3rd column in dict\n    protect = names(.) %in% protected_cols\n  )"},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain-1","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":", new columns column transformations added pipe chain.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n  \n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n   ###################################################\n\n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))"},{"path":"cleaning-data-and-core-functions.html","id":"num_cats","chapter":"1 Cleaning data and core functions","heading":"1.9 Numeric categories","text":"describe special approaches creating numeric categories. Common examples include age categories, groups lab values, etc. discuss:age_categories(), epikit packagecut(), base Rcase_when()quantile breaks quantile() ntile()","code":""},{"path":"cleaning-data-and-core-functions.html","id":"review-distribution","chapter":"1 Cleaning data and core functions","heading":"Review distribution","text":"example create age_cat column using age_years column.First, examine distribution data, make appropriate cut-points. See page [Plot continuous data].CAUTION: Sometimes, numeric variables import class “character”. occurs non-numeric characters values, example entry “2 months” age, (depending R locale settings) comma used decimals place (e.g. “4,5” mean four one half years)..","code":"\n#check the class of the linelist variable age\nclass(linelist$age_years)## [1] \"numeric\"\n# examine the distribution\nhist(linelist$age_years)\nsummary(linelist$age_years, na.rm=T)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \r\n##    0.00    6.00   13.00   16.04   23.00   84.00     107"},{"path":"cleaning-data-and-core-functions.html","id":"age_categories","chapter":"1 Cleaning data and core functions","heading":"age_categories()","text":"epikit package, can use age_categories() function easily categorize label numeric columns (note: function can applied non-age numeric variables ). note: output ordered factor.required inputs:numeric vector (column)breakers = - numeric vector break points new groupsFirst, simple example:break values specify default included “higher” group - groups “open” lower/left side. shown , can add 1 break value achieve groups open top/right.can adjust labels displayed separator =. default “-”can adjust upper cut-values allowed included group. Use ceiling =, default FALSE. TRUE, highest break value “ceiling” category “XX+” included. values highest break value upper (defined) categorized NA. example ceiling = TRUE, category XX+ values 70 (highest break value) assigned NA.Alternatively, instead breakers =, can provide lower =, upper =, =:lower = lowest number want considered - default 0upper = highest number want consideredby = number years groupsSee function’s Help page details (enter ?age_categories R console).","code":"\n# Simple example\n################\npacman::p_load(epikit)\n\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years,\n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  <NA> \r\n##  1227  1223  1048   827  1216   597   251    78    27     7   107\n# Include upper ends for the same categories\n############################################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  <NA> \r\n##  1469  1195  1040   770  1149   547   231    70    24     6   107\n# With ceiling set to TRUE\n##########################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 is ceiling, all above become NA\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  <NA> \r\n##  1227  1223  1048   827  1216   597   251    78    28   113\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  <NA> \r\n##  2450  1875  1216   597   251    78    27     6     1     0     0   107"},{"path":"cleaning-data-and-core-functions.html","id":"cut","chapter":"1 Cleaning data and core functions","heading":"cut()","text":"can also use base R function cut(), creates categories numeric column. differences age_categories() :need install/load another packageYou can specify whether groups open/closed right/leftYou must provide accurate labels yourselfIf want 0 included lowest group must specify thisThe basic syntax within cut() first provide numeric variable cut (age_years), breaks argument, numeric vector (c()) break points. Using cut(), resulting column ordered factor. used within mutate() (dplyr verb) necessary specify dataframe column name (e.g. linelist$age_years).Create new column age categories (age_cat) cutting numeric age_year column specified break points.Specify numeric vector break pointsDefault behavior cut() lower break values excluded category, upper break values included. opposite behavior age_categories() function.Include 0 lowest category adding include.lowest = TRUEAdd vector customized labels using labels = argumentCheck work cross-tabulation numeric category columns - aware missing valuesBelow detailed description behavior using cut() make age_cat column. Key points:Inclusion/exclusion behavior break pointsCustom category labelsHandling missing valuesCheck work!simple example cut() applied age_years make new variable age_cat :default, categorization occurs right/upper side “open” inclusive (left/lower side “closed” exclusive). default labels use notation “(, B]”, means group include (lower break value), includes B (upper break value). Reverse behavior providing right = TRUE argument.default, categorization occurs right/upper side “open” inclusive (left/lower side “closed” exclusive). default labels use notation “(, B]”, means group include (lower break value), includes B (upper break value). Reverse behavior providing right = TRUE argument.Thus, default “0” values excluded lowest group, categorized NA. “0” values infants coded age 0. change add argument include.lowest = TRUE. , “0” values included lowest group. automatically-generated label lowest category change “(0,B]” “[0,B]”, signifies 0 values included.Thus, default “0” values excluded lowest group, categorized NA. “0” values infants coded age 0. change add argument include.lowest = TRUE. , “0” values included lowest group. automatically-generated label lowest category change “(0,B]” “[0,B]”, signifies 0 values included.Check work!!! Verify age value assigned correct category cross-tabulating numeric category columns. Examine assignment boundary values (e.g. 15, neighboring categories 10-15 15-20).Check work!!! Verify age value assigned correct category cross-tabulating numeric category columns. Examine assignment boundary values (e.g. 15, neighboring categories 10-15 15-20).Reverse break inclusion behavior cut()Lower break values included category (upper break values excluded) argument right = included set TRUE. applied - note values shifted among categories.NOTE: include include.lowest = TRUE argument right = TRUE, extreme inclusion now apply highest break point value category, lowest.Add labelsAs manually written, careful ensure accurate! Check work using cross-tabulation, described . code , manual labels added.Re-labeling NA values cut()cut() automatically label NA values, may want assign label “Missing”. requires extra steps cut() automatically classified new column age_cat class Factor (rigid class limited defined values).First, convert age_cut Factor Character class, flexibility add new character values (e.g. “Missing”). Otherwise encounter error. , use dplyr verb replace_na() replace NA values character value like “Missing”. steps can combined one step, shown .Note Missing added, order categories now wrong (alphabetical considering numbers characters).fix , re-convert age_cat factor, define order levels correctly.seems cumbersome, consider using age_categories() instead, described .Make breaks labelsFor fast way make breaks labels manually, use something like . See [R basics] page references seq() rep().Read cut() Help page entering ?cut R console.","code":"\n# Create new variable, by cutting the numeric age variable\n# by default, upper break is excluded and lower break excluded from each category\nlinelist <- linelist %>% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # include 0 in lowest group\n      ))\n\n# tabulate the number of observations per group\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100]     <NA> \r\n##     1469     1195     1040      770     1149      778       94        6      107\n# Cross tabulation of the numeric and category columns. \ntable(\"Numeric Values\" = linelist$age_years,   # names specified in table for clarity.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # don't forget to examine NA values##                     Categories\r\n## Numeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] (70,100] <NA>\r\n##   0                    136      0       0       0       0       0       0        0    0\r\n##   0.0833333333333333     1      0       0       0       0       0       0        0    0\r\n##   0.25                   2      0       0       0       0       0       0        0    0\r\n##   0.333333333333333      6      0       0       0       0       0       0        0    0\r\n##   0.416666666666667      1      0       0       0       0       0       0        0    0\r\n##   0.5                    6      0       0       0       0       0       0        0    0\r\n##   0.583333333333333      3      0       0       0       0       0       0        0    0\r\n##   0.666666666666667      3      0       0       0       0       0       0        0    0\r\n##   0.75                   3      0       0       0       0       0       0        0    0\r\n##   0.833333333333333      1      0       0       0       0       0       0        0    0\r\n##   0.916666666666667      1      0       0       0       0       0       0        0    0\r\n##   1                    275      0       0       0       0       0       0        0    0\r\n##   1.5                    2      0       0       0       0       0       0        0    0\r\n##   2                    308      0       0       0       0       0       0        0    0\r\n##   3                    246      0       0       0       0       0       0        0    0\r\n##   4                    233      0       0       0       0       0       0        0    0\r\n##   5                    242      0       0       0       0       0       0        0    0\r\n##   6                      0    241       0       0       0       0       0        0    0\r\n##   7                      0    256       0       0       0       0       0        0    0\r\n##   8                      0    239       0       0       0       0       0        0    0\r\n##   9                      0    245       0       0       0       0       0        0    0\r\n##   10                     0    214       0       0       0       0       0        0    0\r\n##   11                     0      0     220       0       0       0       0        0    0\r\n##   12                     0      0     224       0       0       0       0        0    0\r\n##   13                     0      0     191       0       0       0       0        0    0\r\n##   14                     0      0     199       0       0       0       0        0    0\r\n##   15                     0      0     206       0       0       0       0        0    0\r\n##   16                     0      0       0     186       0       0       0        0    0\r\n##   17                     0      0       0     164       0       0       0        0    0\r\n##   18                     0      0       0     141       0       0       0        0    0\r\n##   19                     0      0       0     130       0       0       0        0    0\r\n##   20                     0      0       0     149       0       0       0        0    0\r\n##   21                     0      0       0       0     158       0       0        0    0\r\n##   22                     0      0       0       0     149       0       0        0    0\r\n##   23                     0      0       0       0     125       0       0        0    0\r\n##   24                     0      0       0       0     144       0       0        0    0\r\n##   25                     0      0       0       0     107       0       0        0    0\r\n##   26                     0      0       0       0     100       0       0        0    0\r\n##   27                     0      0       0       0     117       0       0        0    0\r\n##   28                     0      0       0       0      85       0       0        0    0\r\n##   29                     0      0       0       0      82       0       0        0    0\r\n##   30                     0      0       0       0      82       0       0        0    0\r\n##   31                     0      0       0       0       0      68       0        0    0\r\n##   32                     0      0       0       0       0      84       0        0    0\r\n##   33                     0      0       0       0       0      78       0        0    0\r\n##   34                     0      0       0       0       0      58       0        0    0\r\n##   35                     0      0       0       0       0      58       0        0    0\r\n##   36                     0      0       0       0       0      33       0        0    0\r\n##   37                     0      0       0       0       0      46       0        0    0\r\n##   38                     0      0       0       0       0      45       0        0    0\r\n##   39                     0      0       0       0       0      45       0        0    0\r\n##   40                     0      0       0       0       0      32       0        0    0\r\n##   41                     0      0       0       0       0      34       0        0    0\r\n##   42                     0      0       0       0       0      26       0        0    0\r\n##   43                     0      0       0       0       0      31       0        0    0\r\n##   44                     0      0       0       0       0      24       0        0    0\r\n##   45                     0      0       0       0       0      27       0        0    0\r\n##   46                     0      0       0       0       0      25       0        0    0\r\n##   47                     0      0       0       0       0      16       0        0    0\r\n##   48                     0      0       0       0       0      21       0        0    0\r\n##   49                     0      0       0       0       0      15       0        0    0\r\n##   50                     0      0       0       0       0      12       0        0    0\r\n##   51                     0      0       0       0       0       0      13        0    0\r\n##   52                     0      0       0       0       0       0       7        0    0\r\n##   53                     0      0       0       0       0       0       4        0    0\r\n##   54                     0      0       0       0       0       0       6        0    0\r\n##   55                     0      0       0       0       0       0       9        0    0\r\n##   56                     0      0       0       0       0       0       7        0    0\r\n##   57                     0      0       0       0       0       0       9        0    0\r\n##   58                     0      0       0       0       0       0       6        0    0\r\n##   59                     0      0       0       0       0       0       5        0    0\r\n##   60                     0      0       0       0       0       0       4        0    0\r\n##   61                     0      0       0       0       0       0       2        0    0\r\n##   62                     0      0       0       0       0       0       1        0    0\r\n##   63                     0      0       0       0       0       0       5        0    0\r\n##   64                     0      0       0       0       0       0       1        0    0\r\n##   65                     0      0       0       0       0       0       5        0    0\r\n##   66                     0      0       0       0       0       0       3        0    0\r\n##   67                     0      0       0       0       0       0       2        0    0\r\n##   68                     0      0       0       0       0       0       1        0    0\r\n##   69                     0      0       0       0       0       0       3        0    0\r\n##   70                     0      0       0       0       0       0       1        0    0\r\n##   72                     0      0       0       0       0       0       0        1    0\r\n##   73                     0      0       0       0       0       0       0        3    0\r\n##   76                     0      0       0       0       0       0       0        1    0\r\n##   84                     0      0       0       0       0       0       0        1    0\r\n##   <NA>                   0      0       0       0       0       0       0        0  107\nlinelist <- linelist %>% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),  # same breaks as above\n      right = FALSE,                # include each *lower* break point\n      include.lowest = TRUE         # include *highest* value *highest* group\n      ))                                                 \n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    [0,5)   [5,10)  [10,15)  [15,20)  [20,30)  [30,50)  [50,70) [70,100]     <NA> \r\n##     1227     1223     1048      827     1216      848      105        7      107\nlinelist <- linelist %>% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),  # same breaks as above\n      right = FALSE,                # include each *lower* break point\n      include.lowest = TRUE,        # include *highest* value *highest* group\n      labels = c(\"0-4\", \"5-9\", \"10-14\",\n                 \"15-19\", \"20-29\", \"30-49\",\n                 \"50-69\", \"70-100\")\n      ))\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    0-4    5-9  10-14  15-19  20-29  30-49  50-69 70-100   <NA> \r\n##   1227   1223   1048    827   1216    848    105      7    107\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n                          right = FALSE,\n                          include.lowest = TRUE,        \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n         # convert to class Character, and replace NA with \"Missing\"\n         age_cat = replace_na(as.character(age_cat), \"Missing\"))\n\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##     0-4   10-14   15-19   20-29   30-49     5-9   50-69  70-100 Missing    <NA> \r\n##    1227    1048     827    1216     848    1223     105       7     107       0\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n                          right = FALSE,\n                          include.lowest = TRUE,        \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n         # convert to class Character, and replace NA with \"Missing\"\n         age_cat = replace_na(as.character(age_cat), \"Missing\"),\n         \n         # re-classify age_cat as Factor, with correct level order and new \"Missing\" level\n         age_cat = factor(age_cat, levels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\",\n                                              \"30-49\", \"50-69\", \"70-100\", \"Missing\")))    \n  \n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##     0-4     5-9   10-14   15-19   20-29   30-49   50-69  70-100 Missing    <NA> \r\n##    1227    1223    1048     827    1216     848     105       7     107       0\n# Make break points from 0 to 90 by 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Make labels for the above categories, assuming default cut() settings\nage_labels = paste0(age_seq+1, \"-\", age_seq + 5)\nage_labels\n\n# check that both vectors are the same length\nlength(age_seq) == length(age_labels)"},{"path":"cleaning-data-and-core-functions.html","id":"quantile-breaks","chapter":"1 Cleaning data and core functions","heading":"Quantile breaks","text":"common understanding, “quantiles” “percentiles” typically refer value proportion values fall. example, 95th percentile ages linelist age 95% age fall.However common speech, “quartiles” “deciles” can also refer groups data equally divided 4, 10 groups (note one break point group).get quantile break points, can use quantile() stats package base R. provide numeric vector (e.g. column dataset) vector numeric probability values ranging 0 1.0. break points returned numeric vector. Explore details statistical methodologies entering ?quantile.input numeric vector missing values best set na.rm = TRUESet names = FALSE get un-named numeric vectorYou can use results quantile() break points age_categories() cut(). create new column deciles using cut() breaks defined using quantiles() age_years. , display results using tabyl() janitor can see percentages (see [Descriptive tables] page). Note exactly 10% group.can use dplyr function ntile() break data n groups. Provide vector number groups. Note new column deciles created contains just group “numbers” 1 10, range values using quantile().","code":"\nquantile(linelist$age_years,               # specify numeric vector to work on\n  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want\n  na.rm = TRUE)                            # ignore missing values ##  0% 25% 50% 75% 90% 95% \r\n##   0   6  13  23  33  41\nlinelist %>%                                # begin with linelist\n  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years\n    breaks = quantile(                      # define cut breaks using quantile()\n      age_years,                               # operate on age_years\n      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1\n      na.rm = TRUE),                           # ignore missing values\n    include.lowest = TRUE)) %>%             # for cut() include age 0\n  janitor::tabyl(deciles)                   # pipe to table to display##  deciles   n    percent valid_percent\r\n##    [0,2] 748 0.11319613    0.11505922\r\n##    (2,5] 721 0.10911017    0.11090601\r\n##    (5,7] 497 0.07521186    0.07644978\r\n##   (7,10] 698 0.10562954    0.10736810\r\n##  (10,13] 635 0.09609564    0.09767728\r\n##  (13,17] 755 0.11425545    0.11613598\r\n##  (17,21] 578 0.08746973    0.08890940\r\n##  (21,26] 625 0.09458232    0.09613906\r\n##  (26,33] 596 0.09019370    0.09167820\r\n##  (33,84] 648 0.09806295    0.09967697\r\n##     <NA> 107 0.01619249            NA\nlinelist %>% \n  mutate(deciles = ntile(age_years, 10)) %>% \n  janitor::tabyl(deciles)##  deciles   n    percent valid_percent\r\n##        1 651 0.09851695    0.10013844\r\n##        2 650 0.09836562    0.09998462\r\n##        3 650 0.09836562    0.09998462\r\n##        4 650 0.09836562    0.09998462\r\n##        5 650 0.09836562    0.09998462\r\n##        6 650 0.09836562    0.09998462\r\n##        7 650 0.09836562    0.09998462\r\n##        8 650 0.09836562    0.09998462\r\n##        9 650 0.09836562    0.09998462\r\n##       10 650 0.09836562    0.09998462\r\n##       NA 107 0.01619249            NA"},{"path":"cleaning-data-and-core-functions.html","id":"case_when","chapter":"1 Cleaning data and core functions","heading":"case_when()","text":"dplyr function case_when() can also used create numeric categories.Allows explicit setting break point inclusion/exclusionAllows designation label NA values one stepMore complicated codeAllow flexibility include variables logicIf using case_when() please review proper use described earlier page, logic order assignment important understand avoid errors.CAUTION: case_when() right-hand side values must class. Thus, categories character values (e.g. “20-30 years”) designated outcome NA age values must also character (either “Missing”, special NA_character_ instead NA).need designate column factor (wrapping case_when() function factor()) provide ordering factor levels using levels = argument close case_when() function. using cut(), factor ordering levels done automatically.now view results table new column:","code":"\nlinelist <- linelist %>% \n  mutate(\n    age_cat = factor(case_when(\n      # provide the case_when logic and outcomes\n      age_years >= 0 & age_years < 5     ~ \"0-4\",          \n      age_years >= 5 & age_years < 10    ~ \"5-9\",\n      age_years >= 10 & age_years < 15   ~ \"10-14\",\n      age_years >= 15 & age_years < 20   ~ \"15-19\",\n      age_years >= 20 & age_years < 30   ~ \"20-29\",\n      age_years >= 30 & age_years < 50   ~ \"30-49\",\n      age_years >= 50 & age_years < 70   ~ \"50-69\",\n      age_years >= 45 & age_years <= 100 ~ \"70-100\",\n      is.na(age_years)                   ~ \"Missing\",      # if age_years is missing\n      TRUE                               ~ \"Check value\"), # trigger for review\n      \n      # define the levels order for factor()\n      levels = c(\"0-4\",\"5-9\", \"10-14\",\n                 \"15-19\", \"20-29\", \"30-49\",\n                 \"50-69\", \"70-100\", \"Missing\", \"Check value\")))\ntable(linelist$age_cat, useNA = \"always\")## \r\n##         0-4         5-9       10-14       15-19       20-29       30-49       50-69      70-100     Missing \r\n##        1227        1223        1048         827        1216         848         105           7         107 \r\n## Check value        <NA> \r\n##           0           0"},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain-2","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":", code create two categorical age columns added cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################   \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))"},{"path":"cleaning-data-and-core-functions.html","id":"add-rows","chapter":"1 Cleaning data and core functions","heading":"1.10 Add rows","text":"Remember column must contain values one class (either character, numeric, logical, etc.). adding row requires nuance maintain .Use ... place row want add. .= 3 put new row 3rd row. default behavior add row end. Columns specified left empty.new row number may look strange (“…23”) row numbers pre-existing rows changed. using command twice, examine/test insertion carefully.class provide see error like :(inserting row date value, remember wrap date function .Date() like .Date(\"2020-10-10\")).","code":"\nlinelist <- linelist %>% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)Error: Can't combine ..1$infection date <date> and ..2$infection date <character>."},{"path":"cleaning-data-and-core-functions.html","id":"filter-rows","chapter":"1 Cleaning data and core functions","heading":"1.11 Filter rows","text":"typical early cleaning step filter dataframe specific rows using dplyr verb filter(). Within filter(), give logic must TRUE row dataset kept.shown filter rows based simple complex logical conditions, filter/subset rows stand-alone command base R","code":""},{"path":"cleaning-data-and-core-functions.html","id":"simple-filter","chapter":"1 Cleaning data and core functions","heading":"Simple filter()","text":"simple example re-defines dataframe linelist , filtered rows meet logical condition. rows logical statement within parentheses TRUE kept.case, logical statement !.na(case_id), asking whether value column case_id missing (NA). Thus, rows case_id missing kept.filter applied, number rows linelist 6608.filter applied, number rows linelist 6473.","code":"\nlinelist <- linelist %>% \n  filter(!is.na(case_id))  # keep only rows where case_id is not missing"},{"path":"cleaning-data-and-core-functions.html","id":"filter-by-row-number","chapter":"1 Cleaning data and core functions","heading":"Filter by row number","text":"data frame tibble, row usually “row number” (seen R Viewer) appears left first column. true column data, can used filter statement.filter based “row number”, can use dplyr function row_number() open parentheses part logical filtering statement. Often use %% operator range numbers part logical statement, shown . see first N rows, can also use special dplyr function head().can also convert row numbers true column piping data frame tibble function rownames_to_column() (put anything parentheses).","code":"\n# View first 100 rows\nlinelist %>% head(100)\n\n# Show row 5 only\nlinelist %>% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns\nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)"},{"path":"cleaning-data-and-core-functions.html","id":"complex-filter","chapter":"1 Cleaning data and core functions","heading":"Complex filter()","text":"complex example using filter():","code":""},{"path":"cleaning-data-and-core-functions.html","id":"examine-the-data","chapter":"1 Cleaning data and core functions","heading":"Examine the data","text":"simple one-line command create histogram onset dates. See second smaller outbreak 2012-2013 also included raw dataset. analyses, want remove entries earlier outbreak.","code":"\nhist(linelist$date_onset, breaks = 50)"},{"path":"cleaning-data-and-core-functions.html","id":"how-filters-handle-missing-numeric-and-date-values","chapter":"1 Cleaning data and core functions","heading":"How filters handle missing numeric and date values","text":"Can just filter date_onset rows June 2013? Caution! Applying code filter(date_onset > .Date(\"2013-06-01\"))) remove rows later epidemic missing date onset!DANGER: Filtering greater (>) less (<) date number can remove rows missing values (NA)! NA treated infinitely large small.(See page [Working dates] information working dates package lubridate)","code":""},{"path":"cleaning-data-and-core-functions.html","id":"design-the-filter","chapter":"1 Cleaning data and core functions","heading":"Design the filter","text":"Examine cross-tabulation make sure exclude correct rows:criteria can filter remove first outbreak (2012 & 2013) dataset? see :first epidemic 2012 & 2013 occurred Hospital , Hospital B, also 10 cases Port Hospital.Hospitals & B cases second epidemic, Port Hospital .want exclude:585 rows onset 2012 2013 either hospital , B, Port:\r\nExclude 559 rows onset 2012 2013\r\nExclude 26 rows Hospitals & B missing onset dates\r\nexclude 256 rows missing onset dates.\r\nExclude 559 rows onset 2012 2013Exclude 26 rows Hospitals & B missing onset datesDo exclude 256 rows missing onset dates.start linelist nrow(linelist). filter statement:re-make cross-tabulation, see Hospitals & B removed completely, 10 Port Hospital cases 2012 & 2013 removed, values - just wanted.Multiple statements can included within one filter command (separated commas), can always pipe separate filter() command clarity.Note: readers may notice easier just filter date_hospitalisation 100% complete missing values. true. date_onset used purposes demonstrating complex filter.","code":"\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2012 2013 2014 2015 <NA>\r\n##   Central Hospital                        0    0  342   94   18\r\n##   Hospital A                            229   46    0    0   13\r\n##   Hospital B                            227   47    0    0   13\r\n##   Military Hospital                       0    0  666  196   34\r\n##   Missing                                 0    0 1090  308   71\r\n##   Other                                   0    0  668  172   45\r\n##   Port Hospital                           9    1 1348  339   75\r\n##   St. Mark's Maternity Hospital (SMMH)    0    0  318   91   13\r\n##   <NA>                                    0    0    0    0    0\nlinelist <- linelist %>% \n  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B\n  filter(date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)## [1] 5888\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2014 2015 <NA>\r\n##   Central Hospital                      342   94   18\r\n##   Military Hospital                     666  196   34\r\n##   Missing                              1090  308   71\r\n##   Other                                 668  172   45\r\n##   Port Hospital                        1348  339   75\r\n##   St. Mark's Maternity Hospital (SMMH)  318   91   13\r\n##   <NA>                                    0    0    0"},{"path":"cleaning-data-and-core-functions.html","id":"standalone-1","chapter":"1 Cleaning data and core functions","heading":"Standalone","text":"Filtering can also done stand-alone command (part pipe chain). Like dplyr verbs, case first argument must dataset .can also use base R subset using square brackets reflect [rows, columns] want retain.TIP: Use bracket-subset syntax View() quickly review records.","code":"\n# dataframe <- filter(dataframe, condition(s) for rows to keep)\n\nlinelist <- filter(linelist, !is.na(case_id))\n# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist <- linelist[!is.na(case_id), ]"},{"path":"cleaning-data-and-core-functions.html","id":"quickly-review-records","chapter":"1 Cleaning data and core functions","heading":"Quickly review records","text":"base R syntax can handy want quickly view subset rows columns. Use base R View() command (note capital “V”) around [ ] subset want see. result appear dataframe RStudio viewer panel. example, want review onset hospitalization dates 3 specific cases:View linelist viewer panel:View specific data three cases:Note: command can also written dplyr verbs filter() select() :","code":"\nView(linelist)\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\nView(linelist %>%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %>%\n       select(date_onset, date_hospitalisation))"},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain-3","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":"","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))"},{"path":"cleaning-data-and-core-functions.html","id":"row-wise-calculations","chapter":"1 Cleaning data and core functions","heading":"1.12 Row-wise calculations","text":"want perform calculation within row, can use rowwise() dplyr. See vignette row-wise calculations.rowwise() essentially special kind group_by(), best use ungroup() done.example, code applies rowwise() creates new column sums number specified symptom columns value “yes”, row linelist. columns name within normal vector c().specify columns, may want use “tidyselect” helper functions described select() section page. just make one adjustment (using within select() summarise()).Put column-specification criteria within dplyr function c_across(). c_across (documentation) designed work rowwise() specifically. example, following code:Applies rowwise() following operation (sum()) applied within row (summing entire columns)Creates new column num_NA_dates, defined row number columns (name containing “date”) .na() evaluated TRUE (missing data).ungroup() remove effects rowwise() subsequent stepsYou also provide functions, max() get latest recent date row:","code":"\nlinelist %>%\n  rowwise() %>%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %>% \n  ungroup() %>% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # for display\nlinelist %>%\n  rowwise() %>%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %>% \n  ungroup() %>% \n  select(num_NA_dates, contains(\"date\")) # for display\nlinelist %>%\n  rowwise() %>%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %>% \n  ungroup() %>% \n  select(latest_date, contains(\"date\"))  # for display## # A tibble: 5,888 x 5\r\n##    latest_date date_infection date_onset date_hospitalisation date_outcome\r\n##    <date>      <date>         <date>     <date>               <date>      \r\n##  1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \r\n##  2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \r\n##  3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \r\n##  4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \r\n##  5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \r\n##  6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \r\n##  7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \r\n##  8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \r\n##  9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \r\n## 10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \r\n## # ... with 5,878 more rows## [1] \"2014-04-17\"## [1] \"2014-04-19\""}]
