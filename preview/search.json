[{"path":"index.html","id":"section","chapter":"","heading":"","text":"DRAFT. REVIEWERS GIVE FEEDBACK LINK.LIKE HANDBOOK? SOMETHING CHANGED? PLEASE TELL US!","code":""},{"path":"index.html","id":"r-for-applied-epi-and-public-health","chapter":"","heading":"R for applied ‘epi’ and public health","text":"handbook strives :Serve quick R code reference manualProvide task-centered examples addressing common epidemiologic problemsAssist epidemiologists transitioning R SAS, STATA, SPSS, ExcelBe accessible settings low internet-connectivity via offline version ([instructions ][Download handbook data])different R books?community-driven - written epidemiologists epidemiologists spare time leveraging experience local, national, academic, emergency settingsIt uses practical epi examples - cleaning case linelists, making transmission chains epidemic curves, automated reports dashboards, modeling incidence making projections, demographic pyramids rate standardization, record matching, outbreak detection, survey analysis, survival analysis, GIS basics, contact tracing, phylogenetic trees…","code":""},{"path":"index.html","id":"how-to-read-this-handbook","chapter":"","heading":"How to read this handbook","text":"Online versionSearch via search box Table ContentsClick “copy” icons copy codeSee “Resources” section page resources“Follow-along” [downloading example data][Download handbook data]Adjust font size browser zoom settingsOffline versionSee instructions download offline version handbook [Download book data] page.LanguagesWe seeking translate book languages English. can help, please contact us.","code":""},{"path":"index.html","id":"contact_us","chapter":"","heading":"Contact us","text":"Structured feedback formEmail us epiRhandbook@gmail.comSubmit issues pull requests Github repositoryTwitter handle @epiRhandbook","code":""},{"path":"index.html","id":"acknowledgements","chapter":"","heading":"Acknowledgements","text":"handbook produced collaboration epidemiologists around world spare time, drawing upon experiences organizations including local, state/provincial, national health agencies, World Health Organization (), MSF (Médecins Sans Frontières / Doctors without Borders), hospital systems, academic institutions.handbook approved product specific organization. Although strive accuracy, provide guarantee content book.","code":""},{"path":"index.html","id":"contributors","chapter":"","heading":"Contributors","text":"Editor--Chief: Neale BatraProject core team: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuthors: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinReviewers: Pat Keating, Mathilde Mousset, Annick Lenglet, Margot Charette, Isha Berry, Paula Blomquist, Natalie Fischer, Daniely Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Daniel Molling, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Wayne Enanoria, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Manual Albela Miranda, Molly Mantus, Priscilla Spencer, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIllustrations: Calder Fong","code":""},{"path":"index.html","id":"funding-and-support","chapter":"","heading":"Funding and support","text":"publication received supportive funding via COVID-19 emergency capacity-building grant Training Programs Epidemiology Public Health Interventions Network (TEPHINET). publication supported Cooperative Agreement number NU2GGH001873, funded Centers Disease Control Prevention TEPHINET, program Task Force Global Health. contents solely responsibility authors necessarily represent official views Centers Disease Control Prevention, Department Health Human Services, Task Force Global Health, Inc. TEPHINET.Administrative support provided EPIET Alumni Network (EAN), special thanks Annika Wendland. EPIET European Programme Intervention Epidemiology Training.","code":""},{"path":"index.html","id":"inspiration","chapter":"","heading":"Inspiration","text":"multitude tutorials vignettes provided knowledge development handbook content credited within respective pages.generally, following sources provided inspiration handbook:“R4Epis” project (collaboration MSF RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"terms-of-use-and-license","chapter":"","heading":"Terms of Use and License","text":"work licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Universities academic courses welcome use handbook students. questions intended use, email epirhandbook@gmail.com.Contributor code","code":""},{"path":"cleaning-data-and-core-functions.html","id":"cleaning-data-and-core-functions","chapter":"1 Cleaning data and core functions","heading":"1 Cleaning data and core functions","text":"page demonstrates common steps used process “cleaning” dataset, also explains use many essential R data management functions.demonstrate data cleaning, page begins importing raw case linelist dataset, proceeds step--step cleaning process. R code, manifests “pipe” chain, references “pipe” operator %>% passes dataset one operation next.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"core-functions","chapter":"1 Cleaning data and core functions","heading":"Core functions","text":"handbook emphasizes use functions tidyverse family R packages. essential R functions demonstrated page listed .Many functions belong dplyr R package, provides “verb” functions solve data manipulation challenges (name reference \"data frame-plier. dplyr part tidyverse family R packages (also includes ggplot2, tidyr, stringr, tibble, purrr, magrittr, forcats among others).want see functions compare Stata SAS commands, see page [Transition R].may encounter alternative data management framework data.table R package operators like := frequent use brackets [ ]. approach syntax briefly explained [Data Table] page.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"nomenclature","chapter":"1 Cleaning data and core functions","heading":"Nomenclature","text":"handbook, generally reference “columns” “rows” instead “variables” “observations”. explained primer “tidy data”, epidemiological statistical datasets consist structurally rows, columns, values.Variables contain values measure underlying attribute (like age group, outcome, date onset). Observations contain values measured unit (e.g. person, site, lab sample). aspects can difficult tangibly define.“tidy” datasets, column variable, row observation, cell single value. However datasets encounter fit mold - “wide” format dataset may variable split across several columns (see example [Pivoting data] page). Likewise, observations split across several rows.handbook managing transforming data, referring concrete data structures rows columns relevant abstract observations variables. Exceptions occur primarily pages data analysis, see references variables observations.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"cleaning-pipeline","chapter":"1 Cleaning data and core functions","heading":"1.1 Cleaning pipeline","text":"page proceeds typical cleaning steps, adding sequentially cleaning pipe chain.epidemiological analysis data processing, cleaning steps often performed sequentially, linked together. R, often manifests cleaning “pipeline”, raw dataset passed “piped” one cleaning step another.chains utilize dplyr “verb” functions magrittr pipe operator %>%. pipe begins “raw” data (“linelist_raw.xlsx”) ends “clean” R data frame (linelist) can used, saved, exported, etc.cleaning pipeline order steps important. Cleaning steps might include:Importing dataColumn names cleaned changedDe-duplicationColumn creation transformation (e.g. re-coding standardising values)Rows filtered added","code":""},{"path":"cleaning-data-and-core-functions.html","id":"load-packages","chapter":"1 Cleaning data and core functions","heading":"1.2 Load packages","text":"code chunk shows loading packages required analyses. handbook emphasize p_load() pacman, installs package necessary loads use. can also load installed packages library() base R. See page [R basics] information R packages.","code":"\npacman::p_load(\n  rio,        # importing data  \n  here,       # relative file pathways  \n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # age_categories() function\n  tidyverse   # data management and visualization\n)"},{"path":"cleaning-data-and-core-functions.html","id":"import-data","chapter":"1 Cleaning data and core functions","heading":"1.3 Import data","text":"","code":""},{"path":"cleaning-data-and-core-functions.html","id":"import","chapter":"1 Cleaning data and core functions","heading":"Import","text":"import “raw” case linelist Excel file using import() function package rio. rio package flexibly handles many types files (e.g. .xlsx, .csv, .tsv, .rds. See page [Import export] information tips unusual situations (e.g. skipping rows, setting missing values, importing Google sheets, etc).want follow along, click download “raw” linelist (.xlsx file).dataset large takes long time import, can useful import command separate pipe chain “raw” saved distinct file. also allows easy comparison original cleaned versions.import raw Excel file save data frame linelist_raw. assume file located working directory R project root, sub-folders specified file path.can view first 50 rows data frame . Note: base R function head(n) allow view just first n rows R console.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\")"},{"path":"cleaning-data-and-core-functions.html","id":"review","chapter":"1 Cleaning data and core functions","heading":"Review","text":"can use function skim() package skimr get overview entire dataframe (see page Descriptive tables info). Columns summarised class/type character, numeric. Note: “POSIXct” type raw date class (see [Working dates].\r\nTable 1.1: Data summary\r\nVariable type: characterVariable type: numericVariable type: POSIXct","code":"\nskimr::skim(linelist_raw)"},{"path":"cleaning-data-and-core-functions.html","id":"column-names","chapter":"1 Cleaning data and core functions","heading":"1.4 Column names","text":"R, column names “header” “top” value column. used refer columns code, serve default label figures.statistical software SAS STATA use “labels” co-exist longer printed versions shorter column names. R offer possibility adding column labels data, emphasized practice. make column names “printer-friendly” figures, one typically adjusts display within commands create outputs (e.g. axis legend titles plot, column headers printed table - see [ggplot tips] [Tables presentation] pages). want assign column labels data, read online .R column names used often, must “clean” syntax. suggest following:Short namesNo spaces (replace underscores _ )unusual characters (&, #, <, >, …)Similar style nomenclature (e.g. date columns named like date_onset, date_report, date_death…)columns names linelist_raw printed using names() base R. can see initially:names contain spaces (e.g. infection date)Different naming patterns used dates (date onset vs. infection date)must merged header across two last columns .xlsx. know name two merged columns (“merged_header”) assigned R first column, second column assigned placeholder name “…28” (empty 28th column).NOTE: reference column name includes spaces, surround name back-ticks, example: linelist$`infection date`. note keyboard, back-tick (`) different single quotation mark (’).","code":"\nnames(linelist_raw)##  [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"      \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"          \"hospital\"       \r\n## [10] \"lon\"             \"lat\"             \"infector\"        \"source\"          \"age\"             \"age_unit\"        \"row_num\"         \"wt_kg\"           \"ht_cm\"          \r\n## [19] \"ct_blood\"        \"fever\"           \"chills\"          \"cough\"           \"aches\"           \"vomit\"           \"temp\"            \"time_admission\"  \"merged_header\"  \r\n## [28] \"...28\""},{"path":"cleaning-data-and-core-functions.html","id":"labels","chapter":"1 Cleaning data and core functions","heading":"Labels","text":"statistical software SAS variable labels","code":""},{"path":"cleaning-data-and-core-functions.html","id":"automatic-cleaning","chapter":"1 Cleaning data and core functions","heading":"Automatic cleaning","text":"function clean_names() package janitor standardizes column names makes unique following:Converts names consist underscores, numbers, lettersAccented characters transliterated ASCII (e.g. german o umlaut becomes “o”, spanish “enye” becomes “n”)Capitalization preference new column names can specified using case = argument (“snake” default, alternatives include “sentence”, “title”, “small_camel”…)can specify specific name replacements providing vector replace = argument (e.g. replace = c(onset = \"date_of_onset\"))online vignetteBelow, cleaning pipeline begins using clean_names() raw linelist.NOTE: last column name “…28” changed “x28”.","code":"\n# pipe the raw dataset through the function clean_names(), assign result as \"linelist\"  \nlinelist <- linelist_raw %>% \n  janitor::clean_names()\n\n# see the new column names\nnames(linelist)##  [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"      \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"          \"hospital\"       \r\n## [10] \"lon\"             \"lat\"             \"infector\"        \"source\"          \"age\"             \"age_unit\"        \"row_num\"         \"wt_kg\"           \"ht_cm\"          \r\n## [19] \"ct_blood\"        \"fever\"           \"chills\"          \"cough\"           \"aches\"           \"vomit\"           \"temp\"            \"time_admission\"  \"merged_header\"  \r\n## [28] \"x28\""},{"path":"cleaning-data-and-core-functions.html","id":"manual-name-cleaning","chapter":"1 Cleaning data and core functions","heading":"Manual name cleaning","text":"Re-naming columns manually often necessary, even standardization step . , re-naming performed using rename() function dplyr package, part pipe chain. rename() uses style NEW = OLD - new column name given old column name., re-naming command added cleaning pipeline. Spaces added strategically align code easier reading.Now can see columns names changed:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \r\n##  [8] \"gender\"               \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \r\n## [15] \"age_unit\"             \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"                \"chills\"              \r\n## [22] \"cough\"                \"aches\"                \"vomit\"                \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"cleaning-data-and-core-functions.html","id":"rename-by-column-position","chapter":"1 Cleaning data and core functions","heading":"Rename by column position","text":"can also rename column position, instead column name, example:","code":"\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)"},{"path":"cleaning-data-and-core-functions.html","id":"rename-via-select-and-summarise","chapter":"1 Cleaning data and core functions","heading":"Rename via select() and summarise()","text":"shortcut, can also rename columns within dplyr select() summarise() functions. select() used keep certain columns (covered later page). summarise() covered [Grouping data] Descriptive tables pages. functions also uses format new_name = old_name. example:","code":"\nlinelist_raw %>% \n  select(# NEW name             # OLD name\n         date_infection       = `infection date`,    # rename and KEEP ONLY these columns\n         date_hospitalisation = `hosp date`)"},{"path":"cleaning-data-and-core-functions.html","id":"other-challenges","chapter":"1 Cleaning data and core functions","heading":"Other challenges","text":"","code":""},{"path":"cleaning-data-and-core-functions.html","id":"empty-excel-column-names","chapter":"1 Cleaning data and core functions","heading":"Empty Excel column names","text":"R dataset columns column names (headers). , import Excel dataset data column headers, R fill-headers names like “…1” “…2”. number represents column number (e.g. 4th column dataset header, R name “..4”).can clean names manually referencing position number (see example ), assigned name (linelist_raw$...1).","code":""},{"path":"cleaning-data-and-core-functions.html","id":"merged-excel-column-names-and-cells","chapter":"1 Cleaning data and core functions","heading":"Merged Excel column names and cells","text":"Merged cells Excel file common occurrence receiving data. explained [Transition R], merged cells can nice human reading data, “tidy data” cause many problems machine reading data. R accommodate merged cells.Remind people data entry human-readable data machine-readable data. Strive train users principles tidy data. possible, try change procedures data arrive tidy format without merged cells.variable must column.observation must row.value must cell.using rio’s import() function, value merged cell assigned first cell subsequent cells empty.One solution deal merged cells import data function readWorkbook() package openxlsx. Set argument fillMergedCells = TRUE. gives value merged cell cells within merge range.DANGER: column names merged readWorkbook(), end duplicate column names, need fix manually - R work well duplicate column names! can re-name referencing position (e.g. column 5), explained section manual column name cleaning..","code":"\nlinelist_raw <- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)"},{"path":"cleaning-data-and-core-functions.html","id":"select-or-re-order-columns","chapter":"1 Cleaning data and core functions","heading":"1.5 Select or re-order columns","text":"Use select() dplyr select columns want retain, specify order data frame.CAUTION: examples , linelist data frame modified select() displayed, saved. demonstration purposes. modified column names printed piping data frame names().column names linelist point cleaning pipe chain:","code":"\nnames(linelist)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \r\n##  [8] \"gender\"               \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \r\n## [15] \"age_unit\"             \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"                \"chills\"              \r\n## [22] \"cough\"                \"aches\"                \"vomit\"                \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"cleaning-data-and-core-functions.html","id":"keep-columns","chapter":"1 Cleaning data and core functions","heading":"Keep columns","text":"Select columns want remainPut names select() command, quotation marks. appear data frame order provide. Note include column exist, R return error (see use any_of() want error situation).","code":"\n# linelist dataset is piped through select() command, and names() prints just the column names\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, fever) %>% \n  names()  # display the column names## [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\" \"fever\""},{"path":"cleaning-data-and-core-functions.html","id":"clean_tidyselect","chapter":"1 Cleaning data and core functions","heading":"“tidyselect” helper functions","text":"helper functions exist make easy specify columns keep, discard, transform. package tidyselect, included tidyverse underlies columns selected dplyr functions.example, want re-order columns, everything() useful function signify “columns yet mentioned”. command moves columns date_onset date_hospitalisation beginning (left) dataset, keeps columns afterward. Note everything() written empty parentheses:“tidyselect” helper functions also work within dplyr functions like select(), across(), summarise():everything() - columns mentionedlast_col() - last columnwhere() - applies function columns selects TRUEcontains() - columns containing character string\r\nexample: select(contains(\"time\"))\r\nexample: select(contains(\"time\"))starts_with() - matches specified prefix\r\nexample: select(starts_with(\"date_\"))\r\nexample: select(starts_with(\"date_\"))ends_with() - matches specified suffix\r\nexample: select(ends_with(\"_post\"))\r\nexample: select(ends_with(\"_post\"))matches() - apply regular expression (regex)\r\nexample: select(contains(\"[pt]al\"))\r\nexample: select(contains(\"[pt]al\"))num_range() - numerical range like x01, x02, x03any_of() - matches column exists returns error found\r\nexample: select(any_of(date_onset, date_death, cardiac_arrest))\r\nexample: select(any_of(date_onset, date_death, cardiac_arrest))addition, use normal operators c() list several columns, : consecutive columns, ! opposite, & , | .Use () specify logical criteria columns. providing function inside (), include function’s empty parentheses. command selects columns class Numeric.Use contains() select columns column name contains specified character string. ends_with() starts_with() provide nuance.function matches() works similarly contains() can provided regular expression (see page [Characters strings]), multiple strings separated bars within parentheses:CAUTION: column name specifically provide exist data, can return error stop code. Consider using any_of() cite columns may may exist, especially useful negative (remove) selections.one columns exists, error produced code continues without stopping cleaning chain.","code":"\n# move date_onset and date_hospitalisation to beginning\nlinelist %>% \n  select(date_onset, date_hospitalisation, everything()) %>% \n  names()##  [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"              \"generation\"           \"date_infection\"       \"date_outcome\"         \"outcome\"             \r\n##  [8] \"gender\"               \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \r\n## [15] \"age_unit\"             \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"                \"chills\"              \r\n## [22] \"cough\"                \"aches\"                \"vomit\"                \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\"\n# select columns that are class Numeric\nlinelist %>% \n  select(where(is.numeric)) %>% \n  names()## [1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"      \"ht_cm\"      \"ct_blood\"   \"temp\"\n# select columns containing certain characters\nlinelist %>% \n  select(contains(\"date\")) %>% \n  names()## [1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"\n# searched for multiple character matches\nlinelist %>% \n  select(matches(\"onset|hosp|fev\")) %>%   # note the OR symbol \"|\"\n  names()## [1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"             \"fever\"\nlinelist %>% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %>% \n  names()## [1] \"date_onset\""},{"path":"cleaning-data-and-core-functions.html","id":"remove-columns","chapter":"1 Cleaning data and core functions","heading":"Remove columns","text":"Indicate columns remove placing minus symbol “-” front column name (e.g. select(-outcome)), vector column names (). columns retained.can also remove column using base R syntax, defining NULL. example:","code":"\nlinelist %>% \n  select(-c(date_onset, fever:vomit)) %>% # remove date_onset and all columns from fever to vomit\n  names()##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_hospitalisation\" \"date_outcome\"         \"outcome\"              \"gender\"              \r\n##  [8] \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                  \"age_unit\"            \r\n## [15] \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"temp\"                 \"time_admission\"       \"merged_header\"       \r\n## [22] \"x28\"\nlinelist$date_onset <- NULL   # deletes column with base R syntax "},{"path":"cleaning-data-and-core-functions.html","id":"standalone","chapter":"1 Cleaning data and core functions","heading":"Standalone","text":"select() can also used independent command (pipe chain). case, first argument original dataframe operated upon.","code":"\n# Create a new linelist with id and age-related columns\nlinelist_age <- select(linelist, case_id, contains(\"age\"))\n\n# display the column names\nnames(linelist_age)## [1] \"case_id\"  \"age\"      \"age_unit\""},{"path":"cleaning-data-and-core-functions.html","id":"add-to-the-pipe-chain","chapter":"1 Cleaning data and core functions","heading":"Add to the pipe chain","text":"linelist_raw, columns need: row_num, merged_header, x28. remove select() command cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n\n    # remove column\n    select(-c(row_num, merged_header, x28))"},{"path":"cleaning-data-and-core-functions.html","id":"deduplication","chapter":"1 Cleaning data and core functions","heading":"1.6 Deduplication","text":"See handbook page [De-duplication] extensive options de-duplicate data. simple row de-duplication example presented .package dplyr offers distinct() function. function examines every row reduce data frame unique rows. , removes rows 100% duplicates.evaluating duplicate rows, takes account range columns - default considers columns. shown de-duplication page, can adjust column range uniqueness rows evaluated regards certain columns.simple example, just add empty command distinct() pipe chain. ensures rows 100% duplicates rows (evaluated across columns).begin 6611 rows linelist.de-duplication 6608 rows. removed rows 100% duplicates rows., distinct() command added cleaning pipe chain:","code":"\nlinelist <- linelist %>% \n  distinct()\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n    \n    # de-duplicate\n    distinct()"},{"path":"cleaning-data-and-core-functions.html","id":"column-creation-and-transformation","chapter":"1 Cleaning data and core functions","heading":"1.7 Column creation and transformation","text":"recommend using dplyr function mutate() add new column, modify existing one.example creating new column mutate(). syntax : mutate(new_column_name = value transformation)Stata, similar command generate, R’s mutate() can also used modify existing column.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"new-columns","chapter":"1 Cleaning data and core functions","heading":"New columns","text":"basic mutate() command create new column might look like . creates new column new_col value every row 10.can also reference values columns, perform calculations. , new column bmi created hold Body Mass Index (BMI) case - calculated using formula BMI = kg/m^2, using column ht_cm column wt_kg.creating multiple new columns, separate comma new line. examples new columns, including ones consist values columns combined using str_glue() stringr package (see page [Characters strings].Review new columns. demonstration purposes, new columns columns used create shown:TIP: variation mutate() function transmute(). function adds new column just like mutate(), also drops/removes columns mention within parentheses.","code":"\nlinelist <- linelist %>% \n  mutate(new_col = 10)\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\nnew_col_demo <- linelist %>%                       \n  mutate(\n    new_var_dup    = case_id,             # new column = duplicate/copy another existing column\n    new_var_static = 7,                   # new column = all values the same\n    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # new column = pasting together values from other columns\n    ) %>% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # show only new columns, for demonstration purposes\n# HIDDEN FROM READER\n# removes new demo columns created above\n# linelist <- linelist %>% \n#   select(-contains(\"new_var\"))"},{"path":"cleaning-data-and-core-functions.html","id":"convert-column-class","chapter":"1 Cleaning data and core functions","heading":"Convert column class","text":"Columns containing values dates, numbers, logical values (TRUE/FALSE) behave expected correctly classified. difference “2” class character 2 class numeric!ways set column class import commands, often cumbersome. See [R Basics] section object classes learn converting class objects columns.First, let’s run checks important columns see correct class. also saw beginning ran skim().Currently, class age column character. perform quantitative analyses, need numbers recognized numeric!class date_onset column also character! perform analyses, dates must recognized dates!resolve , use ability mutate() re-define column transformation. define column , converted different class. basic example, converting ensuring column age class Numeric:similar way, can use .character() .logical(). convert class Factor, can use factor() base R as_factor() forcats. Read [Factors] page.Converting class Date must take care. Several methods explained page [Working dates]. Typically, raw date values must format conversion work correctly (e.g “MM/DD/YYYY”, “DD MM YYYY”). converting class Date, check data confirm value converted correctly.","code":"\nclass(linelist$age)## [1] \"character\"\nclass(linelist$date_onset)## [1] \"character\"\nlinelist <- linelist %>% \n  mutate(age = as.numeric(age))"},{"path":"cleaning-data-and-core-functions.html","id":"grouped-data","chapter":"1 Cleaning data and core functions","heading":"Grouped data","text":"data frame already grouped (see page [Grouping data]), mutate() may behave differently data frame grouped. summarizing functions, like mean(), median(), max(), etc. calculate group, rows.Read using mutate () grouped dataframes tidyverse mutate documentation.","code":"\n# age normalized to mean of ALL rows\nlinelist %>% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# age normalized to mean of hospital group\nlinelist %>% \n  group_by(hospital) %>% \n  mutate(age_norm = age / mean(age, na.rm=T))"},{"path":"cleaning-data-and-core-functions.html","id":"clean_across","chapter":"1 Cleaning data and core functions","heading":"Transform multiple columns","text":"Often write concise code want apply transformation multiple columns . transformation can applied multiple columns using across() function package dplyr (also contained within tidyverse package). across() can used dplyr function, commonly used within select(), mutate(), filter(), summarise(). See applied summarise() page Descriptive tables.Specify columns argument .cols = function(s) apply .fns =. additional arguments provide .fns function can included comma, still within across().","code":""},{"path":"cleaning-data-and-core-functions.html","id":"across-column-selection","chapter":"1 Cleaning data and core functions","heading":"across() column selection","text":"Specify columns argument .cols =. can name individually, use “tidyselect” helper functions. Specify function .fns =. Note using function mode demonstrated , function written without parentheses ( ).transformation .character() applied specific columns named within across().“tidyselect” helper functions available assist specifying columns. detailed section Selecting re-ordering columns, include: everything(), last_col(), (), starts_with(), ends_with(), contains(), matches(), num_range() any_of().example one change columns character class:Convert character columns name contains string “date” (note placement commas parentheses):, example mutating columns currently class POSIXct (raw datetime class shows timestamps) - words, function .POSIXct() evaluates TRUE. want apply function .Date() columns convert normal class Date.Note within across() also use function () .POSIXct evaluating either TRUE FALSE.Note .POSIXct() package lubridate. similar “” functions like .character(), .numeric(), .logical() base R","code":"\nlinelist <- linelist %>% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(.cols = everything(), .fns = as.character))\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\nlinelist <- linelist %>% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))"},{"path":"cleaning-data-and-core-functions.html","id":"across-functions","chapter":"1 Cleaning data and core functions","heading":"across() functions","text":"can read documentation ?across details provide functions across(). summary points: several ways specify function(s) perform column can even define functions:can provide function name alone (e.g. mean .character)can provide function purrr-style (e.g. ~ mean(.x, na.rm = TRUE)) (see [page][Iteration, loops, lists])can specify multiple functions providing list (e.g. list(mean = mean, n_miss = ~ sum(.na(.x))).\r\nprovide multiple functions, multiple transformed columns returned per input column, unique names format col_fn. can adjust new columns named .names = argument using glue syntax (see page [Characters strings]) {.col} {.fn} shorthand input column function.\r\nprovide multiple functions, multiple transformed columns returned per input column, unique names format col_fn. can adjust new columns named .names = argument using glue syntax (see page [Characters strings]) {.col} {.fn} shorthand input column function.online resources using across(): creator Hadley Wickham’s thoughts/rationale","code":""},{"path":"cleaning-data-and-core-functions.html","id":"coalesce","chapter":"1 Cleaning data and core functions","heading":"coalesce()","text":"dplyr function finds first non-missing value position. “fills-” missing values first available value order specify.example outside context data frame: Let us say two vectors, one containing village detection another containing village residence. can use coalesce pick first non-missing value index:works provide data frame columns: row, function assign new column value first non-missing value columns provided (order provided).example “row-wise” operation. complicated row-wise calculations, see section Row-wise calculations.","code":"\nvillage_detection <- c(\"a\", \"b\", NA,  NA)\nvillage_residence <- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage <- coalesce(village_detection, village_residence)\nvillage    # print## [1] \"a\" \"b\" \"a\" \"d\"\nlinelist <- linelist %>% \n  mutate(village = coalesce(village_detection, village_residence))"},{"path":"cleaning-data-and-core-functions.html","id":"cumulative-math","chapter":"1 Cleaning data and core functions","heading":"Cumulative math","text":"want column reflect cumulative sum/mean/min/max etc assessed rows dataframe point, use following functions:cumsum() returns cumulative sum, shown :can used dataframe making new column. example, calculate cumulative number cases per day outbreak, consider code like :first 10 rows:See page [Epidemic curves] plot cumulative incidence epicurve.See also:cumsum(), cummean(), cummin(), cummax(), cumany(), cumall()","code":"\nsum(c(2,4,15,10))     # returns only one number## [1] 31\ncumsum(c(2,4,15,10))  # returns the cumulative sum at each step## [1]  2  6 21 31\ncumulative_case_counts <- linelist %>%  # begin with case linelist\n  count(date_onset) %>%                 # count of rows per day, as column 'n'   \n  mutate(cumulative_cases = cumsum(n))  # new column, of the cumulative sum at each row\nhead(cumulative_case_counts, 10)##    date_onset n cumulative_cases\r\n## 1  2012-04-15 1                1\r\n## 2  2012-05-05 1                2\r\n## 3  2012-05-08 1                3\r\n## 4  2012-05-31 1                4\r\n## 5  2012-06-02 1                5\r\n## 6  2012-06-07 1                6\r\n## 7  2012-06-14 1                7\r\n## 8  2012-06-21 1                8\r\n## 9  2012-06-24 1                9\r\n## 10 2012-06-25 1               10"},{"path":"cleaning-data-and-core-functions.html","id":"using-base-r","chapter":"1 Cleaning data and core functions","heading":"Using base R","text":"define new column (re-define column) using base R, write name data frame, connected $, new column (column modified). Use assignment operator <- define new value(s). Remember using base R must specify data frame name column name every time (e.g. dataframe$column). example creating bmi column using base R:","code":"linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)"},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":", new column added pipe chain classes converted.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    # add new column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% \n  \n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) "},{"path":"cleaning-data-and-core-functions.html","id":"re-code-values","chapter":"1 Cleaning data and core functions","heading":"1.8 Re-code values","text":"scenarios need re-code (change) values:edit one specific value (e.g. one date incorrect year format)reconcile values spelled sameto create new column categorical valuesto create new column numeric categories (e.g. age categories)","code":""},{"path":"cleaning-data-and-core-functions.html","id":"specific-values","chapter":"1 Cleaning data and core functions","heading":"Specific values","text":"change values manually can use recode() function within mutate() function.Imagine nonsensical date data (e.g. “2014-14-15”): fix date manually raw source data, , write change cleaning pipeline via mutate() recode(). latter transparent reproducible anyone else seeking understand repeat analysis.mutate() line can read : “mutate column date_onset equal column date_onset re-coded OLD VALUE changed NEW VALUE”. Note pattern (OLD = NEW) recode() opposite R patterns (new = old). R development community working revising .another example re-coding multiple values within one column.linelist values column “hospital” must cleaned. several different spellings many missing values.recode() command re-defines column “hospital” current column “hospital”, specified recode changes. Don’t forget commas !Now see spellings hospital column corrected consolidated:TIP: number spaces equals sign matter. Make code easier read aligning = rows. Also, consider adding hashed comment row clarify future readers side OLD side NEW. TIP: Sometimes blank character value exists dataset (recognized R’s value missing - NA). can reference value two quotation marks space inbetween (\"\").","code":"\n# fix incorrect values                   # old value       # new value\nlinelist <- linelist %>% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\ntable(linelist$hospital, useNA = \"always\")  # print table of all unique values, including missing  ## \r\n##                      Central Hopital                     Central Hospital                           Hospital A                           Hospital B \r\n##                                   11                                  457                                  290                                  289 \r\n##                     Military Hopital                    Military Hospital                     Mitylira Hopital                    Mitylira Hospital \r\n##                                   32                                  798                                    1                                   79 \r\n##                                Other                         Port Hopital                        Port Hospital St. Mark's Maternity Hospital (SMMH) \r\n##                                  907                                   48                                 1756                                  417 \r\n##   St. Marks Maternity Hopital (SMMH)                                 <NA> \r\n##                                   11                                 1512\nlinelist <- linelist %>% \n  mutate(hospital = recode(hospital,\n                     # for reference: OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\ntable(linelist$hospital, useNA = \"always\")## \r\n##                     Central Hospital                           Hospital A                           Hospital B                    Military Hospital \r\n##                                  468                                  290                                  289                                  910 \r\n##                                Other                        Port Hospital St. Mark's Maternity Hospital (SMMH)                                 <NA> \r\n##                                  907                                 1804                                  428                                 1512"},{"path":"cleaning-data-and-core-functions.html","id":"by-logic","chapter":"1 Cleaning data and core functions","heading":"By logic","text":"demonstrate re-code values column using logic conditions:Using replace(), ifelse() if_else() simple logicUsing case_when() complex logic","code":""},{"path":"cleaning-data-and-core-functions.html","id":"simple-logic","chapter":"1 Cleaning data and core functions","heading":"Simple logic","text":"","code":""},{"path":"cleaning-data-and-core-functions.html","id":"replace","chapter":"1 Cleaning data and core functions","heading":"replace()","text":"re-code simple logical criteria, can use replace() within mutate(). replace() function base R. Use logic condition specify rows change . general syntax :mutate(col_to_change = replace(col_to_change, criteria rows, new value)).One common situation use replace() changing just one value one row, using unique row identifier. , gender changed “Female” row column case_id “2195”.equivalent command using base R syntax indexing brackets [ ] . reads “Change value dataframe linelist‘s column gender (rows linelist’s column case_id value ’2195’) ‘Female’”.","code":"\n# Example: change gender of one specific observation to \"Female\" \nlinelist <- linelist %>% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\nlinelist$gender[linelist$case_id == \"2195\"] <- \"Female\""},{"path":"cleaning-data-and-core-functions.html","id":"ifelse-and-if_else","chapter":"1 Cleaning data and core functions","heading":"ifelse() and if_else()","text":"Another tool simple logic ifelse() partner if_else(). However, cases re-coding clear use case_when() (detailed ). “else” commands simplified versions else programming statement. general syntax :ifelse(condition, value return condition evaluates TRUE, value return condition evaluates FALSE), column source_known defined. value given row set “known” row’s value column source missing. value source missing, value source_known set “unknown”.if_else() special version dplyr handles dates. Note ‘true’ value date, ‘false’ value must also qualify date, hence using special value NA_real_ instead just NA.Avoid stringing together many ifelse commands… use case_when() instead! case_when() much easier read ’ll make fewer errors.Outside context data frame, want object used code switch value, consider using switch() base R.","code":"\nlinelist <- linelist %>% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n# Create a date of death column, which is NA if patient has not died.\nlinelist <- linelist %>% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))"},{"path":"cleaning-data-and-core-functions.html","id":"complex-logic","chapter":"1 Cleaning data and core functions","heading":"Complex logic","text":"Use dplyr’s case_when() re-coding many new groups, need use complex logic statements re-code values. function evaluates every row data frame, assess whether rows meets specified criteria, assigns correct new value.case_when() commands consist statements Right-Hand Side (RHS) Left-Hand Side (LHS) separated “tilde” ~. logic criteria left side pursuant values right side statement. Statements separated commas.example, utilize columns age age_unit create column age_years:row data evaluated, criteria applied/evaluated order case_when() statements written - top--bottom. top criteria evaluates TRUE given row, RHS value assigned, remaining criteria even tested row. Thus, best write specific criteria first, general last.Along lines, final statement, place TRUE left-side, capture row meet previous criteria. right-side statement assigned value like “check !” missing.DANGER: Vvalues right-side must class - either numeric, character, date, logical, etc. assign missing (NA), may need use special variations NA NA_character_, NA_real_ (numeric POSIX), .Date(NA). Read [Working dates].","code":"\nlinelist <- linelist %>% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # if age is given in years\n            age_unit == \"months\" ~ age/12,    # if age is given in months\n            is.na(age_unit)      ~ age,       # if age unit is missing, assume years\n            TRUE                 ~ NA_real_)) # any other circumstance, assign missing"},{"path":"cleaning-data-and-core-functions.html","id":"missing-values","chapter":"1 Cleaning data and core functions","heading":"Missing values","text":"special functions handling missing values context data cleaning.See page [Missing data] detailed tips identifying handling missing values. example, .na() function logically tests missingness.replace_na()change missing values (NA) specific value, “Missing”, use dplyr function replace_na() within mutate(). Note used manner recode - name variable must repeated within replace_na().fct_explicit_na()function forcats package. forcats package handles columns class Factor. Factors R’s way handle ordered values c(\"First\", \"Second\", \"Third\") set order values (e.g. hospitals) appear tables plots. See page [Factors].data class Factor try convert NA “Missing” using replace_na(), get error: invalid factor level, NA generated. tried add “Missing” value, defined possible level factor, rejected.easiest way solve use forcats function fct_explicit_na() converts column class factor, converts NA values character “(Missing)”.slower alternative add factor level using fct_expand() convert missing values.na_if()convert specific value NA, use dplyr’s na_if(). command performs opposite operation replace_na(). example , values “Missing” column hospital converted NA.Note: na_if() used logic criteria (e.g. “values > 99”) - use replace() case_when() :","code":"\nlinelist <- linelist %>% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\nlinelist %>% \n  mutate(hospital = fct_explicit_na(hospital))\nlinelist <- linelist %>% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n# Convert temperatures above 40 to NA \nlinelist <- linelist %>% \n  mutate(temp = replace(temp, temp > 40, NA))\n\n# Convert onset dates earlier than 1 Jan 2000 to missing\nlinelist <- linelist %>% \n  mutate(date_onset = replace(date_onset, date_onset > as.Date(\"2000-01-01\"), NA))"},{"path":"cleaning-data-and-core-functions.html","id":"cleaning-dictionary","chapter":"1 Cleaning data and core functions","heading":"Cleaning dictionary","text":"Use R package linelist ’s function clean_variable_spelling() clean data frame cleaning dictionary. linelist package developed RECON - R Epidemics Consortium.Create cleaning dictionary 3 columns:\r\n“” column (incorrect value)\r\n“” column (correct value)\r\ncolumn specifying column changes applied (“.global” apply columns)\r\n“” column (incorrect value)“” column (correct value)column specifying column changes applied (“.global” apply columns)Note: .global dictionary entries overridden column-specific dictionary entries.Import dictionary file R. example can downloaded via instructions [Download handbook data] page.Pass raw linelist clean_variable_spelling(), specifying wordlists = cleaning dictionary data frame. spelling_vars = argument can used specify column dictionary refers columns (3rd default), can set NULL dictionary apply character factor columns. Note function can take long time run.Now scroll right see values changed - particularly gender (lowercase uppercase), symptoms columns transformed yes/1/0.Note column names cleaning dictionary must correspond names point cleaning script. See online reference linelist package details.","code":"\ncleaning_dict <- import(\"cleaning_dict.csv\")\nlinelist <- linelist %>% \n  linelist::clean_variable_spelling(\n    wordlists = cleaning_dict,\n    spelling_vars = \"col\",        # dict column containing column names, defaults to 3rd column in dict\n  )"},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain-1","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":", new columns column transformations added pipe chain.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n  \n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n   ###################################################\n\n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))"},{"path":"cleaning-data-and-core-functions.html","id":"num_cats","chapter":"1 Cleaning data and core functions","heading":"1.9 Numeric categories","text":"describe special approaches creating categories numerical columns. Common examples include age categories, groups lab values, etc. discuss:age_categories(), epikit packagecut(), base Rcase_when()quantile breaks quantile() ntile()","code":""},{"path":"cleaning-data-and-core-functions.html","id":"review-distribution","chapter":"1 Cleaning data and core functions","heading":"Review distribution","text":"example create age_cat column using age_years column.First, examine distribution data, make appropriate cut-points. See page [Plot continuous data].CAUTION: Sometimes, numeric variables import class “character”. occurs non-numeric characters values, example entry “2 months” age, (depending R locale settings) comma used decimals place (e.g. “4,5” mean four one half years)..","code":"\n#check the class of the linelist variable age\nclass(linelist$age_years)## [1] \"numeric\"\n# examine the distribution\nhist(linelist$age_years)\nsummary(linelist$age_years, na.rm=T)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \r\n##    0.00    6.00   13.00   16.04   23.00   84.00     107"},{"path":"cleaning-data-and-core-functions.html","id":"age_categories","chapter":"1 Cleaning data and core functions","heading":"age_categories()","text":"epikit package, can use age_categories() function easily categorize label numeric columns (note: function can applied non-age numeric variables ). bonum, output column automatically ordered factor.required inputs:numeric vector (column)breakers = argument - provide numeric vector break points new groupsFirst, simple example:break values specify default lower bounds - , included “higher” group / groups “open” lower/left side. shown , can add 1 break value achieve groups open top/right.can adjust labels displayed separator =. default “-”can adjust top numbers handled, ceiling = arguemnt. set upper cut-set ceiling = TRUE. use, highest break value provided “ceiling” category “XX+” created. values highest break value (upper =, defined) categorized NA. example ceiling = TRUE, category XX+ values 70 (highest break value) assigned NA.Alternatively, instead breakers =, can provide lower =, upper =, =:lower = lowest number want considered - default 0upper = highest number want consideredby = number years groupsSee function’s Help page details (enter ?age_categories R console).","code":"\n# Simple example\n################\npacman::p_load(epikit)                    # load package\n\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(             # create new column\n      age_years,                            # numeric column to make groups from\n      breakers = c(0, 5, 10, 15, 20,        # break points\n                   30, 40, 50, 60, 70)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  <NA> \r\n##  1227  1223  1048   827  1216   597   251    78    27     7   107\n# Include upper ends for the same categories\n############################################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  <NA> \r\n##  1469  1195  1040   770  1149   547   231    70    24     6   107\n# With ceiling set to TRUE\n##########################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 is ceiling, all above become NA\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  <NA> \r\n##  1227  1223  1048   827  1216   597   251    78    28   113\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  <NA> \r\n##  2450  1875  1216   597   251    78    27     6     1     0     0   107"},{"path":"cleaning-data-and-core-functions.html","id":"cut","chapter":"1 Cleaning data and core functions","heading":"cut()","text":"cut() base R alternative age_categories(), think see age_categories() developed simplify process. notable differences age_categories() :need install/load another packageYou can specify whether groups open/closed right/leftYou must provide accurate labels yourselfIf want 0 included lowest group must specify thisThe basic syntax within cut() first provide numeric column cut (age_years), breaks argument, numeric vector c() break points. Using cut(), resulting column ordered factor.default, categorization occurs right/upper side “open” inclusive (left/lower side “closed” exclusive). opposite behavior age_categories() function. default labels use notation “(, B]”, means included B . Reverse behavior providing right = TRUE argument.Thus, default, “0” values excluded lowest group, categorized NA! “0” values infants coded age 0 careful! change , add argument include.lowest = TRUE “0” values included lowest group. automatically-generated label lowest category “[],B]”. Note include include.lowest = TRUE argument right = TRUE, extreme inclusion now apply highest break point value category, lowest.can provide vector customized labels using labels = argument. manually written, careful ensure accurate! Check work using cross-tabulation, described .example cut() applied age_years make new variable age_cat :Check work!!! Verify age value assigned correct category cross-tabulating numeric category columns. Examine assignment boundary values (e.g. 15, neighboring categories 10-15 16-20).Re-labeling NA valuesYou may want assign NA values label “Missing”. new column class Factor (restricted values), simply mutate replace_na(). Instead, use fct_explicit_na() forcats explained [Factors] page.Quickly make breaks labelsFor fast way make breaks label vectors, use something like . See [R basics] page references seq() rep().Read cut() Help page entering ?cut R console.","code":"\n# Create new variable, by cutting the numeric age variable\n# by default, upper break is excluded and lower break excluded from each category\nlinelist <- linelist %>% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # include 0 in lowest group\n      ))\n\n# tabulate the number of observations per group\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100]     <NA> \r\n##     1469     1195     1040      770     1149      778       94        6      107\n# Cross tabulation of the numeric and category columns. \ntable(\"Numeric Values\" = linelist$age_years,   # names specified in table for clarity.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # don't forget to examine NA values##                     Categories\r\n## Numeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] (70,100] <NA>\r\n##   0                    136      0       0       0       0       0       0        0    0\r\n##   0.0833333333333333     1      0       0       0       0       0       0        0    0\r\n##   0.25                   2      0       0       0       0       0       0        0    0\r\n##   0.333333333333333      6      0       0       0       0       0       0        0    0\r\n##   0.416666666666667      1      0       0       0       0       0       0        0    0\r\n##   0.5                    6      0       0       0       0       0       0        0    0\r\n##   0.583333333333333      3      0       0       0       0       0       0        0    0\r\n##   0.666666666666667      3      0       0       0       0       0       0        0    0\r\n##   0.75                   3      0       0       0       0       0       0        0    0\r\n##   0.833333333333333      1      0       0       0       0       0       0        0    0\r\n##   0.916666666666667      1      0       0       0       0       0       0        0    0\r\n##   1                    275      0       0       0       0       0       0        0    0\r\n##   1.5                    2      0       0       0       0       0       0        0    0\r\n##   2                    308      0       0       0       0       0       0        0    0\r\n##   3                    246      0       0       0       0       0       0        0    0\r\n##   4                    233      0       0       0       0       0       0        0    0\r\n##   5                    242      0       0       0       0       0       0        0    0\r\n##   6                      0    241       0       0       0       0       0        0    0\r\n##   7                      0    256       0       0       0       0       0        0    0\r\n##   8                      0    239       0       0       0       0       0        0    0\r\n##   9                      0    245       0       0       0       0       0        0    0\r\n##   10                     0    214       0       0       0       0       0        0    0\r\n##   11                     0      0     220       0       0       0       0        0    0\r\n##   12                     0      0     224       0       0       0       0        0    0\r\n##   13                     0      0     191       0       0       0       0        0    0\r\n##   14                     0      0     199       0       0       0       0        0    0\r\n##   15                     0      0     206       0       0       0       0        0    0\r\n##   16                     0      0       0     186       0       0       0        0    0\r\n##   17                     0      0       0     164       0       0       0        0    0\r\n##   18                     0      0       0     141       0       0       0        0    0\r\n##   19                     0      0       0     130       0       0       0        0    0\r\n##   20                     0      0       0     149       0       0       0        0    0\r\n##   21                     0      0       0       0     158       0       0        0    0\r\n##   22                     0      0       0       0     149       0       0        0    0\r\n##   23                     0      0       0       0     125       0       0        0    0\r\n##   24                     0      0       0       0     144       0       0        0    0\r\n##   25                     0      0       0       0     107       0       0        0    0\r\n##   26                     0      0       0       0     100       0       0        0    0\r\n##   27                     0      0       0       0     117       0       0        0    0\r\n##   28                     0      0       0       0      85       0       0        0    0\r\n##   29                     0      0       0       0      82       0       0        0    0\r\n##   30                     0      0       0       0      82       0       0        0    0\r\n##   31                     0      0       0       0       0      68       0        0    0\r\n##   32                     0      0       0       0       0      84       0        0    0\r\n##   33                     0      0       0       0       0      78       0        0    0\r\n##   34                     0      0       0       0       0      58       0        0    0\r\n##   35                     0      0       0       0       0      58       0        0    0\r\n##   36                     0      0       0       0       0      33       0        0    0\r\n##   37                     0      0       0       0       0      46       0        0    0\r\n##   38                     0      0       0       0       0      45       0        0    0\r\n##   39                     0      0       0       0       0      45       0        0    0\r\n##   40                     0      0       0       0       0      32       0        0    0\r\n##   41                     0      0       0       0       0      34       0        0    0\r\n##   42                     0      0       0       0       0      26       0        0    0\r\n##   43                     0      0       0       0       0      31       0        0    0\r\n##   44                     0      0       0       0       0      24       0        0    0\r\n##   45                     0      0       0       0       0      27       0        0    0\r\n##   46                     0      0       0       0       0      25       0        0    0\r\n##   47                     0      0       0       0       0      16       0        0    0\r\n##   48                     0      0       0       0       0      21       0        0    0\r\n##   49                     0      0       0       0       0      15       0        0    0\r\n##   50                     0      0       0       0       0      12       0        0    0\r\n##   51                     0      0       0       0       0       0      13        0    0\r\n##   52                     0      0       0       0       0       0       7        0    0\r\n##   53                     0      0       0       0       0       0       4        0    0\r\n##   54                     0      0       0       0       0       0       6        0    0\r\n##   55                     0      0       0       0       0       0       9        0    0\r\n##   56                     0      0       0       0       0       0       7        0    0\r\n##   57                     0      0       0       0       0       0       9        0    0\r\n##   58                     0      0       0       0       0       0       6        0    0\r\n##   59                     0      0       0       0       0       0       5        0    0\r\n##   60                     0      0       0       0       0       0       4        0    0\r\n##   61                     0      0       0       0       0       0       2        0    0\r\n##   62                     0      0       0       0       0       0       1        0    0\r\n##   63                     0      0       0       0       0       0       5        0    0\r\n##   64                     0      0       0       0       0       0       1        0    0\r\n##   65                     0      0       0       0       0       0       5        0    0\r\n##   66                     0      0       0       0       0       0       3        0    0\r\n##   67                     0      0       0       0       0       0       2        0    0\r\n##   68                     0      0       0       0       0       0       1        0    0\r\n##   69                     0      0       0       0       0       0       3        0    0\r\n##   70                     0      0       0       0       0       0       1        0    0\r\n##   72                     0      0       0       0       0       0       0        1    0\r\n##   73                     0      0       0       0       0       0       0        3    0\r\n##   76                     0      0       0       0       0       0       0        1    0\r\n##   84                     0      0       0       0       0       0       0        1    0\r\n##   <NA>                   0      0       0       0       0       0       0        0  107\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # make missing values explicit\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Missing age\")  # you can specify the label\n  )    \n\n# table to view counts\ntable(linelist$age_cat, useNA = \"always\")## \r\n##         0-4         5-9       10-14       15-19       20-29       30-49       50-69      70-100 Missing age        <NA> \r\n##        1227        1223        1048         827        1216         848         105           7         107           0\n# Make break points from 0 to 90 by 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Make labels for the above categories, assuming default cut() settings\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n# check that both vectors are the same length\nlength(age_seq) == length(age_labels)"},{"path":"cleaning-data-and-core-functions.html","id":"quantile-breaks","chapter":"1 Cleaning data and core functions","heading":"Quantile breaks","text":"common understanding, “quantiles” “percentiles” typically refer value proportion values fall. example, 95th percentile ages linelist age 95% age fall.However common speech, “quartiles” “deciles” can also refer groups data equally divided 4, 10 groups (note one break point group).get quantile break points, can use quantile() stats package base R. provide numeric vector (e.g. column dataset) vector numeric probability values ranging 0 1.0. break points returned numeric vector. Explore details statistical methodologies entering ?quantile.input numeric vector missing values best set na.rm = TRUESet names = FALSE get un-named numeric vectorYou can use results quantile() break points age_categories() cut(). create new column deciles using cut() breaks defined using quantiles() age_years. , display results using tabyl() janitor can see percentages (see Descriptive tables page). Note exactly 10% group.","code":"\nquantile(linelist$age_years,               # specify numeric vector to work on\n  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want\n  na.rm = TRUE)                            # ignore missing values ##  0% 25% 50% 75% 90% 95% \r\n##   0   6  13  23  33  41\nlinelist %>%                                # begin with linelist\n  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years\n    breaks = quantile(                      # define cut breaks using quantile()\n      age_years,                               # operate on age_years\n      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1\n      na.rm = TRUE),                           # ignore missing values\n    include.lowest = TRUE)) %>%             # for cut() include age 0\n  janitor::tabyl(deciles)                   # pipe to table to display##  deciles   n    percent valid_percent\r\n##    [0,2] 748 0.11319613    0.11505922\r\n##    (2,5] 721 0.10911017    0.11090601\r\n##    (5,7] 497 0.07521186    0.07644978\r\n##   (7,10] 698 0.10562954    0.10736810\r\n##  (10,13] 635 0.09609564    0.09767728\r\n##  (13,17] 755 0.11425545    0.11613598\r\n##  (17,21] 578 0.08746973    0.08890940\r\n##  (21,26] 625 0.09458232    0.09613906\r\n##  (26,33] 596 0.09019370    0.09167820\r\n##  (33,84] 648 0.09806295    0.09967697\r\n##     <NA> 107 0.01619249            NA"},{"path":"cleaning-data-and-core-functions.html","id":"evenly-sized-groups","chapter":"1 Cleaning data and core functions","heading":"Evenly-sized groups","text":"Another tool make numeric groups dplyr function ntile(), attempts break data n evenly-sized groups - aware unlike quantile() value appear one group. Provide numeric vector number groups. values new column created just group “numbers” (e.g. 1 10), range values using cut().","code":"\n# make groups with ntile()\nntile_data <- linelist %>% \n  mutate(even_groups = ntile(age_years, 10))\n\n# make table of counts and proportions by group\nntile_table <- ntile_data %>% \n  janitor::tabyl(even_groups)\n  \n# attach min/max values to demonstrate ranges\nntile_ranges <- ntile_data %>% \n  group_by(even_groups) %>% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )## Warning in min(age_years, na.rm = T): no non-missing arguments to min; returning Inf## Warning in max(age_years, na.rm = T): no non-missing arguments to max; returning -Inf\n# combine and print - note that values are present in multiple groups\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")##  even_groups   n    percent valid_percent min  max\r\n##            1 651 0.09851695    0.10013844   0    2\r\n##            2 650 0.09836562    0.09998462   2    5\r\n##            3 650 0.09836562    0.09998462   5    7\r\n##            4 650 0.09836562    0.09998462   7   10\r\n##            5 650 0.09836562    0.09998462  10   13\r\n##            6 650 0.09836562    0.09998462  13   17\r\n##            7 650 0.09836562    0.09998462  17   21\r\n##            8 650 0.09836562    0.09998462  21   26\r\n##            9 650 0.09836562    0.09998462  26   33\r\n##           10 650 0.09836562    0.09998462  33   84\r\n##           NA 107 0.01619249            NA Inf -Inf"},{"path":"cleaning-data-and-core-functions.html","id":"case_when","chapter":"1 Cleaning data and core functions","heading":"case_when()","text":"possible use dplyr function case_when() create categories numeric column, easier use age_categories() epikit cut() create ordered factor automatically.using case_when(), please review proper use described earlier Re-code values section page. Also aware right-hand side values must class. Thus, want NA right-side either write “Missing” use special NA value NA_character_.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain-2","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":", code create two categorical age columns added cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################   \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))"},{"path":"cleaning-data-and-core-functions.html","id":"add-rows","chapter":"1 Cleaning data and core functions","heading":"1.10 Add rows","text":"","code":""},{"path":"cleaning-data-and-core-functions.html","id":"one-by-one","chapter":"1 Cleaning data and core functions","heading":"One-by-one","text":"Adding rows one--one manually tedious can done add_row() dplyr. Remember column must contain values one class (either character, numeric, logical, etc.). adding row requires nuance maintain .Use ... specify placement row want add. .= 3 put new row current 3rd row. default behavior add row end. Columns specified left empty (NA).new row number may look strange (“…23”) row numbers pre-existing rows changed. using command twice, examine/test insertion carefully.class provide see error like :(inserting row date value, remember wrap date function .Date() like .Date(\"2020-10-10\")).","code":"\nlinelist <- linelist %>% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)Error: Can't combine ..1$infection date <date> and ..2$infection date <character>."},{"path":"cleaning-data-and-core-functions.html","id":"bind-rows","chapter":"1 Cleaning data and core functions","heading":"Bind rows","text":"combine datasets together binding rows one dataframe bottom another data frame, can use bind_rows() dplyr. explained detail page [Joining data].","code":""},{"path":"cleaning-data-and-core-functions.html","id":"filter-rows","chapter":"1 Cleaning data and core functions","heading":"1.11 Filter rows","text":"typical cleaning step cleaned columns re-coded values filter data frame specific rows using dplyr verb filter().Within filter(), specify logic must TRUE row dataset kept. show filter rows based simple complex logical conditions.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"simple-filter","chapter":"1 Cleaning data and core functions","heading":"Simple filter()","text":"simple example re-defines dataframe linelist , filtered rows meet logical condition. rows logical statement within parentheses evaluates TRUE kept.example, logical statement gender == \"f\", asking whether value column gender equal “f” (case sensitive).filter applied, number rows linelist 6608.filter applied, number rows linelist 3139.","code":"\nlinelist <- linelist %>% \n  filter(gender == \"f\")   # keep only rows where gender is equal to \"f\""},{"path":"cleaning-data-and-core-functions.html","id":"filter-out-missing-values","chapter":"1 Cleaning data and core functions","heading":"Filter out missing values","text":"fairly common want filter rows missing values. Resist urge write filter(!.na(column) & !.na(column)) instead use tidyr function custom-built purpose: drop_na(). run empty parentheses, removes rows missing values. Alternatively, can provide names specific columns evaluated missingness, use “tidyselect” helper functions described .See page [Missing data] many techniques analyse manage missingness data.","code":"\nlinelist %>% \n  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years"},{"path":"cleaning-data-and-core-functions.html","id":"filter-by-row-number","chapter":"1 Cleaning data and core functions","heading":"Filter by row number","text":"data frame tibble, row usually “row number” (seen R Viewer) appears left first column. true column data, can used filter() statement.filter based “row number”, can use dplyr function row_number() open parentheses part logical filtering statement. Often use %% operator range numbers part logical statement, shown . see first N rows, can also use special dplyr function head().can also convert row numbers true column piping data frame tibble function rownames_to_column() (put anything parentheses).","code":"\n# View first 100 rows\nlinelist %>% head(100)     # or use tail() to see the n last rows\n\n# Show row 5 only\nlinelist %>% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns\nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)"},{"path":"cleaning-data-and-core-functions.html","id":"complex-filter","chapter":"1 Cleaning data and core functions","heading":"Complex filter()","text":"complex logical statements can constructed using parentheses ( ), |, negate !, %%, & operators. example :Note: can use ! operator front logical criteria negate . example, !.na(column) evaluates true column value missing. Likewise !column %% c(\"\", \"b\", \"c\") evaluates true column value vector.","code":""},{"path":"cleaning-data-and-core-functions.html","id":"examine-the-data","chapter":"1 Cleaning data and core functions","heading":"Examine the data","text":"simple one-line command create histogram onset dates. See second smaller outbreak 2012-2013 also included raw dataset. analyses, want remove entries earlier outbreak.","code":"\nhist(linelist$date_onset, breaks = 50)"},{"path":"cleaning-data-and-core-functions.html","id":"how-filters-handle-missing-numeric-and-date-values","chapter":"1 Cleaning data and core functions","heading":"How filters handle missing numeric and date values","text":"Can just filter date_onset rows June 2013? Caution! Applying code filter(date_onset > .Date(\"2013-06-01\"))) remove rows later epidemic missing date onset!DANGER: Filtering greater (>) less (<) date number can remove rows missing values (NA)! NA treated infinitely large small.(See page [Working dates] information working dates package lubridate)","code":""},{"path":"cleaning-data-and-core-functions.html","id":"design-the-filter","chapter":"1 Cleaning data and core functions","heading":"Design the filter","text":"Examine cross-tabulation make sure exclude correct rows:criteria can filter remove first outbreak (2012 & 2013) dataset? see :first epidemic 2012 & 2013 occurred Hospital , Hospital B, also 10 cases Port Hospital.Hospitals & B cases second epidemic, Port Hospital .want exclude:589 rows onset 2012 2013 either hospital , B, Port:\r\nExclude 559 rows onset 2012 2013\r\nExclude 30 rows Hospitals & B missing onset dates\r\nexclude 263 rows missing onset dates.\r\nExclude 559 rows onset 2012 2013Exclude 30 rows Hospitals & B missing onset datesDo exclude 263 rows missing onset dates.start linelist rnrow(linelist)`. filter statement:re-make cross-tabulation, see Hospitals & B removed completely, 10 Port Hospital cases 2012 & 2013 removed, values - just wanted.Multiple statements can included within one filter command (separated commas), can always pipe separate filter() command clarity.Note: readers may notice easier just filter date_hospitalisation 100% complete missing values. true. date_onset used purposes demonstrating complex filter.","code":"\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2012 2013 2014 2015 <NA>\r\n##   Central Hospital                        0    0  351   99   18\r\n##   Hospital A                            229   46    0    0   15\r\n##   Hospital B                            227   47    0    0   15\r\n##   Military Hospital                       0    0  676  200   34\r\n##   Missing                                 0    0 1117  318   77\r\n##   Other                                   0    0  684  177   46\r\n##   Port Hospital                           9    1 1372  347   75\r\n##   St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\r\n##   <NA>                                    0    0    0    0    0\nlinelist <- linelist %>% \n  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B\n  filter(date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)## [1] 6019\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2014 2015 <NA>\r\n##   Central Hospital                      351   99   18\r\n##   Military Hospital                     676  200   34\r\n##   Missing                              1117  318   77\r\n##   Other                                 684  177   46\r\n##   Port Hospital                        1372  347   75\r\n##   St. Mark's Maternity Hospital (SMMH)  322   93   13\r\n##   <NA>                                    0    0    0"},{"path":"cleaning-data-and-core-functions.html","id":"standalone-1","chapter":"1 Cleaning data and core functions","heading":"Standalone","text":"Filtering can also done stand-alone command (part pipe chain). Like dplyr verbs, case first argument must dataset .can also use base R subset using square brackets reflect [rows, columns] want retain.","code":"\n# dataframe <- filter(dataframe, condition(s) for rows to keep)\n\nlinelist <- filter(linelist, !is.na(case_id))\n# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist <- linelist[!is.na(case_id), ]"},{"path":"cleaning-data-and-core-functions.html","id":"quickly-review-records","chapter":"1 Cleaning data and core functions","heading":"Quickly review records","text":"Often want quickly review records, columns. base R function View() print data frame viewing RStudio.View linelist RStudio:two examples viewing specific cells (specific rows, specific columns):dplyr functions filter() select():Within View(), pipe dataset filter() keep certain rows, select() keep certain columns. example, review onset hospitalization dates 3 specific cases:can achieve base R syntax, using brackets [ ] subset want see.","code":"\nView(linelist)\nView(linelist %>%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %>%\n       select(date_onset, date_hospitalisation))\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])"},{"path":"cleaning-data-and-core-functions.html","id":"add-to-pipe-chain-3","chapter":"1 Cleaning data and core functions","heading":"Add to pipe chain","text":"","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))"},{"path":"cleaning-data-and-core-functions.html","id":"row-wise-calculations","chapter":"1 Cleaning data and core functions","heading":"1.12 Row-wise calculations","text":"want perform calculation within row, can use rowwise() dplyr. See online vignette row-wise calculations.\r\nexample, code applies rowwise() creates new column sums number specified symptom columns value “yes”, row linelist. columns specified within sum() name within vector c(). rowwise() essentially special kind group_by(), best use ungroup() done (page [Grouping data]).specify column evaluate, may want use “tidyselect” helper functions described select() section page. just make one adjustment (using within dplyr function like select() summarise()).Put column-specification criteria within dplyr function c_across(). c_across (documentation) designed work rowwise() specifically. example, following code:Applies rowwise() following operation (sum()) applied within row (summing entire columns)Creates new column num_NA_dates, defined row number columns (name containing “date”) .na() evaluated TRUE (missing data).ungroup() remove effects rowwise() subsequent stepsYou also provide functions, max() get latest recent date row:","code":"\nlinelist %>%\n  rowwise() %>%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %>% \n  ungroup() %>% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # for display## # A tibble: 5,888 x 6\r\n##    fever chills cough aches vomit num_symptoms\r\n##    <chr> <chr>  <chr> <chr> <chr>        <int>\r\n##  1 no    no     yes   no    yes              2\r\n##  2 <NA>  <NA>   <NA>  <NA>  <NA>            NA\r\n##  3 <NA>  <NA>   <NA>  <NA>  <NA>            NA\r\n##  4 no    no     no    no    no               0\r\n##  5 no    no     yes   no    yes              2\r\n##  6 no    no     yes   no    yes              2\r\n##  7 <NA>  <NA>   <NA>  <NA>  <NA>            NA\r\n##  8 no    no     yes   no    yes              2\r\n##  9 no    no     yes   no    yes              2\r\n## 10 no    no     yes   no    no               1\r\n## # ... with 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %>% \n  ungroup() %>% \n  select(num_NA_dates, contains(\"date\")) # for display## # A tibble: 5,888 x 5\r\n##    num_NA_dates date_infection date_onset date_hospitalisation date_outcome\r\n##           <int> <date>         <date>     <date>               <date>      \r\n##  1            1 2014-05-08     2014-05-13 2014-05-15           NA          \r\n##  2            1 NA             2014-05-13 2014-05-14           2014-05-18  \r\n##  3            1 NA             2014-05-16 2014-05-18           2014-05-30  \r\n##  4            1 2014-05-04     2014-05-18 2014-05-20           NA          \r\n##  5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \r\n##  6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \r\n##  7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \r\n##  8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \r\n##  9            1 NA             2014-06-05 2014-06-06           2014-06-18  \r\n## 10            1 NA             2014-06-05 2014-06-07           2014-06-09  \r\n## # ... with 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %>% \n  ungroup() %>% \n  select(latest_date, contains(\"date\"))  # for display## # A tibble: 5,888 x 5\r\n##    latest_date date_infection date_onset date_hospitalisation date_outcome\r\n##    <date>      <date>         <date>     <date>               <date>      \r\n##  1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \r\n##  2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \r\n##  3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \r\n##  4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \r\n##  5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \r\n##  6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \r\n##  7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \r\n##  8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \r\n##  9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \r\n## 10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \r\n## # ... with 5,878 more rows"},{"path":"cleaning-data-and-core-functions.html","id":"arrange-and-sort","chapter":"1 Cleaning data and core functions","heading":"1.13 Arrange and sort","text":"Use dplyr function arrange() sort order rows column values.Simple list columns order sorted . Specify .by_group = TRUE want sorting first occur groupings applied data (see page [Grouping data]).default, column sorted “ascending” order (applies numeric also character columns). can sort variable “descending” order wrapping desc().Sorting data arrange() particularly useful making [Tables presentation], using slice() take “top” rows per group, setting factor level order order appearance.example, sort linelist rows hospital, date_onset descending order, use:","code":"\nlinelist %>% \n   arrange(hospital, desc(date_onset))"},{"path":"simple-statistical-tests.html","id":"simple-statistical-tests","chapter":"2 Simple statistical tests","heading":"2 Simple statistical tests","text":"page demonstrates conduct simple statistical tests using base R, rstatix, gtsummary.T-testShapiro-Wilk testWilcoxon rank sum testKruskal-Wallis testChi-squared testCorrelations numeric variables…many tests can performed, showcase just common ones link documentation.packages bring certain advantages disadvantages:Use base R functions print statistical outputs R ConsoleUse rstatix functions return results data frame, want tests run groupUse gtsummary want quickly print publication-ready tables","code":""},{"path":"simple-statistical-tests.html","id":"preparation","chapter":"2 Simple statistical tests","heading":"2.1 Preparation","text":"","code":""},{"path":"simple-statistical-tests.html","id":"load-packages-1","chapter":"2 Simple statistical tests","heading":"Load packages","text":"code chunk shows loading packages required analyses. handbook emphasize p_load() pacman, installs package necessary loads use. can also load installed packages library() base R. See page [R basics] information R packages.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  skimr,        # get overview of data\n  tidyverse,    # data management + ggplot2 graphics, \n  gtsummary,    # summary statistics and tests\n  rstatix,      # statistics\n  corrr,        # correlation analayis for numeric variables\n  janitor,      # adding totals and percents to tables\n  flextable     # converting tables to HTML\n  )"},{"path":"simple-statistical-tests.html","id":"import-data-1","chapter":"2 Simple statistical tests","heading":"Import data","text":"import dataset cases simulated Ebola epidemic. want follow along, click download “clean” linelist (.rds file). Import data import() function rio package (accepts many file types like .xlsx, .rds, .csv - see [Import export] page details).first 50 rows linelist displayed .","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"simple-statistical-tests.html","id":"base-r","chapter":"2 Simple statistical tests","heading":"2.2 base R","text":"can use base R functions conduct statistical tests. commands relatively simple results print R Console simple viewing. However, outputs usually lists harder manipulate want use results subsequent operations.","code":""},{"path":"simple-statistical-tests.html","id":"t-tests","chapter":"2 Simple statistical tests","heading":"T-tests","text":"t-test, also called “Student’s t-Test”, typically used determine significant difference means numeric variable two groups. ’ll show syntax test depending whether columns data frame.Syntax 1: syntax numeric categorical columns data frame. Provide numeric column left side equation categorical column right side. Specify dataset data =. Optionally, set paired = TRUE, conf.level = (0.95 default), alternative = (either “two.sided”, “less”, “greater”). Enter ?t.test details.Syntax 2: can compare two separate numeric vectors using alternative syntax. example, two columns different data sets.can also use t-test determine whether sample mean significantly different specific value. conduct one-sample t-test known/hypothesized population mean mu =:","code":"\n## compare mean age by outcome group with a t-test\nt.test(age_years ~ gender, data = linelist)## \r\n##  Welch Two Sample t-test\r\n## \r\n## data:  age_years by gender\r\n## t = -21.344, df = 4902.3, p-value < 2.2e-16\r\n## alternative hypothesis: true difference in means is not equal to 0\r\n## 95 percent confidence interval:\r\n##  -7.571920 -6.297975\r\n## sample estimates:\r\n## mean in group f mean in group m \r\n##        12.60207        19.53701\nt.test(df1$age_years, df2$age_years)\nt.test(linelist$age_years, mu = 45)"},{"path":"simple-statistical-tests.html","id":"shapiro-wilk-test","chapter":"2 Simple statistical tests","heading":"Shapiro-Wilk test","text":"Shapiro-Wilk test can used determine whether sample came normally-distributed population (assumption many tests analysis, t-test). However, can used sample 3 5000 observations. larger samples quantile-quantile plot may helpful.","code":"\nshapiro.test(linelist$age_years)"},{"path":"simple-statistical-tests.html","id":"wilcoxon-rank-sum-test","chapter":"2 Simple statistical tests","heading":"Wilcoxon rank sum test","text":"Wilcoxon rank sum test, also called Mann–Whitney U test, often used help determine two numeric samples distribution populations normally distributed unequal variance.","code":"\n## compare age distribution by outcome group with a wilcox test\nwilcox.test(age_years ~ outcome, data = linelist)## \r\n##  Wilcoxon rank sum test with continuity correction\r\n## \r\n## data:  age_years by outcome\r\n## W = 2501868, p-value = 0.8308\r\n## alternative hypothesis: true location shift is not equal to 0"},{"path":"simple-statistical-tests.html","id":"kruskal-wallis-test","chapter":"2 Simple statistical tests","heading":"Kruskal-Wallis test","text":"Kruskal-Wallis test extension Wilcoxon rank sum test can used test differences distribution two samples. two samples used gives identical results Wilcoxon rank sum test.","code":"\n## compare age distribution by outcome group with a kruskal-wallis test\nkruskal.test(age_years ~ outcome, linelist)## \r\n##  Kruskal-Wallis rank sum test\r\n## \r\n## data:  age_years by outcome\r\n## Kruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308"},{"path":"simple-statistical-tests.html","id":"chi-squared-test","chapter":"2 Simple statistical tests","heading":"Chi-squared test","text":"Pearson’s Chi-squared test used testing significant differences categorical croups.","code":"\n## compare the proportions in each group with a chi-squared test\nchisq.test(linelist$gender, linelist$outcome)## \r\n##  Pearson's Chi-squared test with Yates' continuity correction\r\n## \r\n## data:  linelist$gender and linelist$outcome\r\n## X-squared = 0.0011841, df = 1, p-value = 0.9725"},{"path":"simple-statistical-tests.html","id":"rstatix-package","chapter":"2 Simple statistical tests","heading":"2.3 rstatix package","text":"rstatix package offers ability run statistical tests retrieve results “pipe-friendly” framework. results automatically data frame can perform subsequent operations results. also easy group data passed functions, statistics run group.","code":""},{"path":"simple-statistical-tests.html","id":"summary-statistics","chapter":"2 Simple statistical tests","heading":"Summary statistics","text":"function get_summary_stats() quick way return summary statistics. Simply pipe dataset function provide columns analyse. columns specified, statistics calculated columns.default, full range summary statistics returned: n, max, min, median, 25%ile, 75%ile, IQR, median absolute deviation (mad), mean, standard deviation, standard error, confidence interval mean.can specify subset summary statistics return providing one following values type =: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci”, “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.can used grouped data well, row returned grouping-variable:can also use rstatix conduct statistical tests:","code":"\nlinelist %>%\n  rstatix::get_summary_stats(age, temp)## # A tibble: 2 x 13\r\n##   variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se    ci\r\n##   <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl> <dbl>\r\n## 1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166 0.325\r\n## 2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013 0.025\nlinelist %>%\n  group_by(hospital) %>%\n  rstatix::get_summary_stats(age, temp, type = \"common\")## # A tibble: 12 x 11\r\n##    hospital                             variable     n   min   max median   iqr  mean     sd    se    ci\r\n##    <chr>                                <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\r\n##  1 Central Hospital                     age        445   0    58     12    15    15.7 12.5   0.591 1.16 \r\n##  2 Central Hospital                     temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\r\n##  3 Military Hospital                    age        884   0    72     14    18    16.1 12.4   0.417 0.818\r\n##  4 Military Hospital                    temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\r\n##  5 Missing                              age       1441   0    76     13    17    16.0 12.9   0.339 0.665\r\n##  6 Missing                              temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \r\n##  7 Other                                age        873   0    69     13    17    16.0 12.5   0.422 0.828\r\n##  8 Other                                temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\r\n##  9 Port Hospital                        age       1739   0    68     14    18    16.3 12.7   0.305 0.598\r\n## 10 Port Hospital                        temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\r\n## 11 St. Mark's Maternity Hospital (SMMH) age        420   0    84     12    15    15.7 12.4   0.606 1.19 \r\n## 12 St. Mark's Maternity Hospital (SMMH) temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095"},{"path":"simple-statistical-tests.html","id":"t-test","chapter":"2 Simple statistical tests","heading":"T-test","text":"Use formula syntax specify numeric categorical columns:use ~ 1 specify mu = one-sample T-test. can also done group.statistical tests can done group, shown :","code":"\nlinelist %>% \n  t_test(age_years ~ gender)## # A tibble: 1 x 10\r\n##   .y.       group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\r\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl> <dbl>    <dbl>    <dbl> <chr>       \r\n## 1 age_years f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****\nlinelist %>% \n  t_test(age_years ~ 1, mu = 30)## # A tibble: 1 x 7\r\n##   .y.       group1 group2         n statistic    df     p\r\n## * <chr>     <chr>  <chr>      <int>     <dbl> <dbl> <dbl>\r\n## 1 age_years 1      null model  5888     -84.2  5801     0\nlinelist %>% \n  group_by(gender) %>% \n  t_test(age_years ~ 1, mu = 18)## # A tibble: 3 x 8\r\n##   gender .y.       group1 group2         n statistic    df         p\r\n## * <chr>  <chr>     <chr>  <chr>      <int>     <dbl> <dbl>     <dbl>\r\n## 1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\r\n## 2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\r\n## 3 <NA>   age_years 1      null model   278     -3.80   191 1.96e-  4"},{"path":"simple-statistical-tests.html","id":"shapiro-wilk-test-1","chapter":"2 Simple statistical tests","heading":"Shapiro-Wilk test","text":"states , sample size must 3 5000.","code":"\nlinelist %>% \n  head(500) %>%            # first 500 rows of case linelist, for example only\n  shapiro_test(age_years)## # A tibble: 1 x 3\r\n##   variable  statistic        p\r\n##   <chr>         <dbl>    <dbl>\r\n## 1 age_years     0.917 6.67e-16"},{"path":"simple-statistical-tests.html","id":"wilcoxon-rank-sum-test-1","chapter":"2 Simple statistical tests","heading":"Wilcoxon rank sum test","text":"","code":"\nlinelist %>% \n  wilcox_test(age_years ~ gender)## # A tibble: 1 x 9\r\n##   .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\r\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl>    <dbl>    <dbl> <chr>       \r\n## 1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****"},{"path":"simple-statistical-tests.html","id":"kruskal-wallis-test-1","chapter":"2 Simple statistical tests","heading":"Kruskal-Wallis test","text":"Also known Mann-Whitney U test.","code":"\nlinelist %>% \n  kruskal_test(age_years ~ outcome)## # A tibble: 1 x 6\r\n##   .y.           n statistic    df     p method        \r\n## * <chr>     <int>     <dbl> <int> <dbl> <chr>         \r\n## 1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis"},{"path":"simple-statistical-tests.html","id":"chi-squared-test-1","chapter":"2 Simple statistical tests","heading":"Chi-squared test","text":"chi-square test function accepts table, first create cross-tabulation, remove left-column passing chisq_test().See documentation rstatix online entering ?rstatix.","code":"\nlinelist %>% \n  tabyl(gender, outcome) %>% \n  select(-gender) %>% \n  chisq_test()## # A tibble: 1 x 6\r\n##       n statistic     p    df method          p.signif\r\n## * <dbl>     <dbl> <dbl> <int> <chr>           <chr>   \r\n## 1  5888      3.53 0.473     4 Chi-square test ns"},{"path":"simple-statistical-tests.html","id":"stats_gt","chapter":"2 Simple statistical tests","heading":"2.4 gtsummary package","text":"Use gtsummary looking add results statistical test pretty table created package (described gtsummary section Descriptive tables page).Performing statistical tests comparison tbl_summary done adding \r\nadd_p function table specifying test use. possible get p-values corrected multiple testing using \r\nadd_q function. Run ?tbl_summary details.","code":""},{"path":"simple-statistical-tests.html","id":"chi-squared-test-2","chapter":"2 Simple statistical tests","heading":"Chi-squared test","text":"Compare proportions categorical variable two groups. default statistical test add_p() applied categorical variable perform chi-squared test independence continuity correction, expected call count 5 Fisher’s exact test used.\r\n          1\r\n          \r\n           \r\n          n (%)\r\n          \r\n          2\r\n          \r\n           \r\n          Pearson's Chi-squared test\r\n          ","code":"\nlinelist %>% \n  select(gender, outcome) %>%    # keep variables of interest\n  tbl_summary(by = outcome) %>%  # produce summary table and specify grouping variable\n  add_p()                        # specify what test to perform## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"simple-statistical-tests.html","id":"t-tests-1","chapter":"2 Simple statistical tests","heading":"T-tests","text":"Compare difference means continuous variable two groups.\r\nexample, compare mean age patient outcome.\r\n          1\r\n          \r\n           \r\n          Mean (SD)\r\n          \r\n          2\r\n          \r\n           \r\n          Welch Two Sample t-test\r\n          ","code":"\nlinelist %>% \n  select(age_years, outcome) %>%             # keep variables of interest\n  tbl_summary(                               # produce summary table\n    statistic = age_years ~ \"{mean} ({sd})\", # specify what statistics to show\n    by = outcome) %>%                        # specify the grouping variable\n  add_p(age_years ~ \"t.test\")                # specify what tests to perform## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"simple-statistical-tests.html","id":"wilcoxon-rank-sum-test-2","chapter":"2 Simple statistical tests","heading":"Wilcoxon rank sum test","text":"Compare distribution continuous variable two groups. default\r\nuse Wilcoxon rank sum test median (IQR) comparing two\r\ngroups. However non-normally distributed data comparing multiple groups,\r\nKruskal-wallis test appropriate.\r\n          1\r\n          \r\n           \r\n          Median (IQR)\r\n          \r\n          2\r\n          \r\n           \r\n          Wilcoxon rank sum test\r\n          ","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # keep variables of interest\n  tbl_summary(                                         # produce summary table\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # specify what statistic to show (this is default so could remove)\n    by = outcome) %>%                                  # specify the grouping variable\n  add_p(age_years ~ \"wilcox.test\")                     # specify what test to perform (default so could leave brackets empty)## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"simple-statistical-tests.html","id":"kruskal-wallis-test-2","chapter":"2 Simple statistical tests","heading":"Kruskal-wallis test","text":"Compare distribution continuous variable two groups,\r\nregardless whether data normally distributed.\r\n          1\r\n          \r\n           \r\n          Median (IQR)\r\n          \r\n          2\r\n          \r\n           \r\n          Kruskal-Wallis rank sum test\r\n          ","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # keep variables of interest\n  tbl_summary(                                         # produce summary table\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # specify what statistic to show (default, so could remove)\n    by = outcome) %>%                                  # specify the grouping variable\n  add_p(age_years ~ \"kruskal.test\")                    # specify what test to perform## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"simple-statistical-tests.html","id":"correlations","chapter":"2 Simple statistical tests","heading":"2.5 Correlations","text":"Correlation numeric variables can investigated using tidyversecorrr package. allows compute correlations using Pearson, Kendall\r\ntau Spearman rho. package creates table also function \r\nautomatically plot values.","code":"\ncorrelation_tab <- linelist %>% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # keep numeric variables of interest\n  correlate()      # create correlation table (using default pearson)\n\ncorrelation_tab    # print## # A tibble: 6 x 7\r\n##   term            generation       age ct_blood days_onset_hosp    wt_kg    ht_cm\r\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>    <dbl>    <dbl>\r\n## 1 generation        NA       -0.0222    0.179         -0.288    -0.0302  -0.00942\r\n## 2 age               -0.0222  NA         0.00849       -0.000635  0.833    0.877  \r\n## 3 ct_blood           0.179    0.00849  NA             -0.600    -0.00636  0.0181 \r\n## 4 days_onset_hosp   -0.288   -0.000635 -0.600         NA         0.0153  -0.00953\r\n## 5 wt_kg             -0.0302   0.833    -0.00636        0.0153   NA        0.884  \r\n## 6 ht_cm             -0.00942  0.877     0.0181        -0.00953   0.884   NA\n## remove duplicate entries (the table above is mirrored) \ncorrelation_tab <- correlation_tab %>% \n  shave()\n\n## view correlation table \ncorrelation_tab## # A tibble: 6 x 7\r\n##   term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\r\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>  <dbl> <dbl>\r\n## 1 generation        NA       NA        NA              NA       NA        NA\r\n## 2 age               -0.0222  NA        NA              NA       NA        NA\r\n## 3 ct_blood           0.179    0.00849  NA              NA       NA        NA\r\n## 4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\r\n## 5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\r\n## 6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n## plot correlations \nrplot(correlation_tab)"},{"path":"simple-statistical-tests.html","id":"resources","chapter":"2 Simple statistical tests","heading":"2.6 Resources","text":"Much information page adapted resources vignettes online:gtsummary\r\ndplyr\r\ncorrr\r\nsthda correlation","code":""},{"path":"descriptive-tables.html","id":"descriptive-tables","chapter":"3 Descriptive tables","heading":"3 Descriptive tables","text":"page demonstrates use janitor, dplyr, gtsummary, base R summarise data create tables descriptive statistics.packages advantages disadvantages areas code simplicity, accessibility outputs, quality printed outputs. Use page decide approach works scenario.See [Tables presentation] page tips nicely format print tables.several choices producing tabulation cross-tabulation summary tables. factors consider include code simplicity ease, desired output (printed R console, “pretty” .png/.jpeg/.html image), can data afterward. Consider points choose tool situation.Use tabyl() janitor produce “adorn” tabulations cross-tabulations.\r\nCons: requires post-processing (e.g flextable) publication-ready tables.\r\nCons: requires post-processing (e.g flextable) publication-ready tables.Use summarise() count() dplyr calculating complex statistics preparing data ggplot()\r\nCons: similar requires even manipulation\r\nCons: similar requires even manipulationUse tbl_summary() gtsummary produce detailed publication-ready tables\r\nCons: missings automatically included percentage calculations. use plotting need extract tibble list output.\r\nCons: missings automatically included percentage calculations. use plotting need extract tibble list output.Use table() base R access packages\r\nCons: requires manipulation post-processing\r\nCons: requires manipulation post-processing","code":""},{"path":"descriptive-tables.html","id":"preparation-1","chapter":"3 Descriptive tables","heading":"3.1 Preparation","text":"","code":""},{"path":"descriptive-tables.html","id":"load-packages-2","chapter":"3 Descriptive tables","heading":"Load packages","text":"code chunk shows loading packages required analyses. handbook emphasize p_load() pacman, installs package necessary loads use. can also load installed packages library() base R. See page [R basics] information R packages.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  skimr,        # get overview of data\n  tidyverse,    # data management + ggplot2 graphics \n  gtsummary,    # summary statistics and tests\n  rstatix,      # summary statistics and statistical tests\n  janitor,      # adding totals and percents to tables\n  scales,       # easily convert proportions to percents  \n  flextable     # converting tables to pretty images\n  )"},{"path":"descriptive-tables.html","id":"import-data-2","chapter":"3 Descriptive tables","heading":"Import data","text":"import dataset cases simulated Ebola epidemic. want follow along, click download “clean” linelist (.rds file). Import data import() function rio package (accepts many file types like .xlsx, .rds, .csv - see [Import export] page details).first 50 rows linelist displayed .","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"descriptive-tables.html","id":"browse-data","chapter":"3 Descriptive tables","heading":"3.2 Browse data","text":"","code":""},{"path":"descriptive-tables.html","id":"skimr-package","chapter":"3 Descriptive tables","heading":"skimr package","text":"using skimr package, can get detailed aesthetically pleasing overview variables dataset. Read skimr github page., function skim() applied entire linelist data frame. overview data frame summary every column (class) produced.\r\nTable 3.1: Data summary\r\nVariable type: characterVariable type: DateVariable type: factorVariable type: numericYou can also use summary() function, base R, get information entire dataset, output can difficult read using skimr. Therefore output shown , conserve page space.","code":"\n## get information about each variable in a dataset \nskim(linelist)\n## get information about each column in a dataset \nsummary(linelist)"},{"path":"descriptive-tables.html","id":"summary-statistics-1","chapter":"3 Descriptive tables","heading":"Summary statistics","text":"can use base R functions return summary statistics numeric column. can return useful summary statistics numeric column using summary(), . Note data frame name must also specified shown .can access save one specific part index brackets [ ]:can return individual statistics base R functions like max(), min(), median(), mean(), quantile(), sd(), range(). See [R basics] page complete list.CAUTION: data contain missing values, R wants know return NA unless specify mathematical functions want R ignore missing values, via argument na.rm = TRUE.can use get_summary_stats() function rstatix return summary statistics data frame format. can helpful performing subsequent operations plotting numbers. See Simple statistical tests page details rstatix package functions.","code":"\nsummary(linelist$age_years)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \r\n##    0.00    6.00   13.00   16.02   23.00   84.00      86\nsummary(linelist$age_years)[[2]]            # return only the 2nd element## [1] 6\n# equivalent, alternative to above by element name\n# summary(linelist$age_years)[[\"1st Qu.\"]]  \nlinelist %>% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # columns to calculate for\n    type = \"common\")                    # summary stats to return## # A tibble: 5 x 10\r\n##   variable     n   min   max median   iqr  mean     sd    se    ci\r\n##   <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\r\n## 1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\r\n## 2 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\r\n## 3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \r\n## 4 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025\r\n## 5 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475"},{"path":"descriptive-tables.html","id":"tbl_janitor","chapter":"3 Descriptive tables","heading":"3.3 janitor package","text":"janitor packages offers tabyl() function produce tabulations cross-tabulations, can “adorned” modified helper functions display percents, proportions, counts, etc., pipe linelist data frame janitor functions print result. desired, can also save resulting tables assignment operator <-.","code":""},{"path":"descriptive-tables.html","id":"simple-tabyl","chapter":"3 Descriptive tables","heading":"Simple tabyl","text":"default use tabyl() specific column produces unique values, counts, column-wise “percents” (actually proportions). proportions may many digits. can adjust number decimals adorn_rounding() described .can see , missing values display row labeled <NA>. can suppress show_na = FALSE. missing values, row appear. missing values, proportions given raw (denominator inclusive NA counts) “valid” (denominator excludes NA counts).column class Factor certain levels present data, levels still appear table. can suppress feature specifying show_missing_levels = FALSE. Read [Factors] page.","code":"\nlinelist %>% tabyl(age_cat)##  age_cat    n     percent valid_percent\r\n##      0-4 1095 0.185971467   0.188728025\r\n##      5-9 1095 0.185971467   0.188728025\r\n##    10-14  941 0.159816576   0.162185453\r\n##    15-19  743 0.126188859   0.128059290\r\n##    20-29 1073 0.182235054   0.184936229\r\n##    30-49  754 0.128057065   0.129955188\r\n##    50-69   95 0.016134511   0.016373664\r\n##      70+    6 0.001019022   0.001034126\r\n##     <NA>   86 0.014605978            NA"},{"path":"descriptive-tables.html","id":"cross-tabulation","chapter":"3 Descriptive tables","heading":"Cross-tabulation","text":"Cross-tabulation counts achieved adding one additional columns within tabyl(). Note now counts returned - proportions percents can added additional steps shown .","code":"\nlinelist %>% tabyl(age_cat, gender)##  age_cat   f   m NA_\r\n##      0-4 640 416  39\r\n##      5-9 641 412  42\r\n##    10-14 518 383  40\r\n##    15-19 359 364  20\r\n##    20-29 468 575  30\r\n##    30-49 179 557  18\r\n##    50-69   2  91   2\r\n##      70+   0   5   1\r\n##     <NA>   0   0  86"},{"path":"descriptive-tables.html","id":"tbl_adorn","chapter":"3 Descriptive tables","heading":"“Adorning” the tabyl","text":"Use janitor’s “adorn” functions add totals convert proportions, percents, otherwise adjust display. Often, pipe tabyl several functions.conscious order apply functions. examples.simple one-way table percents instead default proportions.cross-tabulation total row row percents.cross-tabulation adjusted counts percents displayed.","code":"\nlinelist %>%               # case linelist\n  tabyl(age_cat) %>%       # tabulate counts and proportions by age category\n  adorn_pct_formatting()   # convert proportions to percents##  age_cat    n percent valid_percent\r\n##      0-4 1095   18.6%         18.9%\r\n##      5-9 1095   18.6%         18.9%\r\n##    10-14  941   16.0%         16.2%\r\n##    15-19  743   12.6%         12.8%\r\n##    20-29 1073   18.2%         18.5%\r\n##    30-49  754   12.8%         13.0%\r\n##    50-69   95    1.6%          1.6%\r\n##      70+    6    0.1%          0.1%\r\n##     <NA>   86    1.5%             -\nlinelist %>%                                  \n  tabyl(age_cat, gender) %>%                  # counts by age and gender\n  adorn_totals(where = \"row\") %>%             # add total row\n  adorn_percentages(denominator = \"row\") %>%  # convert counts to proportions\n  adorn_pct_formatting(digits = 1)            # convert proportions to percents##  age_cat     f     m    NA_\r\n##      0-4 58.4% 38.0%   3.6%\r\n##      5-9 58.5% 37.6%   3.8%\r\n##    10-14 55.0% 40.7%   4.3%\r\n##    15-19 48.3% 49.0%   2.7%\r\n##    20-29 43.6% 53.6%   2.8%\r\n##    30-49 23.7% 73.9%   2.4%\r\n##    50-69  2.1% 95.8%   2.1%\r\n##      70+  0.0% 83.3%  16.7%\r\n##     <NA>  0.0%  0.0% 100.0%\r\n##    Total 47.7% 47.6%   4.7%\nlinelist %>%                                  # case linelist\n  tabyl(age_cat, gender) %>%                  # cross-tabulate counts\n  adorn_totals(where = \"row\") %>%             # add a total row\n  adorn_percentages(denominator = \"col\") %>%  # convert to proportions\n  adorn_pct_formatting() %>%                  # convert to percents\n  adorn_ns(position = \"front\") %>%            # display as: \"count (percent)\"\n  adorn_title(                                # adjust titles\n    row_name = \"Age Category\",\n    col_name = \"Gender\")##                      Gender                           \r\n##  Age Category             f             m          NA_\r\n##           0-4  640  (22.8%)  416  (14.8%)  39  (14.0%)\r\n##           5-9  641  (22.8%)  412  (14.7%)  42  (15.1%)\r\n##         10-14  518  (18.5%)  383  (13.7%)  40  (14.4%)\r\n##         15-19  359  (12.8%)  364  (13.0%)  20   (7.2%)\r\n##         20-29  468  (16.7%)  575  (20.5%)  30  (10.8%)\r\n##         30-49  179   (6.4%)  557  (19.9%)  18   (6.5%)\r\n##         50-69    2   (0.1%)   91   (3.2%)   2   (0.7%)\r\n##           70+    0   (0.0%)    5   (0.2%)   1   (0.4%)\r\n##          <NA>    0   (0.0%)    0   (0.0%)  86  (30.9%)\r\n##         Total 2807 (100.0%) 2803 (100.0%) 278 (100.0%)"},{"path":"descriptive-tables.html","id":"printing-the-tabyl","chapter":"3 Descriptive tables","heading":"Printing the tabyl","text":"default, tabyl print raw R console.Alternatively, can pass tabyl flextable similar package print “pretty” image RStudio Viewer, exported .png, .jpeg, .html, etc. discussed page [Tables presentation]. Note printing manner using adorn_titles(), must specify placement = \"combined\".Age Category/GenderfmNA_Total0-4640 (22.8%)416 (14.8%)39 (14.0%)1095 (18.6%)5-9641 (22.8%)412 (14.7%)42 (15.1%)1095 (18.6%)10-14518 (18.5%)383 (13.7%)40 (14.4%) 941 (16.0%)15-19359 (12.8%)364 (13.0%)20  (7.2%) 743 (12.6%)20-29468 (16.7%)575 (20.5%)30 (10.8%)1073 (18.2%)30-49179  (6.4%)557 (19.9%)18  (6.5%) 754 (12.8%)50-69  2  (0.1%) 91  (3.2%) 2  (0.7%)  95  (1.6%)70+  0  (0.0%)  5  (0.2%) 1  (0.4%)   6  (0.1%)  0  (0.0%)  0  (0.0%)86 (30.9%)  86  (1.5%)","code":"\nlinelist %>%\n  tabyl(age_cat, gender) %>% \n  adorn_totals(where = \"col\") %>% \n  adorn_percentages(denominator = \"col\") %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %>% # this is necessary to print as image\n  flextable::flextable() %>%    # convert to pretty image\n  flextable::autofit()          # format to one line per row "},{"path":"descriptive-tables.html","id":"use-on-other-tables","chapter":"3 Descriptive tables","heading":"Use on other tables","text":"can use janitor’s adorn_*() functions tables, created summarise() count() dplyr, table() base R. Simply pipe table desired janitor function. example:","code":"\nlinelist %>% \n  count(hospital) %>%   # dplyr function\n  adorn_totals()        # janitor function##                              hospital    n\r\n##                      Central Hospital  454\r\n##                     Military Hospital  896\r\n##                               Missing 1469\r\n##                                 Other  885\r\n##                         Port Hospital 1762\r\n##  St. Mark's Maternity Hospital (SMMH)  422\r\n##                                 Total 5888"},{"path":"descriptive-tables.html","id":"saving-the-tabyl","chapter":"3 Descriptive tables","heading":"Saving the tabyl","text":"convert table “pretty” image package like flextable, can save functions package - like save_as_html(), save_as_word(), save_as_ppt(), save_as_image() flextable (discussed extensively [Tables presentation] page). , table saved Word document, can hand-edited.","code":"\nlinelist %>%\n  tabyl(age_cat, gender) %>% \n  adorn_totals(where = \"col\") %>% \n  adorn_percentages(denominator = \"col\") %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %>% \n  flextable::flextable() %>%                     # convert to image\n  flextable::autofit() %>%                       # ensure only one line per row\n  flextable::save_as_docx(path = \"tabyl.docx\")   # save as Word document to filepath"},{"path":"descriptive-tables.html","id":"janitor_age_out_stats","chapter":"3 Descriptive tables","heading":"Statistics","text":"can apply statistical tests tabyls, like chisq.test() fisher.test() stats package, shown . Note missing values allowed excluded tabyl show_na = FALSE.See page Simple statistical tests code tips statistics.","code":"\nage_by_outcome <- linelist %>% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)## \r\n##  Pearson's Chi-squared test\r\n## \r\n## data:  age_by_outcome\r\n## X-squared = 6.4931, df = 7, p-value = 0.4835"},{"path":"descriptive-tables.html","id":"other-tips","chapter":"3 Descriptive tables","heading":"Other tips","text":"Include argument na.rm = TRUE exclude missing values calculations.applying adorn_*() helper functions tables created tabyl(), can specify particular column(s) apply like adorn_percentage(,,,c(cases,deaths)) (specify 4th unnamed argument). syntax simple. Consider using summarise() instead.can read detail janitor page tabyl vignette.","code":""},{"path":"descriptive-tables.html","id":"dplyr-package","chapter":"3 Descriptive tables","heading":"3.4 dplyr package","text":"dplyr part tidyverse packages common data management tool. Creating tables dplyr functions summarise() count() useful approach calculating summary statistics, summarize group, pass tables ggplot().summarise() creates new, summary data frame. data ungrouped, return one-row dataframe specified summary statistics entire data frame. data grouped, new data frame one row per group (see [Grouping data] page).Within summarise() parentheses, provide names new summary column followed equals sign statistical function apply.TIP: summarise function works UK US spelling (summarise() summarize()).","code":""},{"path":"descriptive-tables.html","id":"get-counts","chapter":"3 Descriptive tables","heading":"Get counts","text":"simple function apply within summarise() n(). Leave parentheses empty count number rows.gets interesting grouped data beforehand.command can shortened using count() function instead. count() following:Groups data columns provided itSummarises n() (creating column n)Un-groups dataYou can change name counts column default n something else specifying name =.Tabulating counts two grouping columns still returned “long” format, counts n column. See page [Pivoting data] learn “long” “wide” data formats.","code":"\nlinelist %>%                 # begin with linelist\n  summarise(n_rows = n())    # return new summary dataframe with column n_rows##   n_rows\r\n## 1   5888\nlinelist %>% \n  group_by(age_cat) %>%     # group data by unique values in column age_cat\n  summarise(n_rows = n())   # return number of rows *per group*## # A tibble: 9 x 2\r\n##   age_cat n_rows\r\n##   <fct>    <int>\r\n## 1 0-4       1095\r\n## 2 5-9       1095\r\n## 3 10-14      941\r\n## 4 15-19      743\r\n## 5 20-29     1073\r\n## 6 30-49      754\r\n## 7 50-69       95\r\n## 8 70+          6\r\n## 9 <NA>        86\nlinelist %>% \n  count(age_cat)##   age_cat    n\r\n## 1     0-4 1095\r\n## 2     5-9 1095\r\n## 3   10-14  941\r\n## 4   15-19  743\r\n## 5   20-29 1073\r\n## 6   30-49  754\r\n## 7   50-69   95\r\n## 8     70+    6\r\n## 9    <NA>   86\nlinelist %>% \n  count(age_cat, outcome)##    age_cat outcome   n\r\n## 1      0-4   Death 471\r\n## 2      0-4 Recover 364\r\n## 3      0-4    <NA> 260\r\n## 4      5-9   Death 476\r\n## 5      5-9 Recover 391\r\n## 6      5-9    <NA> 228\r\n## 7    10-14   Death 438\r\n## 8    10-14 Recover 303\r\n## 9    10-14    <NA> 200\r\n## 10   15-19   Death 323\r\n## 11   15-19 Recover 251\r\n## 12   15-19    <NA> 169\r\n## 13   20-29   Death 477\r\n## 14   20-29 Recover 367\r\n## 15   20-29    <NA> 229\r\n## 16   30-49   Death 329\r\n## 17   30-49 Recover 238\r\n## 18   30-49    <NA> 187\r\n## 19   50-69   Death  33\r\n## 20   50-69 Recover  38\r\n## 21   50-69    <NA>  24\r\n## 22     70+   Death   3\r\n## 23     70+ Recover   3\r\n## 24    <NA>   Death  32\r\n## 25    <NA> Recover  28\r\n## 26    <NA>    <NA>  26"},{"path":"descriptive-tables.html","id":"show-all-levels","chapter":"3 Descriptive tables","heading":"Show all levels","text":"tabling column class factor can ensure levels shown (just levels values data) adding .drop = FALSE summarise() count() command.technique useful standardise tables/plots. example creating figures multiple sub-groups, repeatedly creating figure routine reports. circumstances, presence values data may fluctuate, can define levels remain constant.See page [Factors] information.","code":""},{"path":"descriptive-tables.html","id":"tbl_dplyr_prop","chapter":"3 Descriptive tables","heading":"Proportions","text":"Proportions can added piping table mutate() create new column. Define new column counts column (n default) divided sum() counts column (return proportion).Note case, sum() mutate() command return sum whole column n use proportion denominator. explained Grouping data page, sum() used grouped data (e.g. mutate() immediately followed group_by() command), return sums group. stated just , count() finishes actions ungrouping. Thus, scenario get full column proportions.easily display percents, can wrap proportion function percent() package scales (note convert class character).method calculate proportions within groups. relies different levels data grouping selectively applied removed. First, data grouped outcome via group_by(). , count() applied. function groups data age_cat returns counts outcome-age-cat combination. Importantly - finishes process, count() also ungroups age_cat grouping, remaining data grouping original grouping outcome. Thus, final step calculating proportions (denominator sum(n)) still grouped outcome.","code":"\nage_summary <- linelist %>% \n  count(age_cat) %>%                     # group and count by gender (produces \"n\" column)\n  mutate(                                # create percent of column - note the denominator\n    percent = scales::percent(n / sum(n))) \n\n# print\nage_summary##   age_cat    n percent\r\n## 1     0-4 1095  18.60%\r\n## 2     5-9 1095  18.60%\r\n## 3   10-14  941  15.98%\r\n## 4   15-19  743  12.62%\r\n## 5   20-29 1073  18.22%\r\n## 6   30-49  754  12.81%\r\n## 7   50-69   95   1.61%\r\n## 8     70+    6   0.10%\r\n## 9    <NA>   86   1.46%\nage_by_outcome <- linelist %>%                  # begin with linelist\n  group_by(outcome) %>%                         # group by outcome \n  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping\n  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group"},{"path":"descriptive-tables.html","id":"plotting","chapter":"3 Descriptive tables","heading":"Plotting","text":"display “long” table output like ggplot() relatively straight-forward. data naturally “long” format, naturally accepted ggplot(). See examples pages [Plot categorical data] [ggplot tips].","code":"\nlinelist %>%                      # begin with linelist\n  count(age_cat, outcome) %>%     # group and tabulate counts by two columns\n  ggplot()+                       # pass new data frame to ggplot\n    geom_col(                     # create bar plot\n      mapping = aes(   \n        x = outcome,              # map outcome to x-axis\n        fill = age_cat,           # map age_cat to the fill\n        y = n))                   # map the counts column `n` to the height"},{"path":"descriptive-tables.html","id":"summary-statistics-2","chapter":"3 Descriptive tables","heading":"Summary statistics","text":"One major advantage dplyr summarise() ability return advanced statistical summaries like median(), mean(), max(), min(), sd() (standard deviation), percentiles. can also use sum() return number rows meet certain logical criteria. , outputs can produced whole data frame set, group.syntax - within summarise() parentheses provide names new summary column followed equals sign statistical function apply. Within statistical function, give column(s) operated relevant arguments (e.g. na.rm = TRUE mathematical functions).can also use sum() return number rows meet logical criteria. expression within counted evaluates TRUE. example:sum(age_years < 18, na.rm=T)sum(gender == \"male\", na.rm=T)sum(response %% c(\"Likely\", \"Likely\")), linelist data summarised describe days delay symptom onset hospital admission (column days_onset_hosp), hospital.tips:Use sum() logic statement “count” rows meet certain criteria (==)Note use na.rm = TRUE within mathematical functions like sum(), otherwise NA returned missing valuesUse function percent() scales package easily convert percents\r\nSet accuracy = 0.1 0.01 ensure 1 2 decimal places respectively\r\nSet accuracy = 0.1 0.01 ensure 1 2 decimal places respectivelyUse round() base R specify decimalsTo calculate statistics entire dataset, use summarise() without group_by()may create columns purposes later calculations (e.g. denominators) eventually drop data frame select().","code":"\nsummary_table <- linelist %>%                                        # begin with linelist, save out as new object\n  group_by(hospital) %>%                                             # group all calculations by hospital\n  summarise(                                                         # only the below summary columns will be returned\n    cases       = n(),                                                # number of rows per group\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # max delay\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # mean delay, rounded\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # standard deviation of delays, rounded\n    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # number of rows with delay of 3 or more days\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # convert previously-defined delay column to percent \n  )\n\nsummary_table  # print## # A tibble: 6 x 7\r\n##   hospital                             cases delay_max delay_mean delay_sd delay_3 pct_delay_3\r\n##   <chr>                                <int>     <dbl>      <dbl>    <dbl>   <int> <chr>      \r\n## 1 Central Hospital                       454        12        1.9      1.9     108 24%        \r\n## 2 Military Hospital                      896        15        2.1      2.4     253 28%        \r\n## 3 Missing                               1469        22        2.1      2.3     399 27%        \r\n## 4 Other                                  885        18        2        2.2     234 26%        \r\n## 5 Port Hospital                         1762        16        2.1      2.2     470 27%        \r\n## 6 St. Mark's Maternity Hospital (SMMH)   422        18        2.1      2.3     116 27%"},{"path":"descriptive-tables.html","id":"conditional-statistics","chapter":"3 Descriptive tables","heading":"Conditional statistics","text":"may want return conditional statistics - e.g. maximum rows meet certain criteria. can done subsetting column brackets [ ]. example returns maximum temperature patients classified fever. aware however - may appropriate add another column group_by() command pivot_wider() (demonstrated ).","code":"\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )## # A tibble: 6 x 3\r\n##   hospital                             max_temp_fvr max_temp_no\r\n##   <chr>                                       <dbl>       <dbl>\r\n## 1 Central Hospital                             40.4        38  \r\n## 2 Military Hospital                            40.5        38  \r\n## 3 Missing                                      40.6        38  \r\n## 4 Other                                        40.8        37.9\r\n## 5 Port Hospital                                40.6        38  \r\n## 6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9"},{"path":"descriptive-tables.html","id":"glueing-together","chapter":"3 Descriptive tables","heading":"Glueing together","text":"function str_glue() stringr useful combine values several columns one new column. context typically used summarise() command.[Characters strings] page, various options combining columns discussed, including unite(), paste0(). use case, advocate str_glue() flexible unite() simple syntax paste0()., summary_table data frame (created ) mutated columns delay_mean delay_sd combined, parentheses formating added new column, respective old columns removed., make table presentable, total row added adorn_totals() janitor (ignores non-numeric columns). Lastly, use select() dplyr re-order rename nicer column names.Now pass flextable print table Word, .png, .jpeg, .html, Powerpoint, RMarkdown, etc.! (see [Tables presentation] page).","code":"\nsummary_table %>% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %>%  # combine and format other values\n  select(-c(delay_mean, delay_sd)) %>%                       # remove two old columns   \n  adorn_totals(where = \"row\") %>%                            # add total row\n  select(                                                    # order and rename cols\n    \"Hospital Name\"   = hospital,\n    \"Cases\"           = cases,\n    \"Max delay\"       = delay_max,\n    \"Mean (sd)\"       = delay,\n    \"Delay 3+ days\"   = delay_3,\n    \"% delay 3+ days\" = pct_delay_3\n    )##                         Hospital Name Cases Max delay Mean (sd) Delay 3+ days % delay 3+ days\r\n##                      Central Hospital   454        12 1.9 (1.9)           108             24%\r\n##                     Military Hospital   896        15 2.1 (2.4)           253             28%\r\n##                               Missing  1469        22 2.1 (2.3)           399             27%\r\n##                                 Other   885        18   2 (2.2)           234             26%\r\n##                         Port Hospital  1762        16 2.1 (2.2)           470             27%\r\n##  St. Mark's Maternity Hospital (SMMH)   422        18 2.1 (2.3)           116             27%\r\n##                                 Total  5888       101         -          1580               -"},{"path":"descriptive-tables.html","id":"percentiles","chapter":"3 Descriptive tables","heading":"Percentiles","text":"Percentiles quantiles dplyr deserve special mention. return quantiles, use quantile() defaults specify value(s) like probs =.want return quantiles group, may encounter long less useful outputs simply add another column group_by(). , try approach instead - create column quantile level desired.dplyr summarise() certainly offers fine control, may find summary statistics need can produced get_summary_stat() rstatix package. operating grouped data, return 0%, 25%, 50%, 75%, 100%. applied ungrouped data, can specify percentiles probs = c(.05, .5, .75, .98).","code":"\n# get default percentile values of age (0%, 25%, 50%, 75%, 100%)\nlinelist %>% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))##   age_percentiles\r\n## 1               0\r\n## 2               6\r\n## 3              13\r\n## 4              23\r\n## 5              84\n# get manually-specified percentile values of age (5%, 50%, 75%, 98%)\nlinelist %>% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )##   age_percentiles\r\n## 1               1\r\n## 2              13\r\n## 3              23\r\n## 4              48\n# get manually-specified percentile values of age (5%, 50%, 75%, 98%)\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )## # A tibble: 6 x 5\r\n##   hospital                               p05   p50   p75   p98\r\n##   <chr>                                <dbl> <dbl> <dbl> <dbl>\r\n## 1 Central Hospital                         1    12    21  48  \r\n## 2 Military Hospital                        1    13    24  45  \r\n## 3 Missing                                  1    13    23  48.2\r\n## 4 Other                                    1    13    23  50  \r\n## 5 Port Hospital                            1    14    24  49  \r\n## 6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\nlinelist %>% \n  group_by(hospital) %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## `mutate_if()` ignored the following grouping variables:\r\n## Column `variable`\r\n## `mutate_if()` ignored the following grouping variables:\r\n## Column `variable`\r\n## `mutate_if()` ignored the following grouping variables:\r\n## Column `variable`\r\n## `mutate_if()` ignored the following grouping variables:\r\n## Column `variable`\r\n## `mutate_if()` ignored the following grouping variables:\r\n## Column `variable`\r\n## `mutate_if()` ignored the following grouping variables:\r\n## Column `variable`## # A tibble: 6 x 8\r\n##   hospital                             variable     n  `0%` `25%` `50%` `75%` `100%`\r\n##   <chr>                                <chr>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\r\n## 1 Central Hospital                     age        445     0     6    12    21     58\r\n## 2 Military Hospital                    age        884     0     6    14    24     72\r\n## 3 Missing                              age       1441     0     6    13    23     76\r\n## 4 Other                                age        873     0     6    13    23     69\r\n## 5 Port Hospital                        age       1739     0     6    14    24     68\r\n## 6 St. Mark's Maternity Hospital (SMMH) age        420     0     7    12    22     84\nlinelist %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## `mutate_if()` ignored the following grouping variables:\r\n## Column `variable`## # A tibble: 1 x 7\r\n## # Groups:   variable [1]\r\n##   variable     n  `0%` `25%` `50%` `75%` `100%`\r\n##   <chr>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\r\n## 1 age       5802     0     6    13    23     84"},{"path":"descriptive-tables.html","id":"summarise-aggregated-data","chapter":"3 Descriptive tables","heading":"Summarise aggregated data","text":"begin aggregated data, using n() return number rows, sum aggregated counts. get sums, use sum() data’s counts column.example, let’s say beginning data frame counts , called linelist_agg - shows “long” format case counts outcome gender.create example data frame linelist case counts outcome gender (missing values removed clarity).sum counts (column n) group can use summarise() set new column equal sum(n, na.rm=T). add conditional element sum operation, can use subset bracket [ ] syntax counts column.","code":"\nlinelist_agg <- linelist %>% \n  filter(!is.na(gender),\n         !is.na(outcome)) %>% \n  count(outcome, gender)\n\nlinelist_agg##   outcome gender    n\r\n## 1   Death      f 1227\r\n## 2   Death      m 1228\r\n## 3 Recover      f  953\r\n## 4 Recover      m  950\nlinelist_agg %>% \n  group_by(outcome) %>% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))## # A tibble: 2 x 4\r\n##   outcome total_cases male_cases female_cases\r\n##   <chr>         <int>      <int>        <int>\r\n## 1 Death          2455       1228         1227\r\n## 2 Recover        1903        950          953"},{"path":"descriptive-tables.html","id":"across-multiple-columns","chapter":"3 Descriptive tables","heading":"across() multiple columns","text":"can use summarise() across multiple columns using across(). makes life easier want calculate statistics many columns. Place across() within summarise() specify following:.cols = either vector column names c() “tidyselect” helper functions (explained ).fns = function perform (parentheses) - can provide multiple within list(), mean() applied several numeric columns. vector columns named explicitly .cols = single function mean specified (parentheses) .fns =. additional arguments function (e.g. na.rm=TRUE) provided .fns =, separated comma.can difficult get order parentheses commas correct using across(). Remember within across() must include columns, functions, extra arguments needed functions.Multiple functions can run . functions mean sd provided .fns = within list(). opportunity provide character names (e.g. “mean” “sd”) appended new column names.“tidyselect” helper functions can provide .cols = select columns:everything() - columns mentionedlast_col() - last columnwhere() - applies function columns selects TRUEstarts_with() - matches specified prefix. Example: starts_with(\"date\")ends_with() - matches specified suffix. Example: ends_with(\"_end\")contains() - columns containing character string. Example: contains(\"time\")matches() - apply regular expression (regex). Example: contains(\"[pt]al\")num_range() -any_of() - matches column named. Useful name might exist. Example: any_of(date_onset, date_death, cardiac_arrest)example, return mean every numeric column use () provide function .numeric() (without parentheses). remains within across() command.","code":"\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columns\n                   .fns = mean,                               # function\n                   na.rm=T))                                  # extra arguments## # A tibble: 3 x 5\r\n##   outcome age_years  temp wt_kg ht_cm\r\n##   <chr>       <dbl> <dbl> <dbl> <dbl>\r\n## 1 Death        15.9  38.6  52.6  125.\r\n## 2 Recover      16.1  38.6  52.5  125.\r\n## 3 <NA>         16.2  38.6  53.0  125.\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columns\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # multiple functions \n                   na.rm=T))                                 # extra arguments## # A tibble: 3 x 9\r\n##   outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd ht_cm_mean ht_cm_sd\r\n##   <chr>            <dbl>        <dbl>     <dbl>   <dbl>      <dbl>    <dbl>      <dbl>    <dbl>\r\n## 1 Death             15.9         12.3      38.6   0.962       52.6     18.4       125.     48.7\r\n## 2 Recover           16.1         13.0      38.6   0.997       52.5     18.6       125.     50.1\r\n## 3 <NA>              16.2         12.8      38.6   0.976       53.0     18.9       125.     50.4\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(\n    .cols = where(is.numeric),  # all numeric columns in the data frame\n    .fns = mean,\n    na.rm=T))## # A tibble: 3 x 12\r\n##   outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp   bmi days_onset_hosp\r\n##   <chr>        <dbl> <dbl>     <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>           <dbl>\r\n## 1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6  45.6            1.84\r\n## 2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6  47.7            2.34\r\n## 3 <NA>          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6  48.3            2.07"},{"path":"descriptive-tables.html","id":"tbls_pivot_wider","chapter":"3 Descriptive tables","heading":"Pivot wider","text":"prefer table “wide” format can transform using tidyr pivot_wider() function. likely need re-name columns rename(). information see page [Pivoting data].example begins “long” table age_by_outcome proportions section. create print, clarity:pivot wider, create new columns values existing column age_cat (setting names_from = age_cat). also specify new table values come existing column n, values_from = n. columns mentioned pivoting command (outcome) remain unchanged far left side.","code":"\nage_by_outcome <- linelist %>%                  # begin with linelist\n  group_by(outcome) %>%                         # group by outcome \n  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping\n  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group\nage_by_outcome %>% \n  select(-percent) %>%   # keep only counts for simplicity\n  pivot_wider(names_from = age_cat, values_from = n)  ## # A tibble: 3 x 10\r\n## # Groups:   outcome [3]\r\n##   outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\r\n##   <chr>   <int> <int>   <int>   <int>   <int>   <int>   <int> <int> <int>\r\n## 1 Death     471   476     438     323     477     329      33     3    32\r\n## 2 Recover   364   391     303     251     367     238      38     3    28\r\n## 3 <NA>      260   228     200     169     229     187      24    NA    26"},{"path":"descriptive-tables.html","id":"tbl_dplyr_totals","chapter":"3 Descriptive tables","heading":"Total rows","text":"summarise() operates grouped data automatically produce “total” statistics. , two approaches adding total row presented:","code":""},{"path":"descriptive-tables.html","id":"janitors-adorn_totals","chapter":"3 Descriptive tables","heading":"janitor’s adorn_totals()","text":"table consists counts proportions/percents can summed total, can add sum totals using janitor’s adorn_totals() described section . Note function can sum numeric columns - want calculate total summary statistics see next approach dplyr., linelist grouped gender summarised table described number cases known outcome, deaths, recovered. Piping table adorn_totals() adds total row bottom reflecting sum column. adorn_*() functions adjust display noted code.","code":"\nlinelist %>% \n  group_by(gender) %>%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # Number of rows in group where outcome is not missing\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # Number of rows in group where outcome is Death\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # Number of rows in group where outcome is Recovered\n  ) %>% \n  adorn_totals() %>%                                # Adorn total row (sums of each numeric column)\n  adorn_percentages(\"col\") %>%                      # Get column proportions\n  adorn_pct_formatting() %>%                        # Convert proportions to percents\n  adorn_ns(position = \"front\")                      # display % and counts (with counts in front)##  gender known_outcome       n_death     n_recover\r\n##       f 2180  (47.8%) 1227  (47.5%)  953  (48.1%)\r\n##       m 2178  (47.7%) 1228  (47.6%)  950  (47.9%)\r\n##    <NA>  207   (4.5%)  127   (4.9%)   80   (4.0%)\r\n##   Total 4565 (100.0%) 2582 (100.0%) 1983 (100.0%)"},{"path":"descriptive-tables.html","id":"summarise-on-total-data-and-then-bind_rows","chapter":"3 Descriptive tables","heading":"summarise() on “total” data and then bind_rows()","text":"table consists summary statistics median(), mean(), etc, adorn_totals() approach shown sufficient. Instead, get summary statistics entire dataset must calculate separate summarise() command bind results original grouped summary table. binding can use bind_rows() dplyr s described [Joining data] page. example:can make summary table outcome hospital group_by() summarise() like :get totals, run summarise() command group data outcome (hospital), like :can bind two data frames together. Note by_hospital 4 columns whereas totals 3 columns. using bind_rows(), columns combined name, extra space filled NA (e.g column hospital values two new totals rows). binding rows, convert empty spaces “Total” using replace_na() (see Cleaning data core functions page).new table “Total” rows bottom.table “long” format, may want. Optionally, can pivot table wider make readable. See section pivoting wider , [Pivoting data] page. can also add columns, arrange nicely. code .can print nicely image - output printed flextable. can read depth example achieve “pretty” table [Tables presentation] page.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nby_hospital <- linelist %>% \n  filter(!is.na(outcome) & hospital != \"Missing\") %>%  # Remove cases with missing outcome or hospital\n  group_by(hospital, outcome) %>%                      # Group data\n  summarise(                                           # Create new summary columns of indicators of interest\n    N = n(),                                            # Number of rows per hospital-outcome group     \n    ct_value = median(ct_blood, na.rm=T))               # median CT value per group\n  \nby_hospital # print table## # A tibble: 10 x 4\r\n## # Groups:   hospital [5]\r\n##    hospital                             outcome     N ct_value\r\n##    <chr>                                <chr>   <int>    <dbl>\r\n##  1 Central Hospital                     Death     193       22\r\n##  2 Central Hospital                     Recover   165       22\r\n##  3 Military Hospital                    Death     399       21\r\n##  4 Military Hospital                    Recover   309       22\r\n##  5 Other                                Death     395       22\r\n##  6 Other                                Recover   290       21\r\n##  7 Port Hospital                        Death     785       22\r\n##  8 Port Hospital                        Recover   579       21\r\n##  9 St. Mark's Maternity Hospital (SMMH) Death     199       22\r\n## 10 St. Mark's Maternity Hospital (SMMH) Recover   126       22\ntotals <- linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    \n      summarise(\n        N = n(),                                       # These statistics are now by outcome only     \n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # print table## # A tibble: 2 x 3\r\n##   outcome     N ct_value\r\n##   <chr>   <int>    <dbl>\r\n## 1 Death    1971       22\r\n## 2 Recover  1469       22\ntable_long <- bind_rows(by_hospital, totals) %>% \n  mutate(hospital = replace_na(hospital, \"Total\"))\ntable_long %>% \n  \n  # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Pivot from long to wide\n    values_from = c(ct_value, N),                       # new values are from ct and count columns\n    names_from = outcome) %>%                           # new column names are from outcomes\n  mutate(                                              # Add new columns\n    N_Known = N_Death + N_Recover,                               # number with known outcome\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)\n  select(                                              # Re-order columns\n    hospital, N_Known,                                   # Intro columns\n    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns\n  arrange(N_Known)                                  # Arrange rows from lowest to highest (Total row at bottom)## # A tibble: 6 x 8\r\n## # Groups:   hospital [6]\r\n##   hospital                             N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death ct_value_Death\r\n##   <chr>                                  <int>     <int> <chr>                  <dbl>   <int> <chr>              <dbl>\r\n## 1 St. Mark's Maternity Hospital (SMMH)     325       126 38.8%                     22     199 61.2%                 22\r\n## 2 Central Hospital                         358       165 46.1%                     22     193 53.9%                 22\r\n## 3 Other                                    685       290 42.3%                     21     395 57.7%                 22\r\n## 4 Military Hospital                        708       309 43.6%                     22     399 56.4%                 21\r\n## 5 Port Hospital                           1364       579 42.4%                     21     785 57.6%                 22\r\n## 6 Total                                   3440      1469 42.7%                     22    1971 57.3%                 22"},{"path":"descriptive-tables.html","id":"tbl_gt","chapter":"3 Descriptive tables","heading":"3.5 gtsummary package","text":"want print summary statistics pretty, publication-ready graphic, can use gtsummary package function tbl_summary(). code can seem complex first, outputs look nice print RStudio Viewer panel HTML image. Read vignette .can also add results statistical tests gtsummary tables. process described gtsummary section Simple statistical tests page.introduce tbl_summary() show basic behavior first, actually produces large beautiful table. , examine detail make adjustments tailored tables.","code":""},{"path":"descriptive-tables.html","id":"summary-table","chapter":"3 Descriptive tables","heading":"Summary table","text":"default behavior tbl_summary() quite incredible - takes columns provide creates summary table one command. function prints statistics appropriate column class: median inter-quartile range (IQR) numeric columns, counts (%) categorical columns. Missing values converted “Unknown”. Footnotes added bottom explain statistics, total N shown top.\r\n          1\r\n          \r\n           \r\n          Median (IQR); n (%)\r\n          ","code":"\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>%  # keep only the columns of interest\n  tbl_summary()                                                  # default"},{"path":"descriptive-tables.html","id":"adjustments","chapter":"3 Descriptive tables","heading":"Adjustments","text":"Now explain function works make adjustments. key arguments detailed :=\r\ncan stratify table column (e.g. outcome), creating 2-way table.statistic =\r\nUse equations specify statistics show display . two sides equation, separated tilde ~. right side, quotes, statistical display desired, left columns display apply.right side equation uses syntax str_glue() stringr (see [Characters Strings]), desired display string quotes statistics within curly brackets. can include statistics like “n” (counts), “N” (denominator), “mean”, “median”, “sd”, “max”, “min”, percentiles “p##” like “p25”, percent total “p”. See ?tbl_summary details.left side equation, can specify columns name (e.g. age c(age, gender)) using helpers all_continuous(), all_categorical(), contains(), starts_with(), etc.simple example statistic = equation might look like , print mean column age_years:\r\n          1\r\n          \r\n           \r\n          Mean\r\n          slightly complex equation might look like \"({min}, {max})\", incorporating max min values within parentheses separated comma:\r\n          1\r\n          \r\n           \r\n          (Range)\r\n          can also differentiate syntax separate columns types columns. complex example , value provided statistc = list indicating continuous columns table print mean standard deviation parentheses, categorical columns print n, denominator, percent.digits =\r\nAdjust digits rounding. Optionally, can specified continuous columns ().label =\r\nAdjust column name displayed. Provide column name desired label separated tilde. default column name.missing_text =\r\nAdjust missing values displayed. default “Unknown”.type =\r\nused adjust many levels statistics shown. syntax similar statistic = provide equation columns left value right. Two common scenarios include:type = all_categorical() ~ \"categorical\" Forces dichotomous columns (e.g. fever yes/) show levels instead “yes” rowtype = all_continuous() ~ \"continuous2\" Allows multi-line statistics per variable, shown later sectionIn example , arguments used modify original summary table:\r\n          1\r\n          \r\n           \r\n          Mean (SD); n / N (%)\r\n          ","code":"\nlinelist %>% \n  select(age_years) %>%         # keep only columns of interest \n  tbl_summary(                  # create summary table\n    statistic = age_years ~ \"{mean}\") # print mean of age\nlinelist %>% \n  select(age_years) %>%                       # keep only columns of interest \n  tbl_summary(                                # create summary table\n    statistic = age_years ~ \"({min}, {max})\") # print min and max of age\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>% # keep only columns of interest\n  tbl_summary(     \n    by = outcome,                                               # stratify entire table by outcome\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # stats and format for continuous columns\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # stats and format for categorical columns\n    digits = all_continuous() ~ 1,                              # rounding for continuous columns\n    type   = all_categorical() ~ \"categorical\",                 # force all categorical levels to display\n    label  = list(                                              # display labels for column names\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # how missing values should display\n  )## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"descriptive-tables.html","id":"multi-line-stats-for-continuous-variables","chapter":"3 Descriptive tables","heading":"Multi-line stats for continuous variables","text":"want print multiple lines statistics continuous variables, can indicate setting type = “continuous2”. can combine previously shown elements one table choosing statistics want show. need tell function want get table back entering type “continuous2”. number missing values shown “Unknown”.many ways modify tables, including adding p-values, adjusting color headings, etc. Many described documentation (enter ?tbl_summary Console), given section statistical tests.","code":"\nlinelist %>% \n  select(age_years, temp) %>%                      # keep only columns of interest\n  tbl_summary(                                     # create summary table\n    type = all_continuous() ~ \"continuous2\",       # indicate that you want to print multiple statistics \n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # line 1: mean and SD\n      \"{median} ({p25}, {p75})\",                   # line 2: median and IQR\n      \"{min}, {max}\")                              # line 3: min and max\n    )"},{"path":"descriptive-tables.html","id":"base-r-1","chapter":"3 Descriptive tables","heading":"3.6 base R","text":"can use function table() tabulate cross-tabulate columns. Unlike options , must specify dataframe time reference column name, shown .CAUTION: NA (missing) values tabulated unless include argument useNA = \"always\" (also set “” “ifany”).TIP: can use %$% magrittr remove need repeating data frame calls within base functions. example written linelist %$% table(outcome, useNA = \"always\") Multiple columns can cross-tabulated listing one , separated commas. Optionally, can assign column “name” like Outcome = linelist$outcome.","code":"\ntable(linelist$outcome, useNA = \"always\")## \r\n##   Death Recover    <NA> \r\n##    2582    1983    1323\nage_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # save table as object\nage_by_outcome   # print table##        \r\n##         Death Recover <NA>\r\n##   0-4     471     364  260\r\n##   5-9     476     391  228\r\n##   10-14   438     303  200\r\n##   15-19   323     251  169\r\n##   20-29   477     367  229\r\n##   30-49   329     238  187\r\n##   50-69    33      38   24\r\n##   70+       3       3    0\r\n##   <NA>     32      28   26"},{"path":"descriptive-tables.html","id":"proportions","chapter":"3 Descriptive tables","heading":"Proportions","text":"return proportions, passing table function prop.table(). Use margins = argument specify whether want proportions rows (1), columns (2), whole table (3). clarity, pipe table round() function base R, specifying 2 digits.","code":"\n# get proportions of table defined above, by rows, rounded\nprop.table(age_by_outcome, 1) %>% round(2)##        \r\n##         Death Recover <NA>\r\n##   0-4    0.43    0.33 0.24\r\n##   5-9    0.43    0.36 0.21\r\n##   10-14  0.47    0.32 0.21\r\n##   15-19  0.43    0.34 0.23\r\n##   20-29  0.44    0.34 0.21\r\n##   30-49  0.44    0.32 0.25\r\n##   50-69  0.35    0.40 0.25\r\n##   70+    0.50    0.50 0.00\r\n##   <NA>   0.37    0.33 0.30"},{"path":"descriptive-tables.html","id":"totals","chapter":"3 Descriptive tables","heading":"Totals","text":"add row column totals, pass table addmargins(). works counts proportions.","code":"\naddmargins(age_by_outcome)##        \r\n##         Death Recover <NA>  Sum\r\n##   0-4     471     364  260 1095\r\n##   5-9     476     391  228 1095\r\n##   10-14   438     303  200  941\r\n##   15-19   323     251  169  743\r\n##   20-29   477     367  229 1073\r\n##   30-49   329     238  187  754\r\n##   50-69    33      38   24   95\r\n##   70+       3       3    0    6\r\n##   <NA>     32      28   26   86\r\n##   Sum    2582    1983 1323 5888"},{"path":"descriptive-tables.html","id":"convert-to-data-frame","chapter":"3 Descriptive tables","heading":"Convert to data frame","text":"Converting table() object directly data frame straight-forward. One approach demonstrated :Create table, without using useNA = \"always\". Instead convert NA values “(Missing)” fct_explicit_na() forcats.Add totals (optional) piping addmargins()Pipe base R function .data.frame.matrix()Pipe table tibble function rownames_to_column(), specifying name first columnPrint, View, export desired. example use flextable() package flextable described [Tables presentation] page. print RStudio viewer pane pretty HTML image.Age CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888","code":"\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% \n  addmargins() %>% \n  as.data.frame.matrix() %>% \n  tibble::rownames_to_column(var = \"Age Category\") %>% \n  flextable::flextable()"},{"path":"descriptive-tables.html","id":"resources-1","chapter":"3 Descriptive tables","heading":"3.7 Resources","text":"Much information page adapted resources vignettes online:gtsummarydplyr","code":""}]
