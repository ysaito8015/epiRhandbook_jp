# Import and export {}

<!-- ======================================================= -->
## Overview

Here we describe ways to import and export data:  

* The **rio** package to import/export  
* The **here** package to locate files  
  * Relative versus absolute filepaths  
* Excel sheets  
* Google sheets 
* Websites  
* Skipping rows  
* Exporting/saving  


<!-- ======================================================= -->
## The **rio** package {}  

The package we recommend for importing data is: **rio**. **rio** utilizes the file extension (e.g. .xlsx, .csv, .rds, etc.) to import or export the file correctly.  

The alternative to using **rio** would be to use functions from many other packages that are specific to a type of file (e.g. `read.csv()`, `read.xlsx()`, etc.). These alternatives can be difficult to remember, whereas using `import()` from **rio** is relatively easy.  

Below is a table, taken from the **rio** online [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html). It shows for each type of data: the file extension that is expected, the packages it uses to import or export the data (so you can look up specific arguments, if needed), and whether this functionality is included in the default installed version of **rio**.  


Format                     | Typical Extension | Import Package    | Export Package     | Installed by Default
---------------------------|-------------------|-------------------|--------------------|---------------------
Comma-separated data | .csv | data.table | data.table |	Yes
Pipe-separated data |	.psv | data.table | data.table | Yes
Tab-separated data| .tsv | data.table | data.table | Yes
SAS | .sas7bdat | haven | haven | Yes
SPSS | .sav | haven | haven | Yes
Stata | .dta | haven | haven | Yes
SAS | XPORT | .xpt | haven | haven | Yes
SPSS Portable | .por | haven | | Yes
Excel | .xls | readxl | | Yes
Excel | .xlsx | readxl | openxlsx | Yes
R syntax | .R	| base | base | Yes
Saved R objects | .RData, .rda | base | base | Yes
Serialized R objects | .rds | base | base | Yes
Epiinfo | .rec | foreign | | Yes
Minitab | .mtp | foreign | | Yes
Systat | .syd |	foreign | | Yes
“XBASE” | database files | .dbf | foreign | foreign | Yes
Weka Attribute-Relation File Format | .arff | foreign | foreign | Yes
Data Interchange Format | .dif | utils | | Yes
Fortran data | no recognized extension | utils | | Yes
Fixed-width format data | .fwf | utils | utils | Yes
gzip comma-separated data | .csv.gz | utils | utils | Yes
CSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | No
EViews | .wf1 |hexView | | No
Feather R/Python interchange format | .feather | feather | feather | No
Fast Storage | .fst | fst |	fst | No
JSON | .json | jsonlite | jsonlite | No
Matlab | .mat | rmatio | rmatio | No
OpenDocument Spreadsheet | .ods | readODS | readODS | No
HTML Tables | .html | xml2 | xml2 | No
Shallow XML documents | .xml | xml2 | xml2 | No
YAML | .yml | yaml | yaml	| No
Clipboard	default is tsv | |  clipr | clipr | No


You can read more about the **rio** package [in this online vignette](https://rdrr.io/cran/rio/f/vignettes/rio.Rmd)



<!-- ======================================================= -->
## Relative filepaths (`here()`) {#here}

*Relative filepaths* differ from static filepaths in that they are *relative from a specific directory location*.  
For example:  

* **A static filepath**: `import("C:/Users/nsbatra/My Documents/R files/epiproject/data/linelists/ebola_linelist.xlsx")`  
  * Specific fixed path
  * Useful if calling a file in a distant directory, or if multiple users are running a script hosted on a network drive
* **A relative filepath**: `import(here("data", "linelists", "ebola_linelist.xlsx"))`  
  * Path is given in relation to a directory  
  * Best if working within an R project  


The package **here** can be used, often in conjunction with **rio** for importing or exporting. **here** locates files on your computer via *relative pathways*, usually within the context of [R projects]. Relative pathways are relative from a designated folder location, so that pathways listed in R code will not break when the script is run on a different computer.

This code chunk shows the loading of packages for importing data. 

```{r import_packages}
# Checks if package is installed, installs if necessary, and loads package for current session
pacman::p_load(rio, here)
```

Use the package **here** and its function `here()` to implement relative pathways.

`here()` works best within [R projects](#rprojects). When the **here** package is first loaded, it places a small file called "here" in the root-level folder of your R project as a "benchmark" or "anchor" for all other files in the project.  

Thus, in your script, if you want to import or reference a file saved in your R project’s folders, you use the function `here()` to tell R where the file is ***in relation to that benchmark***. These relative filepaths can be used for both importing and exporting/saving data.  


If you are unsure where “here” is set to, run the function `here()` with the empty brackets:

```{r import_here, eval=F}
# This command tells you the folder path that "here" is set to 
here::here()
```

Below is an example of importing the file “linelist.xlsx” which is located in the benchmark “here” folder. All you have to do is provide the name of the file in quotes (with the appropriate ending).

```{r import_here_one, eval=F}
linelist <- import(here("linelist_raw.xlsx"))
```

If the file is within a subfolder - let’s say a “data” folder - write these folder names in quotes, separated by commas, as below:

```{r import_here_mutiple, eval=F}
linelist <- import(here("data", "linelist.xlsx"))
```

Using the `here()` command produces a character filepath, which is then processed by the `import()` function.

```{r}
# the filepath
here("data", "linelist.xlsx")
```


```{r, eval=F}
# the filepath is given to the import() function
linelist <- import(here("data", "linelist.xlsx"))
```



<!-- ======================================================= -->
## Importing {}

When you import a dataset, you are doing the following:  

1. Creating a new, named data frame object in your R environment  
2. *Defining the new object* **as** *the imported dataset*  


<!-- ======================================================= -->
### Import from filepath {-}  

The function `import()` (from the package **rio**) accepts a filepath within quotation marks. A few things to note:  

* Slashes must be forward slashes, as in the code shown. This is *NOT* the default for Windows filepaths.  
* Filepaths that begin with double slashes (e.g. "//...") will likely **not be recognized by R** and will produce an error. Consider moving these files to a "named" or "lettered" drive that begins with a letter (e.g. "J:" or "C:"). See the section on using Network Drive for more details on this issue.  
* Do not worry about slash direction if using relative filepaths with **here** 

With absolute filepath:  

```{r eval=F}
# Absolute pathway
p_load(rio)                                                      
my_data <- import("C:/Users/Timothy/Documents/cancer project/data/clean/survival_data.xlsx")
```

With relative filepath:  

```{r eval=F}
# Absolute pathway
p_load(rio)                                                 
my_data <- import(here("data", "clean", "survival_data.xlsx")
```




<!-- ======================================================= -->
### Excel sheet {-}

If importing a specific **sheet** from an Excel file, include the sheet name in the `which = ` argument of `import()`. For example:  

```{r eval=F}
my_data <- rio::import("my_excel_file.xlsx", which = "Sheetname")
```

If using the `here()` method to provide a relative pathway to `import()`, you can still indicate a specific sheet by adding the `which = ` argument after the closing parenthese of the `here()` function.  

```{r import_sheet_here, eval=F}
# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package
linelist_raw <- import(here("data", "linelists", "linelist.xlsx"), which = "Sheet1")`  
```






<!-- ======================================================= -->
### Select file manually {-}

You can import data manually via one of these methods:  

* Environment RStudio Pane, click "Import Dataset", and select the type of data 
* Click File / Import Dataset / (select the type of data)  
* To hard-code manual selection, use the *base R* command `file.choose()` (leaving the parentheses empty) to trigger appearance of a **pop-up window** that allows the user to manually select the file from their computer. For example:  

```{r import_choose, eval=F}
# Manual selection of a file.
# When this command is run, a POP-UP window should appear. 
# The filepath of the selected file will be supplied to the import() command.

my_data <- import(file.choose())
```

<span style="color: darkgreen;">**_TIP:_** The **pop-up window** may appear BEHIND your RStudio window.</span>



<!-- ======================================================= -->
## Google sheets {}

You can import data from an online Google spreadsheet with the **googlesheet4** package and by authenticating your access to the spreadsheet.  


```{r, eval=F}
pacman::p_load("googlesheets4")
```

Below, a demo Google sheet is imported and saved. This command may prompt confirmation of authentification of your Google account. Follow prompts and pop-ups in your internet browser to grant Tidyverse API packages permissions to edit, create, and delete your spreadsheets in Google Drive.  


The sheet below is "viewable for anyone with the link" and you can try to import it.  

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

The sheet can also be imported using only the sheet ID, a shorter part of the URL:  

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```


Another package, **googledrive** offers useful functions for writing, editing, and deleting Google sheets. For example, using the  `gs4_create()` and `sheet_write()` functions found in this package. 

Here are some other helpful online tutorials: [basic importing tutorial](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/) [more detail](https://googlesheets4.tidyverse.org/articles/googlesheets4.html) [interaction between the two packages](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)


<!-- ======================================================= -->
## Websites {}

Scraping data from a website - TBD - Under construction




<!-- ======================================================= -->
## Skip rows  

Sometimes, you may want to avoid importing a row of data. You can do this with the argument `skip = ` if using `import()` from **rio** on a .xlsx or .csv file. Provide the number of rows you want to skip. 


```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # does not import header row
```

Unfortunately `skip = ` only accepts one integer value, *not* a range (e.g. "2:10" does not work). To skip import of specific rows that are not consecutive from the top, consider importing multiple times and using `bind_rows()` from **dplyr**. See the example below of skipping only row 2.  



### Removing a second header row  

Your data may have a *second* row of data, for example if it is a "data dictionary" row (see example below). 

```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```


```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T) )
```

This situation can be problematic because it can result in all columns being imported as class "character". To solve this, you will likely need to import the data twice.  

1) Import the data in order to store the correct column names  
2) Import the data again, skipping the first *two* rows (header and second rows)  
3) Bind the correct names onto the reduced dataframe

The exact arguments used to bind the correct column names depends on the type of data file (.csv, .tsv, .xlsx, etc.). If using **rio**'s `import()` function, understand which function **rio** uses to import your data, and then give the appropriate argument to skip lines and/or designate the column names.  

**For Excel files:**  

```{r, eval=F}
# import first time; store the column names
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # save true column names

# import second time; skip row 2, and assign column names to argument col_names =
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**For CSV files:**  

```{r, eval=F}
# import first time; sotre column names
linelist_raw_names <- import("linelist_raw.csv") %>% names() # save true column names

# note argument for csv files is 'col.names = '
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Backup option** - changing column names as a separate command

```{r, eval=F}
# assign/overwrite headers using the base 'colnames()' function
colnames(linelist_raw) <- linelist_raw_names
```

Bonus! If you do have a second row that is a data dictionary, you can easily create a proper data dictionary from it. See this [vignette](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/)  


### Make a data dictionary {-}  

Bonus! If you do have a second row that is a data dictionary, you can easily create a proper data dictionary from it. This tip is adapted from this [post](source: https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/).  


```{r}
dict <- linelist_2headers %>%             # begin: linelist with dictionary as first row
  head(1) %>%                             # keep only column names and first dictionary row                
  pivot_longer(cols = everything(),       # pivot all columns to long format
               names_to = "Column",       # assign new column names
               values_to = "Description")
```


```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T) )
```



### Combine two header rows {-}  

In some cases, you may want to combine two header rows into one. This command will define the column names as the combination (pasting together) of the existing column names with the value underneath in the first row. Replace "df" with the name of your dataset.  

```{r, eval=F}
names(df) <- paste(names(df), df[1, ], sep = "_")
```




<!-- ======================================================= -->
## Manual data entry {}

### Entry by columns  

Since a data frame is a combination of vertical vectors (columns), R by default expects manual entry of data to also be in vertical vectors (columns). 

```{r import_manual_col}
# define each vector (vertical column) separately, each with its own name
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```
<span style="color: orange;">**_CAUTION:_** All vectors must be the same length (same number of values).</span>

The vectors can then be bound together using the function `data.frame()`:  

```{r}
# combine the columns into a data frame, by referencing the vector names
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

And now we display the new dataset:  

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_cols)
```


### Entry by rows  

Use the `tribble` function from the **tibble** package from the tidverse ([onlinetibble reference](https://tibble.tidyverse.org/reference/tribble.html)).  
  
Note how column headers start with a *tilde* (`~`).  Also note that each column must contain only one class of data (character, numeric, etc.).  
You can use tabs, spacing, and new rows to make the data entry more intuitive and readable. For example:  

```{r import_manual_row}
# create the dataset manually by row
manual_entry_rows <- tibble::tribble(
                        ~colA, ~colB,
                        "a",   1,
                        "b",   2,
                        "c",   3
                      )
```

And now we display the new dataset:  

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_rows)
```




### Pasting from clipboard  


If you copy data from elsewhere and have it on your clipboard, you can try the following command to convert those data into an R data frame:  

```{r, eval=F}
manual_entry_clipboard <- read.table(file = "clipboard",
                                     sep = "t",           # separator could be tab, or commas, etc.
                                     header=TRUE)         # if there is a header row
```




<!-- ======================================================= -->
## Rdata files {}

`.Rdata` files store R objects, and can actually store multiple R objects within one file, for example multiple dataframes, model results, lists, etc. This can be very useful to consolidate or share your data.  

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

If you have a list and you want it to be imported with the original structure (e.g. list of lists), use `import_list()`:  

```{r, eval=F}
rio::import_list("my_list_of_lists.Rdata")
```




<!-- ======================================================= -->
## Export {}  

With **rio**, you can use the `export()` function in a very similar way to `import()`. First give the name of the R object you want to save (e.g. `linelist`) and then in quote the filepath including name and file extension. For example:  

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # will save to working directory
```

You could save the same dataframe as a .csv, and to a folder specified by **here** relative pathway:  

```{r, eval=F}
export(linelist, here("data","clean", "my_linelist.csv")
```

### RDS files {-}

You can also export/save R dataframes as .rds files. The convenient thing about these is that classes of columns are retained, so you have less cleaning to do when importing than with an Excel or even a CSV file. 

```{r, eval=F}
export(linelist, here("data","clean", "my_linelist.rds")
```




<!-- ======================================================= -->
## Saving plots {} 

How to save plots, such as those created by `ggplot()` is discussed in the [ggplot tips] page. In brief, run `ggsave("my_plot_filepath_and_name.png")` after printing your plot.  

How to save a network graph, such as a transmission tree, is addressed in the page on [Transmission chains]. 
