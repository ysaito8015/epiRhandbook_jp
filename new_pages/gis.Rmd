# GIS の基本 { #gis }  

```{r, out.width=c('100%', '100%'), echo=F}
library(tidyverse)
library(here)


# 訳注: macOS で日本語が文字化けしたので、フォント設定を入れています。これは Windows 
# と Linux では逆に余計な警告を出すので、デフォルトでは "sans" にしています。
gis_jfontname <- "sans"
gis_sysinf <- Sys.info()
if (!is.null(gis_sysinf)) {
  if (gis_sysinf['sysname'] == "Darwin") {
    gis_jfontname <- "HiraginoSans-W3"
  }
}

knitr::include_graphics(here::here("images", "gis_head_image.png"))
```

<!-- ======================================================= -->
## 概要 {  }

データの空間情報は、アウトブレイクの状況について多くの洞察を与え、次のような質問に答えることができます。

* 現在の疾病のホットスポットはどこか？
* ホットスポットは時系列でどのように変化しているか？
* 医療施設へのアクセスはどうなっているか？改善が必要か？

この GIS ページでは、応用疫学者がアウトブレイク対応において知りたいニーズに応えることを目的としています。ここでは、**tmap** と **ggplot2** パッケージを使って、基本的な空間データの可視化方法を学びます。また、**sf** パッケージを使用して、基本的な空間データの管理とクエリの方法についても説明します。最後に、**spdep** パッケージを用いて、空間的関係、空間的自己相関、空間回帰など、<u>空間統計</u>の概念に簡単に触れます。 

## 重要な用語 {}  

ここでは、いくつかの重要な用語を紹介します。GIS と空間分析について詳しく知りたい方は、「リソース」節に掲載されている長いチュートリアルやコースをご覧になることをお勧めします。 

**GIS（Geographic Information System, 地理情報システム）** - GIS とは、空間データを収集、管理、分析、視覚化するためのフレームワークまたは環境のことです。

### GIS ソフトウェア {.unnumbered}

一般的な GIS ソフトウェアの中には、ポイント＆クリックで地図の作成や空間分析ができるものがあります。これらのツールには、コードを覚える必要がない、アイコンや機能を手動で選択して地図上に配置するのが簡単であるなどの利点があります。ここでは、人気のある2つのソフトウェアを紹介します。 

**ArcGIS** - ESRI社が開発した商用のGISソフトウェアで、非常に人気がありますますが、かなり高価です。 

**QGIS** - フリーのオープンソースGISソフトウェアで、ArcGIS でできることもおおむねできます。[ここでQGIS をダウンロードすることができます。](https://qgis.org/en/site/forusers/download.html)  

RをGISとして使用することは、「ポイント＆クリック」ではなく「コマンドライン・インターフェース」（目的の結果を得るためにはコーディングが必要）であるため、最初は敷居が高く感じられるかもしれません。しかし、繰り返し地図を作成したり、再現性のある分析を行う必要がある場合には、これは大きな利点となります。 

### 空間データ {.unnumbered}

GIS で使用される空間データには、主にベクトルデータとラスターデータの 2 種類があります。

**ベクトルデータ** - GIS で使用される空間データの最も一般的な形式であるベクトルデータは、頂点とパスの幾何学的なフィーチャ (feature) で構成されています。ベクトルデータは、さらに3つのタイプに分類され、広く使用されています。

  * <u>点</u> -点は、座標系における特定の位置を表す座標ペア(x,y)で構成されます。ポイントは空間データの最も基本的な形態であり、地図上のケース（例：患者の家）や場所（例：病院）を表すのに使用されます。

  * <u>線</u> - 線は、2つの接続されたポイントで構成されます。線には長さがあり、道路や川などを表すのに使われます。

  * <u>ポリゴン</u> - ポリゴンは、点で接続された少なくとも3つの線分で構成されています。ポリゴンのフィーチャは、面積だけでなく、長さ（すなわち、面積の周囲）を持っています。ポリゴンは、地域（例：村）や構造（例：病院の実際の面積）を示すときに使用されます。

**ラスターデータ** - 空間データの代替フォーマットであるラスターデータは、セル（ピクセルなど）のマトリックスで、各セルには高さ、温度、傾斜、森林被覆などの情報が含まれています。これは、航空写真や衛星画像などでよく見られます。ラスターデータは、ベクトルデータの下の「ベースマップ」としても使用されます。

### 空間データの可視化 {.unnumbered}

GISソフトウェアでは、空間データを地図上に視覚的に表現するために、それぞれのフィーチャ（feature、地物とも訳される） がどこにあるのか、お互いの関係について十分な情報を提供する必要があります。ベクトルデータを使用している場合、ほとんどのユースケースでは、この情報は通常シェープファイルに保存されます。

**シェープファイル** - シェープファイルは、線、点、ポリゴンで構成される「ベクトル」空間データを保存するための一般的なデータフォーマットです。1つのシェープファイルは、実際には少なくとも3つのファイル（.shp、.shx、.dbf）の集合体です。シェープファイルを読み取るためには、これらのサブコンポーネントファイルがすべて同一のディレクトリ（フォルダ）に存在する必要があります。これらの関連ファイルは、ZIPフォルダに圧縮してメールで送信したり、ウェブサイトからダウンロードすることができます。 

シェープファイルには、フィーチャ自体の情報だけでなく、地表のどこにあるかという情報も含まれています。空間データをどのように平面化するかは、地図の見た目や解釈に大きな影響を与えるため、重要なポイントとなります。

**Coordinate Reference Systems (CRS) ** - CRSとは、地球上の地理的フィーチャを特定するために使用される座標ベースのシステムです。CRSにはいくつかの重要な要素があります。

  * <u>座標系 (Coordinate System)</u> - 多くの異なる座標系があるので、自分の座標がどのシステムから来ているかを確認してください。緯度/経度の度数は一般的ですが、[UTM](https://www.maptools.com/tutorials/utm/quick_guide)座標を見ることもできます。 
  
  * <u>単位 (Units)</u> - 座標系の単位を知ることができます（例：10進法の度、メートル）。 

  * <u>測地基準系 (Datum)</u> - 地球の特定のモデル化されたバージョンです。これらは長年にわたって改訂されてきたので、マップレイヤーが同じ測地基準系を使用していることを確認してください。 

  * <u>投影 (Projection)</u> - 実際には丸い地球を平らな表面（地図）に投影するために使用された数式への参照。 

以下に示すマッピングツールを使用しなくても、空間データを要約することができることを覚えておいてください。時には、地域別（例：地区、国など）のシンプルな表があれば十分です。 

<!-- 訳注: 日本の主な CRS

* 平面直角座標系（世界測地系）I〜XIII EPSG: 2443-2455
* JGD2000 GRS80楕円体 EPSG:4612 -->

## はじめての GIS  

地図を作るためには、いくつかの重要なアイテムが必要です。それは以下の通りです。

  * **データセット** - これは空間データ形式（上述のようにシェープファイルなど）の場合もあれば、空間形式ではない場合もあります（例えば、単なるcsvなど）。
  
  * データセットが空間フォーマットでない場合は、**参照データ**も必要です。リファレンスデータは、データの空間表現と関連する**属性**で構成されており、特定のフィーチャの位置情報やアドレス情報を含む資料などがあります。
  
    + 事前に定義された地理的境界線（例えば、行政区域）を扱う場合、リファレンス・シェープファイルは、政府機関やデータ共有組織から自由にダウンロードできることが多い。迷ったときは、「[地域名] shapefile」でググってみるといいでしょう。
    
    + 住所情報はあるが、緯度・経度がない場合は、 **ジオコーディング・エンジン** を使ってレコードの空間参照データを取得する必要があるかもしれません。
    
  * データセットの情報を対象者にどのように見せたいか、というアイデア。地図には様々な種類がありますが、どの種類の地図が自分のニーズに最も適しているかを考えることが重要です。

<!-- 訳注：日本の主なGISデータ
*  [国勢調査](http://e-stat.go.jp/SG2/eStatGIS/page/download.html)
*  [国土数値地図](http://nlftp.mlit.go.jp/ksj/)
*  [国土地理院基盤地図](http://www.gsi.go.jp/kiban/etsuran.html)
*  [G空間情報センター](https://www.geospatial.jp/ckan/dataset) -->

### データを可視化するための地図のタイプ {.unnumbered}

**色分け（Choropleth）マップ** - 主題地図の一種で、色、濃淡、またはパターンを使って、ある属性の値に関連して地理的な地域を表現するもの。例えば、大きな値は小さな値よりも濃い色で示されます。このタイプのマップは、ある変数と、それが定義された地域や地政学的エリアでどのように変化するかを視覚化する場合に特に便利です。

```{r, out.width = '50%', fig.align = "center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "gis_choropleth.png"))
```

**症例密度ヒートマップ** - 主題地図の一種で、値の強さを色で表しますが、データをグループ化するために定義された地域や地政学的な境界線は使用しません。このタイプのマップは、一般的に「ホットスポット」や、ポイントが高密度または集中しているエリアを示すために使用されます。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_heatmap.png"))
```

**点密度マップ** - は、データの属性値をドットで表現する主題地図タイプです。このタイプのマップは、データの散らばりを視覚化し、クラスターを視覚的にスキャンするのに適しています。

```{r, fig.align = "center", echo=F}
# dot density img here
```

**等級シンボルマップ (段階のあるシンボルマップ)** - 主題地図は、色分け地図に似ていますが、属性の値を色で表すのではなく、その値に対応するシンボル（通常は円）を使用します。例えば、大きな値は小さな値よりも大きなシンボルで示されます。このタイプの地図は、地域ごとのデータの大きさや量を視覚化したい場合に最適です。

```{r, fig.align = "center", echo=F}
# ここに等級シンボルマップ
```

また、複数の異なるタイプの視覚化を組み合わせて、複雑な地理的パターンを示すこともできます。例えば、下の地図の症例（点）は、最も近い医療施設に応じて色分けされています（凡例参照）。大きな赤い円は、一定の半径を持つ<u>医療施設のキャッチメントエリア</u>を示し、赤色の症例点は、キャッチメントの範囲外にあるケースを示しています。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_hf_catchment.png"))
```

注：この GIS ページの主な焦点は、現場でのアウトブレイク対応の状況に基づいています。そのため、このページの内容は、基本的な空間データの操作、視覚化、および分析をカバーしています。


<!-- ======================================================= -->
## 準備 {  }

### パッケージを読み込む {.unnumbered}  

このコードチャンクは、分析に必要なパッケージのロードを示しています。
このハンドブックでは、**pacman** の `p_load()` を使うことを強調しています。
`p_load()` は、必要に応じてパッケージをインストールし、<u>そして</u>使用するためにパッケージをロードします。
base R から library() を使用してパッケージをロードすることもできます。
R のパッケージについての詳細は[R basics]のページを参照してください。

```{r}
pacman::p_load(
  rio,           # データをインポート
  here,          # ファイルの位置を探す
  tidyverse,     # データを処理、プロット (ggplot2 パッケージを含む)
  sf,            # Simple Featureフォーマットによる空間データの管理
  tmap,          # シンプルな地図を作成、インタラクティブな地図と静的な地図の両方に対応
  janitor,       # 列名のクリーニング
  OpenStreetMap, # ggplot map に OSM ベースマップを追加
  spdep          # 空間統計
  ) 
                  
```

[CRAN "Spatial Task View"](https://cran.r-project.org/web/views/Spatial.html)では、空間データを扱うすべてのRパッケージの概要を見ることができます。

### サンプルケースのデータ {.unnumbered}

デモのために、シミュレーションされたエボラ出血熱の `linelist` データフレームから1000件のランダムなサンプルを使って作業します（計算上、少ない件数で作業した方が、このハンドブックでの表示が容易になります）。続いて、<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>「きれいな」linelist</a>をクリックしてダウンロードできます（.rdsファイル）。 

ここではランダムにサンプルを取っているので、実際にコードを実行してみると、ここでデモされているものとは若干異なる結果になるかもしれません。

データを **rio** パッケージの `import()` 関数を使ってインポートします（.xlsx, .csv, .rds など多くのファイルタイプを扱えます - 詳細は [Import and export] ページを参照してください）。 

```{r, echo=F}
# きれいな linelist ケースをインポート
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))  
```

次に、R の **base** から `sample()` を使って1000行のランダムなサンプルを選択します。  

```{r}
# linelist の行数から1000個のランダム行番号を生成
sample_rows <- sample(nrow(linelist), 1000)

# サンプ行の全ての列だけを保持する linelist にサブセット化する
linelist <- linelist[sample_rows,]
```

このデータフレームクラスの `linelist` をクラス "sf"（空間フィーチャ）のオブジェクトに変換したいと思います。この linelist には、各ケースの居住地の経度と緯度を表す "lon" と "lat" の2つの列があるので、これは簡単です。 

ここでは、**sf**（空間的フィーチャ）パッケージとその関数 `st_as_sf()` を使用して、`linelist_sf` という新しいオブジェクトを作成します。この新しいオブジェクトは、基本的には linelist と同じですが、列 `lon` と `lat` を座標列として指定し、ポイントを表示する際の座標参照系 (CRS) を割り当てています。4326では、GPS座標の標準である[World Geodetic System 1984 (WGS84)](https://gisgeography.com/wgs84-world-geodetic-system/)に基づいた座標が指定されています。  

<!-- 訳注：引数の crs には、空間参照ID (SRID) を与えているようです。
SRID としてもっともよく用いられているのは EPSG によるものです。
ここで用いられているのは、緯度経度で座標を表す地理座標系ですが、4326は米国が構築・維持しています。
日本では、2000年に大幅な見直しが行われ（JGD2000）、東日本大震災後の大規模地殻変動で再び見直されました（JGD2011）。

| 座標 | EPSG | 対象地域 |
| :--- | :--- | :------- |
| 緯度経度 | 4326 | 米国 |
| 緯度経度 | 3857 | ウェブ地図 |
| 緯度経度 | 4612 | 日本（JGD2000） |
| 緯度経度 | 6668 | 日本（JGD2011） | -->


```{r}
# sf オブジェクトを生成
linelist_sf <- linelist %>%
     sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

これがオリジナルの `linelist` データフレームの外観です。このデモでは、`date_onset` と `geometry`（上記の経度と緯度のフィールドから作成されたもので、データフレームの最後の列）の列のみを使用します。 

```{r}
DT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### 行政境界シェープファイル {.unnumbered}  

**シエラレオネ (Sierra Leone): 行政境界シェープファイル**  

事前に、Humanitarian Data Exchange (HDX) [ウェブサイトはこちら](https://data.humdata.org/dataset/sierra-leone-all-ad-min-level-boundaries)からシエラレオネのすべての行政（admin）境界データをダウンロードしておきました。また、[Download handbook and data] のページで説明しているように、これらのデータやその他のハンドブックのサンプルデータは、私たちのRパッケージを介してダウンロードすることができます。 

それでは、Admin Level 3 のシェープファイルを R に保存するために、以下の作業を行います。 

1) シェープファイルのインポート  
2) 列名のクリーンアップ  
3) 興味のあるエリアだけを残すために行をフィルターする  

シェープファイルをインポートするには、**sf** の `read_sf()` 関数を使います。ファイルのパスは `here()` で与えられます。- ここでは、Rプロジェクトの "data"、"gis"、"shp" というサブフォルダにファイル名 "sle_adm3.shp" として格納されています（詳細は [Import and export] と [R Project] のページを参照してください）。独自のファイルパスを設定する必要があります。

```{r, echo=F}
sle_adm3_raw <- sf::read_sf(here("data", "gis", "shp", "sle_adm3.shp"))
```

次に、**janitor** パッケージの `clean_names()` を使って、シェープファイルの列名を標準化します。また、`filter()` を使って、admin2name が "Western Area Urban" または "Western Area Rural" の行だけを残します。   

```{r}
# ADM3 level clean
sle_adm3 <- sle_adm3_raw %>%
  clean_names() %>% # 列名の標準化
  filter(admin2name %in% c("Western Area Urban", "Western Area Rural")) # 特定の地域を残してフィルター
```

下の表は、インポートとクリーニング後のシェープファイルの様子です。*右側にスクロールして*、admin レベル0（国）、admin レベル1、admin レベル2、そして最後に admin レベル3の列があることがわかります。それぞれのレベルには、キャラクター名と固有の識別子「pcode」があります。たとえば、SL（Sierra Leone） -> SL04（Western） -> SL0410（Western Area Rural）-> SL040101（Koya Rural）のように、pcode は admin レベルが上がるごとに拡張されます。 

```{r message=FALSE, echo=F}
# shapefile を表として表示
DT::datatable(head(sle_adm3, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### 人口データ {.unnumbered}

**Sierra Leone: ADM3ごとの人口**  

これらのデータは、HDXからダウンロードすることもできますし（リンク[こちら](https://data.humdata.org/dataset/sierra-leone-population)）、本ページ[ハンドブックとデータのダウンロード]で説明しているように、**epirhandbook** Rパッケージを介してダウンロードすることもできます。.csv ファイルの読み込みには、`import()` を使用します。また、インポートしたファイルを `clean_names()` に渡して列名の構文を標準化します。

```{r}
# ADM3 ごとの人口
sle_adm3_pop <- import(here("data", "gis", "population", "sle_admpop_adm3_2020.csv")) %>%
  clean_names()
```

人口ファイルはこのようになっています。右にスクロールすると、各管轄区域に `male`、`female`、`total` の列があり、さらに年齢層別の列に人口の内訳が表示されています。 

```{r message=FALSE, echo=F}
# 人口を表として表示
DT::datatable(head(sle_adm3_pop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### 医療施設 {.unnumbered}

**Sierra Leone: OpenStreetMap からの医療施設**  

今回も HDX から医療施設の位置情報をダウンロードしました。[こちら](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities) または [Download handbook and data] ページの指示に従ってください。  

施設ポイントのシェープファイルを `read_sf()` でインポートし、列名をクリーンにしてから、hospital、clinic、doctor のいずれかにタグ付けされたポイントだけを残すようにフィルタリングしました。 

```{r}
# OSM 医療施設の shapefile
sle_hf <- sf::read_sf(here("data", "gis", "shp", "sle_hf.shp")) %>% 
  clean_names() %>%
  filter(amenity %in% c("hospital", "clinic", "doctors"))
```

<u>右にスクロールする</u>と、施設名と `geometry` 座標が表示されます。 

```{r message=FALSE, echo=F}
# 人口を表として表示
DT::datatable(head(sle_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## 座標のプロット {  }

X-Y座標（経度・緯度、点）をプロットする最も簡単な方法は、このケースの場合、準備編で作成した `linelist_sf` オブジェクトから直接、点として描画することです。

パッケージ **tmap** は、わずか数行のコードで、静的（plot モード）とインタラクティブ（view  モード）の両方に対応したシンプルなマッピング機能を提供します。
**tmap** の構文は **ggplot2** と似ていて、コマンド同士を `+` で追加していきます。詳しくはこの [vignette](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) をご覧ください。


1) **tmap**モードを設定。ここでは plot モードを使い、静的なアウトプットを作成します。  

```{r, warning = F, message=F}
tmap_mode("plot") # "view" または "plot" を選択
```

以下では、点を単独でプロットしています。`tm_shape()` は、`linelist_sf` オブジェクトとともに提供されます。
次に、`tm_dots()` でサイズと色を指定してポイントを追加します。
`limelist_sf` は sf オブジェクトなので、緯度・経度座標と座標系(CRS)を格納する2つの列は既に指定されています。

```{r, warning = F, message=F}
# ケース（点）のみ
tm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')
```

点だけでは、あまり意味がありません。そこで、行政境界もマッピングする必要があります。 

ここでも `tm_shape()` を使いますが（[documentation](https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape)参照）、症例点のシェープファイルを提供する代わりに、行政境界のシェープファイル（ポリゴン）を提供します。 

`bbox = ` の引数（bboxは "bounding box"の略）で、座標の境界を指定することができます。まず `bbox` なしの地図表示を行い、次に `bbox` ありの地図表示を行います。 

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# 行政境界（ポリゴン）のみ
tm_shape(sle_adm3) +               # 行政境界shapefile
  tm_polygons(col = "#F7F7F7")+    # ポリゴンを薄い灰色で表示
  tm_borders(col = "#000000",      # 境界を色と線の太さで表示
             lwd = 2) +
  tm_text("admin3name")            # 各ポリゴンについて表示する列テキスト


# 上と同様、ただしバウンディングボックスから縮尺指定
tm_shape(sle_adm3,
         bbox = c(-13.3, 8.43,    # 角
                  -13.2, 8.5)) +  # 角
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")

```

そして、今度は点とポリゴンの両方を一緒に表示します。

```{r, warning=F, message=FALSE}
# すべてまとめる
tm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")+
tm_shape(linelist_sf) +
  tm_dots(size=0.08, col='blue', alpha = 0.5) +
  tm_layout(title = "エボラ症例の分布",                    # 地図にタイトルを付ける
            title.fontfamily = gis_jfontname)              # フォントは macOS では、"HiraginoSans-W3" など

```

Rでのマッピングオプションの比較については、こちらの [ブログ記事](https://rstudio-pubs-static.s3.amazonaws.com/324400_69a673183ba449e9af4011b1eeb456b9.html) をご覧ください。 

<!-- ======================================================= -->
## 空間結合 {}

あるデータセットのデータを別のデータセットに <u>join</u> することはよく知られているでしょう。いくつかの方法は、このハンドブックの [Joining data] のページで説明しています。空間結合は、同様の目的を持ちますが、空間的な関係を利用します。観測値を正しく一致させるために列の共通の値に頼るのではなく、あるフィーチャが他のフィーチャの中に入っているとか、他のフィーチャに<u>最近傍</u>であるとか、他のフィーチャから一定の半径の<u>バッファ</u>内にあるなど、空間的な関係を利用することができます。 


**sf** パッケージには、空間結合のための様々なメソッドが用意されています。st_join メソッドや空間結合の種類については、こちらの[参考文献](https://r-spatial.github.io/sf/reference/geos_binary_pred.html)に詳しい説明があります。 


### ポリゴン内の点 {.unnumbered}
**ケースに行政単位を空間的に割り当てる**。

ここで興味深い問題があります。ケースの linelist には、ケースの admin 単位に関する情報が含まれていません。このような情報は、最初のデータ収集段階で収集するのが理想的ですが、空間的な関係（つまり、点がポリゴンと交差する）に基づいて、個々のケースに admin 単位を割り当てることもできます。 

以下では、ケースの位置（点）と ADM3 の境界（ポリゴン）を空間的に交差させます。 

1) linelist（点）から始める  
2) 結合のタイプを "st_intersects" に設定して、境界線に空間的に結合する
3) `select()` を使用して、新しい行政境界列のうち特定のものだけを残す  

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # 空間交差に基づいて行政境界を linelist に結合
  sf::st_join(sle_adm3, join = st_intersects)
```

`sle_adms` のすべての列が linelist に追加されました! 各ケースには、該当するadminレベルの詳細を示す列が追加されました。この例では、新しい列のうち2つ（admin レベル3）だけを残したいので、古い列名を `select()` して、追加したい2つだけを選択します。 

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # 空間交差に基づいて、行政境界ファイルを linelist に結合
  sf::st_join(sle_adm3, join = st_intersects) %>% 
  
  # 古い列名はそのままに、新たに2つの admin の列名を追加
  select(names(linelist_sf), admin3name, admin3pcod)
```

下の図は、最初の10件と、ポリゴン図形と空間的に交差する点に基づいて付けられた admin レベル3（ADM3）の行政境界を表示しています。

```{r, warning=F, message=F}
# これで、各ケースに ADM3 名がついたことが確認できます。
linelist_adm %>% select(case_id, admin3name, admin3pcod)
```

空間結合の前にはできなかった、行政単位でのケースの表現が可能になりました。

```{r, warning=F, message=F}
# 行政単位ごとにケースの数を含むデータフレームを新規作成
case_adm3 <- linelist_adm %>%          # 新しい admin 列を含む linelist で始める
  as_tibble() %>%                      # 見やすいように tibble に変換
  group_by(admin3pcod, admin3name) %>% # 名前と pcode で行政単位をグループ化
  summarise(cases = n()) %>%           # 要約と行数のカウント
  arrange(desc(cases))                 # 下り順に並べ替え

case_adm3
```

また、行政単位ごとの症例数の棒グラフを作成することもできます。 

この例では、`ggplot()` を `linelist_adm` で始めているので、頻度で棒グラフを並べる `fct_infreq()` などのファクタ関数を適用することができます（ヒントは [Factors] のページを参照してください）。 

```{r, warning=F, message=F}
ggplot(
    data = linelist_adm,                     # admin unit 情報を含む linelist で始める
    mapping = aes(
      x = fct_rev(fct_infreq(admin3name))))+ # x軸は行政単位、件数で並べ替え
  geom_bar()+                                # 帽を作成、高さは行数
  coord_flip()+                              # adm を読みやすくするためにXとYを入れ替える
  theme_classic(base_family = gis_jfontname)+   # 背景を単純に、フォントは macOS では、"HiraginoSans-W3" など
  labs(                                      # タイトルとラベル
    x = "Admin level 3",
    y = "ケース数",
    title = "行政単位ごとのケース数",
    caption = "linelistからのランダムな1000個のサンプルから空間結合で決定"
  )
```


<!-- ======================================================= -->
### 最近傍 {.unnumbered}

**最寄の医療施設／集客エリアを探す**  

病気のホットスポットに関連して、医療施設がどこにあるかを知っておくと便利かもしれません。

ここでは、`st_join()` 関数(**sf** パッケージ)の <u>st_nearest_feature</u> 結合メソッドを使って、個々のケースに最も近い医療施設を可視化することができます。 

1) まず、シェープファイルのラインリスト `linelist_sf` を用意します。 
2) 保健施設や診療所の位置（点）である `sle_hf` と空間的に結合します。 

```{r, warning=F, message=F}
# 各ケースに最も近い医療施設
linelist_sf_hf <- linelist_sf %>%                  # linelist shapefile で始める
  st_join(sle_hf, join = st_nearest_feature) %>%   # ケースデータから最も近いクリニックからのデータ
  select(case_id, osm_id, name, amenity) %>%       # 残しておくべき列、例えば id, name, type, と医療施設の位置情報
  rename("nearest_clinic" = "name")                # 分かりやすいように名前を変更
```

以下（最初の50行）のように、それぞれの症例には最寄りのクリニックや病院のデータがあることがわかります。 

```{r message=FALSE, echo=F}
DT::datatable(head(linelist_sf_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

約30％のケースで "Den Clinic" が最も近い医療機関であることがわかります。

```{r}
# 医療施設ごとにケースを数える
hf_catchment <- linelist_sf_hf %>%   # 最寄りのクリニックデータを含むlinelistで始める
  as.data.frame() %>%                # shapefile をデータフレームに変換
  count(nearest_clinic,              # （クリニックの）"name" で行を数える
        name = "case_n") %>%         # 数えたデータの列に "case_n" と命名
  arrange(desc(case_n))              # 下がり順で並べ替え

hf_catchment                         # console に表示
```

結果を可視化するために、**tmap** を使用することができます。 

```{r, warning=F, message=F}
tmap_mode("view")   # tmap モードをインタラクティブに設定

# ケースとクリニックの点をプロット
tm_shape(linelist_sf_hf) +            # ケースをプロット
  tm_dots(size=0.08,                  # 最も近いクリニックでケースを色分け
          col='nearest_clinic') +    
tm_shape(sle_hf) +                    # クリニックを大きい黒い点でプロット
  tm_dots(size=0.3, col='black', alpha = 0.4) +      
  tm_text("name") +                   # 施設名でオーバーレイ
tm_view(set.view = c(-13.2284, 8.4699, 13), # 縮尺を調整 (中心座標, zoom)
        set.zoom.limits = c(13,14))+
tm_layout(title = "最寄りのクリニックで色分けされたケース")
```


### バッファ {.unnumbered} 

また、最も近い医療施設から徒歩2.5km（約30分）以内にあるケースがどれくらいあるかを調べることもできます。

<u>注: より正確な距離を計算するためには、UTM（地球を平面に投影したもの）などの各地域の地図投影系にsfオブジェクトを再投影するのがよいでしょう。この例では、簡単にするために、世界測地系（WGS84）の地理的座標系（地球は球状/円形の表面で表現され、そのため単位は10進法の度数）にこだわります。ここでは、一般的な換算方法を用います。ここでは、一般的な換算として、1度＝～111kmとします。</u>

地図投影法と座標系については、こちらの[esriの記事](https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/)をご覧ください。こちらの
[ブログ](http://www.geo.hunter.cuny.edu/~jochen/gtech201/lectures/lec6concepts/map%20coordinate%20systems/how%20to%20choose%20a%20projection.htm) 
では、様々なタイプの地図投影について、また、興味のある分野や地図・分析の文脈に応じて、どのように適切な投影を選ぶことができるかについて述べられています。


**まず**、各医療施設の周囲に半径約2.5kmの円形バッファを作成します。これは **tmap** の関数 `st_buffer()` で行います。地図の単位は緯度・経度の10進法であるため、"0.02" は度数として解釈されます。地図の座標系がメートル単位の場合は、数値もメートル単位で指定する必要があります。 

```{r, warning=F, message=F}
sle_hf_2k <- sle_hf %>%
  st_buffer(dist=0.02)       # 約2.5kmに度数を変換
```

以下のように、バッファゾーン自体を作ります。

```{r, warning=F, message=F}
tmap_mode("plot")
# 円バッファを作成
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2)+
tm_shape(sle_hf) +                    # クリニックを大きい赤丸でプロット
  tm_dots(size=0.3, col='black')      
```


**次に**、`st_join()`と <u>st_intersects</u> の結合タイプを使って、これらのバッファとケース（点）を交差させます。つまり、バッファからのデータは、それらが交差する点に結合されます。

```{r, warning=F, message=F}
# バッファでケースを交差
linelist_sf_hf_2k <- linelist_sf_hf %>%
  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%
  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%
  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)
```

これで、結果を数えることができます。`nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),])` 1000件のうち、どのバッファとも交差していない（値が欠けている）ので、最寄りの医療施設から徒歩30分以上の場所に住んでいることになります。

```{r}
# どの医療施設バッファとも交差しなかったケース
linelist_sf_hf_2k %>% 
  filter(is.na(osm_id.y)) %>%
  nrow()
```

その結果、どのバッファとも交わらなかったケースが赤で表示されるように可視化されます。 

```{r, out.width = '100%', warning=F, message=F}
tmap_mode("view")

# まずケースを点で表示
tm_shape(linelist_sf_hf) +
  tm_dots(size=0.08, col='nearest_clinic') +

# クリニックを大きい黒点でプロット
tm_shape(sle_hf) +                    
  tm_dots(size=0.3, col='black')+   

# 医療施設バッファをポリラインで重ねる
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2) +

# どの医療施設バッファにもないケースを赤点で強調
tm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +
  tm_dots(size=0.1, col='red') +
tm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+

# タイトルを追加
tm_layout(title = "クリニックのキャッチメントでのケース分類")

```


### 他の空間結合 {.unnumbered}  

`join`の引数は、このほかに以下の値をとります。 ([ドキュメント](https://r-spatial.github.io/sf/reference/st_join.html)より)

* st_contains_properly  
* st_contains  
* st_covered_by  
* st_covers  
* st_crosses  
* st_disjoint  
* st_equals_exact  
* st_equals  
* st_is_within_distance  
* st_nearest_feature  
* st_overlaps  
* st_touches  
* st_within  


## 色分け（Choropleth）地図 {}

色分け地図は、あらかじめ定義されたエリア（通常は行政単位や保健エリア）ごとにデータを視覚化するのに役立ちます。例えば、感染発生対応では、発生率の高い特定の地域にリソースを割り当てる際に役立ちます。

すべての症例に行政単位名が割り当てられたので（上記の「空間結合」のセクションを参照）、症例数をエリア別にマッピングすることができます（コロプレマップ）。

ADM3ごとの人口データもあるので、この情報を先に作成した <u>case_adm3</u> テーブルに追加することができます。

まず、前のステップで作成したデータフレーム `case_adm3` から始めます。これは、各行政単位とその症例数の要約表です。 

1) 人口データ `sle_adm3_pop` は、**dplyr** の `left_join()` を用いて、`case_adm3` データフレームの `admin3pcod` 列と `sle_adm3_pop` データフレームの `adm_pcode` 列に共通する値に基づいて結合されています。データの結合]のページを参照）。 
2) `select()` を新しいデータフレームに適用して、有用な列だけを残す - `total` は総人口です。 
3) `mutate()`を用いて、人口10,000人あたりの症例数を新しい列として計算する。

```{r}
# 人口データを追加し、１万人当たりの症例数を計算
case_adm3 <- case_adm3 %>% 
     left_join(sle_adm3_pop,                             # 人口データから列を追加　
               by = c("admin3pcod" = "adm3_pcode")) %>%  # 二つの列の共通の値に基づく結合
     select(names(case_adm3), total) %>%                 # 重要な列のみ保持、総人口など
     mutate(case_10kpop = round(cases/total * 10000, 3)) # 10000あたりのケース数の列を作成、小数点以下３桁で四捨五入

case_adm3                                                # console に表示
```

このテーブルをADM3 polygons shapefileと結合してマッピングします。

```{r, warning=F, message=F}
case_adm3_sf <- case_adm3 %>%                 # 行政単位でのケースと感染率で始める
  left_join(sle_adm3, by="admin3pcod") %>%    # shapefile データと共通列で結合
  select(objectid, admin3pcod,                # 指定した列のみ保持
         admin3name = admin3name.x,           # 一つの列名をきれいにする
         admin2name, admin1name,
         cases, total, case_10kpop,
         geometry) %>%                        # プロットできるように座標を保持
  st_as_sf()                                  # shapefile に変換

```

結果をマッピング。

```{r, message=F, warning=F}
case_adm3_sf <- na.omit(case_adm3_sf)

# tmap mode
tmap_mode("plot")               # 静的地図を表示

# ポリゴンをプロット
tm_shape(case_adm3_sf) + 
        tm_polygons("cases") +  # 症例数の列で色分け
        tm_text("admin3name")   # 表示に名前を付ける
```

インシデンス率もまた地図にします。

```{r, warning=F, message=F}
# 1万人あたりのケース
tmap_mode("plot")             # 静的ビューモード

# プロット
tm_shape(case_adm3_sf) +                # ポリゴンをプロット
  tm_polygons("case_10kpop",            # 症例率を含む列で色分け
              breaks=c(0, 10, 50, 100), # 色分けの値を定義
              palette = "Purples"       # 紫色のカラーパレットを使用
              ) +
  tm_text("admin3name")                 # テキストを表示

```

## ggplot2 で地図作成

すでに **ggplot2** の使用に慣れている場合は、データの静的なマップを作成する代わりに、このパッケージを使用することができます。関数 `geom_sf()` は、データに含まれる特徴 (点、線、多角形) に応じて異なるオブジェクトを描画します。例えば、ポリゴンを含む `sf` データを使った `ggplot()` の中で `geom_sf()` を使うと、色分け地図を作ることができます。

これがどのように機能するかを説明するために、先ほど使用した ADM3 ポリゴンのシェープファイルから始めましょう。このポリゴンは、シエラレオネの Admin Level 3 の地域であることを思い出します。

```{r}
sle_adm3
```

**dplyr** の `left_join()` 関数を使って、マッピングしたいデータをシェープファイルオブジェクトに追加することができます。この例では、先ほど作成した `case_adm3` データフレームを使って、行政区ごとの症例数をまとめていますが、データフレームに格納されているどのようなデータでも、同様の方法でマッピングすることができます。

```{r}
sle_adm3_dat <- sle_adm3 %>% 
  inner_join(case_adm3, by = "admin3pcod") # inner join = どちらのデータオブジェクトにもある場合にのみ残す

select(sle_adm3_dat, admin3name.x, cases) # console に選択した変数を表示
```

**ggplot2** を使って、地域別の症例数の柱状図を作成するには、次のように `geom_col()` を呼び出します。

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +
  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # 'cases' 下がり順でx軸を並べ替え
               y=cases)) +                                  # y軸は地域ごとのケース数
  theme_bw(base_family = gis_jfontname) +                   # フォントは macOS では、"HiraginoSans-W3" など
  labs(                                                     # 図のテキストを設定
    title="行政単位のケース数",
    x="Admin level 3",
    y="ケース数"
  ) + 
  guides(x=guide_axis(angle=45))                            # 見やすいようにx軸を45度傾ける

```

もし、**ggplot2** を使ってケース数の色分け地図を作りたい場合は、同様の構文で `geom_sf()` 関数を呼び出すことができます。

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) + 
  geom_sf(aes(fill=cases))    # 症例数で塗りつぶしが変化するように設定

```

そして、例えば、**ggplot2** で統一されている文法を使って、地図の外観をカスタマイズすることができます。

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +                           
  geom_sf(aes(fill=cases)) +						
  scale_fill_continuous(high="#54278f", low="#f2f0f7") +    # 色の段階を変更
  theme_bw(base_family = gis_jfontname) +                   # フォントは macOS では、"HiraginoSans-W3" など
  labs(title = "行政単位でのケース数",                      # 図のテキストを設定
       subtitle = "Admin level 3"
  )
```



**ggplot2** に慣れているRユーザーにとって、`geom_sf()`はシンプルで直接的な実装であり、基本的な地図の可視化に適しています。詳しくは、[geom_sf() vignette](https://ggplot2.tidyverse.org/reference/ggsf.html)または[ggplot2 book](https://ggplot2-book.org/maps.html)をご覧ください。




<!-- ======================================================= -->
## ベースマップ { }

### OpenStreetMap {.unnumbered} 

以下では、OpenStreetMap の機能を使って **ggplot2** マップのベースマップを作成する方法を説明します。他の方法としては、Googleへの無料登録が必要な **ggmap** を使用する方法があります([詳細](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/ggmap-basemap/))。

[**OpenStreetMap**](https://en.wikipedia.org/wiki/OpenStreetMap)は、自由に編集可能な世界地図を作成する共同プロジェクトです。このプロジェクトの基本となるジオロケーション・データ（都市、道路、自然、空港、学校、病院、道路などの位置情報）は、このプロジェクトの主要なアウトプットと考えられています。

まず、**OpenStreetMap** パッケージをロードして、そこからベースマップを取得します。 

次に、オブジェクト `map` を作成します。これは、**OpenStreetMap** パッケージの関数 `openmap()` を使用して定義します ([documentation](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/openmap))。以下のものを用意します。


* `upperLeft` and `lowerRight` ベースマップタイルの限界を指定する2つの座標ペア。 
  * ここでは、ラインリストの行の最大値と最小値を入れているので、マップはデータにダイナミックに反応します。 
* `zoom = ` (nullの場合は自動的に決定されます)  
* `type =` ベースマップの種類 - ここではいくつかの可能性を挙げていますが、コードは現在、最初のもの（`[1]`）である "osm" を使用しています。 
* `mergeTiles = ` TRUEを選択したので、ベースタイルはすべて1つに統合されます。

```{r, message=FALSE, warning=FALSE}
# パッケージをロード
pacman::p_load(OpenStreetMap)

# 緯度経度の範囲にベースマップを切り取る。タイル種別を選択。
map <- openmap(
  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # ベース地図のタイルの制限
  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),
  zoom = NULL,
  type = c("osm", "stamen-toner", "stamen-terrain", "stamen-watercolor", "esri","esri-topo")[1])
```

今、このベースマップを **OpenStreetMap** パッケージの `autoplot.OpenStreetMap()` を使ってプロットしてみると、軸の単位が緯度・経度座標ではない違う座標系を使っていることがわかります。緯度/経度で保存されている）ケースの住宅を正しく表示するには、これを変更する必要があります。 

```{r, warning=F, message=F,eval=F}
autoplot.OpenStreetMap(map)
```

そこで、 **OpenStreetMap** パッケージの `openproj()` 関数を使って、地図を緯度/経度に変換したいと思います。ベースマップ `map` と、必要な座標系（CRS）を指定します。ここでは、WGS 1984投影の "proj.4"文字列を指定していますが、他の方法でCRSを指定することもできます。(proj.4文字列が何であるかを理解するには、[このページ](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/understand-epsg-wkt-and-other-crs-definition-file-types/)を参照してください)  

```{r, warning=F, message=F}
# 座標系 WGS84
map_latlon <- openproj(map, projection = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
```

プロットを作成すると、軸に沿って緯度と経度の座標が表示されています。これで座標系が変換されたことになります。これで、ケースを重ね合わせても正しくプロットできるようになりました。 

```{r, warning=F, message=F}
# 地図をプロット。ggplot を使うためには、"autoplot" が必須。
autoplot.OpenStreetMap(map_latlon)
```

詳しくはチュートリアル[こちら](http://data-analytics.net/cep/Schedule_files/geospatial.html)と[こちら](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/autoplot.OpenStreetMap)をご覧ください。 



## 等高線密度ヒートマップ {}

以下では、ベースマップの上に症例の等高線付き密度ヒートマップを作成する方法を説明しますが、まずラインリストから始めます（1症例につき1行）。

1) 上述のように OpenStreetMap からベースマップタイルを作成する  
2) `linelist` の症例を、緯度と経度の列を使ってプロットする。 
3) **ggplot2** の `stat_density_2d()` を使って、ポイントを密度ヒートマップに変換する。

緯度・経度座標を持つベースマップがあれば、その上に事例の居住地の緯度・経度座標を使ってプロットすることができます。

ベースマップを作成するための関数 `autoplot.OpenStreetMap()` をベースにして、**ggplot2** 関数を使えば、以下の `geom_point()` のように簡単に上に追加することができます。 

```{r, warning=F, message=F}
# 地図をプロット。ggplot と使うためには autoplot が必須。
autoplot.OpenStreetMap(map_latlon)+                 # ベース地図から始める
  geom_point(                                       # linelist の経度と緯度の列から xy の点を追加
    data = linelist,                                
    aes(x = lon, y = lat),
    size = 1, 
    alpha = 0.5,
    show.legend = FALSE) +                          # 凡例を完全に削除
  labs(x = "経度",                                  # タイトルとラベル
       y = "緯度",
       title = "総ケース数") +
  theme_bw(base_family = gis_jfontname)             # フォントは macOS では、"HiraginoSans-W3" など
```

上のマップは、特にポイントが重なっているため、解釈が難しいかもしれません。そこで、 **ggplot2** 関数 `stat_density_2d()` を用いて 2 次元密度マップを作成することができます。ラインリストの緯度/軽度座標を使用していますが、2D カーネル密度推定を行い、その結果を等高線で表示します（地形図のように）。完全な[ドキュメントはこちら](https://ggplot2.tidyverse.org/reference/geom_density_2d.html)をご覧ください。 

```{r, warning=F, message=F}
# ベース地図から始める
autoplot.OpenStreetMap(map_latlon)+
  
  # 密度プロットを追加
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # カラースケールを指定
  scale_fill_gradient(low = "black", high = "red")+
  
  # ラベル 
  labs(x = "経度",
       y = "緯度",
       title = "総ケース数の分布") +
  
  # フォントは macOS では、"HiraginoSans-W3" など
  theme_bw(base_family = gis_jfontname)
```





<!-- ======================================================= -->
### タイムシリーズヒートマップ {.unnumbered}

上の密度ヒートマップは、<u>累積症例</u>を示しています。このヒートマップをラインリストから得られた<u>症状の発症月</u>に基づいてファセット化することで、時空間的なアウトブレイクを調べることができます。 

訳注：facet とはなんだ？

まず、`linelist`で、発症した年と月の新しい列を作成します。**base** Rの `format()` 関数は、日付の表示方法を変更します。ここでは "YYYY-MM"とします。 

```{r, warning=F, message=F}
# 発症した月を抽出
linelist <- linelist %>% 
  mutate(date_onset_ym = format(date_onset, "%Y-%m"))

# 値を調査
table(linelist$date_onset_ym, useNA = "always")
```

ここでは、密度ヒートマップに **ggplot2** によるファセットを導入するだけです。`facet_wrap()` が適用され、新しい列が行として使用されます。わかりやすくするために、ファセット列の数を3に設定しました。 

```{r, warning=F, message=F}
# パッケージ
pacman::p_load(OpenStreetMap, tidyverse)

# ベース地図から始める
autoplot.OpenStreetMap(map_latlon)+
  
  # 密度プロットを追加
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # カラースケールを指定
  scale_fill_gradient(low = "black", high = "red")+
  
  # ラベル
  labs(x = "経度",
       y = "緯度",
       title = "一定期間の総ケース数の分布")+
  
  # facet the plot by month-year of onset
  facet_wrap(~ date_onset_ym, ncol = 4) +

  # フォントは macOS では、"HiraginoSans-W3" など
  theme_bw(base_family = gis_jfontname)
```



<!-- SPATIAL STATISTICS SECTION IS UNDER DEVELOPMENT --> 
## 空間統計

これまでの議論のほとんどは、空間データの視覚化に焦点を当ててきました。場合によっては、<u>空間統計</u>を使用し、データ内の属性の空間的な関係を定量化すことにも興味があるでしょう。ここでは、空間統計の主要な概念を簡単に説明し、より包括的な空間分析を行いたい場合に参考となるリソースを紹介します。

### 空間的な関係 {.unnumbered}

空間統計を計算する前に、データのフィーチャ間の関係を特定する必要があります。空間的な関係を概念化する方法は数多くありますが、シンプルで一般的に適用できるモデルは「隣接関係」です。具体的には、境界を共有している、または「隣り合っている」エリア間に地理的な関係があると考えます。

**spdep**パッケージで使用している　`sle_adm3`　データの行政区域ポリゴン間の隣接関係を定量化することができます。ここでは、<u>共辺または共点</u>隣接 (*queen* contiguity) を指定します。
こちらは、地域がその境界に沿って少なくとも1つのポイントを共有していれば、隣り合っていることを意味します。
この他には、<u>共点</u>隣接 (*rook*) を指定することもできます。
こちらは、地域がその境界に沿って境界縁を共有していれば、隣り合っていることを意味します。
この違いは些細なことですが、この事例は不規則なポリゴンですので、場合によっては queen と rook の選択が影響を与えることもあります。 

```{r}
sle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # 隣接を作成
sle_adjmat <- spdep::nb2mat(sle_nb)    # 隣接関係をまとめた行列の作成
sle_listw <- spdep::nb2listw(sle_nb)   # listw (list of weights) オブジェクトを作成 -- 後で使います

sle_nb
round(sle_adjmat, digits = 2)
```

上の図は、`sle_adm3` データの9つのリージョン間の関係を示しています。スコア0は2つの地域が隣り合っていないことを示し、0以外の値は隣り合っていることを示しています。行列の値は、各地域の行の重みの合計が1になるようにスケーリングされています。

これらの隣接関係を視覚化するより良い方法は、プロットすることです。

```{r, fig.align='center', results='hide'}
plot(sle_adm3_dat$geometry) +                                           # 地域境界をプロット
  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # 隣接関係を追加
```

ここでは、隣接するポリゴンを特定するために、隣接アプローチを用いました。特定した隣接は、**隣接ベース近傍** (**contiguity-based neighbors**) と呼ばれることもあります。しかし、これは、どの地域が地理的な関係を持っていると予想されるかを選択する一つの方法に過ぎません。地理的関係を特定するため別の方法で、最も一般的な方法は、以下のような**距離ベース近傍**を生成することです。
  
  * **K-最近傍** - セントロイド（各ポリゴン領域の地理的に重み付けされた中心）間の距離に基づいて、*n*個の最も近い領域を近傍として選択します。最大距離の近さのしきい値を指定することもできます。**spdep** では、`knearneigh()` が使えます（[documentation](https://r-spatial.github.io/spdep/reference/knearneigh.html)参照）。
  
  * **距離閾値近傍** - 距離閾値以内のすべての近傍を選択します。**spdep** では、これらの近傍関係は `dnearneigh()` を使って特定できます（[documentation](https://www.rdocumentation.org/packages/spdep/versions/1.1-7/topics/dnearneigh)参照）。

### 空間的自己相関 {.unnumbered}

よく引用されるトブラーの地理学の第一法則では、「すべてのものは他のすべてのものに関係しているが、近くのものは遠くのものより関係している」とされています。疫学においては、ある地域における特定の健康結果のリスクは、遠くの地域よりも近隣の地域に類似していることを意味していることが多い。この概念は、「空間的自己相関」として正式に定義されています。これは、類似した値を持つ地理的フィーチャが空間的に集まっているという統計的特性です。空間的自己相関の統計的測定は、データにおける<u>空間的クラスタリングの程度を定量化</u>し、クラスタリングが発生する場所を特定し、データ内の異なる変数間の空間的自己相関の<u>共通パターンを特定</u>するために使用することができます。このセクションでは、空間的自己相関の一般的な測定方法とRでの計算方法について説明します。

**Moran's I** - これは、ある地域での変数の値と、近隣の地域での同じ変数の値との間の相関のグローバルな要約統計です。Moran's I統計は、通常、-1から1の範囲です。0の値は、空間的な相関のパターンがないことを示し、1や-1に近い値は、それぞれ空間的な自己相関（似たような値が近くにある）や空間的な分散（似ていない値が近くにある）が強いことを示しています。

例として、先ほどマッピングしたエボラ出血熱の症例の空間的自己相関を定量化するために、Moran's I 統計を計算してみます（これは、シミュレーションされた流行の `linelist` データフレームからの症例のサブセットであることを覚えておいてください）。**spdep** パッケージには、この計算を行うための関数、`moran.test` があります。

```{r}
moran_i <-spdep::moran.test(sle_adm3_dat$cases,    # 指定の変数で数値ベクトル
                            listw=sle_listw)       # 隣接関係を要約したlistwオブジェクト

moran_i                                            # Moran's I 検定の結果を表示
```

`moran.test()` 関数の出力を見ると、Moran's I 統計は `round(moran_i$estimate[1],2)` となっています。これは、データに空間的な自己相関が存在することを示しています。具体的には、エボラ出血熱の患者数が同程度の地域は、近くにある可能性が高いということです。`moran.test()` で得られるp値は、空間的自己相関がないという帰無仮説の下での期待値との比較によって生成され、正式な仮説検定の結果を報告する必要がある場合に使用できます。

**Local Moran's I** - 上で計算した（グローバルな）Moran's I 統計を分解することで、<u>局所的な</u>空間的な自己相関を識別することができ、データ内の特定のクラスターを識別することができます。この統計は、LISA（Local Indicator of Spatial Association）統計と呼ばれることもあり、個々の地域における空間的自己相関の程度を要約したものです。これは、地図上のホットとコールドなスポットを見つけるのに役立ちます。

例として、上で使用したエボラ出血熱の症例数に対して、**spdep** の `local_moran()` 関数を用いて、Local Moran's I を計算し、マップすることができます。

```{r, fig.align='center'}
# local Moran's I を計算
local_moran <- spdep::localmoran(                  
  sle_adm3_dat$cases,                              # 指定の変数
  listw=sle_listw                                  # 隣接の重み付けをした listw オブジェクト
)

# 結果を sf データに結合
sle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    

# 地図をプロット
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=Ii)) +
  theme_bw(base_family = gis_jfontname) +          # フォントは macOS では、"HiraginoSans-W3" など
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Local Moran's I") +
  labs(title="エボラ感染症例の Local Moran's I 統計",
       subtitle="Admin level 3 地域, Sierra Leone")

```



**Getis-Ord Gi*** - これもホットスポット分析によく使われる統計です。この統計が人気である理由は、ArcGISのホットスポット分析ツールで使われていることに関係しています。この統計は、通常、近隣地域間の変数の値の差は正規分布に従うはずだという仮定に基づいています。このツールは、z-score アプローチを使用して、指定された変数の値が近隣の地域に比べて著しく高い（ホットスポット）または著しく低い（コールドスポット）地域を特定します。

**spdep** の `localG()` 関数を使って Gi* 統計量を計算し、マッピングすることができます。 

```{r}
# local G 分析を実行
getis_ord <- spdep::localG(
  sle_adm3_dat$cases,
  sle_listw
)

# 結果を sf データに結合
sle_adm3_dat$getis_ord <- getis_ord

# 地図をプロット
ggplot(data=sle_adm3_dat) +
  theme_bw(base_family = gis_jfontname) +           # フォントは macOS では、"HiraginoSans-W3" など
  geom_sf(aes(fill=getis_ord)) +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Gi*") +
  labs(title="エボラ感染症例の Getis-Ord Gi* 統計",
       subtitle="Admin level 3 regions, Sierra Leone")
```



上のとおり、Getis-Ord Gi* のマップは、先に作成した Local Moran's のマップとは若干異なっています。これは、これらの2つの統計量を計算するために使用される方法がわずかに異なることを反映しています。どちらを使用すべきかは、特定の事例とあなたが関心を持っているリサーチクエスチョンに依存します。

**Lee's L test** - これは、二変量の空間相関に関する統計的なテストです。与えられた変数 *x* の空間パターンが、*x* に空間的に関連すると仮定された別の変数 *y* の空間パターンに類似しているかどうかを検定することができます。

例として、シミュレーションしたエボラ出血熱の患者数の空間パターンが、人口の空間パターンと相関しているかどうかを検証してみましょう。まず始めに、`sle_adm3` データに `population` 変数が必要です。先ほど読み込んだ `sle_adm3_pop` データフレームの `total` 変数を使うことができます。

```{r}
sle_adm3_dat <- sle_adm3_dat %>% 
  rename(人口 = total)                          # 列名 total を 人口 に変更
```

2つの変数の空間パターンを並べて視覚化することで、似ているかどうかをすぐに確認することができます。

```{r, fig.align='center', warning=F, message=F}
tmap_mode("plot")

cases_map <- tm_shape(sle_adm3_dat) + tm_polygons("cases") + 
  tm_layout(main.title="ケース",
            fontfamily = gis_jfontname)    # フォントは macOS では、"HiraginoSans-W3" など
pop_map <- tm_shape(sle_adm3_dat) + 
  tm_polygons("人口") + 
  tm_layout(main.title="人口", 
            fontfamily = gis_jfontname)    # フォントは macOS では、"HiraginoSans-W3" など

tmap_arrange(cases_map, pop_map, ncol=2)   # arrange into 2x1 facets
```

視覚的には、この2つのパターンは似ていないように見えます。
**spdep** の `lee.test()` 関数を使って、2つの変数の空間的自己相関のパターンが関連しているかどうかを統計的に検定することができます。
L 統計量は、パターン間に相関がなければ0に近く、強い正の相関があれば（つまりパターンが似ている）1に近く、強い負の相関があれば（つまりパターンが逆）-1に近くなります。

```{r, warning=F, message=F}
lee_test <- spdep::lee.test(
  x=sle_adm3_dat$cases,          # 比較する変数１
  y=sle_adm3_dat$人口,     　　　# 比較する変数２
  listw=sle_listw                # 隣接重みづけのある listw オブジェクト
)

lee_test
```

上記の出力では、2つの変数の Lee's L 統計量が `round(lee_test$estimate[1],2)` となり、弱い負の相関があることを示しています。これは、症例のパターンと人口が互いに関連していないという私たちの視覚的な評価を裏付けるものであり、症例の空間的なパターンは、厳密には高リスク地域の人口密度の結果ではないという証拠となります。

Lee's L 統計は、空間的に分布する変数間の関係について、このような推論を行うのに役立ちます。しかし、2つの変数間の関係の性質をより詳細に記述したり、交絡を調整したりするには、<u>空間回帰</u>技術が必要になります。以下では、これらについて簡単に説明します。

### 空間回帰 {.unnumbered}

空間データの変数間の関係を統計的に推論したい場合があります。このような場合には、<u>空間回帰</u>の手法、つまり、データ内のユニットの空間的な構成を明示的に考慮した回帰のアプローチを検討することが有用です。GLMのような標準的な回帰モデルではなく、空間回帰モデルを検討する必要がある理由は以下の通りです。

  * 標準的な回帰モデルは、残差が互いに独立していることを前提としています。標準回帰モデルは、残差が互いに独立であると仮定していますが、強い<u>空間的自己相関</u>がある場合、標準回帰モデルの残差は空間的にも自己相関している可能性が高く、この仮定に反することになります。これは、モデルの結果を解釈する際に問題となる可能性があり、そのような場合には、空間モデルを使用することが望ましいでしょう。
  
  * また、回帰モデルでは、変数 *x* の効果がすべての観測点で一定であることを仮定します。<u>空間的に異質</u>である場合、推定したい効果は空間によって異なる可能性があり、その違いを定量化することに興味があるかもしれません。このような場合、空間回帰モデルは効果の推定と解釈をより柔軟に行うことができます。
  
空間回帰アプローチの詳細については、このハンドブックの範囲外です。このセクションでは、最も一般的な空間回帰モデルとその用途の概要を説明し、この分野をさらに探求したい場合に役立つ参考文献を紹介します。

**空間誤差モデル** - これらのモデルは、空間ユニット間の誤差項が相関していると仮定していますが、その場合、データは標準的な最小二乗法(OLS) モデルの仮定に反することになります。空間誤差モデルは、「同時自己回帰（SAR）モデル」と呼ばれることもあります。空間誤差モデルは、 **spatialreg** パッケージの `errorsarlm()` 関数（空間回帰関数、以前は **spdep** の一部だった）を使ってフィットさせることができます。

**空間ラグモデル** - このモデルは、ある地域 *i* の従属変数が、*i* の独立変数の値だけでなく、*i* に隣接する地域のそれらの変数の値にも影響されると仮定しています。空間誤差モデルと同様に、空間ラグモデルもまた、**同時自己回帰（SAR）モデル**と呼ばれることがあります。 空間ラグモデルは、**spatialreg** パッケージの`lagsarlm()`関数を使ってフィットさせることができます。

**spdep** パッケージには、標準的な最小二乗法 (OLS)  モデル、空間ラグモデル、空間誤差モデルを決定するための便利な診断テストがいくつか含まれています。これらのテストは、<u>ラグランジュ乗数診断</u>と呼ばれ、データの空間依存性のタイプを特定し、どのモデルが最も適切かを選択するために使用することができます。関数 `lm.LMtests()` を用いると、すべてのラグランジュ乗数検定を計算することができる。Anselin (1988) は、ラグランジュ乗数検定の結果に基づいて、どの空間回帰モデルを使用するかを決定するための便利なフローチャートツールも提供しています。

```{r, fig.align='center', echo=F}
knitr::include_graphics(here::here("images", "gis_lmflowchart.jpg"))
```

**ベイズ階層モデル** - ベイズを用いた手法は、いくつかの応用例において空間分析で一般的に使用されています。最も一般的なのは [疾患マッピング](https://pubmed.ncbi.nlm.nih.gov/15690999/) です。症例データの分布がまばらであったり（例えば、稀な結果の場合）、統計的に「ノイズが多い」場合には、潜在的な空間プロセスを考慮して疾病リスクの「平滑化された」推定値を生成するために使用することができるので、ベイズを用いた手法の方が好まれます。これにより、推定値の質が向上する可能性があります。また、データに存在する可能性のある複雑な空間的相関パターンを（選択することで）事前に指定することができ、独立変数と従属変数の両方における空間依存および非依存の変動を説明することができます。Rでは、**CARbayes** パッケージ（ [vignette](https://cran.r-project.org/web/packages/CARBayes/vignettes/CARBayes.pdf) 参照）や R-INLA（[website](https://www.r-inla.org/home) や [textbook](https://becarioprecario.bitbucket.io/inla-gitbook/) 参照）を用いてベイズ階層モデルをフィットさせることができます。また、R は JAGS や WinBUGS のようなベイズ推定を行う外部ソフトウェアを呼び出すのにも使うことができます。

<!-- ======================================================= -->
## リソース {  }

* R Simple Features and sf package [vignette](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)

* R tmap package [vignette](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)

* ggmap: [Spatial Visualization with ggplot2](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf)

* [Intro to making maps with R, overview of different packages](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html)  

* Spatial Data in R [(EarthLab course)](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/)

* Applied Spatial Data Analysis in R [textbook](https://link.springer.com/book/10.1007/978-1-4614-7618-4)

* **SpatialEpiApp** - a [Shiny app that is downloadable as an R package](https://github.com/Paula-Moraga/SpatialEpiApp), allowing you to provide your own data and conduct mapping, cluster analysis, and spatial statistics.  

* An Introduction to Spatial Econometrics in R [workshop](http://www.econ.uiuc.edu/~lab/workshop/Spatial_in_R.html)