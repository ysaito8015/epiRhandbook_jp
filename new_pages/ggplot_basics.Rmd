
# ggplot basics {}


**ggplot2** is the most popular data visualisation package in R and is generally used instead of **base** `R` for creating figures. The "gg" in the name represents a "**g**rammar of **g**raphics". **ggplot2** benefits from a wide variety of supplementary R packages that further enhance its functionality.  

The syntax is significantly different from **base** `R` plotting, and has a learning curve associated with it. Using **ggplot2** generally requires the user to format their data in a way that is highly **tidyverse** compatible, which ultimately makes using these packages together very effective.

In this page we will cover:  

* The fundamentals of plotting with **ggplot2**  
* Tips and tricks to make your plots sharp  

There a several extensive **ggplot2** tutorials linked in the resources section. You can also download this [data visualization with ggplot cheatsheet](https://rstudio.com/resources/cheatsheets/) from the RStudio website. If you want inspiration for ways to creatively visualise your data, we suggest reviewing websites like the [R graph gallery](https://www.r-graph-gallery.com/) and [Data-to-viz](https://www.data-to-viz.com/caveats.html). 



<!-- ======================================================= -->
## Preparation {}

### Load packages {-}

This code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  

```{r}
pacman::p_load(
  tidyverse,      # includes ggplot2 and other
  rio,            # import/export
  here,           # file locator
  stringr,        # working with characters   
  scales,         # transform numbers
  ggrepel,        # smartly-placed labels
  gghighlight,    # highlight one part of plot
  RColorBrewer    # color scales
)
```

### Import data {-}  

We import the dataset of cases from a simulated Ebola epidemic. If you want to download the data to follow step-by-step, see instructions in the [Download handbook and data] page. The dataset is imported using the `import()` function from the **rio** package. See the page on [Import and export] for various ways to import data.

```{r, eval=T, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.xlsx")
```

The first 50 rows of the linelist are displayed below. We will focus on the continuous variables `age`, `wt_kg` (weight in kilos), `ct_blood` (CT values), and `days_onset_hosp` (difference between onset date and hospitalisation).  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### General cleaning {-}

When preparing data to plot, it is best to make the data adhere to ["tidy" data standards](https://r4ds.had.co.nz/tidy-data.html) as much as possible. How to achieve this is expanded on in the data management pages of this handbook, such as [Cleaning data and core functions]. 

Some simple ways we can prepare our data to make it better for plotting can include making the contents of the data better for display - this does not necessarily mean its better for data manipulation! For example:  

* Replace `NA` values in a character column with the string "Unknown"  
* Clean some columns so that their "data friendly" values with underscores etc are changed to normal text or title case (see [Characters and strings])  

Here are some examples of this in action:

```{r, eval = TRUE}
linelist <- linelist %>%
  # make display version of columns with more friendly names
  mutate(
    # f to Male, f to Female, NA to Unknown
    gender_disp = case_when(gender == "m" ~ "Male",
                            gender == "f" ~ "Female",
                            is.na(gender) ~ "Unknown"),
    # replace NA with unknown for outcome
    outcome_disp = replace_na(outcome, "Unknown")
  )
```

### Pivoting longer {-}

As a matter of data structure, for **ggplot2** we often also want to pivot our data into *longer* formats, which will allow us to use a set of variables as a single variable. Read more about this is the page on [Pivoting data].  

For example, say that we have "wide" data with each case and their symptoms (as shown shown below, in the style of the linelist).  

```{r}
symptoms_data <- linelist %>% 
  select(c(case_id, fever, chills, cough, aches, vomit))
```

Here is how the first 50 rows look: 

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(symptoms_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

If we wanted to show the number of cases with specific symptoms, we are limited by the fact that each symptom is a specific column. However, we can *pivot* the symptoms columns to a longer format like this:

```{r, eval = T}
symptoms_data_long <- symptoms_data %>%
  pivot_longer(cols = -case_id,
               names_to = "symptom_name",
               values_to = "symptom_is_present") %>%
  mutate(symptom_is_present = replace_na(symptom_is_present, "unknown"))

```


Here are the first 50 rows. Note that case has 5 rows - one for each possibly symptom. Scroll to the right to see the new columns `symptom_name` and `symptom_is_present`. Note that this format is not very useful for other operations, and should just be used for the plot it was made for.

```{r, message=FALSE, echo=F}
DT::datatable(head(symptoms_data_long, 50), rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```






<!-- ======================================================= -->
## Basics of ggplot {}

**"Grammar of graphics" - ggplot2**  

Plotting with **ggplot2** is based on "adding" plot layers and attribute specifications on top of one another, with each sub-command added with a plus symbol (`+`). The result is a multi-layer plot object that can be saved, modified, printed, exported, etc.  

ggplot objects can be highly complex, but the basic order of layers will usually look like this:  

1. Begin with the baseline `ggplot()` command - establish the coordinate base and specify the dataset  
2. Add "geom" layers - these geometric functions visualize the data as a bar graph, line plot, scatter plot, histogram, etc (or a combination!). These functions all start with `geom_` as a prefix.  
3. Add adjustments to the plot such as to specify the axis labels, title, fonts, sizes, color schemes, legends, rotate the axes, etc.  

A simple example of skeleton code is as follows. We will explain each component in the sections below.  

```{r, eval=F}
ggplot(data = my_data)+  
  geom_XXXX(mapping = aes(x = col1, y = col2), fill = "color")+
  labs()+
  theme()
```

 


## `ggplot()`  

The opening command of any ggplot2 plot is `ggplot()`. This command simply creates a blank canvas upon which to add layers. It "opens" the way for further layers to be added with a `+` symbol.

Typically, the command `ggplot()` includes the `data = ` argument for the plot. This sets the default dataset to be used for subsequent layers of the plot.  

Finally, this command will end with a `+` after the closing parentheses. This leaves the command "open". The plot will only execute/appear when the command includes a final layer without a `+` at the end.  

```{r, eval=F}
# This will create plot that is a blank canvas
ggplot(data = linelist)
```


## Geoms  

A blank canvas is not sufficient! We need to create geometries from our data! Bar plots, histograms, scatter plots, box plots!  

This is done by adding layers of geometry to the initial `ggplot()` command. There are many **ggplot2** functions that create "geoms". Each of these functions begins with "geom_", so we will refer to them generically as `geom_XXXX()`. There are over 40 geoms in **ggplot2** and many others created by fans. View them at the [ggplot2 gallery](https://exts.ggplot2.tidyverse.org/gallery/). Some common geoms are listed below:  

* Histograms - `geom_histogram()`  
* Bar charts - `geom_bar()`  
* Box plots - `geom_boxplot()`  
* Points (e.g. scatter plots) - `geom_point()`  
* Line graphs - `geom_line()` or `geom_path()`  
* Trend lines - `geom_smooth()`  

In one plot you can display one or multiple geoms. Each is added with a `+`, and they are plotted sequentially such that later geoms are plotted on top of previous ones.  

But simply knowing these geom functions is not sufficient to produce a plot! We must also *map* the data to the plot...


## Mapping plot aesthetics to data  

The next core component of a `ggplot()` object is how plot "aesthetics" are mapped to columns in the data. By a plot "aesthetic", we mean a visual property of an object in the plot. The two essential "aesthetics" are the x-axis, and (if necessary) the y-axis.  

For aesthetics that are "mapped" to columns of the data are given to the `mapping = ` argument, but the actual assignments are listed within `aes()`, as shown below. 

Below, in the `ggplot()` command the data are set as the case `linelist`, and then the column `age` is mapped to the x-axis, and the column `wt_kg` is mapped to the y-axis. A `+` continues the plotting command and leads to `geom_point()`. This geom *inherits* the mapped aesthetics from the `ggplot()` command - it know the axis-column assignments and proceeds to visualize those relationships as *points* on the canvas.  

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+
  geom_point()
```

The following command utilizes the same data, but slightly different aesthetic mapping and a different geom. It produces a histogram with `geom_histogram()`, which by its very nature only requires a column mapped to the x-axis. The count y-axis is generated automatically.  

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()
```


**Aesthetic mapping can be defined in several places, even multiple times!**  

`mapping = aes()` can be written in several places, or more than once. It can be written in the top `ggplot()` command, and/or for each individual `geom_XXXX()` beneath. The nuances include:  

* Mapping assignments specified in the top `ggplot()` command will apply as defaults across any geom below.  
* Mapping assignments specified within one `geom_XXXX()` apply only to that geom.  

Likewise, `data = ` specified in the top `ggplot()` will apply by default to any geom below, but you can also specify data for each geom, if desired (this is one way to create a plot that combines multiple datasets).  

Thus, both of the following commands will create the same plot:  

```{r, eval=F, warning=F, message=F}
# These commands will produce the exact same plot
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()

ggplot(data = linelist)+
  geom_histogram(mapping = aes(x = age))
```

## Other aesthetics   

There are other aesthetics, which can be specific to the type of geom. Some examples:  

* `shape =` Display of a point (`geom_point()`) as a dot, star, triangle, square, etc.  
* `fill = ` The interior color (e.g. of a bar or boxplot)  
* `color =` The exterior line(s) of a bar, boxplot, etc. (or the point color if using `geom_point()`)  
* `size = ` Size (e.g. line thickness, point size)  
* `alpha = ` Transparency (1 = opaque, 0 = invisible)  
* `binwidth = ` Width of histogram bins  
* `linetype =` Line type (e.g. solid, dashed, dotted)  

*Assignments for these kinds of aesthetics (non-axes) can be placed inside or outside the `aes()`.* This depends on whether you want their value to be static or to be scaled/depend on the values in each row of data.  

If you want the value to be static, you would write its assignment within the `geom_XXXX()` but *outside* of a `mapping = aes()` statement (there may not even be one in the geom). The assignment values would be unchanging - for example, `size = 1` or `color = "blue"`.  

Here are two examples. In the first, the mapping assignments of the axes is set in the `ggplot()` command, and the color, size, and alpha are alone in the `geom_point()`. Note that they could not be written in `ggplot()`. In the second example, the axis mapping is done within the geom (just for example - it does not make a difference), and the binwidth, color, fill, and alpha are *outside* the `aes()` and set to static values.  


```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# scatterplot
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # set data and axes mapping
  geom_point(color = "red", size = 0.5, alpha = 0.1)         # set static point aesthetics

# histogram
ggplot(data = linelist)+       # set data
  geom_histogram(              # display histogram
    mapping = aes(x = age),      # axis mapping for histogram
    binwidth = 7,                # width of bins
    color = "red",               # bin line color
    fill = "blue",               # bin interior color
    alpha = 0.1)                 # bin transparency
```


But you can instead map these aesthetics to columns in the data. In this case, their display is scaled and depends on the value in each row of data. Essentially, the data are grouped by the values in that column. If the column is continuous, as in the examples below, the aesthetic scale is continuous. If the column you assign is discrete, then the groups/colors/sizes/etc. will display by group (read more in the [grouping](#ggplotgroups) section).      

In this case, you assign these aesthetics *within* the `aes()`, alongside the axes assignments. The assignments are now made to column names, not to static values. And finally, like the axes assignments, if you choose to put these in an `aes()` in the top `ggplot()` command these assignments will apply by default to any geoms below.  

Two examples are below.  

Note in the first example how the color of each point reflects the age value - and a scale has appeared in a legend! For now just note that the scale exists - we will show how to modify it in later sections. The second example highlights two new mapped aesthetics (color *and* size), while shape and alpha remain mapped to static values outside of any `aes()`.  

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# scatterplot
ggplot(data = linelist,   # set data
       mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age))+     # map color to age
  geom_point()            # display data as points 

# scatterplot
ggplot(data = linelist,   # set data
       mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age,       # map color to age
         size = age))+      # map size to age
  geom_point(             # display data as points
    shape = "diamond",      # points display as diamonds
    alpha = 0.3)            # point transparency at 30%


```

It becomes important to track your layers and aesthetics when making more complex plots - like those with multiple geoms.  

In the example below, the `size = ` aesthetic is assigned twice - once for `geom_point()` and once for `geom_smooth()` - both times as a static value.  

```{r, warn=F, message=F}
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg, color = age_years)) + # map aesthetics to columns
  geom_point(size = 1, alpha = 0.5) +  # add points for each row of data
  geom_smooth(method = "lm", size = 2) # add a trend line with linear method, width of 2
```

Note that propoerly aligning axes to plot from multiple dataset on top of one another can be difficult. Consider instead using **cowplot** or a similar package to combine two plots - as described in that section of the [ggplot tips] page.  

## Storing plots  

### Saving plots {-}

Plots can be printed to the Plots RStudio pane, as we have done until now, by simply beginning the command with `ggplot()`. However, you can also save the plot as an object by using the assignment operator `<-` and giving it a name. It will not print unless the object name itself is run. You can also print it by wrapping the plot name with `print()`, but this is only necessary in certain circumstances like if the plot is created inside a *for loop*.  

```{r, warning=F, message=F}
# define plot
age_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+
  geom_point(alpha = 0.1)

age_by_wt    # print
```


### Modifying saved plots {-}  

One nice thing about **ggplot2** is that you can define a plot (as above), and then add layers to it starting with its name. You do not have to repeat all the commands that created the original plot! 

For example, to modify the plot `age_by_wt` that was defined above, to include a vertical line at age 50, we would just add a `+` and continue....

```{r, warning=F, message=F}
age_by_wt+
  geom_vline(xintercept = 50)
```



## Labels 

Surely you will want to add or adjust the plot's labels. These are most easily done with the `labs()` function, added with `+` just as the geoms were.  

Within `labs()` you can provide character strings to these arguements:  

* `x = ` and `y = ` The x-axis and y-axis title (labels)  
* `title = ` The main plot title  
* `subtitle = ` The subtitle of the plot, in smaller text below the title  
* `caption = ` The caption of the plot, or bottom-right by default  

Here is a plot we made earlier, but with nicer labels:  

```{r, warning=F, message=F}
age_by_wt <- ggplot(
  data = linelist,   # set data
  mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age))+     # map color to age
  geom_point()+           # display data as points
  labs(
    title = "Age and weight distribution",
    subtitle = "Fictional Ebola outbreak, 2014",
    x = "Age in years",
    y = "Weight in kilos",
    caption = stringr::str_glue("Data as of {max(linelist$date_hospitalisation, na.rm=T)}"))

age_by_wt
```
Note how in the caption assignment we used `str_glue()` from the **stringr** package to implant dynamic R code within the string text. The caption will display the maximum hospitalization date in the linelist. Read more about this in the page on [Characters and strings].  

You can also use `labs()` to adjust the legend title(s), but this is a bit more complicated. See the section on legends in the [ggplot tips] page.  


## Themes 

One of the best parts of **ggplot2** is the amount of control you have over the plot - you can define anything! Generally this done by adjusting the "theme" arguments for the plot. This is done in one of two ways:  

* Adding pre-defined `theme_XXXX()` functions to make sweeping adjustments  
  * These include `theme_classic()`, `theme_minimal()`, `theme_dark()`, `theme_light()` `theme_grey()`, `theme_bw()` and others  
* Adjusting each tiny aspect of the plot individually within `theme()`  

We have mention the pre-defined `theme_XXXX()` functions above, will demonstrate them below, and will not describe them further here.  

The `theme()` function can take a large number of arguments, each of which edits a very specific aspects of the plot. We won't go through all examples, but will describe the general pattern and show you how to find the argument you need. The basic syntax is this:

1. Add `theme()` as you would a geom or `labs()`  
2. Within `theme()`, provide the specific argument name for the element you want to edit (e.g. `plot.title = ` for the plot title)  
3. Supply the `element_XXXX()` function as the value for the argument  
  * Most of the time this is `element_text()`, but other versions include `element_rect()` for editing the plot canvas background colors, or even `element_blank()` to remove plot elements  
4. Within the `element_XXXX()` give arguments to make fine adjustments  

That was quite abstract and convoluted, so here are some examples.  

The below plot looks quite silly, but it serves to show you a variety of the ways you can adjust your plot.  We begin with the plot `age_by_wt` (that we defined above), and add `+` `theme_classic()` (with empty parentheses) to enact several adjustments in one command. Then, for finer adjustments, we add a `theme()` command. Within it, we list the arguments for each aspect we want to adjust - in this case there are many. It can be nice to organize them into sub-grounds with new lines.  

To describe just some of them: The `legend.position = ` is unique in that it accepts simple values like "bottom", but generally text-related arguements require that you place the details within `element_text()`. See how we adjust the title size with `size = `, the caption horizontal alignment with `hjust = 0` (from right to left), and make the subtitle italicized with `face = `.  

```{r, eval=TRUE, warning=F, message=F}
age_by_wt + 
  theme_classic()+                                 # pre-defined theme adjustments
  theme(
    legend.position = "bottom",                    # move legend to bottom
    
    plot.title = element_text(size = 30),          # size of title to 30
    plot.caption = element_text(hjust = 0),        # left-align caption
    plot.subtitle = element_text(face = "italic"), # italicize subtitle
    
    axis.text.x = element_text(color = "red", size = 15, angle = 90), # adjusts only x-axis text
    axis.text.y = element_text(size = 15),         # adjusts only y-axis text
    
    axis.title = element_text(size = 20)           # adjusts both axes titles
    )     
```

Here are some especially common `theme()` arguments. You will recognize some patterns, such as appending `.x` or `.y` to apply the change only to one axis.  


`theme()` argument                 |What it adjusts
-----------------------------------|----------------------------------
`plot.title = element_text()`      |The title
`plot.subtitle = element_text()`   |The subtitle
`plot.caption = element_text()`    |The caption (family, face, color, size, angle, vjust, hjust...) 
`axis.title = element_text()`      |Axis titles (both x and y) (size, face, angle, color...)
`axis.title.x = element_text()`    |Axis title x-axis only (use `.y` for y-axis only)
`axis.text = element_text()`       |Axis text (both x and y)
`axis.ticks = element_blank()`     |Remove axis ticks
`axis.line = element_line()`       |Axis lines (colour, size, linetype: solid dashed dotted etc)
`strip.text = element_text()`      |Facet strip text (colour, face, size, angle...)
`strip.background = element_rect()`|facet strip (fill, colour, size...)  

But there are so many theme arguments! How could I remember them all??? Do not worry - it is impossible to remember them all. Luckily there are a few tools to help you:  

See the **tidyverse** documentation on [modifying theme](https://ggplot2.tidyverse.org/reference/theme.html) has a complete list.  

<span style="color: darkgreen;">**_TIP:_** Run `theme_get()` from **ggplot2** to print a list of all 90+ `theme()` arguments to the console.</span>  

<span style="color: darkgreen;">**_TIP:_** If you ever want to remove an element of a plot, you can also do it through `theme()`! Just pass `element_blank()` to an argument to have it disappear completely!</span>  


## Groups {#ggplotgroups}  

You can easily group the data and "plot by group". This is demonstrated more extensively in the pages on [Plot continuous data] and [Plot discrete data], but we describe the mechanism briefly below.  


A very simple way to group the data is to add the `color = ` or `fill = ` arguments *within* the `mapping = aes()`, and assign the discrete column name to group the data by. Each unique value in the grouping column will be plotted separately (`NA` missing values will appear as a group).  

In fact, you have already done this! Above, we moved the `color = ` argument within `aes()` and assigned it the column `age`. This effectively grouped the data by age, which was a continuous scale. In contrast, here we discuss grouping by discrete columns.  

Below we show the scatter plot of age and weight, but we have set `color = ` to the column `gender`. A legend automatically appears.  

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg, color = gender))+
  geom_point(alpha = 0.5)

```
Note that depending on the geom, you may need to use different arguments to group the data. `fill = ` or `color = ` are appropriate for most cases, but you could also adjust by `shape = ` etc.  

The most basic way of grouping the data is by adding the `group = ` argument within the `mapping = aes()` and assigning it to a discrete column. However, this by itself will not change the colors, fill, or shapes. Nor will it create a legend. Yet it is good to be aware of this argument in case you want to use it.  

There are many examples of grouped plot in the pages on plotting continuous and discrete variables.  

To adjust the order and presentaton of groups in a plot, see the [ggplot tips] page or the page on [Working with factors].  


### Facets / Multiple plots {-}  

Often its useful to show multiple graphs on one page, or one super-figure. There are a few ways to achieve this and a lot of packages that can help to facilitate it. However, while external packages are nice, it is often easier to use faceting as an alternative that is prebuilt into `ggplot2`. Faceting plots is extremely easy to do in terms of code, and produces plots with more predictable aesthetics - you wont have to wrangle legends and ensure that axes are aligned etc.

Faceting is a very specific way to obtain multiple plots - by definition, to facet you have to show the same type of plot in each facet, where every plot is specific to a level of a variable. This is done with one of two functions:

  1. `facet_wrap()` This is used when you want to show a different graph for each level of a *single* variable. One example of this could be showing a different epidemic curve for each hospital in a region. 
  
  2. `facet_grid()` This is used when you want to bring a second variable into the faceting arrangement. Here each element of a grid is shows the intersection between an x or y element of a grid. For example, this could involve showing a different epidemic curve for each hospital in a region, shown horizontally, for each age group, shown vertically.
  
This can quickly become an overwhelming amount of information - its good to ensure you don't have too many levels of each variable that you choose to facet by! Here are some quick examples with the malaria dataset:

```{r, eval = TRUE, warning=F, message=F}
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) 

# show a wrapped plot with facets by district

ggplot(malaria_data, aes(x = data_date, y = malaria_tot, fill = District)) +
  geom_bar(stat = "identity") +
  labs(
    x = "date of data collection",
    y = "malaria cases",
    title = "Malaria cases by district"
  ) +
  facet_wrap(~District) +
  theme_minimal()

```

We can also use a `facet_grid()` approach with the different age groups - we need to do some data transformations first however, as the age groups all are in their own columns - we want them in a single column. When you pass the two variables to `facet_grid()`, you can use formula notation (e.g. `x ~ y`) or wrap the variables in `vars()`. For reference, this: `facet_grid(x ~ y)` is equivalent to `facet_grid(rows = vars(x), cols = vars(y))` Here's how we can do this:

```{r, eval = T, warning=F, message=F}

malaria_age <- malaria_data %>%
  pivot_longer(
    # choose all the columns that start with malaria rdt (age group specific)
    cols = starts_with("malaria_rdt_"),
    # column names become age group
    names_to = "age_group",
    # values to a single column (num_cases)
    values_to = "num_cases"
  ) %>%
  # clean up age group column - replace "malaria_rdt_" to leave only age group
  # then replace 15 with 15+
  # then refactor the age groups so they are in order
  mutate(age_group = str_replace(age_group, "malaria_rdt_", "") %>%
           ifelse(. == "15", "15+", .) %>%
           forcats::fct_relevel(., "5-14", after = 1))


# make the same plot as before, but show in a grid
ggplot(malaria_age, aes(x = data_date, y = num_cases, fill = age_group)) +
  geom_bar(stat = "identity") +
  labs(
    x = "date of data collection",
    y = "malaria cases",
    title = "Malaria cases by district and age group"
  ) +
  facet_grid(rows = vars(District), cols = vars(age_group)) +
  theme_minimal()



```



### Piping into **ggplot2** {-}  

When using pipes to clean and transform your data, it is easy to pass the transformed data into `ggplot()`. The pipes that pass the dataset from function-to-function will transition to `+` once the `ggplot()` function is called. Note that in this case, there is no need to specify the `data = ` argument, as this is automatically defined as the piped-in dataset.  

This is how that might look:  

```{r, warning=F, message=F}
linelist %>%                                                     # begin with linelist
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns
  pivot_longer(                                                  # pivot longer
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # replace missing values
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  ggplot(                                                        # begin ggplot!
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )
```


### Exporting plots {-}  

Exporting ggplots is made easy with the `ggsave()` function from **ggplot2**. It can work in two ways, either:  

* Specify the name of the plot object, then the file path and name with extension  
  * For example: `ggsave(my_plot, "My Documents/work/plots/my_plot.png")`  
* Save the last plot that was printed  
  * For example: `ggsave("My Documents/work/plots/my_plot.png")`  
  
You can export as png, pdf, jpeg, tiff, bmp, svg, or several other file types, by specifying the file extension in the file path.  

You can also specify the arguments `width = `, `height = `, and `units = ` (either "in", "cm", or "mm"). You can also specify `dpi = ` with a number for plot resolution (e.g. 300). See the function details by entering `?ggsave` or reading the [documentation online](https://ggplot2.tidyverse.org/reference/ggsave.html). 



## Resources  

R for Data Science pages on [data visualization](https://r4ds.had.co.nz/data-visualisation.html) and [graphics for communicaton](https://r4ds.had.co.nz/graphics-for-communication.html)  

