# 反復、ループ、リスト {\# iteration}

疫学者は、しばしば、国、地区、年齢階級などによって層別化されたサブグループを対象として同じ分析を繰り返す必要に迫られます。このほかにも、非常にたくさんの場面で*反復処理*が必要となります。以下では、より速く、より正確に、より短く、このような反復処理をコードする方法を示します。

このページでは、反復処理を行うための2つの方法、すなわち、*for ループ*を使用する方法と **purrr** パッケージを使用する方法を紹介します。

1)  一連の入力に対してコードを反復する *for ループ* は、他のプログラミング言語に比べて R ではあまり一般的ではありません。しかし、ここでは学習の一貫として参考までに紹介します。

2)  **purrr** パッケージは、**tidyverse** パッケージ群の中の反復処理を行うためのパッケージであり、多くの入力（値、列、データセットなど）に対して関数を "マッピング" し、反復処理を行います。

反復処理のコードの紹介の中で、以下の内容にも触れます。

-   複数のファイルのインポート／エクスポート
-   複数の管轄区ごとの流行曲線の作成
-   データフレーム内の複数の列に対する t 検定の実行

また、**purrr** [セクション](#iter_purrr)では、`リスト`の作成と処理の例をいくつか紹介します。

## 準備

### パッケージの読み込み {.unnumbered}

次のコードチャンクは、分析に必要なパッケージの読み込みをしています。このハンドブックでは、**pacman** の `p_load()` を用いています。`p_load()` は、必要に応じてパッケージをインストールし、*そして*パッケージの読み込みまで行ってくれます。R の **base** パッケージ内の `library()` を用いても、パッケージの読み込みを行うことが出来ます。パッケージの詳細については ［R の基本］のページを参照してください。

```{r}
pacman::p_load(
     rio,         # インポート／エクスポートのためのパッケージ
     here,        # ファイルの場所の指定のためのパッケージ
     purrr,       # 反復処理のためのパッケージ
     tidyverse    # データ管理と視覚化のためのパッケージ
)
```

### データのインポート {.unnumbered}

エボラ出血熱のシミュレーション症例のデータセットをインポートします。同じように行いたい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'> をクリックして"クリーニングされた（cleaned）" linelist をダウンロードしてください</a>（.rds ファイル）。データをインポートする際には、**rio** パッケージの `import()` 関数を使用します（.xlsx, .csv, .rds などの多くのファイルを扱うことができます ー 詳細は ［Import and export］ ページをご覧ください）。

```{r, echo=F}
# linelist を R にインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# linelist をインポートする
linelist <- import("linelist_cleaned.rds")
```

linelist の始めの 50 行が示されています。

```{r, message=FALSE, echo=F}
# linelist データをテーブルとして表示する
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

<!-- ======================================================= -->

## *for ループ*

### R における *for ループ* {#iter_loops .unnumbered}

*for ループ*は R ではあまり取り沙汰されることがないですが、他のプログラミング言語では一般的な方法です。初心者の場合、特に自分で関数を書くことに慣れていない場合は、反復処理ごとに何が起こっているのかを正確に把握し、"探索" したり "デバッグ" を行ったりすることが容易になるので、学習や練習に便利です。

*for ループ*を飛ばして、**purrr** パッケージでマッピングされた関数を使用して反復処理を行う方法へ移動しても構いません（[以下のセクション](#iter_purrr)を参照）。

### 中心となる要素 {.unnumbered}

*for ループ*は以下の 3 つの主要な部分から成り立っています。

1)  繰り返し実行するアイテムの**シーケンス**
2)  シーケンス内の各アイテムに対して実行される**オペレーション**
3)  結果を格納する**コンテナ** （オプション）

基本的な構文は以下に示しているように、`for (アイテム in シーケンス) {アイテムを用いたオペレーションの指示}`です。括弧と中括弧の違いに注意してください。結果は、コンソールに出力したり、コンテナに格納したりすることができます。

簡単な *for ループ*の例を以下に示します。

```{r}
for (num in c(1,2,3,4,5)) {  # シーケンスの定義（1 から 5 の数）と "{" によるループの開始
  print(num + 2)             # オペレーション（それぞれのシーケンス内の数に 2 を足して表示してください）
}                            # "}" によるループの終了                            
                             # この例ではコンテナは示していない
```

### シーケンス {.unnumbered}

これは、*for ループ*において "for" で示されている部分です。オペレーションはシーケンス内の各アイテムに対して（"for" each item）実行されます。シーケンスには、一連の値（管轄区名、疾患名、列名、リスト要素など）や、一連の連続した数値（1, 2, 3, 4, 5 など）を指定することができます。以下に説明するように、それぞれに実用性があります。

シーケンス文の基本構造は、`アイテム in ベクトル`です．

-   "アイテム" の部分には任意の文字や単語を書くことができます（例："i", "num", "hosp", "district" など）。この "アイテム" の値は、ループを繰り返すたびにベクトル内の各値に順番に変化していきます。
-   *ベクトル*には、文字列や列名、あるいは数字列などを用いることが出来ます。ループを繰り返すたびに順番に変化していく値であり、これらの値は、"アイテム" を用いたオペレーションの指示により、"for ループ" の中で使用されます。

**例: 文字列のシーケンス**

この例では、あらかじめ病院名の文字ベクトルを定義し、その各値に対してループを実行します。

```{r}
# 病院名のベクトルを作成する
hospital_names <- unique(linelist$hospital)
hospital_names # 表示する
```

ここでは、`hospital_names` の値を、`hosp` という単語を使って示しています。ループの最初の繰り返しでは、`hosp` の値は `hospital_names[[1]]` 、2 回目のループでは`hospital_names[[2]]`といった具合になります。

```{r, eval=F}
# 文字列シーケンスに対する 'for ループ'

for (hosp in hospital_names){       # シーケンス
  
       # オペレーションがここに来る
  }
```

**例: 列名のシーケンス**

これは、上記の文字列のバリエーションで、既存の R オブジェクトの名前（例えば、データフレームの列名など）を抽出してベクトルとするものです。便利なことに、*for ループ*のオペレーションコードでは，列名を用いて元のデータフレームを*指定する*（サブセットする）ことが出来ます。

下の例では、シーケンスとして `linelist` データフレームの `names()`（列名）を指定しています。"アイテム" の名前は `col` で、ループが繰り返すのに従って各列名に、その表す値が変化します。

例として、*for ループ*の中に、シーケンスの各値に対して実行されるオペレーションを加えます。このコードでは、シーケンスの値（列名）を使って、`linelist` を順番に*指定して*（サブセットして）います。［R の基本］の章で説明したように、2 重ブランケット `[[ ]]` は、サブセットするのに用いられます。ループにより指定された列は `is.na()`、次に `sum()` に渡され、列内の欠損値の数を算出しています。結果は各列に対してそれぞれ 1 つの数値がコンソールに表示されます。

列名を用いてインデックスする場合の注意点 ー 列自体を指定したいときには、 *単に "col" と書いてはいけません！* `col` は、単に列の名前を表しています。列内の値全体を指定するには、`linelist[[col]]` と書いて列名を `linelist` の *index* として使用する必要があります。

```{r}
for (col in names(linelist)){        # linelist 内の各列に対するループ：列名は "col" で表されている
  
  # オペレーションコードの例 - 各列の欠損地の数を表示せよ 
  print(sum(is.na(linelist[[col]])))  # linelist は "col" の現在の値によってインデックスされている
     
}
```

**数のシーケンス**

次は、連続した数字の列をシーケンスとして用いる例を説明します。すなわち、"アイテム" の値は文字値（"Central Hospital" や "date_onset" など）ではなく、数字となります。これは、データフレームをループする際に便利で、*for ループ*内で "item" の番号を使うことで、データフレームを*行番号*でインデックスすることができます。

例えば、データフレーム内のすべての行をループして、ある情報を抽出したいとします。この場合、"アイテム" は行番号になります。この場合、"アイテム" は `i` と書かれることが多いです。

*for ループ*の処理は、言葉で説明すると、「1 からデータフレームの行の総数までの数からなるシーケンス内のすべてのアイテムに対して、X を行う」となります。ループの最初の繰り返しでは、"アイテム" `i` の値は 1 です。2 回目の繰り返しでは、`i` は 2 になります。

このシーケンスをコードにすると、次のようになります：`for (i in 1:nrow(linelist)) {オペレーションのコード}`。`i` は "アイテム" を表し、`1:nrow(linelist)` は、1 から `linelist` の総行数までの連続した数字からなるシーケンスを表しています。

```{r, eval=F}
for (i in 1:nrow(linelist)) {  # データフレームに対して使用
  # オペレーションのコードがここに来る
}  
```

シーケンスを数字にしたいが、（データフレームではなく）ベクトルを用いる場合は、ショートカットの `seq_along()` を使うことで，ベクトルの各要素に対する数字のシーケンスを得ることが出来ます。例えば、`for (i in seq_along(hospital_names) {オペレーションのコード}` とします。

以下のコードによって数字を得ることが出来、その数字がそれぞれのループの中における `i` の値になります。

```{r}
seq_along(hospital_names)  # 名前のついているベクトルに対して使用
```

シーケンスに数字を使うと、ループの出力を格納する*コンテナ*のインデックスとして、`i` 番号を簡単に使用できるという利点があります。これについては、以下のオペレーションのセクションで例を示しています。

### オペレーション {.unnumbered}

オペレーションは、*for ループ*の中の中括弧 `{ }` の中に記述されているコードのことです。このコードが、*シーケンス*内の各 "アイテム" ごとに実行される必要があります。したがって、"アイテム" によって変化するコードのすべての部分が、実際に変化するように正しくコードされているかどうか注意する必要があります。例えば、インデックスには `[[ ]]` を使うことを忘れないでください。

以下の例では、`linelist` の各行に対して反復処理を実行します。各行の `gender` と `age` の値を結合し、文字ベクトルのコンテナである `cases_demographics` に格納する作業を行います。また、`[[i]]` を使ってインデックスすることで、ループの出力を "コンテナ" ベクトルの正しい位置に保存しているところもポイントです。

```{r}
# 結果を格納するコンテナを作成する - 文字ベクトル
cases_demographics <- vector(mode = "character", length = nrow(linelist))

# for ループ
for (i in 1:nrow(linelist)){
  
  # オペレーション
  # ブラケットをインデックスに用いることで、linelist の i 行の値を取り出す
  row_gender  <- linelist$gender[[i]]
  row_age     <- linelist$age_years[[i]]    # インデックスを忘れずに！
     
  # genderとageを貼り合わせ、コンテナのベクトル内のインデックスされた場所に格納する
  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = ",") 

}  # ループの終了


# 最初の 10 行を示す
head(cases_demographics, 10)
```

### コンテナ {.unnumbered}

*for ループ* の結果はコンソールに表示したり、RStudio プロットペインに出力したりすることが出来ます。また、後で使用するために出力を "コンテナ" に保存しておきたい場合もあります。出力を保存するコンテナとして、ベクトル、データフレーム、あるいはリストなどを使用することが出来ます。

結果を保存するコンテナは、*for ループ*を開始する*前に*作成するのが最も効率的です。実際には，空のベクトル、データフレーム、またはリストを作成することになります。これらは，ベクトルやリストであれば，関数 `vector()` で，データフレームであれば，関数 `matrix()` や 関数 `data.frame()` で作成することができます．

**空のベクトル**

`vector()` を使用します。また、挿入するオブジェクトのクラスに従って、`mode =` を指定します（"double"（数を格納する場合）、"character"、または "logical"）。また、事前に `length =` を設定する必要があります。これは、*for ループ*のシーケンスの長さになります。

例えば、各病院の入院までの時間の中央値を格納したいとします。その場合、"double" を使用し、予想される出力数（ここではデータセット内の病院の数）を length として設定します。

```{r}
delays <- vector(
  mode = "double",                            # 数字を格納します
  length = length(unique(linelist$hospital))) # データセット内の病院の数
```

**空のデータフレーム**

次のように行と列の数を指定することで、空のデータフレームを作ることができます。

```{r, eval=F}
delays <- data.frame(matrix(ncol = 2, nrow = 3))
```

**空のリスト**

*for ループ*で作成したプロットをリストに格納したい場合などに用いります。リストはベクトルに似ていますが、リストは中に異なるクラスの R オブジェクトを格納することが出来ます。リストのアイテムは、数値、データフレーム、ベクトル、そして別のリストを取ることが出来ます。

実際に空のリストを作成するには、上記と同じ `vector()` コマンドを用いますが、`mode = "list"` とする必要があります。長さは好きなように指定してください。

```{r, eval=F}
plots <- vector(mode = "list", length = 16)
```

### 表示 {.unnumbered}

なお，*for ループ*内で表示することを指示するには、関数 `print()` で明示する必要があります。

以下の例では、シーケンスは文字ベクトルであり、これを使用して病院ごとに linelist をサブセットしています。結果はコンテナには保存されず、`print()` 関数によってコンソールに出力されています。

```{r}
for (hosp in hospital_names){ 
     hospital_cases <- linelist %>% filter(hospital == hosp)
     print(nrow(hospital_cases))
}
```

### for ループの動作確認 {.unnumbered}

ループがきちんと動作するか確認するために、`i <- 10` や `hosp <- "Central Hospital"` など、"アイテム" を一時的に代入するコマンドを実行します。これを*ループの外*で行い、その後、オペレーションコードのみ（中括弧内のコード）を実行して、期待通りの結果が得られるかどうかを確認します。

### プロットをループする {.unnumbered}

3つの要素（コンテナ、シーケンス、オペレーション）を全部使って、各病院の流行曲線をプロットしてみましょう（［Epidemic curve］のページを参照）。

以下のように **incidence2** パッケージを使って、性別ごとの*全て*の症例を示した流行曲線を作ることができます。

```{r, warning=F, message=F}
# 'incidence' のオブジェクトを作成する
outbreak <- incidence2::incidence(   
     x = linelist,                   # データフレーム - linelist全体
     date_index = date_onset,        # 日付の列
     interval = "week",              # 週ごとに集計
     groups = gender,                # 性別によるグルーピング
     na_as_group = TRUE)             # 性別の欠損値は欠損のグループとして扱う

# 流行曲線をプロットする
plot(outbreak,                       # incidence のオブジェクト名
     fill = "gender",                # 性別ごとにバーの色を変更
     color = "black",                # バーの外枠の色指定
     title = "Outbreak of ALL cases" # タイトル
     )
```

各病院の症例について個別のプロットを作成するには、この流行曲線のコードを *for ループ*の中に入れる必要があります。

まず、病院名の入ったベクトル `hospital_names` を保存します。*for ループ*は、これら病院の名前ごとに一度だけ実行されます：`for (hosp in hospital_names)`。`hosp` の値は、*for ループ*が繰り返されるたびに、ベクトル内のそれぞれの病院名を表し、ループ内で使用されます。

ループ内では、通常通り R のコードを書くことができますが、"アイテム"（この場合は `hosp`）の値が変化することに注意してください。このループ内では：

-   列 `hospital` が `hosp` の現在の値と等しくなるように、`linelist` に `filter()` を適用しています。
-   incidence オブジェクトは、フィルタリングされた linelist に対して作成されています。
-   現在の病院についてのプロットには、`hosp` を用いたタイトルが自動生成されます。
-   現在の病院についてのプロットは、一時的に保存されたのちに表示されます。
-   ループは次に進み、`hospital_names` 内の次の病院に対して同じことが繰り返されます。

```{r, out.width='50%', message = F}
# 病院名のベクトルを作成する
hospital_names <- unique(linelist$hospital)

# hospital_names 内のそれぞれの病院名（"hosp"）に対して、流行曲線を作成し表示する
for (hosp in hospital_names) {
     
     # 現在の病院に対して incidence オブジェクトを作成する
     outbreak_hosp <- incidence2::incidence(
          x = linelist %>% filter(hospital == hosp),   # 現在の病院名によって linelist をフィルタリングする
          date_index = date_onset,
          interval = "week", 
          groups = gender,
          na_as_group = TRUE
     )
     
     # プロットを作成し保存する。タイトルは現在の病院名に合わせて自動生成される。
     plot_hosp <- plot(
       outbreak_hosp,
       fill = "gender",
       color = "black",
       title = stringr::str_glue("Epidemic of cases admitted to {hosp}")
     )
     
     # 現在の病院のプロットを表示する
     print(plot_hosp)
     
} # hospital_names 内の全ての病院名に対してオペレーションが行われたら for ループを終了する 
```

### ループの進行状況を確認する {.unnumbered}

反復回数の多いループは、実行終了までに何分、何時間もかかることがあります。そのため，進捗状況を R のコンソールに表示すると便利です．以下の `if` 文をループのオペレーション*の中に*配置することで、100番目の数字ごとに結果を表示することができます。コード内で用いる際には、`i`が自分の作成したループ内の "アイテム" となるように適宜変更してください。

```{r, eval=F}
# 進捗を 100 回の反復処理のたびに示すループ
for (i in seq_len(nrow(linelist))){

  # print progress
  if(i %% 100==0){    # 演算子 %% は剰余を示す
    print(i)

}
```

<!-- ======================================================= -->

## **purrr** とリスト {#iter_purrr}

反復処理のもう一つの方法として、**purrr** パッケージを用いるものがあります。これは **tidyverse** 内の反復処理を行うパッケージです。

同じタスクを何度も実行しなければならない場合、汎用性の高い方法を習得していると、非常に便利です。この方法は、例えば、複数の管轄区域のプロットを作成したり、多くのファイルをインポートして結合したりする場合などにも用いることが出来ます。

**purrr** には他にもいくつかの利点があります。パイプ `%>%` と一緒に使用できること、通常の *for ループ*よりもエラー処理に優れていること、そして構文が非常にすっきりとしてシンプルであること、などが挙げられます。もし *for ループ*を使っているのであれば、**purrr** を使うことでより明確で簡潔にコードを書くことができるでしょう。

覚えておくべきなのは、**purrr** は*関数型のプログラミングツール*であるということです。つまり、繰り返し適用されるオペレーションは、*関数*内に示す必要があります。自分で関数を書く方法については、［Writing functions］のページを参照してください。

**purrr** はまた、多くの場合*リスト*と*ベクトル*に対して働きます ー なので、リスト／ベクトルの各要素に関数を適用すると考えてください！

### パッケージの読み込み {.unnumbered}

**purrr** は **tidyverse** の一部なので、別々にパッケージをインストールする／読み込む必要はありません。

```{r}
pacman::p_load(
     rio,            # インポート/エクスポート
     here,           # ファイルパス
     tidyverse,      # データの管理と視覚化
     writexl,        # 複数のシートからなるエクセルファイルを作成
     readxl          # 複数のシートからなるエクセルファイルをインポート
)
```

### `map()` {.unnumbered}

**purrr** の中核となる関数の 1 つが `map()` で、これは与えられたリストやベクトルの各入力要素に関数を「マッピング」（適用）するものです。

基本的な構文は、`map(.x = シーケンス, .f = 関数, その他の引数)` です。もう少し詳しく説明すると：

-   `.x =` は、`.f` 関数が繰り返し適用される *入力* であり、例えば、管轄区名のベクトル、データフレームの列、またはデータフレームのリストです。
-   `.f =` は、入力 `.x` の各要素に対して適用される *関数* です。これは、既に存在する `print()` のような関数でも、自分で定義したカスタム関数でも構いません。関数は、チルダ `~` の後に書かれることが多いです（詳細は後述）。

構文についての注意点です：

-   関数がそれ以上引数を指定する必要がない場合は、括弧やチルダを使わずに書くことができます（例：`.f = mean`）。全ての反復処理において同じ値になる引数がある場合、`map()` の中、かつ `.f =` の外で指定します（例：`map(.x = my_list, .f = mean, na.rm = T)` の `na.rm = T`）。
-   `.x`（または単に`.`）は、反復処理の `.x` 値の代用値として、`.f =` 関数*の中*で使用することができます。
-   関数をより細かく設定するには、チルダ構文（`~`）を使用してください ー 関数を、括弧を用いて通常通り書いてください（例: `map(.x = my_list, .f = ~mean(., na.rm = T))`）。特に、引数の値が反復処理ごとに変化する場合や、値が `.x` 自体である場合には、この構文を使用してください（以下の例を参照）。

**`map()` を用いた際の出力は*リスト*になります** ー リストはベクトルに似ていますが、構成要素が異なります。リストには、多くのデータフレーム、多くのベクトル、多くの単一の値、あるいは多くのリストが含まれる可能性があります。以下に説明するように、他のタイプの出力を生成する `map()` の代替関数があります（例えば、データフレームを生成する `map_dfr()`、文字ベクトルを生成する `map_chr()`、数字ベクトルを生成する `map_dbl()` など）。

#### 例 ー エクセルシートをインポートし、結合する {#iter_combined .unnumbered}

**疫学者の一般的なタスクで説明しましょう：**症例データの入ったエクセルワークブックをインポートしたいが、データがワークブック内の異なる名前のシートに分かれて入っているとします。どうすれば効率的にシートをインポートして 1 つのデータフレームにまとめることができるでしょうか？

以下のようなエクセルワークブックが送られてきたとします。各シートには、それぞれの病院の症例が含まれています。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "hospital_linelists_excel_sheets.png"))
```

ここでは、`map()` を使った方法を紹介します。

1)  関数 `import()` を、各エクセルシートごとに実行するように `map()` する。
2)  インポートされたデータフレームを `bind_rows()` を用いて 1 つにまとめる。
3)  各行の元のシート名を保存し、最終的なデータフレームの新しい列にこの情報を保存する。

まず、シート名を抽出して保存する必要があります。**readxl** というパッケージ内の関数 `excel_sheets()` にエクセルワークブックのファイルパスを渡して、シート名を抽出します。抽出されたシート名は、`sheet_names` という文字ベクトルに格納されます。

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")
```

これが各シートの名前です：

```{r}
sheet_names
```

これで名前のベクトルができたので、`map()` を用いて関数 `import()` に 1 つずつ名前を渡すことができます。この例では、`sheet_names` が `.x` であり、`import()` が `.f` となります。

［インポートとエクスポート］のページで説明したように、エクセルワークブックで使用する場合、`import()` 内に、インポートするシートを指定する引数 `which =` を用いることが出来ます。`.f` 関数 `import()` 内で、`which = .x` と指定すると、ベクトル `sheet_names` を繰り返すたびに値が変化します ー 最初は "Central Hospital" 、次に "Military Hospital" となります。

注意点としては、`map()` を使用しているので、各エクセルシートのデータは、リスト内のデータフレームとして別々に保存されるということです。各リスト要素（データフレーム）に適切な*名前*を付けるために、`sheet_names` を `map()` に渡す前に、**purrr** の `set_names()` に渡しています。

出力されたリストは `combined` という名前で保存されます。

```{r, echo=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x))
```

```{r, eval=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import("hospital_linelists.xlsx", which = .x))
```

出力を確認すると、各エクセルシートのデータが名前付きリストに保存されていることがわかります。これでいいのですが、まだ完成ではありません。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_list.png"))
```

最後に、関数 `bind_rows()`（**dplyr** より）を使用します。これは、似たような構造のデータフレームのリストを受け取り、それらを 1 つのデータフレームに結合する関数です。リスト要素である *names* から新しい列を作成するには、`.id =` を使用して、新しい列に必要な名前を指定します。

以下が一連のコマンドの流れです。

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x)) %>% 
  bind_rows(.id = "origin_sheet")
```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")  # シート名を抽出する
 
combined <- sheet_names %>%                                     # シート名から開始
  purrr::set_names() %>%                                        # 名前を指定
  map(.f = ~import("hospital_linelists.xlsx", which = .x)) %>%  # 反復処理を行い、インポートし、リストに保存する
  bind_rows(.id = "origin_sheet") # データフレームのリストを結合し、新しい列に元データを保存する  
```

これで元のシート名が保存された列を含むデータフレームができました。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_df.png"))
```

`map()` には様々なバリエーションがあります。例えば、`map_dfr()` はリストではなく、データフレームを返します。そのため、上記のタスクに使用する場合、行を結合する必要はありません。しかし、各症例がどのシート（病院）のものかは把握できません。

他には、`map_chr()` や `map_dbl()` があります。これらは 2 つの理由から非常に便利な関数だと言えます。第一に、反復関数の出力を自動的に（リストではなく）ベクトルに変換してくれます。第二に、データがどのような形式で返ってくるかを指定することが出来ます ー `map_chr()` では文字ベクトル、`map_dbl()` では数字ベクトルとしてデータが戻ってきます。これらについては、後ほど詳しくみてみましょう！

関数 `map_at()` と `map_if()` は、反復処理を行う際に非常に便利です。インデックス／名前のベクトル（`map_at()` の場合）や、論理的テスト（`map_if()` の場合）を適用するだけで、リストのどの要素を反復処理するかを指定することが出来ます。

例えば、病院のデータの最初のシートを読みたくない場合を考えてみましょう。ここでは、`map()` の代わりに `map_at()` を使用し、`.at =` の引数に `c(-1)` を指定します。これは、`.x` の最初の要素を使用*しない*ことを意味します。また、`.at =` に正の数のベクトルや名前を指定して、使用する要素を指定することもできます。

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # 最初のシートは除く
     map_at(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x),
            .at = c(-1))
```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # 最初のシートは除く
     map_at(.f = ~import( "hospital_linelists.xlsx", which = .x),
            .at = c(-1))
```

最初のシートの名前が出力リストの要素として表示されていますが、これは単なる文字名（データフレームではない）になっています。行を結合する前には、この要素を削除する必要があります。リストの要素を削除したり変更したりする方法については、後のセクションで説明します。

### データセットを分割しエクスポートする {.unnumbered}

以下では、データセットをパーツに分割し、`map()` の反復処理を用いて、各パーツを個別のエクセルシート、または個別の CSV ファイルとしてエクスポートする方法を例示します。

#### データの分割 {.unnumbered}

例えば、コンプリートケースであるデータフレーム `linelist` があるとします。各病院ごとに個別の linelist を作成し、それぞれを個別の CSV ファイルとしてエクスポートしたいとします。次のような手順で行います：

`group_split()`（**dplyr** より）を使用して、データフレーム `linelist` を `hospital` 列内の値で分割します。これにより、病院別のデータフレームからなるリストが出力されます。

```{r}
linelist_split <- linelist %>% 
     group_split(hospital)
```

`View(linelist_split)` を実行すると、このリストは 6 つのデータフレーム（"tibbles"）からなり、それぞれが 1 つの病院の症例を表していることがわかります。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split.png"))
```

ただし、リスト内のデータフレームには、デフォルトでは名前が付いていないことに注意してください！それぞれのデータフレームに名前を付けて、CSV ファイルを保存するときにその名前を使うようにしたいと思います。

名前を抽出する方法として、**dplyr** の `pull()` を使って、リストの各データフレームから `hospital` 列を抽出する方法があります。次に、エラーの無いように、値を文字に変換してから、`unique()` を使って、データフレームの名前を得ます。これらのステップはすべて、`map()` によって各データフレームに適用されます。

```{r}
names(linelist_split) <- linelist_split %>%   # リストされたデータフレームの名前を指定する 
     # それぞれのデータフレームに以下の関数を適用することで、名前を抽出する 
     map(.f = ~pull(.x, hospital)) %>%        # hospital 列を取り出す
     map(.f = ~as.character(.x)) %>%          # 取り出した値を、念のため、文字に変換する
     map(.f = ~unique(.x))                    # 病院名を抽出する
```

これで、リストの各要素に名前を付けることが出来ました。これらの名前は `names(linelist_split)` で確認することが出来ます。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split_named.png"))
```

```{r}
names(linelist_split)
```

##### 2 つ以上の列を用いた `group_split()` {.unnumbered}

例えば、病院と性別の組み合わせで linelist のサブセットを作成するなど、*複数の列により条件づけて* linelist を分割したい場合は、リストの要素に名前を付けるやり方が異なります。まず、**dplyr** の `group_keys()` を使って、病院・性別の全ての組み合わせに対する "グループキー" を作成します（これは、データフレームとして作成されます）。次に、以下のように、`unite()` を使ってグループキーを値に結合し、変数の組み合わせ名を `linelist_split` に割り当てます。

```{r}
# linelist を病院と性別の全ての組み合わせによって分割する
linelist_split <- linelist %>% 
     group_split(hospital, gender)

# グループキーをデータフレームとして抽出する
groupings <- linelist %>% 
     group_by(hospital, gender) %>%       
     group_keys()

groupings      # グループキーを表示する 
```

次に、グループキーをダッシュで区切って結合し、それを `linelist_split` のリスト要素の名前とします。これには、`NA` を "Missing" に置き換え、**dplyr** の `unite()` を使って列の値をダッシュで区切って結合し、無名のベクトルに変換して、`linelist_split` の名前として使えるようにする、という追加の処理が必要になります。

```{r, eval=F}
# 一つの名前の値に結合する 
names(linelist_split) <- groupings %>% 
     mutate(across(everything(), replace_na, "Missing")) %>%  # 全ての列において NA を "Missing" に置き換える
     unite("combined", sep = "-") %>%                         # 全ての列の値を一つに結合する
     setNames(NULL) %>% 
     as_vector() %>% 
     as.list()
```

#### エクセルシートとして出力する {.unnumbered}

**writexl** パッケージの `write_xlsx()` 関数に名前付きリストである `linelist_split` を 与えることで、*シートごとに 1 つの*病院の*ラインリストを持つエクセルワークブック*として出力することが出来ます。この関数は、複数のシートからなるエクセルワークブックを保存する機能があります。また、リストの要素名がシート名として自動的に適用されます。

```{r, eval=F}
linelist_split %>% 
     writexl::write_xlsx(path = here("data", "hospital_linelists.xlsx"))
```

エクセルファイルを開くと、それぞれの病院ごとに一つのシートに保存されているのが分かると思います。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_sheets.png"))
```

#### CSVファイルとして出力する {.unnumbered}

少し複雑になりますが、それぞれの病院固有のラインリストを、別々の CSV ファイルとして出力することもできます。ファイルの名前をそれぞれの病院の名前として出力します。

今回も、 `map()` を使用します：上に示したように、リストの要素名のベクトルを `map()` に与えることで、リスト `linelist_split` 内のデータフレームに **rio** パッケージの `export()`（［Import and export］ページを参照）を繰り返し適用します。また、この名前は、病院固有のファイル名を作るのに使用します。以下にその方法を示します：

-   まず、文字名ベクターを `.x` として `map()` に与えます

-   `.f` 関数は `export()` になります。この中で、書き込み先となるデータフレームとファイルパスを指定します

-   入力された `.x`（病院名）は `.f` *の中において、*リスト `linelist_split` 内のインデックスとなります。こうすることで、データフレームとして `export()` に適用することが出来ます

-   例えば、"Military Hospital" のデータに対して `map()` が適用されている時は、`linelist_split[[.x]]` は実際には `linelist_split[["Military Hospital"]]` のことであり、 `linelist_split` の "Military Hospital" の要素が返されます

-   `export()` に適用されるファイルパスは、 `str_glue()` を使用することで、各病院名を適用することが出来ます（［Characters and strings］ページを参照）：

    -   ファイルパスの起点、および "データ" のフォルダを特定するために `here()` を用います。（`str_glue()` 内で使用されている二重引用符を邪魔しないように、一重引用符を使用していることに注意してください）

-   それから、`/` と再び `.x` を記載し、ファイルが特定できるように病院名をファイル名にあてがいます

-   最後に、`export()` によって CSV ファイルが作成されるように拡張子 ".csv" を記します

```{r, eval=F, message = F, warning=F}
names(linelist_split) %>%
     map(.f = ~export(linelist_split[[.x]], file = str_glue("{here('data')}/{.x}.csv")))
```

これで、それぞれのファイルが R プロジェクト "Epi_R\_handbook" の "data" フォルダ内に保存されました！

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_csv.png"))
```

### カスタム関数 {.unnumbered}

`map()` に与える関数を自分で作成したい場合はどうするのでしょうか。

例えば、それぞれの病院のケースごとに流行曲線を作成したいとします。これを **purrr** を用いて行うには、`.f` 関数を `ggplot()` （`+` を用いて通常通り拡張することも可能です）にすることで出来ます。`map()` は常にリストを出力するので、プロットもリストに保存されます。プロットの場合は **ggpubr** パッケージの `ggarrange()` 関数を用いて抽出しプロットすることが出来ます。([documentation](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html))

```{r, message = F, warning=F}

# リストから要素をプロットするためのパッケージのローディング
pacman::p_load(ggpubr)

# 6 つの病院の "名前" のベクターに対してマッピングする（前に作成済）
# ggplot 関数を用いる
# 出力は6 つの ggplots からなるリストとなる

hospital_names <- unique(linelist$hospital)

my_plots <- map(
  .x = hospital_names,
  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +
                geom_histogram(aes(x = date_onset)) +
                labs(title = .x)
)

# ggplots を表示する（リストとして保存されている）
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

この `map()` コードが複雑すぎる場合、作成した `ggplot()` コマンドをユーザーの定義したカスタム関数として用いても、同様の結果を得ることが出来ます。例えば、その関数を `make_epicurve())` と名づけるとします。この関数は `map()` 内で用いることが出来ます。`.x` は繰り返しごとにそれぞれの病院名として機能し、`make_epicurve()` 関数内では `hosp_name` として表示されています。［Writing functions］のページを参照してください。

```{r, eval=F}
# 関数を作成する
make_epicurve <- function(hosp_name){
  
  ggplot(data = linelist %>% filter(hospital == hosp_name)) +
    geom_histogram(aes(x = date_onset)) +
    theme_classic()+
    labs(title = hosp_name)
  
}
```

```{r, eval=F}
# マッピングする
my_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))

# ggplots を表示する（リストとして保存されている）
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

### 列全体に対して関数をマッピングする {.unnumbered}

その他に良く用いられる例としては、列全体に対して関数をマッピングする、というものです。以下では、データフレーム `linelist` 内の数字列に対して `t.test()` 関数を `map()` し、性別で数値を比較しています。

［Simple statistical tests］のページで学んだことを思い出してください。`t.test()` は `t.test(numeric column ~ binary column)` のような数式形式の入力を受けることが出来るのでした。この例では、以下のことを行います：

-   比較したい数字列を、`linelist` から選びます。これらは、`map()` に対しての入力 `.x` になります

-   `t.test()` 関数は、`.f` 関数として、それぞれの数字列に対して適用されます

-   `t.test()` のカッコ内は：

    -   最初の `~` は `.f` に先行し、`.x` に対して `map()` が反復処理を行うことを意味します
    -   `.x` は現在 `t.test()` 関数に適用されている列を表します
    -   2つ目の `~` は、上で説明した通り、t 検定の数式の一部です
    -   `t.test()` 関数は、右辺に 2 値変数からなる列を受けることが出来ます。ここでは `linelist$gender` というベクターを受けています（`select()` には含まれていないことに注意してください）

-   `map()` はリストを返すので、出力は t 検定の結果を示すリストになります。一つのリスト要素がそれぞれの数字列の結果を表しています

```{r}
# 結果はリストとして保存される
t.test_results <- linelist %>% 
  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # マッピングしたい数字列だけを選択する
  map(.f = ~t.test(.x ~ linelist$gender))        # t.test 関数は、数字値 ~ カテゴリ値で表される数式と用いる
```

RStudio では、`t.test_results` はこのように表示されます。重要なポイントをいくつかあげます。

-   一番上に全てのリストを束ねる `t.test_results` と名づけられたリストがあるのが分かると思います。これは、5 つの要素からなり、それぞれの要素は `linelist` から選択され `gender` での t 検定に用いられた変数名から `age`, `wt_km`, `ht_cm`, `ct_blood`, `temp` と名づけられています。\
-   5 つの要素それぞれはリストであり、`p.value` や `conf.int` といった要素からなっています。これらの要素のうち、`p.value` などは単一の値であり、一方 `estimate` などは 2 つ以上の要素（`mean in group f` と `mean in group m`）からなっています。

```{r, out.height="150%", echo=F}
knitr::include_graphics(here::here("images", "purrr_ttest.png"))
```

注意事項：データフレーム内の特定の列にのみ関数を適用させたい場合、［Cleaning data and core functions］ ページで説明したように、もっとシンプルに `mutate()` と `across()` を用いることも出来ます。下に、"age" の列にだけ `as.character()` を適用させる例を示しています。括弧とコンマの位置に注意してください。

```{r, eval=F}
# 列名に "age" を含む列を文字変数に変換する
linelist <- linelist %>% 
  mutate(across(.cols = contains("age"), .fns = as.character))  
```

### リストから抽出する {.unnumbered}

`map()` からリスト変数が出力されるので、**purrr** 関数を用いてリストからデータを抽出する方法について少し説明したいと思います。説明のために、前のセクションで出てきた `t.test_results` というリストを使用したいと思います。これは、5 つのリストからなるリストで、5 つのリストにはそれぞれデータフレーム `linelist` のいくつかの変数と 2 値変数である `gender` との間の t 検定の結果が保存されています。リスト構造の図は上に示されています。

#### 要素の名前 {.unnumbered}

要素自体の名前を抽出するには、R の基本パッケージ **base** の `names()` を使うことで簡単にできます。今回は、`names()` を `t.test_results` に適用することでそれぞれのサブリスト名（t 検定に用いられた変数の名前）を抽出します。

```{r}
names(t.test_results)
```

#### 名前または位置による要素の特定 {.unnumbered}

リストの要素を名前、または位置で抽出するには、［R basics］ ページで説明したように `[[ ]]` を用いることで出来ます。以下では、二重括弧を `t.tests_results` というリストに用いて `age` に対する t 検定の結果（リストの最初の要素）を特定しています。

```{r}
t.test_results[[1]] # 位置で最初の要素を特定
t.test_results[[1]]["p.value"] # 最初の要素内の "p.value" という名前の要素を返す  
```

しかし、以下では、よりシンプルで柔軟性の高い **purrr** の関数 `map()` と `pluck()` を用いる方法を説明します。

#### `pluck()` {.unnumbered}

`pluck()` は要素を名前もしくは位置で抽出することが出来ます。例えば、年齢に対する t 検定の結果を抽出するには `pluck()` を以下のように用いることが出来ます：

```{r}
t.test_results %>% 
  pluck("age")        # 代わりに pluck(1) を用いることもできる
```

さらに下の階層を指定するには、コンマを使います。以下の例では、`t.test_results` というリスト内の `age` というリストの要素である "p.value" を抽出しています。文字名ではなく、数字を代わりに用いることもできます。

```{r}
t.test_results %>% 
  pluck("age", "p.value")
```

*全ての*最上階層から、より下の階層にある要素を抽出するには `map()` を用いて、`pluck()` 関数をそれぞれの最上階層の要素に適用させればよいです。例えば、以下のコードでは `t.test_results` 内の全てのリストから "p.value" という要素を抽出しています。すなわち、`t.test_results` は反復処理対象となる `.x` であり、`pluck()` ば反復処理内容となる `.f` 関数であり、"p-value" は関数に対して適用されています。

```{r}
t.test_results %>%
  map(pluck, "p.value")   # 全ての p 値を返す
```

他には、`map()` で要素の名前を引用符をつけて示し、それを抽出してくる方法があります。`map()` を利用すると出力はリストなのですが、`map_chr()` を用いると名前付きの文字ベクターを出力でき、`map_dbl()` を用いると名前付きの数字ベクターを出力することが出来ます。

```{r}
t.test_results %>% 
  map_dbl("p.value")   # p 値を名前付きの数字ベクターとして返す
```

`pluck()` については、**purrr** [documentation](https://purrr.tidyverse.org/reference/pluck.html) に詳しく書いてあります。`chuck()` という関数もあり、こちらは要素が存在しなければ NULL ではなくエラーを返してくれます。

### リストをデータフレームに変換する {.unnumbered}

これは少し複雑な内容です。より網羅的なチュートリアルが必要な場合は Resources セクションを参考にしてください。ここではリストで得られた t 検定の結果をデータフレームに変換する方法を示します。p 値と 2 つのグループ（男性と女性）の平均値の変数を示している列からなるデータフレームを作成します。

方法と使用する関数を示します：

-   tibble （データフレームのようなもの）を作成するために `tibble()` を使います

    -   全ての `t.test_results` が tibble の最初の列として保存されないように `tibble()` 関数をひげ括弧で括ります

-   `tibble()` 内では、それぞれの列が明示的に作成されるので、`mutate()` での列の作成に似ています：

    -   `.` は `t.test_results` を表しています
    -   列名を t 検定で用いた変数名（それぞれのリスト要素の名前）にしたい場合、上で示しているように `names()` を使用します
    -   列名を p 値にしたい場合、上で示しているように `map_dbl()` を用いて `p.value` の要素を引用しそれを数字ベクターに変換します

```{r}
t.test_results %>% {
  tibble(
    variables = names(.),
    p         = map_dbl(., "p.value"))
  }
```

今回は、さらにそれぞれのグループ（男性と女性）の平均値の列を追加したいと思います。

`estimate` の要素を抽出したいのですが、問題はその中に *2 つの*要素 （`mean in group f` と `mean in group m`）が含まれているということです。なので、`map_chr()` や `map_dbl()` を用いてベクターに変換することはできません。その代わりに、`tibble()` 内で `map()` を用いることで *tibble 内にリスト要素の列*を作成することが出来ます！

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate"))}
```

一旦リスト要素の列が出来てしまえば、こうした "入れ子構造内のリスト要素の列" を "外に取り出す" のに役立つ **tidyr** 関数（**tidyverse** の関数の一つ）がいくつかあります。[here]() を参照するか、`vignette("rectangle")` と打ち込んでみてください。簡単に述べると：

-   `unnest_wider()` ー リスト要素の列のそれぞれの要素を、列として外に出します
-   `unnest_longer()` ー リスト要素の列のそれぞれの要素を、行として外に出します
-   `hoist()` ー `unnest_wider()` と似ていますが、どの要素を入れ子構造の外に出すか指定する必要があります

以下では、`unnest_wider()` に tibble を渡し、tibble 内の入れ子になっているリスト要素である `means` 列を指定しています。この結果、`means` はもともとそれぞれの `means` のセル内の値であった要素からなる 2 つの列に変換されました。

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate")
    )} %>% 
  unnest_wider(means)
```

### リストを捨てたり、キープしたり、コンパクトにしたりする {.unnumbered}

**purrr** を用いる際にはリストを扱うことが多いので、簡単にリストを変換するのに用いられる **purrr** 関数をいくつか見てみたいと思います。より **purrr** 関数の詳細を知りたい方は Resources セクションを参照してください。

-   `list_modify()` にはいくつかの機能がありますが、例えばリストの要素を取り除く、という機能があります\
-   `keep()` は、`.p =` によって指定された要素、もしくは `.p =` に与えられた関数が TRUE となる要素をキープします\
-   `discard()` は、`.p =` によって指定された要素、もしくは `.p =` に与えられた関数が TRUE となる要素を取り除きます\
-   `compact()` は、全ての空の要素を取り除きます

それでは、[using map() to import and combine multiple files](#iter_combined) のセクションで作成したリスト `combined` （6つのデータフレームを含むリストです）を用いて例を示します：

要素は、`list_modify()` を用いてリスト名を `NULL` に指定することで取り除くことが出来ます。

```{r, eval=F}
combined %>% 
  list_modify("Central Hospital" = NULL)   # リスト要素を名前を指定して取り除く
```

また、何かの基準を指定して要素を取り除くこともできます。その場合は、"述語" 関数（TRUE か FALSE を判定する関数）を `.p =` に渡します。チルダ `~` を関数の前に用い、リスト要素を表す `.x` を用います。TRUE と判定されたリスト要素をキープするのに `keep()` を用います。逆に、TRUE と判定されたリスト要素を取り除くには `discard()` を用います。

```{r, eval=F}
# 500 行以上を含むリスト要素のみをキープする
combined %>% 
  keep(.p = ~nrow(.x) > 500)  
```

以下の例では、データフレームでない要素を取り除いています。

```{r, eval=F}
# データフレームではないリスト要素を取り除く
combined %>% 
  discard(.p = ~class(.x) != "data.frame")
```

述語関数にそれぞれのリスト内の要素や列を用いることもできます。例えば、以下では、`ct_blood` 列の平均値が 25 よりも大きいリスト要素を取り除いています。

```{r, eval=F}
# ct_blood 列の平均値が 25 以上のリスト要素を取り除く
combined %>% 
  discard(.p = ~mean(.x$ct_blood) > 25)  
```

以下のコマンドでは全ての空の列を取り除いています：

```{r, eval=F}
# 全ての空の列を取り除く
combined %>% 
  compact()
```

### `pmap()` {.unnumbered}

THIS SECTION IS UNDER CONSTRUCTION

## Apply 関数

反復処理の際に **purrr** の代わりに R の **base** 関数である "apply" の仲間を用いることもできます。詳しくはこちらを読んでみてください。[here](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family)

<!-- ======================================================= -->

## Resources

[for loops with Data Carpentry](https://datacarpentry.org/semester-biology/materials/for-loops-R/)

The [R for Data Science page on iteration](https://r4ds.had.co.nz/iteration.html#iteration)

[Vignette on write/read Excel files](https://martinctc.github.io/blog/vignette-write-and-read-multiple-excel-files-with-purrr/)

A purrr [tutorial](https://jennybc.github.io/purrr-tutorial/index.html) by jennybc

Another purrr [tutorial](http://www.rebeccabarter.com/blog/2019-08-19_purrr/) by Rebecca Barter

A purrr [tutorial](http://zevross.com/blog/2019/06/11/the-power-of-three-purrr-poseful-iteration-in-r-with-map-pmap-and-imap/) on map, pmap, and imap

[purrr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png)

[purrr tips and tricks](https://www.hvitfeldt.me/blog/purrr-tips-and-tricks/)

[keep and discard](https://hookedondata.org/going-off-the-map/#keep-and-discard)
