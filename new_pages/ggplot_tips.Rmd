
# ggplotのヒント {}

このページでは、ggplotを使ってより美しい図を作るためのヒント・トリックを紹介します。より基礎的な使い方については、前章 [ggplot の基礎](#ggplot-basics)のページを参照してください。 

この章の終わりにあるリソースのページには、ggplot2に関するいくつかの詳細な[チュートリアル](https://ggplot2.tidyverse.org/)を掲載しています。RStudio のウェブサイトからはこちらの [ggplot によるデータ可視化のためのチートシート](https://rstudio.com/resources/cheatsheets/)をダウンロードすることができます。また [R graph gallery](https://www.r-graph-gallery.com/) と [Data-to-viz](https://www.data-to-viz.com/caveats.html) は美しい図を作るインスピレーションを得るためにとてもおすすめのウェブサイトです。



<!-- ======================================================= -->
## 準備 {}

### パッケージの読み込み {.unnumbered}

以下のコードにより必要なパッケージを読み込みます。このハンドブックでは **pacman** パッケージの `p_load()` を使うことで、パッケージのインストールと読み込みを同時に行っています。インストールされたパッケージの読み込みはRの基本パッケージ **base**　に含まれる `library()` でも可能です。詳細は[R の基礎](#r-basics)のページを参照してください。 

```{r}
pacman::p_load(
  tidyverse,      # includes ggplot2 and other
  rio,            # import/export
  here,           # file locator
  stringr,        # working with characters   
  scales,         # transform numbers
  ggrepel,        # smartly-placed labels
  gghighlight,    # highlight one part of plot
  RColorBrewer    # color scales
)
```

### データの読み込み {.unnumbered}  

このページでは、エボラウイルスパンデミックのシミュレーションデータから、症例リストを読み込みます。チュートリアルに沿って操作したい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>こちらのリンクから</a>整頓されたラインリスト（.rdsファイル）をダウンロードしてください。 **rio** パッケージの `import()` を使ってデータを読み込みます（この関数は.xlsx、.csv、.rdsなど多くのファイル形式を処理できます。詳細は[インポートとエクスポート](#import-and-export)のページを参照してください）。

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

以下に最初の５０行を表示します。

```{r, message=FALSE, echo=F}
# ラインリストをテーブルで表示
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




<!-- ======================================================= -->
## color、fill、座標軸などのスケール {#ggplot_tips_colors}

**ggplot2** でエステティクスパラーメータ（size、color、shape、fill、座標軸など）をデータフレームの列に対応させるとき、それぞれのスケールを操作することで、どのように図に反映するかを詳細に調整することができます。


### 色の調整

**ggplot2** を使う上で最初に躓きやすいものが色の調整です。この節では点や線、棒グラフやタイルなど、図のオブジェクトの色の調整を扱います。テキストやタイトル、背景などの色の調整に関しては [ggplot の基礎](#ggplot-basics)のページの [Themes](#ggplot_basics_themes) の節を参照してください。

図の "色" を調整するとき、影響されるエステティクスパラメータは `color = `（外側の色）もしくは `fill = `（内側の色）です。`geom_point()` では例外的に `color = ` のみを調整することで、点の色（内と外両方）を操作します。

色を指定するには、`"red"` のような色の名前（[こちらのリスト](http://sape.inf.usi.ch/quick-reference/ggplot2/colour)を参照するか、`?colors` コマンドで一覧が表示できます）か、`"#ff0505"` のような16進コードを用います。

```{r, warning=F, message=F}
# ヒストグラム 
ggplot(data = linelist, mapping = aes(x = age))+       # データと軸を指定
  geom_histogram(              # ヒストグラムを表示
    binwidth = 7,                # ビンの幅
    color = "red",               # ビンの外側の色
    fill = "lightblue")          # ビンの内側の色
```



As explained the [ggplot basics] section on [mapping data to the plot](#ggplot_basics_mapping), aesthetics such as `fill = ` and `color = ` can be defined either *outside* of a `mapping = aes()` statement or *inside* of one. If *outside* the `aes()`, the assigned value should be static (e.g. `color = "blue"`) and will apply for *all* data plotted by the geom. If *inside*, the aesthetic should be mapped to a column, like `color = hospital`, and the expression will vary by the value for that row in the data. A few examples:  

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# Static color for points and for line
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(color = "purple")+
  geom_vline(xintercept = 50, color = "orange")+
  labs(title = "Static color for points and line")

# Color mapped to continuous column
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = temp))+         
  labs(title = "Color mapped to continuous column")

# Color mapped to discrete column
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = gender))+         
  labs(title = "Color mapped to discrete column")

# bar plot, fill to discrete column, color to static value
ggplot(data = linelist, mapping = aes(x = hospital))+     
  geom_bar(mapping = aes(fill = gender), color = "yellow")+         
  labs(title = "Fill mapped to discrete column, static color")

```


### Scales {#ggplot_tips_scales .unnumbered}  

Once you map a column to a plot aesthetic (e.g. `x = `, `y = `, `fill = `, `color = `...), your plot will gain a scale/legend. See above how the scale can be continuous, discrete, date, etc. values depending on the class of the assigned column. If you have multiple aesthetics mapped to columns, your plot will have multiple scales.  

You can control the scales with the appropriate `scales_()` function. The scale functions of **ggplot()** have 3 parts that are written like this: `scale_AESTHETIC_METHOD()`.  

1) The first part, `scale_()`, is fixed.  
2) The second part, the AESTHETIC, should be the aesthetic that you want to adjust the scale for (`_fill_`, `_shape_`, `_color_`, `_size_`, `_alpha_`...) - the options here also include `_x_` and `_y_`.  
3) The third part, the METHOD, will be either `_discrete()`, `continuous()`, `_date()`, `_gradient()`, or `_manual()` depending on the class of the column and *how* you want to control it. There are others, but these are the most-often used.  

Be sure that you use the correct function for the scale! Otherwise your scale command will not appear to change anything. If you have multiple scales, you may use multiple scale functions to adjust them! For example:  

### Scale arguments {.unnumbered}  

Each kind of scale has its own arguments, though there is some overlap. Query the function like `?scale_color_discrete` in the R console to see the function argument documentation.  

For continuous scales, use `breaks = ` to provide a sequence of values with `seq()` (take `to = `, `from = `, and `by = ` as shown in the example below. Set `expand = c(0,0)` to eliminate padding space around the axes (this can be used on any `_x_` or `_y_` scale.  

For discrete scales, you can adjust the order of level appearance with `breaks = `, and how the values display with the `labels = ` argument. Provide a character vector to each of those (see example below). You can also drop `NA` easily by setting `na.translate = FALSE`.  

The nuances of date scales are covered more extensively in the [Epidemic curves] page.  


### Manual adjustments {.unnumbered}  

One of the most useful tricks is using "manual" scaling functions to explicitly assign colors as you desire. These are functions with the syntax `scale_xxx_manual()` (e.g. `scale_colour_manual()` or `scale_fill_manual()`). Each of the below arguments are demonstrated in the code example below.  

* Assign colors to data values with the `values = ` argument  
* Specify a color for `NA` with `na.value = `  
* Change how the values are *written* in the legend with the `labels = ` argument  
* Change the legend title with `name = `  


Below, we create a bar plot and show how it appears by default, and then with three scales adjusted - the continuous y-axis scale, the discrete x-axis scale, and manual adjustment of the fill (interior bar color).  


```{r, warning=F, message=F}
# BASELINE - no scale adjustment
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")

# SCALES ADJUSTED
ggplot(data = linelist)+
  
  geom_bar(mapping = aes(x = outcome, fill = gender), color = "black")+
  
  theme_minimal()+                   # simplify background
  
  scale_y_continuous(                # continuous scale for y-axis (counts)
    expand = c(0,0),                 # no padding
    breaks = seq(from = 0,
                 to = 3000,
                 by = 500))+
  
  scale_x_discrete(                   # discrete scale for x-axis (gender)
    expand = c(0,0),                  # no padding
    drop = FALSE,                     # show all factor levels (even if not in data)
    na.translate = FALSE,             # remove NA outcomes from plot
    labels = c("Died", "Recovered"))+ # Change display of values
    
  
  scale_fill_manual(                  # Manually specify fill (bar interior color)
    values = c("m" = "violetred",     # reference values in data to assign colors
               "f" = "aquamarine"),
    labels = c("m" = "Male",          # re-label the legend (use "=" assignment to avoid mistakes)
              "f" = "Female",
              "Missing"),
    name = "Gender",                  # title of legend
    na.value = "grey"                 # assign a color for missing values
  )+
  labs(title = "Adjustment of scales") # Adjust the title of the fill legend
```

### 連続数の座標軸スケール {.unnumbered}  

データを座標軸に反映させる場合でも、スケール関数を用いて表示方法を操作することができます。よくある例として、y 軸などの座標軸を連続数からなる列に対応させる場合を紹介します。

`scale_y_continuous()` を用いて、座標軸のブレークや値の表示方法を変更することを考えます。前述のとおり、breaks = により入力する一連の数字によって座標軸上のブレークポイントが指定できます。ここで入力された数字が座標軸上に表示される数字に対応します。`c()` ベクターにより表示させたい数字を直接入力するか、**base** 関数 `seq()` を用いて表示される数字の開始（`from = `）と終わり（`to = `）、インターバル（`by = `）をそれぞれ入力することができます。

```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# 基本構文 – スケール操作なし
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")

# 
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  scale_y_continuous(
    breaks = seq(
      from = 0,
      to = 3000,
      by = 100)
  )+
  labs(title = "Adjusted y-axis breaks")

```



#### パーセント表示 {.unnumbered}  

座標軸に対応させるデータの値が割合のとき、以下のようにスケール関数中に `labels = scales::percent` を加えることで、簡単にパーセント表示に変更することができます。

値の種類を文字に変更し "%" を付加することでもパーセント表示が得られますが、その場合データが連続数ではなくなるため好ましくありません。 


```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# 元々の割合表示
#############################
linelist %>%                                   # start with linelist
  group_by(hospital) %>%                       # group data by hospital
  summarise(                                   # create summary columns
    n = n(),                                     # total number of rows in group
    deaths = sum(outcome == "Death", na.rm=T),   # number of deaths in group
    prop_death = deaths/n) %>%                   # proportion deaths in group
  ggplot(                                      # begin plotting
    mapping = aes(
      x = hospital,
      y = prop_death))+ 
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis original proportions")



# パーセント表示
########################################
linelist %>%         
  group_by(hospital) %>% 
  summarise(
    n = n(),
    deaths = sum(outcome == "Death", na.rm=T),
    prop_death = deaths/n) %>% 
  ggplot(
    mapping = aes(
      x = hospital,
      y = prop_death))+
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis as percents (%)")+
  scale_y_continuous(
    labels = scales::percent                    # display proportions as percents
  )

```

#### Log スケール {.unnumbered}  

Logスケールを用いるには、 `trans = "log2"` をスケール関数に加えます。例として、 各地域とその `preparedness_index` および累積症例数を列にもつデータフレームを考えます。

```{r}
plot_data <- data.frame(
  region = c("A", "B", "C", "D", "E", "F", "G", "H", "I"),
  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),
  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)
)

plot_data
```

地域 "I" の症例数は他と比べて遥かに高くなっています。このような場合、y 軸を log スケールにすることで、症例数が少ない地域間の差異を見やすくすることができます。

```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# もともとの y 軸スケール
preparedness_plot <- ggplot(data = plot_data,  
       mapping = aes(
         x = preparedness_index,
         y = cases_cumulative))+
  geom_point(size = 2)+            # points for each region 
  geom_text(
    mapping = aes(label = region),
    vjust = 1.5)+                  # add text labels
  theme_minimal()

preparedness_plot                  # print original plot


# y 軸を log スケールで表示
preparedness_plot+                   # begin with plot saved above
  scale_y_continuous(trans = "log2") # add transformation for y-axis
```



### 勾配スケール {.unnumbered}  

配色に勾配スケールを用いることで、表現の幅を広げることができます。初期設定でも美しい図が得られますが、値や切り捨て値などの詳細を調整することが可能です。

ここでは、[コンタクトトレーシングのページ](#contact-tracing-1)で扱った各症例とその感染源の年齢を値に持つデータを用いて、連続数に対応するカラースケールの調整方法を紹介します。 


```{r, warning=F, message=F}
case_source_relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>% 
  select(source_age, target_age) 
```

以下の例では、ラスターヒートマップを描画します。ヒートマップについての詳細はここでは扱わず（前段落のリンクを参照してください）、カラースケールの変更方法に焦点を当てます。**ggplot2** の `stat_density2d()` 関数については[こちら](https://ggplot2.tidyverse.org/reference/geom_density_2d.html)を参照してください。`fill` スケールが連続数であることに注意してください。

```{r, warn=F, message=F}
trans_matrix <- ggplot(
    data = case_source_relationships,
    mapping = aes(x = source_age, y = target_age))+
  stat_density2d(
    geom = "raster",
    mapping = aes(fill = after_stat(density)),
    contour = FALSE)+
  theme_minimal()
```

ここでいくつかのバリエーションを紹介します：

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
trans_matrix
trans_matrix + scale_fill_viridis_c(option = "plasma")
```

ブレークポイントを変更する例も見ていきましょう：

* `scale_fill_gradient()` は2つの色(high/low)を入力に取ります
* `scale_fill_gradientn()` は `values = `で長さの制限なく色のベクターを入力に取ります。間の値は自動で補完されます。
* [`scales::rescale()`](https://www.rdocumentation.org/packages/scales/versions/0.4.1/topics/rescale) によって各色が勾配のどの位置に置かれるかを指定できます。この関数は数字ベクターをとり、0から1の間で色の位置をリスケールします。 


```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
trans_matrix + 
  scale_fill_gradient(     # ２色スケール
    low = "aquamarine",    # 低い値の色
    high = "purple",       # 高い値の色
    na.value = "grey",     # NAの色
    name = "Density")+     # レジェンドタイトル
  labs(title = "Manually specify high/low colors")

# ３色以上の指定
trans_matrix + 
  scale_fill_gradientn(    # 3色（low/mid/high）
    colors = c("blue", "yellow","red") # ベクターで色を指定
  )+
  labs(title = "3-color scale")

# rescale() で色の配置を調整
trans_matrix + 
  scale_fill_gradientn(    # 任意の数の色を指定
    colors = c("blue", "yellow","red", "black"),
    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # 色の位置を0から1の間で指定
    )+
  labs(title = "Colors not evenly positioned")

# limits により配色される下限・上限値を設定
trans_matrix + 
  scale_fill_gradientn(    
    colors = c("blue", "yellow","red"),
    limits = c(0, 0.0002))+
  labs(title = "Restrict value limits, resulting in grey space")

```


### カラーパレット {.unnumbered}  

#### Colorbrewer と Viridis {.unnumbered}
`scale_xxx_brewer` もしくは `scale_xxx_viridis_y` の関数によって既成のカラーパレットを使用できます。ctions.  

'Brewer' 関数は [colorbrewer.org](colorbrewer.org) にあるパレットを使用します。  

'Viridis' 関数は viridis パレットを使用します。Viridis は "色付きでも白黒でも同様に認識でき、かつ色盲のひとにも識別しやすい色調になっています。"（詳細は[こちら](https://ggplot2.tidyverse.org/reference/scale_viridis.html)と[こちら](https://bids.github.io/colormap/)のリンクを参照してください。）カラーパレットが連続数、離散数、もしくはビニングスケールかによって、関数の末尾を変更します（例：離散数では `scale_xxx_viridis_d`）。

作成した図は[色盲シミュレータ](https://www.color-blindness.com/coblis-color-blindness-simulator/)で色盲のひとへの見え方をテストするようにしましょう。赤と緑の配色は色盲の人には識別しづらいため、[こちら](https://www.visualisingdata.com/2019/08/five-ways-to-design-for-red-green-colour-blindness/#:~:text=The%20pink%2Dred%20through%20to,green%20hues%20used%20by%20default.)で紹介されているように "熱冷"（赤・青）配色を代わりに用いましょう。 

ここでは [ggplot の基礎](#ggplot-basics)のページで扱った例を用いて、さまざまな配色を見ていきましょう。

```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F} 
symp_plot <- linelist %>%                                         # ラインリストから始める
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # 列を選択
  pivot_longer(                                                  # データを伸長
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # 欠測値を入れ替える
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  ggplot(                                                        # ggplotの入力開始！
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  theme(legend.position = "bottom")+
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )

symp_plot  # 初期設定による配色で表示

#################################
# print with manually-specified colors
symp_plot +
  scale_fill_manual(
    values = c("yes" = "black",         # 個別に色を指定する
               "no" = "white",
               "unknown" = "grey"),
    breaks = c("yes", "no", "unknown"), # ファクターの並び替え
    name = ""                           # タイトルなし
  ) 

#################################
# viridisによる離散スケールの配色
symp_plot +
  scale_fill_viridis_d(
    breaks = c("yes", "no", "unknown"),
    name = ""
  )


```



<!-- ======================================================= -->
## 離散値の順序変更 {}  

`ggplot2` に慣れないうちは、図に現れる離散値の順序変更はしばしば難しく感じられるでしょう。しかし、一度仕組みを理解すれば簡単です。一般的に離散値は `factor` として扱われ、アルファベット順に並べられます。これを並べ替えるには、ファクター のレベルを表示したい順序に変更するだけです。`factor` の並べ替えについてのさらなる詳細は [ファクターのページ](#factors)を参照してください。

例として年齢グループの並べ替えを見てみましょう。初期設定ではアルファベット順に従い、5-9 歳のグループは図の中央に配置されています。ファクターのレベルを変更することで、これを 0-4 歳の後に移動することができます。


```{r, , warning=F, message=F}
ggplot(
  data = linelist %>% drop_na(age_cat5),                         # age_cat5 を欠測した行の削除
  mapping = aes(x = fct_relevel(age_cat5, "5-9", after = 1))) +  # ファクターレベルの変更

  geom_bar() +
  
  labs(x = "Age group", y = "Number of hospitalisations",
       title = "Total hospitalisations by age group") +
  
  theme_minimal()


```

#### **ggthemr** {.unnnumbered}  

Also consider using the **ggthemr** パッケージも有用なパッケージの１つです。[こちらの Github](https://github.com/Mikata-Project/ggthemr) からチュートリアルに従ってダウンロードできます。このパッケージはとても美しいカラーパレットを使用できますが、扱える色の数に上限があるため、7-8 色以上の図を作成する際には注意が必要です。






## 等高線プロット

等高線プロットは、散布図だとデータポイントが多く重なり合ってしまうような場合（"オーバープロッティング" といいます）に有用です。先程の症例-感染源の年齢データを、ここでは `stat_density2d()` と `stat_density2d_filled()` を用いて地形図のように等高線プロットで描画します。統計学的な詳細については[こちら](https://ggplot2.tidyverse.org/reference/geom_density_2d.html)を参照してください。


```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F}
case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d()+
  geom_point()+
  theme_minimal()+
  labs(title = "stat_density2d() + geom_point()")


case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d_filled()+
  theme_minimal()+
  labs(title = "stat_density2d_filled()")

```



## 周辺分布

`geom_point()` による散布図の外側にデータ分布を示すには、**ggExtra** パッケージの `ggMarginal()` が有用です。オブジェクトとして保存したプロットデータを、以下のように `ggMarginal()` に入力します。いくつかの重要な引数を示します：

* `type = ` を用いてプロットのタイプを "histogram"、"density"、"boxplot"、"violin"、"densigram" のいずれかに指定する必要があります。
* 初期設定では、x 軸と y 軸両方に分布図が表示されます。どちらか一方のみにしたい場合は、`margins = `を "x" または "y" に設定します。
* 他に設定できる引数として `fill = `（バーの内側の色）`color = `（線の色）、`size = `（メインの図とマージン部分の比率。数字が大きいほどマージン部分は小さくなります）があります。
* `xparams = `と `yparams = `を用いて、座標軸を指定してその他のパラメータを設定できます。以下の例では、軸ごとに異なるビンの幅を指定しています。

周辺分布にデータ内のグループ（`ggplot()` 内のエステティクスで `color = `に指定されている列）を反映させることもできます。その場合は以下のように、`ggMarginal()` 内の `groupColour = `もしくは `groupFill = `を `TRUE` に設定します。

より詳しい解説は[こちらのビネット](https://cran.r-project.org/web/packages/ggExtra/vignettes/ggExtra.html)、[R グラフギャラリー](https://www.r-graph-gallery.com/277-marginal-histogram-for-ggplot2.html)もしくは `?ggMarginal` を R コンソールに入力して表示できるページを参照してください。

```{r, message=FALSE, warning=FALSE}
# ggExtra のインストールと読み込み
pacman::p_load(ggExtra)

# 体重と年齢を基本の散布図で図示する
scatter_plot <- ggplot(data = linelist)+
  geom_point(mapping = aes(y = wt_kg, x = age)) +
  labs(title = "Scatter plot of weight and age")
```

ヒストグラムを周辺図として追加する場合は `type = "histogram"` を指定します。さらに `groupFill = TRUE` と設定することで多重ヒストグラムを描画できます。

```{r, message=FALSE, warning=FALSE}
# ヒストグラム
ggMarginal(
  scatter_plot,                     # 周辺分布図を追加
  type = "histogram",               # ヒストグラムを指定
  fill = "lightblue",               # バー内の色を指定
  xparams = list(binwidth = 10),    # x 軸側の分布図のパラメータ
  yparams = list(binwidth = 5))     # y 軸側の分布図のパラメータ
```

グループ毎に色分けされた周辺分布図：

```{r, message=FALSE, warning=FALSE}

# 性別毎に色分けされた散布図
# ggplot の color を性別の列に対応させます。ggMarginal の groupFill を TRUE に設定します。
scatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+
  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +
  labs(title = "Scatter plot of weight and age")+
  theme(legend.position = "bottom")

ggMarginal(scatter_plot_color, type = "density", groupFill = TRUE)
```

`size = `によって周辺分布図のサイズを指定します。数字が小さいほど大きな周辺分布図が得られます。また `color = `も設定できます。以下の例は周辺分布ボックスプロットで、`margins = `により片方の軸にのみ表示させています：

```{r, message=FALSE, warning=FALSE}
# with boxplot 
ggMarginal(
  scatter_plot,
  margins = "x",      # only show x-axis marginal plot
  type = "boxplot")   
```



<!-- ======================================================= -->
## スマートラベリング {}  

**ggplot2** では図中にテキストを表示することもできます。しかし、テキストと図中のデータポイントが重なり読みづらくなってしまうということがしばしば起こります。R の基本関数ではこの問題を解決することは難しいですが、**ggrepel** という追加パッケージを使うことでうまく処理することができます！

**ggrepel** パッケージは `geom_label()` と `geom_text()` それぞれの代わりとなる新しい関数`geom_label_repel()` と `geom_text_repel()` を持ちます。これらの関数を基本関数の代わりに使うだけで、整ったラベルを作ることができます。これらの関数内では `aes()` を通常通り設定しますが、その中で `label = `によりラベルに使いたい列（例：患者 ID や名前など）を指定します。また `str_glue()` を使えば、以下の例のように複数の列を改行（`\n`）で繋いでより複雑なラベルを作ることも可能です。

いくつかのヒントを示します：

* `min.segment.length = 0` と設定すると常にデータポイントとラベルを繋ぐ線が描画され、逆に `min.segment.length = Inf` と設定すれば常に線は描画されません。
* `size = ` を `aes()` の外側で設定することで文字サイズを指定できます。
* `force = `によりラベルとデータポイント間をどの程度離すかを設定できます（初期設定は 1 ）。
* `fill = `を `aes()` 内で設定することでラベルの色を指定できます。
  * その場合、レジェンドには文字 "a" が表示されますが、これは `guides(fill = guide_legend(override.aes = aes(color = NA)))` により除くことができます。

より詳細なチュートリアルは[こちら]](https://ggrepel.slowkow.com/articles/examples.html)を参照してください。

```{r, , warning=F, message=F}
pacman::p_load(ggrepel)

linelist %>%                                               # ラインリスト
  group_by(hospital) %>%                                   # 病院でグループ分け
  summarise(                                               # 病院毎にまとめた新しいデータフレームを作る
    n_cases = n(),                                           # 病院毎の症例数
    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # 病院毎の発症までの平均日数
  ) %>% 
  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # ggplot にデータを入力
  geom_point(size = 2)+                                    # 散布図
  geom_label_repel(                                        # ラベルの追加
    mapping = aes(
      label = stringr::str_glue(
        "{hospital}\n{n_cases} cases, {delay_mean} days")  # ラベルの表示を指定
      ), 
    size = 3,                                              # ラベルの文字サイズ
    min.segment.length = 0)+                               # 全てのデータポイントとラベル間に線を表示segments                
  labs(                                                    # 図と座標軸のタイトル
    title = "Mean delay to admission, by hospital",
    x = "Number of cases",
    y = "Mean delay (days)")
```

You can label only a subset of the data points - by using standard `ggplot()` syntax to provide different `data = ` for each `geom` layer of the plot. Below, All cases are plotted, but only a few are labeled.    

```{r, warning=F, message=FALSE}

ggplot()+
  # All points in grey
  geom_point(
    data = linelist,                                   # all data provided to this layer
    mapping = aes(x = ht_cm, y = wt_kg),
    color = "grey",
    alpha = 0.5)+                                              # grey and semi-transparent
  
  # Few points in black
  geom_point(
    data = linelist %>% filter(days_onset_hosp > 15),  # filtered data provided to this layer
    mapping = aes(x = ht_cm, y = wt_kg),
    alpha = 1)+                                                # default black and not transparent
  
  # point labels for few points
  geom_label_repel(
    data = linelist %>% filter(days_onset_hosp > 15),  # filter the data for the labels
    mapping = aes(
      x = ht_cm,
      y = wt_kg,
      fill = outcome,                                          # label color by outcome
      label = stringr::str_glue("Delay: {days_onset_hosp}d")), # label created with str_glue()
    min.segment.length = 0) +                                  # show line segments for all
  
  # remove letter "a" from inside legend boxes
  guides(fill = guide_legend(override.aes = aes(color = NA)))+
  
  # axis labels
  labs(
    title = "Cases with long delay to admission",
    y = "weight (kg)",
    x = "height(cm)")
```





<!-- ======================================================= -->
## Time axes {}

Working with time axes in ggplot can seem daunting, but is made very easy with a few key functions. Remember that when working with time or date that you should ensure that the correct variables are formatted as date or datetime class - see the [Working with dates] page for more information on this, or [Epidemic curves] page (ggplot section) for examples.

The single most useful set of functions for working with dates in `ggplot2` are the scale functions (`scale_x_date()`, `scale_x_datetime()`, and their cognate y-axis functions). These functions let you define how often you have axis labels, and how to format axis labels. To find out how to format dates, see the _working with dates_ section again! You can use the `date_breaks` and `date_labels` arguments to specify how dates should look:

  1. `date_breaks` allows you to specify how often axis breaks occur - you can pass a string here (e.g. `"3 months"`, or "`2 days"`)
  
  2. `date_labels` allows you to define the format dates are shown in. You can pass a date format string to these arguments (e.g. `"%b-%d-%Y"`):


```{r, , warning=F, message=F}
# make epi curve by date of onset when available
ggplot(linelist, aes(x = date_onset)) +
  geom_histogram(binwidth = 7) +
  scale_x_date(
    # 1 break every 1 month
    date_breaks = "1 months",
    # labels should show month then date
    date_labels = "%b %d"
  ) +
  theme_classic()

```



<!-- ======================================================= -->
## Highlighting {}

Highlighting specific elements in a chart is a useful way to draw attention to a specific instance of a variable while also providing information on the dispersion of the full dataset. While this is not easily done in base **ggplot2**, there is an external package that can help to do this known as **gghighlight**. This is easy to use within the ggplot syntax.

The **gghighlight** package uses the `gghighlight()` function to achieve this effect. To use this function, supply a logical statement to the function - this can have quite flexible outcomes, but here we'll show an example of the age distribution of cases in our linelist, highlighting them by outcome.

```{r, , warning=F, message=F}
# load gghighlight
library(gghighlight)

# replace NA values with unknown in the outcome variable
linelist <- linelist %>%
  mutate(outcome = replace_na(outcome, "Unknown"))

# produce a histogram of all cases by age
ggplot(
  data = linelist,
  mapping = aes(x = age_years, fill = outcome)) +
  geom_histogram() + 
  gghighlight::gghighlight(outcome == "Death")     # highlight instances where the patient has died.

```

This also works well with faceting functions - it allows the user to produce facet plots with the background data highlighted that doesn't apply to the facet! Below we count cases by week and plot the epidemic curves by hospital (`color = ` and `facet_wrap()` set to `hospital` column).  

```{r, , warning=F, message=F}

# produce a histogram of all cases by age
linelist %>% 
  count(week = lubridate::floor_date(date_hospitalisation, "week"),
        hospital) %>% 
  ggplot()+
  geom_line(aes(x = week, y = n, color = hospital))+
  theme_minimal()+
  gghighlight::gghighlight() +                      # highlight instances where the patient has died
  facet_wrap(~hospital)                              # make facets by outcome

```





## Plotting multiple datasets  

Note that properly aligning axes to plot from multiple datasets in the same plot can be difficult. Consider one of the following strategies:  

* Merge the data prior to plotting, and convert to "long" format with a column reflecting the dataset  
* Use **cowplot** or a similar package to combine two plots (see below)  






<!-- ======================================================= -->
## Combine plots {}

Two packages that are very useful for combining plots are **cowplot** and **patchwork**. In this page we will mostly focus on **cowplot**, with occassional use of **patchwork**.  

Here is the online [introduction to cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html). You can read the more extensive documentation for each function online [here](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1). We will cover a few of the most common use cases and functions below.  

The **cowplot** package works in tandem with **ggplot2** - essentially, you use it to arrange and combine ggplots and their legends into compound figures. It can also accept **base** R graphics.  

```{r}
pacman::p_load(
  tidyverse,      # data manipulation and visualisation
  cowplot,        # combine plots
  patchwork       # combine plots
)
```


While faceting (described in the [ggplot basics] page) is a convenient approach to plotting, sometimes its not possible to get the results you want from its relatively restrictive approach. Here, you may choose to combine plots by sticking them together into a larger plot. There are three well known packages that are great for this - **cowplot**, **gridExtra**, and **patchwork**. However, these packages largely do the same things, so we'll focus on **cowplot** for this section. 

### `plot_grid()` {.unnumbered}

The **cowplot** package has a fairly wide range of functions, but the easiest use of it can be achieved through the use of `plot_grid()`. This is effectively a way to arrange predefined plots in a grid formation. We can work through another example with the malaria dataset - here we can plot the total cases by district, and also show the epidemic curve over time.


```{r, , warning=F, message=F}
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) 

# bar chart of total cases by district
p1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +
  geom_bar(stat = "identity") +
  labs(
    x = "District",
    y = "Total number of cases",
    title = "Total malaria cases by district"
  ) +
  theme_minimal()

# epidemic curve over time
p2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1) +
  labs(
    x = "Date of data submission",
    y =  "number of cases"
  ) +
  theme_minimal()

cowplot::plot_grid(p1, p2,
                  # 1 column and two rows - stacked on top of each other
                   ncol = 1,
                   nrow = 2,
                   # top plot is 2/3 as tall as second
                   rel_heights = c(2, 3))


```




### Combine legends {.unnumbered}  

If your plots have the same legend, combining them is relatively straight-forward. Simple use the **cowplot** approach above to combine the plots, but remove the legend from one of them (de-duplicate).  

If your plots have different legends, you must use an alternative approach:  

1) Create and save your plots *without legends* using `theme(legend.position = "none")`  
2) Extract the legends from each plot using `get_legend()` as shown below - *but extract legends from the plots modified to actually show the legend*  
3) Combine the legends into a legends panel  
4) Combine the plots and legends panel  


For demonstration we show the two plots separately, and then arranged in a grid with their own legends showing (ugly and inefficient use of space):  

```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F}
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  labs(title = "Cases by outcome")


p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(axis.text.y = element_blank())+
  labs(title = "Cases by age")

```

Here is how the two plots look when combined using `plot_grid()` without combining their legends:  

```{r, warning=F, message=F}
cowplot::plot_grid(p1, p2, rel_widths = c(0.3))
```

And now we show how to combine the legends. Essentially what we do is to define each plot *without* its legend (`theme(legend.position = "none"`), and then we define each plot's legend *separately*, using the `get_legend()` function from **cowplot**. When we extract the legend from the saved plot, we need to add `+` the legend back in, including specifying the placement ("right") and smaller adjustments for alignment of the legends and their titles. Then, we combine the legends together vertically, and then combine the two plots with the newly-combined legends. Voila!  

```{r, warning=F, message=F}

# Define plot 1 without legend
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(legend.position = "none")+
  labs(title = "Cases by outcome")


# Define plot 2 without legend
p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(
    legend.position = "none",
    axis.text.y = element_blank(),
    axis.title.y = element_blank()
  )+
  labs(title = "Cases by age")


# extract legend from p1 (from p1 + legend)
leg_p1 <- cowplot::get_legend(p1 +
                                theme(legend.position = "right",        # extract vertical legend
                                      legend.justification = c(0,0.5))+ # so legends  align
                                labs(fill = "Outcome"))                 # title of legend
# extract legend from p2 (from p2 + legend)
leg_p2 <- cowplot::get_legend(p2 + 
                                theme(legend.position = "right",         # extract vertical legend   
                                      legend.justification = c(0,0.5))+  # so legends align
                                labs(fill = "Age Category"))             # title of legend

# create a blank plot for legend alignment
#blank_p <- patchwork::plot_spacer() + theme_void()

# create legends panel, can be one on top of the other (or use spacer commented above)
legends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))

# combine two plots and the combined legends panel
combined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))

combined  # print


```

This solution was learned from [this post](https://stackoverflow.com/questions/52060601/ggplot-multiple-legends-arrangement) with a minor fix to align legends from [this post](https://github.com/wilkelab/cowplot/issues/33).  


<span style="color: darkgreen;">**_TIP:_** Fun note - the "cow" in **cowplot** comes from the creator's name - Claus O. Wilke.</span>  


### Inset plots {.unnumbered} 

You can inset one plot in another using **cowplot**. Here are things to be aware of:  

* Define the main plot with `theme_half_open()` from **cowplot**; it may be best to have the legend either on top or bottom  
* Define the inset plot. Best is to have a plot where you do not need a legend. You can remove plot theme elements with `element_blank()` as shown below.  
* Combine them by applying `ggdraw()` to the main plot, then adding `draw_plot()` on the inset plot and specifying the coordinates (x and y of lower left corner), height and width as proportion of the whole main plot.  


```{r, out.width=c('100%'), fig.show='hold', warning=F, message=F}

# Define main plot
main_plot <- ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset, fill = hospital))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+ 
  theme_half_open()+
  theme(legend.position = "bottom")+
  labs(title = "Epidemic curve and outcomes by hospital")


# Define inset plot
inset_plot <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
    scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
    coord_flip()+
    theme_minimal()+
    theme(legend.position = "none",
          axis.title.y = element_blank())+
    labs(title = "Cases by outcome") 


# Combine main with inset
cowplot::ggdraw(main_plot)+
     draw_plot(inset_plot,
               x = .6, y = .55,    #x = .07, y = .65,
               width = .4, height = .4)

```


This technique is explained more in these two vignettes:  

[Wilke lab](https://wilkelab.org/cowplot/articles/drawing_with_on_plots.html)  
[draw_plot() documentation](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1/topics/draw_plot)




<!-- ======================================================= -->
## Dual axes {}

A secondary y-axis is often a requested addition to a `ggplot2` graph. While there is a robust debate about the validity of such graphs in the data visualization community, and they are often not recommended, your manager may still want them. Below, we present one method to achieve them: using the **cowplot** package to combine two separate plots.  

This approach involves creating two separate plots - one with a y-axis on the left, and the other with y-axis on the right. Both will use a specific `theme_cowplot()` and must have the same x-axis. Then in a third command the two plots are aligned and overlaid on top of each other. The functionalities of **cowplot**, of which this is only one, are described in depth at this [site](https://wilkelab.org/cowplot/articles/aligning_plots.html).  

To demonstrate this technique we will overlay the epidemic curve with a line of the weekly percent of patients who died. We use this example because the alignment of dates on the x-axis is more complex than say, aligning a bar chart with another plot. Some things to note:  

* The epicurve and the line are aggregated into weeks prior to plotting *and* the `date_breaks` and `date_labels` are identical - we do this so that the x-axes of the two plots are the same when they are overlaid.  
* The y-axis is moved to the right-side for plot 2 with the `position = ` argument of `scale_y_continuous()`.  
* Both plots make use of `theme_cowplot()`  

Note there is another example of this technique in the [Epidemic curves] page - overlaying cumulative incidence on top of the epicurve.  

**Make plot 1**  
This is essentially the epicurve. We use `geom_area()` just to demonstrate its use (area under a line, by default)  

```{r, warning=F, message=F}
pacman::p_load(cowplot)            # load/install cowplot

p1 <- linelist %>%                 # save plot as object
     count(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     ggplot()+
          geom_area(aes(x = epiweek, y = n), fill = "grey")+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
     theme_cowplot()+
     labs(
       y = "Weekly cases"
     )

p1                                      # view plot 
```

**Make plot 2**  
Create the second plot showing a line of the weekly percent of cases who died.  

```{r, warning=F, message=F}

p2 <- linelist %>%         # save plot as object
     group_by(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     summarise(
       n = n(),
       pct_death = 100*sum(outcome == "Death", na.rm=T) / n) %>% 
     ggplot(aes(x = epiweek, y = pct_death))+
          geom_line()+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
          scale_y_continuous(
               position = "right")+
          theme_cowplot()+
          labs(
            x = "Epiweek of symptom onset",
            y = "Weekly percent of deaths",
            title = "Weekly case incidence and percent deaths"
          )

p2     # view plot
```

Now we align the plot using the function `align_plots()`, specifying horizontal and vertical alignment ("hv", could also be "h", "v", "none"). We specify alignment of all axes as well (top, bottom, left, and right) with "tblr". The output is of class list (2 elements).    

Then we draw the two plots together using `ggdraw()` (from **cowplot**) and referencing the two parts of the `aligned_plots` object.  

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(p1, p2, align="hv", axis="tblr")         # align the two plots and save them as list
aligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # overlay them and save the visual plot
aligned_plotted                                                                # print the overlayed plots

```



<!-- ### Statistical transformation {.unnumbered}   -->
<!-- Another way to do this to have the second axis be a direct transformation of the secondary axis.  -->

<!-- Differences in axis values will be purely cosmetic - if you want to show two different variables on one graph, with different y-axis scales for each variable, this will not work without some work behind the scenes. To obtain this effect, you will have to transform one of your variables in the data, and apply the same transformation *in reverse* when specifying the axis labels. Based on this, you can either specify the transformation explicitly (e.g. variable a is around 10x as large as variable b) or calculate it in the code (e.g. what is the ratio between the maximum values of each dataset). -->


<!-- The syntax for adding a secondary axis is very straightforward! When calling a `scale_xxx_xxx()` function (e.g. `scale_y_continuous()`), use the `sec.axis` argument to call the `sec_axis()` function. The `trans` argument in this function allows you to specify the label transformation for the axis - provide this in standard tidyverse syntax.  -->

<!-- For example, if we want to show the number of positive RDTs in the malaria dataset for facility 1, showing 0-4 year olds and all cases on chart: -->


<!-- ```{r, , warning=F, message=F} -->

<!-- # take malaria data from facility 1 -->
<!-- malaria_facility_1 <- malaria_data %>% -->
<!--   filter(location_name == "Facility 1") -->

<!-- # calculate the ratio between malaria_rdt_0-4 and malaria_tot  -->

<!-- tf_ratio <- max(malaria_facility_1$malaria_tot, na.rm = T) / max(malaria_facility_1$`malaria_rdt_0-4`, na.rm = T) -->

<!-- # transform the values in the dataset -->

<!-- malaria_facility_1 <- malaria_facility_1 %>% -->
<!--   mutate(malaria_rdt_0_4_tf = `malaria_rdt_0-4` * tf_ratio) -->


<!-- # plot the graph with dual axes -->

<!-- ggplot(malaria_facility_1, aes(x = data_date)) + -->
<!--   geom_line(aes(y = malaria_tot, col = "Total cases")) + -->
<!--   geom_line(aes(y = malaria_rdt_0_4_tf, col = "Cases: 0-4 years old")) + -->
<!--   scale_y_continuous( -->
<!--     name = "Total cases", -->
<!--     sec.axis = sec_axis(trans = ~ . / tf_ratio, name = "Cases: 0-4 years old") -->
<!--   ) + -->
<!--   labs(x = "date of data collection") + -->
<!--   theme_minimal() + -->
<!--   theme(legend.title = element_blank()) -->



<!-- ``` -->






<!-- ## Sparklines   -->

<!-- UNDER CONSTRUCTION   -->
<!-- (perhaps move to Tables for presentation page) -->




## Packages to help you  


There are some really neat R packages specifically designed to help you navigate **ggplot2**:  


### Point-and-click **ggplot2** with **equisse**  {.unnumbered}

"This addin allows you to interactively explore your data by visualizing it with the ggplot2 package. It allows you to draw bar plots, curves, scatter plots, histograms, boxplot and sf objects, then export the graph or retrieve the code to reproduce the graph."

Install and then launch the addin via the RStudio menu or with `esquisse::esquisser()`.

See the [Github page](https://github.com/dreamRs/esquisse)

[Documentation](https://dreamrs.github.io/esquisse/index.html)









## Miscellaneous  


### Numeric display {.unnumbered}  

You can disable scientific notation by running this command prior to plotting.  

```{r, eval=F}
options(scipen=999)
```

Or apply `number_format()` from the **scales** package to a specific value or column, as shown below.  

Use functions from the package **scales** to easily adjust how numbers are displayed. These can be applied to columns in your data frame, but are shown on individual numbers for purpose of example.  

```{r}
scales::number(6.2e5)
scales::number(1506800.62,  accuracy = 0.1,)
scales::comma(1506800.62, accuracy = 0.01)
scales::comma(1506800.62, accuracy = 0.01,  big.mark = "." , decimal.mark = ",")
scales::percent(0.1)
scales::dollar(56)
scales::scientific(100000)
```

## Resources

Inspiration
[ggplot graph gallery](https://www.tidyverse.org/blog/2018/07/ggplot2-3-0-0/)

Presentation of data
European Centre for Disease Prevention and Control [Guidelines of presentation of surveillance data](https://ecdc.europa.eu/sites/portal/files/documents/Guidelines%20for%20presentation%20of%20surveillance%20data-final-with-cover-for-we....pdf) 


Facets and labellers
[Using labellers for facet strips](http://www.cookbook-r.com/Graphs/Facets_(ggplot2)/#modifying-facet-label-text)
[Labellers](https://ggplot2.tidyverse.org/reference/labellers.html)

Adjusting order with factors
[fct_reorder](https://forcats.tidyverse.org/reference/fct_reorder.html)  
[fct_inorder](https://forcats.tidyverse.org/reference/fct_inorder.html)  
[How to reorder a boxplot](https://cmdlinetips.com/2019/02/how-to-reorder-a-boxplot-in-r/)  
[Reorder a variable in ggplot2](https://www.r-graph-gallery.com/267-reorder-a-variable-in-ggplot2.html)  
[R for Data Science - Factors](https://r4ds.had.co.nz/factors.html)  

Legends  
[Adjust legend order](https://stackoverflow.com/questions/38425908/reverse-stacking-order-without-affecting-legend-order-in-ggplot2-bar-charts)  

Captions
[Caption alignment](https://stackoverflow.com/questions/64701500/left-align-ggplot-caption)  

Labels  
[ggrepel](https://ggrepel.slowkow.com/articles/examples.html)  

Cheatsheets  
[Beautiful plotting with ggplot2](http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/)  




<!-- TO DO - Under construction -->


<!-- * Straight horizontal, vertical, or other line -->

<!-- You can also add straight lines to your plot with `geom_hline()` (horizontal), `geom_vline()` (vertical) or `geom_abline()` (with a specified y intercept and slope) -->


<!-- Using option `label_wrap_gen` in facet_wrap to have multiple strip lines -->
<!-- labels and colors of strips -->

<!-- Axis text vertical adjustment -->
<!-- rotation -->
<!-- Labellers -->

<!-- limit range with limit() and coord_cartesian(), ylim(), or scale_x_continuous() -->
<!-- theme_classic() -->

<!-- expand = c(0,0) -->
<!-- coord_flip() -->
<!-- tick marks -->

<!-- ggrepel -->
<!-- animations -->

<!-- remove -->
<!-- remove title -->
<!-- using fill = or color = in labs() -->
<!-- flip order / don't flip order -->
<!-- move location -->
<!-- color?    theme(legend.title = element_text(colour="chocolate", size=16, face="bold"))+ scale_color_discrete(name="This color is\ncalled chocolate!?") -->
<!-- Color of boxes behind points in legend  -->
<!--      theme(legend.key=element_rect(fill='pink'))   or use fill = NA to remove them. http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/  -->
<!-- Change size of symbols in legend only guides(colour = guide_legend(override.aes = list(size=4))) -->


<!-- Turn off a layer in the legend -->
<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp)), size=4) -->
<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp), size=4), show_guide=FALSE) -->

<!-- Force a legend even if there is no aes().  -->
<!-- ggplot(nmmaps, aes(x=date, y=o3))+ -->
<!--      geom_line(aes(color="Important line"))+ -->
<!--      geom_point(aes(color="My points")) -->
<!-- Control the shape in the legend with guides - a list with linetype and shape -->
<!-- ggplot(nmmaps, aes(x=date, y=o3))+geom_line(aes(color="Important line"))+ -->
<!--    geom_point(aes(color="Point values"))+ -->
<!--   scale_colour_manual(name='', values=c('Important line'='grey', 'Point values'='red'), guide='legend') + -->
<!--   guides(colour = guide_legend(override.aes = list(linetype=c(1,0) -->
<!--                                                       , shape=c(NA, 16)))) -->
