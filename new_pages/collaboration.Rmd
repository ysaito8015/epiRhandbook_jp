# Git と Github を使ったバージョン管理と共同作業 { #collaboration }

この章では、Git を使った共同作業の概要を説明します。より詳細なチュートリアルは、下部にある「リソース」セクションでご覧いただけます。

## Git とは何？

Git は、フォルダ内の変更を追跡することができる**バージョン管理**ソフトウェアです。Word や LibreOffice、Google Docs の「変更履歴」オプションのように、あらゆる種類のファイルに対して使用することができます。これは、バージョン管理のための最も強力で最も使用されるオプションの一つです。

**なぜ聞いたことがないのか？** - ソフトウェア開発の経験がある人は日常的にバージョン管理ソフト（Git、Mercurial、Subversionなど）の使い方を学んでいますが、データ分析分野の人はあまりバージョン管理スキルを教わっていません。そのため、疫学者のほとんどは学生時代にバージョン管理ソフトの存在を知らず、仕事する中で学ばなければなりません。

**待って、Github って聞いたことあるけど、同じなの？** - 正確には違いますが、よく一緒に使うことがありますので、その方法をご紹介します。簡単に言いますと


-   **Git** はバージョン管理システムで、ソフトウェアの一つです。あなたのコンピュータ上でローカルに使用することもできますし、あるフォルダをホスト**サイト**と同期させることもできます。デフォルトでは、ターミナルを使って Git にコマンドラインで指示を与えます。

-   **Git クライアント/GUI** を使えば、コマンドラインを使わずに、（少なくとも単純で超一般的なものについては）同じ動作を行うことができます。

-   フォルダを**ホストサイト**に保存して他の人と共同作業をしたい場合は、Github、Gitlab、Bitbucket などにアカウントを作成してください。

そこで、クライアント/GUI である **Github Desktop** を使用すると、バックグラウンドで **Git** を使用して、自分のコンピュータのローカルと **Github** サーバーのリモートの両方でファイルを管理することができます。

## なぜ Git と Github を組み合わせて使うの？

**Git** を使うことで、以下のようなことが期待されます。

1)  文書化されたバージョンを増分の変更とともにアーカイブし、以前の状態に簡単に戻すことができます。
2)  並行してブランチを持つこと、つまり、レビュー後に変更を統合するための構造化された方法で開発版/「動く」版を持つこと。

これは、他の人と共同作業をしなくても、自分のコンピュータでローカルに行うことができます。今までに

-   コードの一部分を削除してしまって2ヶ月後には実際に必要だったことに気づいて後悔したり

-   一時停止していたプロジェクトに戻ってきて、あるモデルにトリッキーな修正をしたかどうかを思い出そうとしたり

-   *model_1.R* というファイルと、*model_1_test.R* というファイルと、*model_1_not_working.R* というファイルを用意して、いろいろ試してみたり

-   ファイル *report.Rmd* 、ファイル *report_full.Rmd* 、ファイル *report_true_final.Rmd* 、ファイル *report_final_20210304.Rmd* 、ファイル *report_final_20210402.Rmd* があり、自分のアーカイブ技術を呪っていたのですね。

Git はその手助けをしてくれるので、それだけでも学ぶ価値があります。

しかし、Github のようなオンラインリポジトリと併用することで、**共同プロジェクト**をサポートすることができ、さらに強力になります。これにより、以下の点が促進されます。

-   共同作業：他の人がレビュー、コメント、変更の承認/却下が可能

-   コード、データ、アウトプットを共有し、一般から（またはチーム内で）フィードバックを募る。

また、以下のことは避けることができます。

-   「おっと、前回のバージョンを送るのを忘れていたので、2日分の作業をこの新しいファイルでやり直さなければならない」

-   Mina、Henry、Oumar の3人が1つのスクリプトで同時に作業を行い、それぞれの変更を手動で merge する必要があります。

-   2人の人が Dropbox と Sharepoint で同じファイルを変更しようとすると、同期エラーが発生します。

### 複雑なようですが、私はプログラマーではありません。 {-}

確かに複雑なときもあります。高度な使い方の例は、かなり怖いものがあります。しかし、R や Excel のように、エキスパートにならなくてもツールのメリットを享受することができます。<u>ちょっとした関数や概念</u>を学ぶだけで、変更点の追跡、オンラインリポジトリ上でのファイルの同期、同僚との共同作業などが、ごく短時間でできるようになります。

学習曲線の関係で、緊急時の状況はこれらのツールを学ぶのに最適なタイミングではないかもしれません。しかし、学習は段階的に行うことができます。いくつかの概念を身につければ、ワークフローは非常に効率的かつ迅速になります。もしあなたが Git を使った共同作業が必要なプロジェクトに携わっていないのであれば、共同作業で Git を使う前に、**一人で Git を使うことで自信を持つことができる**でしょう。

## 環境構築

### Git をインストール {.unnumbered}

*Git* とは、コンピュータの舞台裏にあるエンジンのことで、変更、ブランチ（バージョン）、マージ、リバートを追跡することができます。**まず、<https://git-scm.com/downloads>から <u>Git</u> をインストールする必要があります。**

### GUI をインストール (必須ではないが推奨) {.unnumbered}

Git には独自のコマンド言語があり、コマンドライン・ターミナルに入力することができます。しかし、多くのクライアントや GUI があり、開発者ではない人が日常的に Git と直接やりとりする必要はほとんどないでしょうし、 GUI は通常、ファイルの変更やブランチを視覚化するツールを提供します。

初心者向けのものから複雑なものまで、あらゆる OS で多くの選択肢が存在します。 初心者向けの GUI としては、この章で紹介する　RStudio の Git ペインや[Github Desktop](https://desktop.github.com/)などがあります。中級者向け（より強力だがより複雑）のオプションとしては、Sourcetree、Gitkracken、Smart Git などがあります。

[Git clients](-%09https:/happygitwithr.com/git-client.html#git-client) の簡単な解説

<u>注：実際にはすべての GUI が内部的に Git を使用しているので、複数の GUI を試してみたり、特定のプロジェクトで GUI を切り替えたり、 GUI がサポートしていないアクションのために時間的にコンソールを使用したり、あるいは Github 上でオンラインでさまざまなアクションを実行したりすることができます。</u>

後述するように、RStudio の Terminal ペイン（Rコンソールの隣にあるタブ）や Git Bash ターミナルなどのターミナルに Git コマンドを書き込まなければならないこともあります。

### Github アカウント {.unnumbered}

[github.com](github.com)で無料のアカウントを登録します。

携帯電話のアプリで2ファクタ認証を設定するように言われることがあります。詳しくは、Github の [ヘルプドキュメント](https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa) をご覧ください。

Github Desktop を使用している場合は、インストール後に以下の [手順](https://docs.github.com/en/desktop/installing-and-configuring-github-desktop/authenticating-to-github) に従って Gitub の認証情報を入力することができます。これをしておかないと、後で Github からプロジェクトをクローンしようとしたときに認証情報を求められます。

## 用語と概念と基本機能

R を学ぶときのように、Git を理解するためにはかなりの量の用語を覚えなければなりません。
ここでは、[Basics to get you going](https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/) / [interactive tutorial](learnngitbranching.js.org)を参照してください。
次のセクションでは、GUI の使い方を紹介しますが、GUI を使うときに必要になるので、またメンタルモデルを構築するためにも、用語や概念を覚えておくといいでしょう。

### リポジトリ {.unnumbered}

Git の<u>リポジトリ</u>（<u>repo</u>）とは、プロジェクトのすべてのサブフォルダーやファイル（データ、コード、画像など）とそれらのリビジョン履歴を含むフォルダーのことです。リポジトリの変更をそれで追跡するようになると、Git はすべての追跡情報を含む隠しフォルダを作成します。典型的な Git リポジトリは、<u>Rプロジェクト</u>フォルダです（ハンドブックの [R projects] のページを参照）。

次のセクションでは、Github、Github Desktop、または RStudio からGitリポジトリを作成（_initialize_）する方法を紹介します。

### コミット {.unnumbered}

コミット（commit）とは、ある時点でのプロジェクトの **スナップショット** です。 プロジェクトに変更を加えた場合、ファイルに加えられた変更（差分）を追跡するために、新しいコミット を作成します。例えば、何行かのコードを編集し、関連するデータセットを更新したとします。変更が保存されると、これらの変更を1つのコミットに束ねることができます。

各コミットには固有のID（ハッシュ）があります。バージョンコントロールの目的では、コミット に基づいてプロジェクトを過去に戻すことができるので、比較的小さくまとまったものにしておくとよいでしょう。また、「コミット・メッセージ」と呼ばれる変更内容の簡単な説明を添付します。

<u>ステージされた変更</u>？変更をステージするとは、次のコミットに備えて、変更を<u>ステージ・エリア</u>に追加することです。これは、あるコミットにどの変更を含めるかをきめ細かく決められるということです。例えば、あるスクリプトでモデルの仕様書を作成し、その後別のスクリプトで図を作成した場合、2つの異なるコミットを作成することは理にかなっています（モデルではなく図の変更を戻したい場合に簡単にできます）。


### ブランチ {.unnumbered}

ブランチは、リポジトリ内の変更点の中でも<u>独立したライン</u>として表され、プロジェクトファイルの並行した別バージョンを意味します。

ブランチは、変更内容を main ブランチに反映させる前にテストするのに便利です。main ブランチは、通常、プロジェクトの主要/最終/ライブバージョンです。ブランチでの実験が終わったら、その変更を <u>main</u> ブランチに<u>マージ</u>して取り込むことができますし、変更がうまくいかなかった場合はブランチを削除することもできます。

<u>注：ブランチを使う際に他の人と共同作業をする必要はありませんし、リモートのオンラインリポジトリを持つ必要もありません。</u>

### ローカルとリモートのリポジトリ {.unnumbered}

<u>クローン</u>とは、Git リポジトリのコピーを別の場所に作成することです。

例えば、Github からオンラインリポジトリをパソコンに<u>クローン</u>したり、ローカルリポジトリから始めてオンラインで Github <u>に</u> クローンすることができます。

リポジトリをクローンすると、プロジェクトファイルは2つの場所に存在することになります。

-   あなたの物理的なコンピュータ上の <u>ローカル</u> リポジトリ。ここで、ファイルやコードに実際の変更を加えます。

-   <u>リモート</u>、オンラインリポジトリ：Github リポジトリ（またはその他のウェブホスト）にあるプロジェクトファイルのバージョン。

これらのリポジトリを同期させるためには、より多くの機能を使うことになります。Sharepoint や Dropbox その他の同期ソフトウェアとは異なり、Git は自動的にオンラインのものに基づいてローカルのリポジトリを更新したり、その逆を行ったりしません。いつ、どのように同期させるかは、あなたが決めることです。

-   `git fetch` は、リモートリポジトリから新しい変更点をダウンロードしますが、ローカルリポジトリは変更しません。リモートリポジトリの状態をチェックしていると考えてください。

-   `git pull` は、リモートリポジトリから新しい変更点をダウンロードして、ローカルリポジトリを更新します。

-   ローカルで1つまたは複数のコミットを行った後、そのコミットをリモートリポジトリに `git push` することができます。これにより、変更が Github 上に送信され、他の人がそれを見たり、必要に応じてプルすることができます。


## 始める: 新しいリポジトリを作成

新しいリポジトリを作成する方法はたくさんあります。コンソールからでも、Github からでも、GUI からでも可能です。

２つの方法があります。

-   既存または新規の Github リポジトリから新しい R プロジェクトを作成する (初心者の方にお勧めです)。または
-   既存のRプロジェクトに Github リポジトリを作成する。

### 最初のファイル {.unnumbered}

新しいリポジトリを作成する際に、オプションで以下のファイルをすべて作成することもできますし、後からリポジトリに追加することもできます。これらのファイルは通常、リポジトリの "root" フォルダーに置かれます。

-   <u>README</u> ファイルとは、あなたのプロジェクトがなぜ存在するのか、そしてそれを使うために何を知っておくべきなのかを理解するために、誰かに読んでもらうためのファイルです。最初は空ですが、後で完成させましょう。

-   <u>.gitignore</u> ファイルとは、Git が無視すべき (変更を追跡しない) フォルダやファイルを各行に記述したテキストファイルのことです。詳細や例は [こちら](https://www.freecodecamp.org/news/gitignore-what-is-it-and-how-to-add-to-repo/) を参照ください。

-   自分の作業に対して、<u>ライセンス</u>を選ぶことができます。他の人々は、どのような条件であなたの作品を使用したり複製したりできるかを知ることができます。詳しくは、[Creative Commons licenses](https://creativecommons.org/licenses/)をご覧ください。

### Github で新しいリポジトリを作成する {.unnumbered}

新しいリポジトリを作成するには、Github にログインし、新しいリポジトリを作成する緑色のボタンを探してください。この空のリポジトリは、コンピュータにローカルでクローンすることができます（次のセクションを参照）。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_new.png"))
```

リポジトリを **public** （インターネット上で誰でも見ることができる）にするか **private** （許可を得た人だけが見ることができる）にするかを選択する必要があります。これは、データが機密である場合に重要な意味を持ちます。リポジトリがプライベートの場合、Github の <u>actions</u> を使ってコードをクラウド上で自動的に実行する場合など、高度な特別な状況では、いくつかのクォータが発生します。

### Github リポジトリからのクローン {.unnumbered}

既存の Github リポジトリを<u>クローン</u>して、コンピュータ上に新しいローカル R プロジェクトを作成することができます。

Github リポジトリは、すでに存在していてコンテンツが含まれているものでも、作成したばかりの空のリポジトリでもよいです。後者の場合、基本的には Github リポジトリとローカル R プロジェクトを同時に作成することになります（上記の説明を参照）。

注：Github リポジトリのコントリビュート権を持っていない場合は、まずそのリポジトリを自分のプロファイルに <u>フォーク (fork)</u>してから、他の作業を進めることができます。フォーク については本章の最後で説明しますが、まずは他のセクションをお読みになることをお勧めします。

ステップ1： Github でリポジトリに移動し、緑色の "**Code**" ボタンをクリックして、**HTTPS クローン URL** をコピーします（以下の画像を参照）。

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone.png"))
```

次のステップは、どのような GUI でも実行できます。ここでは、RStudio と Github デスクトップを例に説明します。

#### RStudio の場合 {.unnumbered}

RStudio で、<u>File \> New Project \> Version Control \> Git</u> をクリックして、新しい R プロジェクトを開始します。

-   "Repository URL" を聞かれたら、Github から HTTPS URL を貼り付けます。
-   Rプロジェクトに短くてわかりやすい名前をつけます。
-   新しいRプロジェクトをローカルに保存する場所を選択する。
-   "Open in new session" にチェックを入れ、"Create project" をクリックする。

これで、Github リポジトリのクローンである、新しいローカルの RStudio プロジェクトに入りました。このローカルプロジェクトと Github リポジトリがリンクされました。

#### Github Desktop の場合 {.unnumbered}

-   *File \> Clone a repository*をクリックします。
-   URL タブを選択します。
-   最初のボックスにGithubからのHTTPS URLをペーストする。
-   ローカルリポジトリを作成するフォルダを選択する。
-   "CLONE" をクリックする。

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone_desktop.png"))
```

### 既存のRプロジェクトからの新規 Github リポジトリの作成 {.unnumbered}

別の設定方法として、コンテンツを含む既存の R プロジェクトがある場合があります。ここから Github リポジトリを作成します。

1)  プロジェクトのために、新しい空の Github リポジトリを作成する（上記の手順を参照）。
2)  このリポジトリをローカルにクローンする（上記の HTTPS の手順を参照）。
3)  既存の R プロジェクトからすべてのコンテンツ（コード、データなど）を、この新しい空のローカルリポジトリにコピーします（例：コピー＆ペーストを使用）。
4)  RStudio で新しいプロジェクトを開き、Git ペインに移動します。新しいファイルはファイルの変更として登録され、Git によって追跡されるようになります。したがって、これらの変更を<u>コミット</u>としてバンドルして、Github に <u>プッシュ</u>することができます。一旦<u>プッシュ</u>すると、Github 上のリポジトリにすべてのファイルが反映されます。

このプロセスの詳細については、以下の Github のワークフローのセクションを参照してください。

### どのように見えますか？ {.unnumbered}

#### RStudio の場合 {-}

Github リポジトリを新しい R プロジェクトに clone すると、RStudio に "Git" タブが表示されます。このタブは、R 環境と同じ RStudio ペインに表示されます。

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Git_console.png"))
```

上の画像で丸で囲ったボタンは、後に参照するので注意してください（左から順に）。

-   保存したファイルの変更をローカルブランチに *Commit* するボタン（新しいウィンドウが開きます）。
-   青色の矢印で *Pull* （ローカル版のブランチに、そのブランチのリモート/Github版で行われた変更を反映させる）
-   緑の矢印で *Push* (ローカルバージョンのブランチのコミットや変更を、そのブランチのリモート/Github バージョンに送信)
-   RStudio の Git タブ
-   右側に表示されているローカルブランチをベースにして、新しいブランチを作成するためのボタンです。<u>ほとんどの場合、main ブランチからブランチを作成します。</u>
-   現在作業しているブランチ
-   コードや他のファイルに加えた変更は、以下のように表示されます。

#### Github Desktop の場合 {-}

Github Desktop は、すべてのリポジトリを管理するための独立したアプリケーションです。Github Desktop を開くと、作業したいリポジトリを選択して、そこから Git の基本的な操作を行うことができます。

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_interface.png"))
```


## Git + Github 作業の流れ

### Process overview {.unnumbered}

上記のセットアップが完了すると、ローカルの R プロジェクトに接続された（<u>clone された</u>）Github レポができあがります。(デフォルトで作成される) *main* ブランチは、いわゆる "live" バージョンで、 <u>すべての</u>ファイルが含まれています。修正を加えたいときには、*main* ブランチから *new branch* を作成するのがよいでしょう ("Make a Copy" のように)。
ブランチの作成は簡単で速いので、これが Git の典型的な作業の進め方になります。

典型的な作業の流れは次のとおりです。

1.  ローカルリポジトリが最新であることを確認し、そうでない場合は更新します

2.  以前作業していたブランチに移動するか、新しいブランチを作成していくつかのことを試してみます

3.  コンピュータのローカルでファイルを編集し、このブランチに 1 回または数回コミットします

4.  ブランチのリモートバージョンに対し、あなたの変更で更新します（プッシュ）

5.  ブランチに満足したら、作業用ブランチのオンライン版をオンラインの "main" ブランチにマージして、変更を移行します

他のチームメンバーも、自分のブランチで同じことをしているかもしれませんし、自分の作業ブランチにコミット を追加しているかもしれません。

以下では、上記のプロセスを順を追って詳しく説明します。ここでは、私たちが作成した概略図を紹介します。二元配置の表形式になっているので、疫学者にも理解しやすいでしょう。

```{r echo=F, out.height='150%', out.width='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_table.png"))
```

ここに[別の図](https://build5nines.com/introduction-to-git-version-control-workflow/)があります。

<u>注：最近まで　"master" ブランチという言葉が使われていましたが、現在は "main" ブランチと呼ばれています。</u>

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "GitHub-Flow.png"))
```

画像
[ソース](https://build5nines.com/introduction-to-git-version-control-workflow/)

## 新しいブランチを作成

作業するブランチを選択すると、**Git は作業ディレクトリを、前回このブランチにいたときの状態にリセットします。**

### RStudio の Git pane の場合 {.unnumbered}

"main" ブランチにいることを確認し、紫のアイコンをクリックして新しいブランチを作成します（上の画像を参照）。

-   ブランチの名前を、一言で説明できる名前にするよう求められます（必要に応じてアンダースコアを使用できます）。
-   ローカルでは、同じ R プロジェクトに属していますが、"main" ブランチでの作業ではなくなっていることがわかります。
-   新しいブランチを作成すると、Github のウェブサイトでもブランチとして表示されるようになります。
    
ブランチは、RStudio の Git ペインで History をクリックすると表示されます。

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_rstudio_branchs.png"))
```


### Github Desktop の場合 {.unnumbered}

プロセスは非常によく似ており、ブランチに名前を付けるよう促されます。その後、"Publish you branch to Github" というプロンプトが表示され、新しいブランチがリモートリポジトリにも表示されるようになります。

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_new_branch.png"))
```

### Console の場合 {.unnumbered}

舞台裏で実際に行われているのは、`git branch` で新しいブランチを作成し、`git checkout` でそのブランチに移動することです (つまり、次のコミットがそこで行われることを Git に伝えます)。あなたの git リポジトリから

```{bash, eval = FALSE}
git branch my-new-branch  # 新規にブランチを作成
git checkout my-new-branch # 作成したブランチに行く
git checkout -b my-new-branch # 上の二つを同時に行う
```

Console の使い方については、末尾の Git コマンドの項を参照してください。

## 変更の commit

これで、コードの編集や新しいファイルの追加、データセットの更新などができるようになりました。

すべての変更は、それぞれのファイルが保存された時点で追跡されます。変更されたファイルは RStudio の Git タブ、Github Desktop、またはターミナルの `git status` コマンドで表示されます (下記参照)。

実質的な変更 (コードのセクションの追加や更新など) を行った場合は、必ず一旦停止して、その変更を<u>コミット</u>してください。コミットとは、共通の目的に関連した変更の「バッチ」と考えてください。変更をコミットした後でも、ファイルの修正を続けることは可能です。

<u>コミットに関するアドバイス</u>: 一般的には、問題が発生したときに簡単に元に戻せるような小さな コミットを行い、共通の目的に関連する変更をまとめてコミットするのが良いでしょう。これを実現するためには、<u>頻繁に commit する</u>ことが必要です。最初のうちは、頻繁にコミットすることを忘れてしまうかもしれませんが、そのうちに習慣になります。

### RStudio の場合 {.unnumbered}

以下の例では、前回のコミット以降、R Markdown スクリプト collaboration.Rmd が変更され、いくつかの PNG 画像が追加されています。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking2.png"))
```

ファイル名の横にある黄色、青、緑、赤の四角は何を表しているのか気になりますよね。ここでは、[RStudio cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) からのスナップショットで、その意味を説明します。なお、黄色の「？」がついた変更でも、ステージ、コミット、プッシュは可能です。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking.png"))
```

- Git タブの "Commit" ボタンを押すと、新しいウィンドウが開きます（下図）。

- 左上のボックスにあるファイル名をクリックします。

- そのファイルに加えた変更を確認します（以下、緑または赤でハイライトされる）

- ファイルをステージすると、その変更がコミットに反映されます。ファイル名の横にあるボックスにチェックを入れてください。あるいは、複数のファイル名をハイライトしてから "Stage" をクリックすることもできます。

- 短くてわかりやすい コミット・メッセージを書く（必須）

- "Commit" ボタンを押します。成功またはエラーメッセージを示すポップアップ・ボックスが表示されます。

これで、さらに変更を加え、何度でもコミットすることができます。

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_commit.png"))
```

### Github Desktop の場合 {.unnumbered}

左側に変更されたファイルのリストが表示されます。テキストファイルを選択すると、右ペインに変更内容の概要が表示されます（この表示は、.docs や .xlsx などの複雑なファイルでは機能しません）。

変更をステージするには、ファイル名の近くにある小さなボックスにチェックを入れます。このコミットに追加したいファイルを選択し、コミットに名前を付け、必要に応じてメッセージを付けて **commit** ボタンをクリックします。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_commit.png"))
```

### Console の場合 {.unnumbered}

ステージは、実際にはファイルを選択/ステージするための `git add` と、実際にコミットを行うための `git commit` という2つの機能が使われています。

```{bash, eval = FALSE}
git status # 変更を見る

git add new_pages/collaboration.Rmd  # コミットするファイルを選択 (= 変更をステージ)

git commit -m "Github Desktop からコミットについて記述" # メッセージをつけて変更をコミット

git log  # 過去のコミットの情報を表示
```


### 過去のコミットを修正 {.unnumbered}

Console では  

ある変更を commit して作業を続けているうちに、（あなたの考えでは）過去の commit に属するべき変更を行ったことに気付いた場合、どうなるでしょうか。 心配ありません。これらの変更は、前のcommit に追加することができます。

RStudio では、Commit ボタンと同じ行に "Amend previous commit" ボックスがあるので、とてもわかりやすいはずです。

理由は不明ですが、Github Desktop ではこの機能は実装されていません。コミットはしたが、まだプッシュはしていない場合、COMMIT ボタンのすぐ下に "UNDO" ボタンが表示されます。このボタンをクリックすると、コミットを元に戻すことができます（ただし、ステージされたファイルと コミット・メッセージは保持されます）。 変更内容を保存し、必要に応じて新しいファイルをコミットに追加し、再度コミットします。

Console では

```{bash, eval = FALSE}
git add [YOUR FILES] # 変更をステージ

git commit --amend  # 以前のコミットを修正 (修正)

git commit --amend -m "commit メッセージの更新"  # 以前のコミットを修正「かつ」コミット・メッセージを更新
```

<u>注: public になって他の協力者と共有しているコミットを変更を修正する前に、もう一度考えましょう。</u>

## プルしてから、変更を Github にプッシュ

"First PULL, Then PUSH"

プロジェクトに取り掛かる前に<u>フェッチ</u>して<u>プル</u>し、ローカルコンピュータ上のブランチバージョンをリモート/Github バージョンで行われた変更に更新するのは良い習慣です。
PULL は頻繁に行いましょう。躊躇することはありません。<u>プッシュする前に必ずプルしましょう</u>。

変更が完了してコミットし、プロジェクトの状態に満足したら、コミットした内容をブランチのリモート/Github バージョンに<u>プッシュ</u>します。

リポジトリで作業している間は、この作業を繰り返します。

**注記:** リモートリポジトリにプッシュされた変更(そしておそらく他の人が既にプルした変更)を元に戻すよりも、コミットされたがプッシュされていない（つまりローカルに残っている）変更を元に戻す方がはるかに簡単なので、作業していたタスクの変更を導入し終わった後でプッシュすると良いでしょう。

#### RStudio の場合 {.unnumbered}

*PULL* - まず、取り込みと引き込みを同時に行う "Pull" アイコン（下向き矢印）をクリックします。

*PUSH* - 緑色の "Push" アイコン（上向き矢印）をクリックします。Github のユーザー名とパスワードの入力を求められることがあります。最初に尋ねられたときには、2つの Git コマンドラインを *Terminal* に入力する必要があるかもしれません。

-   **git config --global user.email
    "[you\@example.com](mailto:you@example.com){.email}"** （Github メールアドレス）とし、

-   **git config --global user.name "Github ユーザー名"**

これらのコマンドの入力方法については、以下の Git コマンドのセクションを参照してください。

***TIP:*** パスワードの入力を頻繁に求められる？SSHキーを使ってリポジトリに接続するには、この[チュートリアル](https://happygitwithr.com/credential-caching.html#credential-caching)の10章と11章を参照してください（より複雑です）

<!-- 訳注：認証方式がより厳格になったので、この上の情報はすでに古いです。 -->

#### Github Desktop の場合 {.unnumbered}

"Fetch origin" ボタンをクリックすると、リモートリポジトリに新しい commit があるかどうかを確認できます。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_fetch_button.png"))
```

Git がリモートリポジトリで新しいコミットを見つけると、このボタンは "Pull" ボタンに変わります。push と pull に同じボタンが使われるので、事前にプルしておかないと変更をプッシュできません。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_pull_button.png"))
```

"History" タブ（"Changes" タブの近く）に行くと、すべてのコミット（自分のコミットと他の人のコミット）を見ることができます。これは、共同作業者が何をしたかを知るための良い方法です。
コミット・メッセージや説明文がある場合はそれを読み、<u>diff</u>ペインを使って 2 つのファイルのコードを比較することができます。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_history.png"))
```

すべてのリモートの変更がプルされ、少なくとも1つのローカルの変更がコミットされたら、同じボタンをクリックしてプッシュすることができます。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_push_button.png"))
```

#### Console の場合 {.unnumbered}

なななんと！コマンド名は *fetch* と *pull* と *push* です。

```{bash, eval = FALSE}
git fetch  # リモートに新しいコミットはあるか?
git pull   # リモートのコミットをローカルブランチに持ってくる
git push   # ローカルへのコミットをリウモーとにプッシュ
```

### プルしたいがローカルでの作業がある {.unnumbered}

ローカルのリポジトリで変更を加えたのに、リモートのリポジトリにはあなたがプルしなかったコミットがある。

あなたの変更が上書きされる可能性があるので、Git はプルを拒否します。 自分の変更を維持するための戦略はいくつかあります。[Happy Git with R](https://happygitwithr.com/pull-tricky.html)でよく説明されていますが、その中でも主なものは次のふたつです。- 変更をコミットし、リモートの変更を取得してそれを取り込み、必要に応じて衝突を解決して (後述のセクションを参照ください)、すべてをオンラインにプッシュする - 変更を「隠して」おき、プルして隠しを解除 (復元) してから、コミットして衝突を解決してプッシュする。

リモートでの変更に関連するファイルとローカルでの変更に関連するファイルが重なっていない場合は、Git は自動的にコンフリクトを解決することができます。

Github Desktop では、この操作をボタンで行うことができます。スタッシュするには、_Branch > Stash all changes_ と進みます。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_stash.png"))
```

## ブランチを main に merge

変更が完了したら、その変更をメインブランチにマージする作業を始めましょう。状況に応じて、この作業を迅速に行うこともできますし、チームメイトを巻き込んで慎重にレビューや承認の手順を踏むこともできます。

### Github デスクトップでのローカル作業 {.unnumbered}

Github Desktop を使ってローカルにブランチを merge することもできます。まず、コミットを受け取る側のブランチ、つまり更新したい側のブランチに移動 (checkout) します。次に、メニューの *Branch \> Merge into current branch* をクリックします。インポート元のブランチを選択するボックスが表示されます。

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_merge.png"))
```

### Console の場合 {.unnumbered}

まず、変更を受け付けるブランチに戻ります。これは通常は *master* ですが、別のブランチになることもあります。次に、作業中のブランチを master にマージします。

```{bash, eval = FALSE}
git checkout main  # main (あるいは、その他の branch) に戻る
git merge this_fancy_new_branch
```

[このページ](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)では、より高度な分岐の例を示し、裏で何が起こっているかを少し説明しています。

### Github で pull request の提出 {.unnumbered}

2つのブランチを誰にも知らせずに merge することも可能ですが、master ブランチに統合する前に、複数の人で merge について
議論したり調査したりすることがあります。このプロセスを支援するために、Github では merge に関する議論を行うための機能として、**pull request** を提供しています。

pull request (PR) とは、あるブランチを別のブランチに merge するためのリクエストです (「私の作業ブランチを "main" ブランチに引き込んでほしい」というリクエストです)。 pull request には通常、複数の　commit が含まれます。pull request を受け入れてブランチに merge する前に、議論とレビューのプロセスが始まります。例えば、[dplyr's github](https://github.com/tidyverse/dplyr/pulls)で pull request の議論を読むことができます。

pull request (PR) は、下図のように Web サイトから直接送信することも、Github Desktop から送信することもできます。

-   Github リポジトリ（オンライン）にアクセスします。
-   "Pull Requests" タブを表示し、"New pull request" ボタンをクリックします。
-   ドロップダウンメニューから、自分のブランチを main に merge するものを選択します。
-   プル・リクエストの詳細なコメントを書き、"Create Pull Request" をクリックします。

下の画像では、"forests" というブランチが "main" にマージされるように選択されています。

```{r echo=F, out.width = '100%', out.height='150%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request2.png"))
```

これで、プルリクエストが表示されるようになりました（下の画像例）。

-   タブの "Files changed" を確認すると、"main" ブランチがマージされた場合にどのように変化するかがわかります。

-   右側には、Github ID をタグ付けすることで、チームのメンバーにレビューを要求することができます。main にマージするためには承認するレビューが1つ必要になるようにリポジトリの設定をすることもできます。

-   プル・リクエストが承認されると、"Merge pull request" のボタンがアクティブになります。これをクリックします。

-   マージが完了したら、以下の手順でブランチを削除します。

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request.png"))
```

### コンフリクトの解決 {.unnumbered}

二人の人間が同じ行を同時に変更すると、マージ・コンフリクトが発生します。Git はどちらのバージョンを残すかの判断はしませんが、コンフリクトが発生している場所を探すのには役立ちます。**慌てないでください。**
ほとんどの場合は、簡単に解決できます。

例えば、Github の場合

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict2.png"))
```

マージでコンフリクトが発生したら、そのファイルをエディターで開いてください。コンフリクトは一連の文字で示されます。

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict3.png"))
```

*\<\<\<\<\<\<\< HEAD* と *=======* の間のテキストは、自分のローカルリポジトリから、*=======* と *\>\>\>\>\>\>\>* の間のテキストはもう一方のブランチ (origin や main などのブランチ) から来ています。

どちらのバージョンのコードがいいかを決めて（あるいは、両方の変更点を含んだ3つ目のコードを書いて）、残りの部分を削除し、Gitが付けたマーク
*(\<\<\<\<\<\<\< HEAD, =======, \>\>\>\>\>\>\> origin/master/your_branch_name*) をすべて削除します。

そして、ファイルを保存し、ステージし、コミットします。これが、マージされたバージョンを「公式」にするためのコミットです。その後、プッシュすることを忘れないでください。

あなたと共同作業者の双方がプル＆プッシュを頻繁に行えば行うほど、コンフリクトは小さくなります。

<u>注：Console での操作に慣れてきたら、もっと多くの[高度な merge オプション](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging)があります（例：空白を無視する、共同作業者に優先権を与えるなど）。</u>

### ブランチの削除 {.unnumbered}

ブランチが master にマージされて不要になったら、そのブランチを削除することができます。

#### Github + RStudio

Github のリポジトリに行き、すべてのブランチを表示するボタンをクリックします（ブランチを選択するドロップダウンの横）。自分のブランチを見つけて、その横にあるゴミ箱アイコンをクリックします。ブランチの削除について詳しくは[こちら](https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/creating-and-deleting-branches-within-your-repository#deleting-a-branch)をご覧ください。

必ず、あなたのコンピュータのローカルでブランチを削除してください。これは自動的には行われません。

-   RStudio から、main ブランチにいることを確認します。

-   RStudio の "Terminal"（R コンソールの隣のタブ）で Git コマンドの入力に切り替え、次のように入力します。**git branch -d branch_name**、ここで "branch_name" は削除するブランチの名前です。

-   Git タブを更新すると、ブランチは消えているはずです。

#### Github Desktop の場合

削除したいブランチをチェックアウトして、メニューの *Branch \> Delete* で削除してください。

### Fork {.unnumbered}

プロジェクトに貢献したいが権利がない場合や、個人的に使用するためにプロジェクトを変更したい場合には、 プロジェクトをフォークすることができます。フォークについての簡単な説明は[こちら](https://guides.github.com/activities/forking/)にあります。

Github で "Fork" ボタンをクリックします。 

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_1.png"))
```

これでオリジナルのリポジトリがクローンされますが、あなたのプロファイルにもクローンされます。これで、**Github** 上に2つのバージョンのリポジトリが存在することになります。オリジナルのリポジトリは変更できませんが、クローンされたバージョンはあなたのプロファイルにあります。

次に、前のセクションで説明した方法のいずれかを使って、オンラインリポジトリの自分のバージョンをコンピュータのローカルにクローンします。 その後、新しいブランチを作成し、変更を加えてコミットし、リモートリポジトリにプッシュします。

結果に満足したら、Github または Github Desktop からプル・リクエスト を作成して、元のリポジトリのオーナーやメンテナと会話を始めることができます。


**公式リポジトリの最新のコミットが必要な場合は？**

誰かが公式リポジトリに重要な変更を加え、それをあなたのクローンバージョンに含めたいとします。自分のフォークと公式リポジトリを同期させることは可能です。ターミナルを使うことになりますが、それほど複雑ではありません。 ほとんどの場合、次のことを覚えておく必要があります。
- _upstream_ = 公式リポジトリ、あなたが変更できなかったリポジトリ
- _origin_ = あなたの Github プロファイルにあるリポジトリのバージョン

[このチュートリアル](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) をお読みいただくか、以下の手順で進めてください。

まず、Git ターミナル（あなたのリポジトリ内）で次のように入力します。 

```{bash, eval = FALSE}
git remote -v
```

upstream のリポジトリをまだ設定していない場合は、_origin_ で始まる2行が表示されます。この行は、`fetch` と `push` が指すリモートリポジトリを示しています。覚えておいてほしいのは、_origin_ は Github 上にある自分のリポジトリ示しているいうことです。例えば  

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_2.png"))
```

ここで、新しい remote リポジトリを追加します。

```{bash, eval = FALSE}
git remote add upstream https://github.com/appliedepi/epirhandbook_eng.git
```
 
ここでのアドレスは、Github がリポジトリをクローンしたときに生成するアドレスです (クローンについてのセクションを参照)。これで、4つのリモートポインターができています。

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_3.png"))
```

これで設定は完了したので、元の（_upstream_）リポジトリから変更を取得したいときはいつでも、更新したいブランチに行って（_checkout_）、以下をタイプすればいいのです。

```{bash, eval = FALSE}
git fetch upstream # リモートリポジトリから新しいコミットを取得
git checkout the_branch_you_want_to_update
git merge upstream/the_branch_you_want_to_update  # upstream ブランチを自分のブランチにマージ
git push # 自分の remote リポジトリを更新
```

コンフリクトが発生した場合は、「コンフリクトの解決」で説明しているように、解決しなければなりません。

**要約**: フォークはクローンすることと同義ですが、Github サーバー側で行います。 残りのアクションは、典型的な共同作業の流れの実際の行動です（クローン、プッシュ、プル、コミット、マージプル・リクエストの提出...）。

<u>注：フォークは概念であってGitコマンドではありませんが、[Bitbucket](https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow) など他のホストにもあります。</u>

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_4.png"))
```

## 学んだこと

以下のことを学びました。 

- Git を設定して、自分のフォルダの変更を追跡する。 
- ローカルのリポジトリを、リモートのオンラインリポジトリに接続する。 
- 変更をコミットする。 
- ローカルとリモートのリポジトリを同期させる。 

疫学者としての必要なことは、これだけでほぼ十分でしょう。私たちは通常、ソフトウェア開発者のような高度な使い方はしません。

しかし、もっと高度なことをしたい（あるいはする必要がある）場合、Git にはコミットの履歴を単純化したり、1つまたは複数のコミットを戻したり、コミットを cherry-pick（訳注：いいとこ取り、cherry-pick はgit のコマンドの一つ）したりといった、より強力な機能があることを知っておいてください。 このようなことをすると、まるで魔法のように聞こえるかもしれませんが、基本的な知識を身につけたことで、その上に構築することが容易になるのです。

RStudio の Git ペインや Github Desktop は、初心者や日々の仕事での使用には適していますが、中級者や上級者向けの Git 機能への GUI は提供していないことに注意してください。 より完成度の高い GUI  では、ポイント・アンド・クリックでより多くのことができるようになります（通常は、より複雑なレイアウトを犠牲にして）。

リポジトリの追跡にはどんなツールでも使うことができるので、たまに試してみたいときやあまり一般的ではない複雑な作業をするときには GUI をインストールし、それ以外のときにはシンプルな GUI を使うということも簡単にできるということを覚えておきましょう （たとえば、ほとんどの時間は Github Desktop を使い、特定の作業をするときには SourceTree や Gitbash に切り替えるなど）。

## Git コマンド {#git}

### おすすめの学習方法 {.unnumbered}

Git のコマンドをインタラクティブなチュートリアルで学ぶには、[このウェブサイト](https://learngitbranching.js.org/)を参照してください。

### コマンドを入力する場所 {.unnumbered}

Git シェルでコマンドを入力します。

<u>選択肢 1</u> RStudio で新しい Terminal を開くことができます。このタブは R Console の隣にあります。文字が入力できない場合は、"Terminal" の下のドロップダウンメニューをクリックし、"New terminal" を選択します。ドル記号 "$" の前の点滅しているスペースにコマンドを入力します。

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_terminal.png"))
```

<u>オプション2</u> Gitタブ（RStudio Environmentの近く）の青い「歯車」アイコンをクリックして、<u>shell</u>（コマンドを入力するターミナル）を開くこともできます。ドロップダウンメニューから "Shell" を選択します。新しいウィンドウが開くので、ドル記号 "$" の後にコマンドを入力します。

<u>オプション3</u> 右クリックして "Git Bash here" を開くと、同じようなターミナルが表示されます。[Git Bash](https://happygitwithr.com/shell.html) の見つけ方、必要な bash コマンドなど、初心者向けの情報をご紹介します。

### サンプルコマンド {.unnumbered}

以下では、一般的な git コマンドをいくつか紹介します。これらのコマンドを使う際には、どのブランチがアクティブ (チェックアウト済み) なのかを覚えておきましょう。

以下のコマンドでは、\<name\> はブランチの名前を表します。 \<commit_hash\> は、特定のコミットのハッシュIDを表します。\<num\> は数字を表します。 \< と \> 記号は入力しないでください。

| Git コマンド             | 内容                                                                     |
|--------------------------|--------------------------------------------------------------------------|
| `git branch <name>`      | 新規にブランチ \<name\> を作成                                           |
| `git checkout <name>`    | ブランチ \<name\> に移動                                                 |
| `git checkout -b <name>` | 新規にブランチを作成し移動                                               |
| `git status`             | 変更を見る                                                               |
| `git add <file>`         | ファイルをステージ                                                       |
| `git commit -m <message>`| 現在のブランチにステージされた変更をメッセージ付きでコミット             |
| `git fetch`              | リモートリポジトリからコミットをフェッチ                                  |
| `git pull`               | 現在のブランチのリモートリポジトリからコミットをプル                     |
| `git push`               | ローカルのコミットをリモートにプッシュ                                   |
| `git switch`             | `git checkout` と同じ、今後はこちらに移行                                |
| `git merge <name>`       | ブランチ \<name\> を現在のブランチにマージ                               |
| `git rebase <name>`      | 現在のブランチから \<name\> へのコミットを修正                           |



<!-- ======================================================= -->

## リソース

このページの多くは、Jenny Bryan氏による[この "Happy Git with R "ウェブサイト](https://happygitwithr.com/)を参考にしています。このウェブサイトには、Git や R に関連する一般的なエラーのトラブルシューティングに役立つセクションが用意されています。

[Github.com documentation and start guide](https://docs.github.com/en/github)をご覧ください。

RStudio の ["IDE" cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) には、RStudio での Git に関するヒントがあります。

<https://ohi-science.org/news/github-going-back-in-time>

**初心者のための Git コマンド**

Git コマンドを学ぶための[インタラクティブチュートリアル](learnngitbranching.js.org)。

<https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/>: 自分のコンピュータ上の1つのフォルダの変更を追跡するための絶対的な基本を学ぶのに適しています。

ブランチを理解するための良い図解があります。<https://speakerdeck.com/alicebartlett/git-for-humans>


**基本的なことからより高度なことまでをカバーするチュートリアル**

<https://tutorialzine.com/2016/06/learn-git-in-30-minutes>

<https://dzone.com/articles/git-tutorial-commands-and-operations-in-git>
<https://swcarpentry.github.io/git-novice/> (ショートコース)
<https://rsjakob.gitbooks.io/git/content/chapter1.html>

[Pro Git book](https://git-scm.com/book/en/v2) は、公式のリファレンスとされています。 いくつかの章は大丈夫でしょうが、おおむね <u>技術的な</u>内容になっています。Git を少し使ってみて、何が起こっているのか、どうすればいいのかをもう少し正確に知りたいと思ったら、この本はいい資料になるでしょう。


