---
editor_options: 
  markdown: 
    wrap: 72
  chunk_output_type: console
---

# Version control and collaboration with Git and Github

This chapter presents an overview of using Git to collaborate with others.
More extensive tutorials can be
found at the bottom in the Resources section.

## What is Git?

Git is a **version control** software that allows tracking changes in a
folder. It can be used like the "track change" option in Word, LibreOffice or
Google docs, but for all types of files. It is one of the most powerful
and most used options for version control.

**Why have I never heard of it? -** While people with a developer
background routinely learn to use version control software (Git,
Mercurial, Subversion or others), few of us from
quantitative disciplines are taught these skills. Consequently, most epidemiologists never
hear of it during their studies, and have to learn it on the fly.

**Wait, I heard of Github, is it the same?** - Not exactly, but you
often use them together, and we will show you how to. In short:

-   **Git** is the version control system, a piece of software. You can use it
    locally on your computer or to synchronize a folder with a
    host **website**. By default, one uses a terminal to give Git
    instructions in command-line.

-   You can use a **Git client/interface** to avoid the command-line and
    perform the same actions (at least for the simple, super common
    ones). Many options exist: Github Desktop, Tortoise Git, Source
    Tree, GitKraken, the Git pane in Rstudio... Quick explanation on
    [Git
    clients](-%09https:/happygitwithr.com/git-client.html#git-client).

-   If you want to store your folder in a **host website** to
    collaborate with others, you may create an account at Github,
    Gitlab, Bitbucket or others.

So you could use the client/interface **Github Desktop**, which uses
**Git** in the background to manage your files, both locally on your
computer, and remotely on a **Github** server.

## Why use the combo Git and Github?

Using **Git** facilitates:

1)  Archiving documented versions with incremental changes so that you
    can easily revert backwards to any previous state
2)  Having parallel *branches*, i.e. developing/"working" versions with
    structured ways to integrate the changes after review

This can be done locally on your computer, even if you don't collaborate
with other people. Have you ever:

-   regretted having deleted a section of code, only to realize two
    months later that you actually needed it?

-   come back on a project that had been on pause and attempted to
    remember whether you had made that tricky modification in one of the
    models?

-   had a *file model_1.R* and another file *model_1\_test.R* and a file
    *model_1\_not_working.R* to try things out?

-   had a file *report.Rmd*, a file *report_full.Rmd*, a file
    *report_true_final.Rmd*, a file *report_final_20210304.Rmd*, a file
    *report_final_20210402.Rmd* and cursed your archiving skills?

Git will help with all that, and is worth to learn for that alone.

However, it becomes even more powerful when used with a online repository
such as Github to support **collaborative projects**. This facilitates:

-   Collaboration: others can review, comment on, and
    accept/decline changes

-   Sharing your code, data, and outputs, and invite feedback
    from the public (or privately, with your team)

and avoids:

-   "Oops, I forgot to send the last version and now you need to
    redo two days worth of work on this new file"

-   Mina, Henry and Oumar all worked at the same time on one script and
    need to manually merge their changes

-   Two people try to modify the same file on Dropbox and Sharepoint 
    and this creates a synchronization error.

### This sounds complicated, I am not a programmer {-}

It can be. Examples of advanced uses can be quite scary. However, much
like R, or even Excel, you don't need to become an expert to reap the
benefits of the tool. Learning a *small number of functions and notions*
lets you track your changes, synchronize your files on a online
repository and collaborate with your colleagues in a very short amount
of time.

Due to the learning curve, emergency context may not be the best of time
to learn these tools. But learning can be achieved by steps. Once you acquire 
a couple of notions, your workflow can be quite efficient and fast.
If you are not working on a project where collaborating with people
through Git is a necessity, **it is actually a good time to get
confident using it** in solo before diving in collaboration.

## Setup

### Install Git {.unnumbered}

*Git* is the engine behind the scenes on your computer, which tracks
changes, branches (versions), merges, and reverting. **You must first
install *Git* from <https://git-scm.com/downloads>.**

### Install an interface (optional but recommended) {.unnumbered}

Git has its own language of commands, which can be typed into a command
line terminal. However, there are many clients/interfaces and in
day-to-day use, you will rarely need to interact with Git directly. Good
options for beginners include the RStudio Git pane and [Github
Desktop](https://desktop.github.com/).

*Note: since interfaces actually all use Git internally, you can try several of
them, switch from one to another on a given project, or even perform any
number of actions online on Github.*

As noted below, you may *occasionally* have to write Git commands into a
terminal such as the RStudio terminal pane (a tab adjacent to the R
Console) or the Git Bash terminal.

### Github account {.unnumbered}

Sign-up for a free account at [github.com](github.com).

You may be offered to set-up two-factor authentication with an app on
your phone. Read more in the Github [help
documents](https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa).

If you use Github Desktop, you can enter your Gitub credentials after
installation following these
[steps](https://docs.github.com/en/desktop/installing-and-configuring-github-desktop/authenticating-to-github).
If you don't do it know, credentials will be asked later when you try to
clone a project from Github.

## Vocabulary, concepts and basic functions

As when learning R, there is a bit of vocabulary to remember to
understand Git. Here are the [basics to get you
going](https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/)
/ [interactive tutorial](learngitbranching.js.org). In the next
sections, we will show how to use interfaces, but it is good
to have the vocabulary and concepts in mind, to build your mental model, and as you'll need them when using interfaces anyway.

### Repository {.unnumbered}

A Git *repository* ("*repo*") is a folder that contains all the
sub-folders and files for your project (data, code, images, etc.) and
their revision histories. When you begin tracking changes in the
repository with it, Git will create a hidden folder that contains
all tracking information. A typical Git repository is
your *R Project* folder (see handbook page on [R projects]).

We will show how to create (_initialize_) a Git repository 
from Github, Github Desktop or Rstudio in the next
sections.

### Commits {.unnumbered}

A *commit* is a **snapshot** of the project at a given time. 
When you make a change to the project, you will make a new commit
to track the changes (the delta) made to your
files. For example, perhaps you edited some lines of code and updated a
related dataset. Once your changes are saved, you can bundle these
changes together into one "commit".

Each commit has a unique ID (a *hash*). For version control purposes,
you can revert your project back in time based on commits, so it is best
to keep them relatively small and coherent. You will also attach a brief
description of the changes called the "commit message".

*Staged changes*? To stage changes is to add them to the *staging area*
in preparation for the next commit. The idea is that you can finely
decide which changes to include in a given commit. For example, if you
worked on model specification in one script, and later on a figure in
another script, it would make sense to have two different commits (it would be easier
in case you wanted to revert the changes on the figure but not the model).


### Branches {.unnumbered}

A branch represents an *independent line* of changes in your repo, a
parallel, alternate version of your project files. 

Branches are useful to test changes before they are incorporated into
the *main* branch, which is usually the primary/final/"live" version of
your project. When you are done experimenting on a branch, you can bring
the changes into your *main* branch, by *merging* it, or delete it, if
the changes were not so successful.

*Note: you do not have to collaborate with other people to use branches,
nor need to have a remote online repository.*


### Local and remote repositories {.unnumbered}

To *clone* is to create a copy of a Git repository in another place.

For example, you can *clone* a online repository _from_ Github locally on
your computer, or begin with a local repository and clone
it online _to_ Github.

When you have cloned a repository, the project files exist in
two places:

-   the *LOCAL* repository on your physical computer. This
    is where you make the actual changes to the files/code.

<!-- -->

-   the *REMOTE*, online repository: the versions of your project files
    in the Github repository (or on any other web
    host).

To synchronize these repositories, we will use more functions. Indeed,
unlike Sharepoint, Dropbox or other synchronizing software, Git does
not automatically update your local repository based or what's online,
or vice-versa. You get to choose when and how to synchronize.

-   `git fetch` checks the state of the remote repository.

-   `git pull` downloads the new changes from the remote repositories
    into your local branch.

-   When you have made one or several commits locally, you can
    `git push` the commits to the remote repository. This sends your
    changes on Github so that other people can see and pull them if
    they want to.


## Get started: create a new repository

There are many ways to create new repositories. You can do it from the
console, from Github, from an interface.

Two general approaches to set-up are:

-   Create a new R Project from an existing or new Github repository
    (*preferred for beginners*), or
-   Create a Github repository for an existing R project


### Start-up files {.unnumbered}

When you create a new repository, you can optionally create 
all of the below files, or you can add them to your repository at a later stage.
They would typically live in the "root" folder of the repository.

-   A *README* file is a file that someone can read to understand why
    your project exists and what else they should know to use it. It
    will be empty at first, but you should complete it later.

-   A *.gitignore* file is a text file where each line would contain
    folders or files that Git should ignore (not track changes). Read
    more about it and see examples
    [here](https://www.freecodecamp.org/news/gitignore-what-is-it-and-how-to-add-to-repo/).

-   You can choose a *license* for your work, so that other people
    know under which conditions they can use or reproduce your work. For more
    information, see the [Creative Commons
    licenses](https://creativecommons.org/licenses/).

### Create a new repository in Github {.unnumbered}

To create a new repository, log into Github and look for the green
button to create a new repository. This now empty repository can be
cloned locally to your computer (see next section).

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_new.png"))
```

You must choose if you want your repository to be **public** (visible to
everyone on the internet) or **private** (only visible to those with
permission). This has important implications if your data are sensitive.
If your repository is private you will encounter some quotas in advanced
special circumstances, such as if you are using Github *actions* to
automatically run your code in the cloud.
 
### Clone from a Github repository {.unnumbered}

You can *clone* an existing Github repository to create
a new local R project on your computer.

The Github repository could be one that already exists and contains
content, or could be an empty repository that you just created. In this
latter case you are essentially creating the Github repo and local R
project at the same time (see instructions above).

_Note_: if you do not have contributing rights on a Github repository, it is possible to first _fork_ the repository to your profile, and then proceed with the other actions. Forking is explained at the end of this chapter, but we recommend that you read the other sections first.

Step 1: Navigate in Github to the repository, click on the green "**Code**"
button and copy the **HTTPS clone URL** (see image below)

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone.png"))
```

The next step can be performed in any interface. We will illustrate with
Rstudio et Github desktop.

#### In Rstudio {.unnumbered}

In RStudio, start a new R project by clicking *File \> New Project \>
Version Control \> Git*

-   When prompted for the "Repository URL", paste the HTTPS URL from
    Github\
-   Assign the R project a short, informative name\
-   Choose where the new R Project will be saved locally\
-   Check "Open in new session" and click "Create project"

You are now in a new, local, RStudio project that is a clone of the
Github repository. This local project and the Github repository are now
linked.

#### In Github Desktop {.unnumbered}

-   Click on *File \> Clone a repository*

-   Select the URL tab

-   Paste the HTTPS URL from Github in the first box

-   Select the folder in which you want to have your local repository

-   Click "CLONE"

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone_desktop.png"))
```

### New Github repo from existing R project {.unnumbered}

An alternative setup scenario is that you have an existing R project
with content, and you want to create a Github repository for it.

1)  Create a new, empty Github repository for the project (see
    instructions above)\
2)  Clone this repository locally (see HTTPS instructions above)\
3)  Copy all the content from your pre-existing R
    project (codes, data, etc.) into this new empty, local, repository (e.g. use copy and paste).\
4)  Open your new project in RStudio, and go to the Git pane. The new files should
    register as file changes, now tracked by Git. Therefore, you can
    bundle these changes as a *commit* and *push* them up to Github.
    Once *pushed*, the repository on Github will reflect all the files.
    
See the Github workflow section below for details on this process.

### What does it look like now? {.unnumbered}

#### In RStudio {-}

Once you have cloned a Github repository to a new R project, 
you now see in RStudio a "Git" tab. This tab appears in the same RStudio pane
as your R Environment:

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Git_console.png"))
```

Please note the buttons circled in the image above, as they will be
referenced later (from left to right):

-   Button to *commit* the saved file changes to the local
    branch (this will open a new window)
-   Blue arrow to *pull* (update your local version of the branch with
    any changes made on the remote/Github version of that branch)
-   Green arrow to *push* (send any commits/changes for your local
    version of the branch to the remote/Github version of that branch)
-   The Git tab in RStudio
-   Button to create a NEW branch using whichever local branch is shown
    to the right as the base. *You almost always want to branch off from
    the main branch (after you first pull to update the main branch)*
-   The branch you are currently working in
-   Changes you made to code or other files will appear below

#### In Github Desktop {-}

Github Desktop is an independent application that allows you to manage
all your repositories. When you open it, the interface allows you to
choose the repository you want to work on, and then to perform basic Git
actions from there.

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_interface.png"))
```

## Git + Github workflow

### Process overview {.unnumbered}

Once you have completed the setup (described above), you will have a
Github repo that is connected (*cloned*) to a local R project. The
*main* branch (created by default) is the so-called "live" version of
*all* the files. When you want to make modifications, it is a good
practice to create a *new branch* from the *main* branch (like "Make a
Copy"). This is a typical workflow in Git because creating a branch is
easy and fast.

A typical workflow is as follow:

1.  Make sure that your local repository is up-to-date, update it if
    not

2.  Go to the branch you were working on previously, or create a new
    branch to try out some things

3.  Work on the files locally on your computer, make one or several
    commits to this branch

4.  Update the remote version of the branch with your changes (push)

5.  When you are satisfied with your branch, you can merge the online
    version of the working branch into the online "main" branch to
    transfer the changes

Other team members may be doing the same thing with their own branches,
or perhaps contributing commits into your working branch as well. 

We go through the above process step-by-step in more detail below.
Here is a schematic we've developed - it's in the format of a two-way
table so it should help epidemiologists understand.

```{r echo=F, out.height='150%', out.width='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_table.png"))
```

Here's [another diagram](https://build5nines.com/introduction-to-git-version-control-workflow/).

*Note: until recently, the term "master" branch was used, but it is now
referred to as "main" branch.*

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "GitHub-Flow.png"))
```

Image
[source](https://build5nines.com/introduction-to-git-version-control-workflow/)

## Create a new branch

When you select a branch to work on, **Git resets your working directory
the way it was the last time you were on this branch**.

### In Rstudio Git pane {.unnumbered}

Ensure you are in the "main" branch, and then click on the purple icon to
create a new branch (see image above).

-   You will be prompted to name your branch with a one-word descriptive
    name (can use underscores if needed).
-   You will see that locally, you are still in the same R project, but
    you are no longer working on the "main" branch.
-   Once created, the new branch will also appear in the Github website
    as a branch.
    
You can visualize branches in the Git Pane in Rstudio after clicking on "History"

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_rstudio_branchs.png"))
```

### In Github Desktop {.unnumbered}

It is very much a similar process, you are prompted to give your branch
a name. After, you will be prompted to "Publish you branch to Github" to
make the new branch appear in the remote repo as well.

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_new_branch.png"))
```

### In console {.unnumbered}

What is actually happening behind the scenes is that you create a new
branch with `git branch`, then go to the branch with
`git checkout` (_i.e._ tell Git that your next commits will occur there). From your git repository:

```{bash, eval = FALSE}
git branch my-new-branch  # Create the new branch branch
git checkout my-new-branch # Go to the branch
git checkout -b my-new-branch # Both at once (shortcut)
```

For more information about using the console, see the section on
Git commands at the end.

## Commit changes

Now you can edit code, add new files, update datasets, etc.

Every one of your changes is tracked, *once the respective file is
saved*. Changed files will appear in the RStudio Git tab, or in Github
Desktop, or using the command `git status` in the terminal (see below).

When you make substantial changes (e.g. adding or updating a section of
code), pause and *commit* those changes. Think of a commit as a "batch"
of changes related to a common purpose. You can always continue to
revise a file after having committed changes on it.

*Advice on commits*: generally, it is better to make small commits, that
can be easily reverted if a problem arises, to commit together
modifications related to a common purpose. To achieve this, you will
find that *you should commit often*. At the beginning, you'll probably
forget to commit often, but then the habit kicks in.

### In Rstudio {.unnumbered}

In the example below, it has been recorded that I modified an R Markdown
script called "collaboration.Rmd" and also several PNG images.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking2.png"))
```

You might wonder what the yellow, blue, green, and red squares next to
the file names represent. Here is a snapshot from the [RStudio
cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)
that explains their meaning. Note that changes with yellow "?" can still
be staged, committed, and pushed.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking.png"))
```

-   Press the "Commit" button in the Git tab, which will open a new
    window (shown below)

-   Click on a file name in the upper-left box

-   Review the changes you made to that file (highlighted below in green
    or red)

-   "Stage" the file, which will include those changes in the commit. Do
    this by checking the box next to the file name. Alternatively, you
    can highlight multiple file names and then click "Stage"

-   Write a commit message that is short but descriptive (required)

-   Press the "Commit" button. A pop-up box will appear showing success
    or an error message.

-   Make more changes and more commits, as many times as you would like

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_commit.png"))
```

### In Github Desktop {.unnumbered}

You can see the list of the files that were changed on the left. When
you select one, there is a glimpse of the modifications that were made
in the right pane if it is a text file (the view will not work on more
complex files like .docs or .xlsx).

To stage the file, just tick the little box near file names. When you
have selected the files you want to add to this commit, give the commit
a name, optionally a description and then click on the **commit**
button.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_commit.png"))
```

### In console {.unnumbered}

The two functions used behind the scenes are `git add` to select/stage
files and `git commit`.

```{bash, eval = FALSE}
git status # see the changes 

git add new_pages/collaboration.Rmd  # select files to commit (= stage the changes)

git commit -m "Describe commit from Github Desktop" # commit the changes with a message

git log  # View information on past commits
```


### Amend a previous commit

Sometimes, you commit  some changes, carry on working, and realise that you made changes that conceptually belong to the past commit. Fear not! You can append these changes to your previous commit.

In Rstudio, it should be pretty obvious as there is a "Amend previous commit" box on the same line as the COMMIT button. 

For some unclear reason, the functionality has not been implemented as such in Github Desktop, but there is a (conceptually awkward but easy) way around. If you have committed **but not pushed** your changes yet, an "UNDO" button appears just unde the COMMIT button. If you click on it, it will revert your commit (but let your files staged and keep your commit message). Save your changes, add new files to the commit if necessary and commit again.

```{bash, eval = FALSE}
git add [YOUR FILES] # Stage your new changes

git commit --amend  # Amend the previous commit

git commit --amend -m "an updated commit message"  # Amend the previous commit AND update the commit message
```


_Note: be cautious (avoid) modifying commits that are already public and shared with your collaborators_.


## Pull and push changes up to Github

"First PULL, then PUSH"

It is good practice to *fetch* and *pull* before you begin working on
your project, to update the branch version on your local computer with
any changes that have been made to it in the remote/Github version.

PULL often. Don't hesitate. *Always pull before pushing*.

When your changes are made and committed, you can *push* your commits up
to the remote/Github version of your branch.

Repeat and rince while you work on the repository.

#### In Rstudio {.unnumbered}

*PULL* - First, click the PULL icon (downward arrow) which fetch and
pull at the same time.

*PUSH* - clicking the green "Pull" icon (upward arrow). You may be asked
to enter your Github username and password. The first time you are
asked, you may need to enter two Git command lines into the *Terminal*:

-   **git config --global user.email
    "[you\@example.com](mailto:you@example.com){.email}"** (your Github
    email address), and\
-   **git config --global user.name "Your Github username"**

To learn more about how to enter these commands, see the section below
on Git commands.

[***TIP:*** Asked to provide your password too often? See these chapters
10 & 11 of this
[tutorial](https://happygitwithr.com/credential-caching.html#credential-caching)
to connect to a repository via SSH key (more
complicated)]{style="color: darkgreen;"}

#### In Github Desktop {.unnumbered}

Click on the "Fetch origin" button to check if there are new commits on
the remote repository.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_fetch_button.png"))
```

If Git finds new commits on the remote repository, the button will
change into a "Pull" button. Because the same button is used to push and
pull, you cannot push your changes if you don't pull before.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_pull_button.png"))
```

You can go to the "History" tab (near the "Changes" tab) to see all
commits (yours and others). This is a nice way of acquainting yourself
with what your collaborators did. You can read the commit message, the
description if there is one, and compare the code of the two files using
the *diff* pane.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_history.png"))
```

Once all remote changes have been pulled, and at least one local change
has been commited, you can push by clicking on the same button.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_push_button.png"))
```

#### Console {.unnumbered}

Without surprise, the commands are *fetch*, *pull* and *push*.

```{bash, eval = FALSE}
git fetch  # are there new commits in the remote directory?
git pull   # Bring remote commits into your local branch
git push   # Puch local commits of this branch to the remote branch
```

## Merge branch into Main 

If you have finished making changes, you can begin the process of
merging those changes into the main branch. Depending on your situation,
this may be fast, or you may build in deliberate review and approval
steps involving teammates.

### Locally in Github Desktop {.unnumbered}

One can merge branches locally using Github Desktop. First, go
(checkout) to the branch that will be the recipient of the commits, the
branch you want to update. Then go to the menu *Branch \> Merge into
current branch* and click. A box will allow you to select the branch you
want to import from.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_merge.png"))
```

### In console {.unnumbered}

First move back to the branch that will be the receivers of the changes.
Usually *master*, but it could be another branch. Then merge your
working branch into master.

```{bash, eval = FALSE}
git checkout master  # Go back to master (or to the branch you want to move your )
git merge this_fancy_new_branch
```

[This
page](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)
shows a more advanced example of branching and explains a bit what is
happening behind the scenes.

### In Github: submitting pull requests {.unnumbered}

While it is totally possible to merge two branches locally, or without
informing anybody, a merge may be discussed, or investigated by several
people before being integrated to the master branch. To help with the
process, Github offers some discussion features around the merge: the
**pull request**.

A pull request - (a "PR") is a request to merge one branch into another (in other words, a request that _your working branch be pulled into the "main" branch_). A pull request typically involves multiple commits, which each contain changes to certain files. A pull request usually begins a conversation and review process before the it is accepted and the branch is merged. For example, see pull request discussions on the [dplyr's
github](https://github.com/tidyverse/dplyr/pulls).

You can submit a pull request (PR) directly form the website (as
illustrated bellow) or from Github Desktop.

-   Go to Github repository (online)
-   View the tab "Pull Requests" and click the "New pull request" button
-   Select from the drop-down menus to merge your branch into main
-   Write a detailed Pull Request comment and click "Create Pull
    Request".

In the image below, the branch "forests" has been selected to be merged
into "main":

```{r echo=F, out.width = '100%', out.height='150%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request2.png"))
```

Now you should be able to see the pull request (example image below):

-   Review the tab "Files changed" to see how the "main" branch would
    change if the branch were merged.\
-   On the right, you can request a review from members of your team by
    tagging their Github ID. If you like, you can set the repository
    settings to require one approving review in order to merge into
    main.\
-   Once the pull request is approved you will see a button available to
    "Merge pull request". Click this.\
-   Once completed, delete your branch as explained below

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request.png"))
```

### Resolving conflicts {.unnumbered}

When someone modified the same line(s) as yours at the same time, a
merge conflict arises. Indeed, Git refuses to make a decision about
which version to keep but it helps you find the exact place of the
conflict. **DO NO PANIC**. Most of the time, it is pretty straighforward
to resolve.

For example, on Github site:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict2.png"))
```

As usual, you can use different tools. You can do some edits directly
from Github for very minor things. But you can also use your favourite
code editing software.

After the merge raised a conflict, open the file. The conflict will be
indicated by series of characters:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict3.png"))
```

The text between *\<\<\<\<\<\<\< HEAD* and *=======* is the one on your
local repository, and the one between *=======* and *\>\>\>\>\>\>\>* the
one on the other branch (which may be origin, master or any branch of
your choice).

You need to decide which version of the code you prefer (or to write a
third, including changes from both sides if pertinent), delete the rest
and remove all the marks that Git added *(\<\<\<\<\<\<\< HEAD, =======,
\>\>\>\>\>\>\> origin/master/your_branch_name*). Then, save the file,
stage it and commit it.

Once the conflicts have been resolved, you will need a last commit to
officialize the merging.

The more often you and your collaborators pull and push, the smaller the
conflicts will be.

*Note: If you feel at ease with the console, there are more [advanced
merging
options](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging)
(e.g. ignoring whitespace, giving a collaboartor priority etc.).*

### Delete your branch {.unnumbered}

Once a branch was merged into master and is no longer needed, you can
suppress it.

#### Github + Rstudio

Go to the repository on Github and click the button to view all the
branches (next to the drop-down to select branches). Now find your
branch and click the trash icon next to it. Read more detail on deleting
a branch
[here](https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/creating-and-deleting-branches-within-your-repository#deleting-a-branch)

Be sure to also delete the branch locally on your computer. This will
not happen automatically.

-   From RStudio, make sure you are in the Main branch
-   Switch to typing Git commands in the RStudio "Terminal" (the tab
    adjacent to the R console), and enter this: **git branch -d
    branch_name** , where "branch_name" is the name of your branch to be
    deleted
-   Refresh your Git tab and this branch should be gone

#### In Github Desktop

Just go checkout to the branch you want to delete, and go to the menu
*Branch \> Delete*.


### Forking

You can fork a project if you would like to contribute to a project but  do not have the rights to create a branch on this project. Or if you just want to make some modifications to a project for your personnal use. A short description of forking can be found [here](https://guides.github.com/activities/forking/).

On Github, click on the "Fork" button:  

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_1.png"))
```

This will clone the original repository, but in your own profile. So now, there are two version of the repository **on Github**: the original one, that you cannot modify, and the cloned version in your profile.

Then, you can proceed to clone your version of the online repository locally on your computer, using any of the methods describes in previous sections. Then, you can create a new branch, make changes, commit and push them _to your remote repository_.

Once you are happy with the result, if you wish so, you can create a Pull Request from Github or Github Desktop to begin the conversation with the owners/maintainers of the original repository.


**What if the original repository had some critical changes that you need during development?**

It is possible to synchronize your fork with the original folder. It involves using the terminal, but it should not too complicated. You mostly need to remember that:
- _upstream_ = the original repository, the one that you could not modify
- _origin_ = your version of the repository on your Github profile

You can read [this tutorial](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) or follow along here: 


First, in your Git terminal (within your repo) type:  

```{bash, eval = FALSE}
git remote -v
```
 
If you have not yet configured the upstream repository you should see two lines, begining by _origin_. These shows the remote repo that `fetch` and `push` point to. Remember, _origin_ is the conventional nickname for your own version of the repository on github. For example:  

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_2.png"))
```

Now, add a new remote repository:  

```{bash, eval = FALSE}
git remote add upstream https://github.com/epirhandbook/Epi_R_handbook.git
```
 
Here the adress is the adress that Github generates when you clone a repository (see section on cloning). Now you will have four remote pointers:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_3.png"))
```

Now that the setup is done, whenever you want to get the changes from the original (_upstream_) repository, you just have to go (_checkout_) to the branch you want to update and type:

```{bash, eval = FALSE}
git fetch upstream # Get the new commits from the remote repository
git checkout the_branch_you_want_to_update
git merge upstream/the_branch_you_want_to_update  # Merge the upstream branch into your branch.
git push # to update your own version of the remote repo with all these
```

If there are conflicts, you will have to solve them, as explained in the Resolving conflicts session. 


**Summary**: forking is cloning, but on the Github server side. The rest of the actions as typical collaboration workflow actions (clone, push, pull, commit, merge, submit pull requests...).

_Note: while forking is a concept, not a Git command, it also exist on other Web hosts, like [Bitbucket](https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow)._


```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_4.png"))
```



## Gitignore

File that says what git should ignore (not save to history) file or
pattern . Ones that are really big (500MB) or sensitive (tokens) CAP
size? .gitignore

.Rproj.use .RHistory .RData phifunc_token (txt file with no extension)
*\~ (anything followed by tilde) outputs/ (take lots of space)
data/raw/for_quick_loading data/clean/final_dat*





## Git commands {#git}


### Recommended learning {.unnumbered}

To learn Git commands in an interactive tutorial, please see [this
website](https://learngitbranching.js.org/).

### Where to enter commands {.unnumbered}

*Option 1* You can open a new Terminal in RStudio. This tab is next to
the R Console. If it does not seem to be accepting any text, click the
drop-down menu below "Terminal" and select "New terminal". Type the
commands at the blicking space in front of the dollar sign "\$".

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_terminal.png"))
```

*Option 2* You can also open a *Shell* (a terminal to enter commands) by
clicking the blue "gears" icon in the Git tab (near the RStudio
Environment). Select "Shell" from the drop-down menu. A new window will
open where you can type the commands after the dollar sign "\$".

*Option 3* Right click to open "Git Bash here" which will open the same
sort of terminal. Or open *Git Bash* form your application list.

### Sample commands {.unnumbered}

Below we present a few git commands that are more common. Keep in mind
if you use them which branch you is active (checked-out) when you write
the command, as that will change the action!

In the commands below, <name> represents a branch name (do not type the
\< or \> symbols). <commit_hash> represents the hash ID of a specific
commit. <num> represents a number.

| Git command              | Action                                                          |
|--------------------------|-----------------------------------------------------------------|
| `git branch <name>`      | Create a new branch with the name <name>                        |
| `git checkout <name>`    | Switch current branch to <name>                                 |
| `git checkout -b <name>` | Shortcut to create new branch *and* switch to it                |
| `git switch`             | An alternative to `git checkout` that is being phased in to Git |
| `git commit`             | Commit the currently saved changes to the current branch        |
| `git branch <name>`      | Make a new branch called <name> as copy of the current branch   |
| `git merge <name>`       | Merge <name> branch into current branch                         |
| `git rebase <name>`      | Append commits from current branch on to <name> branch          |

\^ \| Move backwards one commit \~<num> \|Move backwards <num> commits
git checkout HEAD\~4 git log \| see hashes git checkout <commit_hash>
git checkout <name>; git merge main = Merge main into bugfix

### Revert mistakes {.unnumbered}

`git branch -f main HEAD~3` = Moves by force the main branch to three
parents behind HEAD (e.g. HEAD may be in bugFix branch) (other branches
may stay where they are).

`main^` is the parent commit of main git checkout main\^ = this moves
the HEAD to the commit before main's last commit HEAD can be used as a
relatively reference, e.g. using HEAD\^ multiple time to keep moving
backwards

git reset \| Moves HEAD back "rewriting history" move a branch reference
backwards in time to an older commit, as if that commit had never been
made in the first place. Works well for local branches on your own
machine. But doesn't work for remote branches that others are using. git
reset HEAD\~1 Moves branch backwards from most recent C2 back to C1 to
reverse changes and SHARE those reversed changes with others, use git
revert

git revert git revert HEAD makes new commit that is prime e.g. C2 to C2'

git commit

## Package management with **renv**

UNDER CONSTRUCTION

[Introduction to
**renv**](https://rstudio.github.io/renv/articles/renv.html)

<!-- ======================================================= -->

## Resources

Much of this page was informed by [this "Happy Git with R"
website](https://happygitwithr.com/) by Jenny Bryan. There is a helpful
section of this website that helps you troubleshoot common Git and
R-related errors.

The [Github.com documentation and start
guide](https://docs.github.com/en/github)

The RStudio ["IDE"
cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)
which includes tips on Git with RStudio

<https://ohi-science.org/news/github-going-back-in-time>

**Git commands for beginers**

This website provides an [interactive
tutorial](https://epirhandbook.com/learngitbranching.js.org) to learn
Git commands

<https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/>:
good for learning the absolute basics to track changes in one folder on
you own computer.

Nice scematics to understand branches:
<https://speakerdeck.com/alicebartlett/git-for-humans>

**Tutorials covering both basic and more advanced subjects**

<https://tutorialzine.com/2016/06/learn-git-in-30-minutes>

<https://dzone.com/articles/git-tutorial-commands-and-operations-in-git>
<https://swcarpentry.github.io/git-novice/> (short course)
<https://rsjakob.gitbooks.io/git/content/chapter1.html>
