---
editor_options: 
  markdown: 
    wrap: 72
---

# データテーブル

このハンドブックでは、データを整理しグループ化する方法として、**dplyr**
の「動詞」関数と**magrittr** パイプ演算子`%>%`
に焦点を当てていますが、**data.table**
パッケージは、Rを使用していく上で経験する可能性のある代替方法を提供します。

<!-- ======================================================= -->

## データテーブルの概要

データ表は、データフレームのような2次元のデータ構造であり、複雑なグループ化操作を実行することができます。
data.table構文は、行、列、およびグループに対して操作を実行できるように構成されています。

構造は **DT\[i, j, by\]** で、**i**、**j**、**by**
による3つの部分で区切られています。
**i**引数を使用すると、必要な行をサブセット化できます。**j**
引数を使用すると、列を操作できます。**by**
引数を使用すると、グループごとに列を操作できます。

このページでは、次のトピックについて説明します。

-   データのインポートと`fread()` および`fwrite()` の使用
-   **i** 引数を使用した行の選択とフィルタリング
-   ヘルパー関数`%like%`、`%chin%`,、`%between%` の使用
-   **j** 引数を使用した列の選択と計算
-   **by** 引数を使用したグループによる計算
-   `:=` を使用してデータテーブルにデータを追加および更新する

<!-- ======================================================= -->

## パッケージの読み込みとデータのインポート

### パッケージの読み込み {.unnumbered}

**pacman** の `p_load()`
関数を使用して、この分析に必要なパッケージを読み込み（および必要に応じてインストールし）ます。

```{r}
pacman::p_load(
  rio,        # データのインポート
  data.table, # データのグループ化
  tidyverse,  # この章でパイプ（%>%）関数を使用可にする
  here 
  ) 
```

### データのインポート {.unnumbered}

このページでは、ハンドブック全体で参照されているケースラインリストを使用して、**data.table**
のコア機能のいくつかについて説明します。

シミュレートされたエボラ出血熱の流行から症例のデータセットをインポートします。
データをダウンロードして段階的に実行する場合は、［Download book and
data］の手順を参照してください。 データセットは、**rio** パッケージの
`import()` 関数を使用してインポートされます。
データをインポートするさまざまな方法については、［インポートとエクスポート］のページを参照してください。
ここから、 `data.table()`
を使用してデータフレームをデータテーブルに変換します。

```{r}
linelist <- rio::import(here("data", "linelist_cleaned.xlsx")) %>% data.table()
```

`fread()`
関数は、.csvファイルなどの通常の区切りファイルをデータテーブル形式に直接インポートするために使用されます。この関数とそれに対応する
`fwrite()` は、通常の区切りファイルとして data.tables
を書き込むために使用され、大規模なデータベースでは非常に高速で計算効率の高いオプションです。

`linelist` の最初の20行：

```{r message=FALSE, echo=F, eval=FALSE}
DT::datatable(head(linelist,20), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

データフレームに使用される `dim()` などのベース R
コマンドは、データテーブルにも使用できます。

```{r}
dim(linelist) #データテーブルの行と列の数を示す
```

<!-- ======================================================= -->

## i引数: 行の選択とフィルタリング

先ほど説明した **DT\[i, j, by\]**
構造を使い、行番号または論理式のいずれかを使用して行をフィルタリングできます。
i引数が最初です。 したがって、構文 **DT\[i\]** または **DT\[i,\]**
を使用できます。

最初の例ではデータテーブルの最初の5行を取得し、2番目の例では18歳以上のケースをサブセット化し、3番目の例では18歳以上であるが中央病院で診断されていないケースをサブセット化します。

```{r, eval=F}
linelist[1:5] #1行目から5行目を取得
linelist[age >= 18] #18歳以上をサブセット化
linelist[age >= 18 & hospital != "Central Hospital"] #18歳以上であるが、中央病院で診断されていない症例のサブセット

```

i 引数で .N を使用すると、データテーブルの行の総数を表します。
これは、行番号のサブセット化に使用できます。

```{r, eval=F}
linelist[.N] #最後の行を取得
linelist[15:.N] #15行目から最後の行を取得
```

### ヘルパー関数を使用したフィルタリング {.unnumbered}

データテーブルは、行のサブセット化を容易にするヘルパー関数を使用します。
`%like%` 関数は列のパターンを照合するために使用され、`%chin%`
は特定の文字を照合するために使用され、`%between%`
ヘルパー関数は事前に指定された範囲内の数値列を照合するために使用されます。

以下の例では、\*病院変数に「Hospital」が含まれる行をフィルタリングする、\*予後が「回復」または「死」である行をフィルタリング、\*40〜60歳の範囲の行をフィルタリングします。

```{r, eval=F}
linelist[hospital %like% "Hospital"] #病院変数に「Hospital」が含まれる行をフィルタリングする
linelist[outcome %chin% c("Recover", "Death")] #予後が「回復」または「死」である行をフィルタリングする
linelist[age %between% c(40, 60)] #40〜60歳の範囲の行をフィルタリングする

#%between%を使う際は長さ2のベクトルが必要だが、%chin%を使う場合は長さ1以上のベクトルが使用できる。

```

## j引数: 列の選択と計算

**DT\[i, j, by\]**
構造を使用すると、数値または名前を使用して列を選択できます。**j**
引数は2番目です。 したがって、構文 **DT\[, j\]** が使用されます。**j**
引数の計算を容易にするために、列は `list()` または `.()`
のいずれかを使用して表示されることもあります。

### 列の選択 {.unnumbered}

最初の例では、データテーブルの1番目、3番目、5番目の列を取得し、2番目の例では、身長、体重、性別の列を除くすべての列を選択します。3番目の例では、
`.()` を使用して、**case_id** 列と**outcome** 列を選択します。

```{r, eval=F}
linelist[ , c(1,3,5)]
linelist[ , -c("gender", "age", "wt_kg", "ht_cm")]
linelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)]でも可

```

### 列での計算 {.unnumbered}

**i** 引数と**j**
引数を組み合わせることにより、行をフィルタリングして列を計算することができます。
**j** 引数で **.N**
を使用すると、データテーブルの行の総数も表され、行フィルタリング後に行数を取得するのに役立ちます。

次の例では、入院7日以上の症例数をカウントし、軍病院で死亡した症例の平均年齢、中央病院で回復した症例の標準偏差、中央値、平均年齢を計算します。

```{r}
linelist[days_onset_hosp > 7 , .N]
linelist[hospital %like% "Military" & outcome %chin% "Death", .(mean(age, na.rm = T))] #na.rm = T removes N/A values
linelist[hospital == "Central Hospital" & outcome == "Recover", 
                 .(mean_age = mean(age, na.rm = T),
                   median_age = median(age, na.rm = T),
                   sd_age = sd(age, na.rm = T))] #この構文はヘルパー関数を使用しないが、同様に機能する

```

j
引数でラップを使用すると、計算が容易になり、データテーブルを取得し、列に名前を付けることができます。

## by引数: グループによる計算

**by** 引数は、**DT\[i, j, by\]** 構造体の3番目の引数です。 **by**
引数は、文字ベクトルと `list()` または `.()` 構文の両方を使用できます。
**by** 引数で、 `.()` 構文を使用すると、列の名前をその場で変更できます。

次の例では、症例数を病院ごとにグループ化し、18歳以上の場合は、性別や回復したか死亡したかによって、平均身長と体重を計算します。また、7日間以上の入院では、入院した月と入院した病院に応じて症例数をカウントします。

```{r}
linelist[, .N, .(hospital)] #病院別の症例数
linelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T),
                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAは、データが欠落しているデータカテゴリを表す
linelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]

```

Data.table では、次のように式を連鎖させることもできます。

```{r}

linelist[, .N, .(hospital)][order(-N)][1:3] #1番目は病院ごとにすべての症例を選択し、2番目は症例を降順で並べ替え、3番目は最大の症例数を持つ3つの病院をサブセット化する

```

これらの例では、データテーブルの行は新しい症例にあたるという仮定に従っているため、**.N**を使用してデータテーブルの行数を表すことができます。Another
useful function to represent the number of unique cases is `uniqueN()`,
which returns the number of unique values in a given input. This is
illustrated here:　固有の症例数を表すもう1つの便利な関数は、 `uniqueN()`
です。これにより、指定されたインプットの固有値の数を取得できます。
以下のように実行されます。

```{r}

linelist[, .(uniqueN(gender))] #j引数の .()によりデータテーブルを取得する
```

性別の列の固有値はm、f、およびN/Aであるため、答えは3になります。
指定されたインプットのすべての固有の値を\`取得するベースR関数`unique()`と比較してください。

```{r}

linelist[, .(unique(gender))]
```

特定の月の固有の症例数を取得するには、次のように記述します。

```{r}

linelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]

```

## データテーブルへの追加と更新

`:=`
演算子は、データテーブルのデータを追加または更新するために使用されます。
データテーブルへの列の追加は、次の方法で実行できます。

```{r}

linelist[, adult := age >= 18] #1列追加
linelist[, c("child", "wt_lbs") := .(age < 18, wt_kg*2.204)] #複数の列を追加するには、c("") とlist() または。.() 構文が必要
linelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),
                         no_infector_source_data = is.na(infector) | is.na(source))] #this method uses := as a functional operator `:=`
linelist[, adult := NULL] #列の削除

```

これよりも複雑な集計は、本導入章の範囲を超えていますが、データのグループ化と整理のために、**dplyr**
の一般的で実行可能な代替手段を提供することを目的としています。
**data.table**
パッケージは、読みやすいコードを可能にする優れたパッケージです。

## 資料

詳細については、以下の資料をご覧ください。\*
<https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html>
\* <https://github.com/Rdatatable/data.table> \*
<https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf>
\*
<https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/>
\* <https://www.datacamp.com/community/tutorials/data-table-r-tutorial>

グループ化されたデータに対して任意の要約機能を実行できます。
詳細については、こちらのチートシートをご参照ください。<https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf>
