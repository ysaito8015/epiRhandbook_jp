
# Working with dates {.tabset .tabset-fade}


<!-- ======================================================= -->
## Overview

Working with dates in R is notoriously difficult when compared to other object classes. R often interprets dates as character objects - this means they cannot be used for general date operations such as making time series and calculating time intervals. To make matters more difficult, there are many date formats, some of which can be confused for other formats. Luckily, dates can be wrangled easily with practice, and with a set of helpful packages.

Dates in R are their own class of object - the `Date` class. It should be noted that there is also a class that stores objects with date *and* time. Date time objects are formally referred to as  and/or `POSIXt`, `POSIXct`, and/or `POSIXlt` classes (the difference isn't important). These objects are informally referred to as *datetime* classes.

You can get the system date or system datetime by doing the following:

```{r eval=T}
# get the system date - this is a DATE class
Sys.Date()

# get the system time - this is a DATETIME class
Sys.time()

```

* It is important to make R recognize when a column contains dates.  
* Dates are an object class and can be tricky to work with.  
* Here we present several ways to convert date columns to Date class.  


<!-- ======================================================= -->
## Packages

The following packages are recommended for working with dates:  

```{r dates_packages, warning=F, message=F}
# Checks if package is installed, installs if necessary, and loads package for current session

pacman::p_load(aweek,      # flexibly converts dates to weeks, and vis-versa
               lubridate,  # for conversions to months, years, etc.
               linelist,   # function to guess messy dates
               ISOweek,    # another option for creating weeks
               tidyverse,
               )    
```



<!-- ======================================================= -->
## Convert to Date class

### `as.Date()` {-}  

The standard, **base** R function to convert an object or column to class Date is `as.Date()` (note capitalization).  

`as.Date()` requires that the user *specify the **existing** format of the date*, so it can understand, convert, and store each element (day, month, year, etc.) correctly. [Read more online about `as.Date()`](https://www.stat.berkeley.edu/~s133/dates.html).  

**If used on a column, `as.Date()` therefore requires that all the character date values be in the same format before converting.** If your data are messy, try cleaning them manually or consider using `guess_dates()` from the **linelist** package.  

It can be easiest to first convert the column to character class, and then convert to date class:  

  1. Turn the column into character values using the function `as.character()`
```{r eval=F}
# With pipes
linelist <- linelist %>% 
  mutate(date_onset = as.character(date_onset))

# In base R
linelist$date_onset <- as.character(linelist$date_onset)
```
  2. Convert the column from character values into date values, using the function `as.Date()`  
  (note the capital "D")  
  + Within the `as.Date()` function, you must use the `format=` argument to tell R the *current* format of the date components - which characters refer to the month, the day, and the year, and how they are separated. If your values are already in one of R's standard date formats (YYYY-MM-DD or YYYY/MM/DD) the `format=` argument is not necessary.  
    
    + The codes are:  
         %d = Day # (of the month e.g. 16, 17, 18...)  
         %a = abbreviated weekday (Mon, Tues, Wed, etc.)  
         %A = full weekday (Monday, Tuesday, etc.)  
         %m = # of month (e.g. 01, 02, 03, 04)  
         %b = abbreviated month (Jan, Feb, etc.)  
         %B = Full Month (January, February, etc.)  
         %y = 2-digit year  (e.g. 89)  
         %Y = 4-digit year  (e.g. 1989)  

For example, if your character dates are in the format DD/MM/YYYY, like "24/04/1968", then your command to turn the values into dates will be as below. **Putting the format in quotation marks is necessary.**  

```{r eval=F}
# Using pipes
linelist <- linelist %>% 
  mutate(date_onset = as.Date(date_of_onset, format = "%d/%m/%Y"))

# Using base R
linelist$date_onset <- as.Date(linelist$date_of_onset, format = "%d/%m/%Y"))
```

<span style="color: darkgreen;">**_TIP:_** The `format =` argument is *not* telling R the format you want the dates to be, but rather how to identify the date parts as they are *before* you run the command.</span>  

<span style="color: darkgreen;">**_TIP:_**Be sure that in the `format =` argument you use the *date-part separator* (e.g. /, -, or space) that is present in your dates.</span>  

Once the values are in class Date, R will by default display them in the standard format, which is YYYY-MM-DD.



### **lubridate** {-}  

Conveting character objects to dates can be made *far* easier by using the **lubridate** package. This is a `tidyverse` package designed to make working with dates and time more simple and consistent than in base R. For these reasons, **lubridate** is often considered the gold-standard package for dates and time, and is recommended whenever working with them.

The **lubridate** package provides several different helper functions designed to convert character objects to dates in an intuitive, and more lenient way than specifying the format in `as.Date()`. These functions are specific to the rough date format, but allow for a variety of separators, and synonyms for dates (e.g. 01 vs Jan vs January) - they are named after abbreviations of date formats. 


```{r, eval = T}
# install/load lubridate 
pacman::p_load(lubridate)
```

The `ymd()` function flexibly converts date values supplied as **year, then month, then day**.  

```{r}
# read date in year-month-day format
ymd("2020-10-11")
ymd("20201011")
```

The `mdy()` function flexibly converts date values supplied as **month, then day, then year**.  

```{r}
# read date in month-day-year format
mdy("10/11/2020")
mdy("Oct 11 20")
```

The `dmy()` function flexibly converts date values supplied as **day, then month, then year**.  

```{r}
# read date in day-month-year format
dmy("11 10 2020")
dmy("11 October 2020")
```

<!-- The `as.character()` and `as.Date()` commands can optionally be combined as:   -->

<!-- ```{r eval=F} -->
<!-- linelist_cleaned$date_of_onset <- as.Date(as.character(linelist_cleaned$date_of_onset), format = "%d/%m/%Y") -->
<!-- ``` -->

If using [piping](#piping) and the tidyverse, the converting a character column to dates with lubridate might look like this:  

```{r, eval=F}
linelist <- linelist %>%
  mutate(date_onset = lubridate::dmy(date_onset))
```

Once complete, you can run a command to verify the class of the column
```{r, eval=F}
# Check the class of the column
class(linelist$date_onset)  
```

Once the values are in class Date, R will by default display them in the standard format, which is YYYY-MM-DD.




<!-- ======================================================= -->
## Convert to `datetime` classes

As previously mentioned, R also supports a `datetime` class - a column that contains date **and** time information. As with the `Date` class, these often need to be converted from `character` objects to `datetime` objects. 

A standard `datetime` object is formatted with the date first, which is followed by a time component - for example  _01 Jan 2020, 16:30_. As with dates, there are many ways this can be formatted, and there are numerous levels of precision (hours, minutes, seconds) that can be supplied.  

Luckily, **lubridate** helper functions also exist to help convert these strings to `datetime` objects. These functions are extensions of the date helper functions, with `_h` (only hours supplied), `_hm` (hours and minutes supplied), or `_hms` (hours, minutes, and seconds supplied) appended to the end (e.g. `dmy_hms()`). These can be used as shown:

Convert datetime with only hours to datetime object  

```{r}
ymd_h("2020-01-01 16hrs")
ymd_h("2020-01-01 4PM")
```

Convert datetime with hours and minutes to datetime object  

```{r}
dmy_hm("Jan 1st 2020 16:20")
```

Convert datetime with hours, minutes, and seconds to datetime object  

```{r}
mdy_hms("01 January 20, 16:20:40")
```

You can supply time zone but it is ignored. See section later in this page on time zones.  

```{r}
mdy_hms("01 January 20, 16:20:40 PST")

```

When working with a dataframe, time and date columns can be combined to create a datetime column using `str_glue()` from **stringr** package and an appropriate **lubridate** function:

```{r, eval = FALSE}
# packages
pacman::p_load(tidyverse, lubridate, stringr)

# time_admission is a column in hours:minutes
linelist <- linelist %>%
  
  # when time of admission is not given, assign the median admission time
  mutate(
    time_admission_clean = ifelse(
      is.na(time_admission),
      median(time_admission),
      time_admission
  ) %>%
  
    # use str_glue() to combine two columns to create a character column
    # and then use ymd_hm() to convert to datetime
  mutate(
    date_time_of_admission = str_glue("{date_hospitalisation} {time_admission_clean}") %>% 
      ymd_hm()
  )

```


<!-- ======================================================= -->
## Working with dates   

`lubridate` can also be used for a variety of other functions, such as **extracting aspects of a date/datetime**, **performing date arithmetic**, or **calculating date intervals**

Here we define a date to use for the examples:  

```{r, eval = T}
# create object of class Date
example_date <- ymd("2020-03-01")
```


```{r}
# extract the month and year from this date
month(example_date)  # month number
year(example_date)   # year
day(example_date)    # day (number)
wday(example_date)   # day number of the week (1-7)
```

You can also extract time components from a `datetime` object or column. This can be useful if you want to view the distribution of admission times.  

```{r, eval=F}
example_datetime <- ymd_hm("2020-03-01 14:45")

hour(example_datetime)     # extract hour
minute(example_datetime)   # extract minute
second(example_datetime)   # extract second
```


You can retrieve epiweeks with `epiweek()` from **lubridate**:  

```{r}
# get the epiweek of this date (this will be expanded later)
epiweek(example_date)
```

### Date math {-}  

```{r}
# add 3 days to this date
example_date + days(3)
  
# add 7 weeks and subtract two days from this date
example_date + weeks(7) - days(2)
```

### Date intervals {-}  

```{r}
# find the interval between this date and Feb 20 2020 
example_date - ymd("2020-02-20")
```

This can all be brought together to work with data - for example:

```{r, eval = F}
pacman::p_load(lubridate, tidyverse)   # load packages

linelist <- linelist %>%
  
  # convert date of onset from character to date objects by specifying dmy format
  mutate(date_onset = dmy(date_onset),
         date_hospitalisation = dmy(date_hospitalisation)) %>%
  
  # filter out all cases without onset in march
  filter(month(date_onset) == 3) %>%
    
  # find the difference in days between onset and hospitalisation
  mutate(onset_to_hosp_days = date_hospitalisation - date_of_onset)
```



<!-- ======================================================= -->
## Messy dates  

The function `guess_dates()` from the **linelist** package attempts to read a "messy" date column containing dates in many different formats and convert the dates to a standard format. You can [read more online about `guess_dates()`](https://www.repidemicsconsortium.org/linelist/reference/guess_dates.html). If `guess_dates()` is not yet available on CRAN for R 4.0.2, try install via `pacman::p_load_gh("reconhub/linelist")`.

For example `guess_dates` would see a vector of the following character dates "03 Jan 2018", "07/03/1982", and "08/20/85" and convert them to class Date as: `2018-01-03`, `1982-03-07`, and `1985-08-20`.  

```{r, eval = T}
linelist::guess_dates(c("03 Jan 2018",
                        "07/03/1982",
                        "08/20/85"))
```

Some optional arguments for `guess_dates()` that you might include are:  

* `error_tolerance` - The proportion of entries which cannot be identified as dates to be tolerated (defaults to 0.1 or 10%)
* `last_date` - the last valid date (defaults to current date)  
* `first_date` - the first valid date. Defaults to fifty years before the last_date.


```{r eval = FALSE}
# An example using guess_dates on the column dater_onset
linelist <- linelist %>%                 # the dataset is called linelist
  mutate(
    date_onset = linelist::guess_dates(  # the guess_dates() from package "linelist"
      date_onset,
      error_tolerance = 0.1,
      first_date = "2016-01-01"
    )
```


<!-- ======================================================= -->
## Excel Dates

Excel stores dates as the number of days since December 30, 1899. If the dataset you imported from Excel shows dates as numbers or characters like "41369"... use the `as.Date()` or **lubridate**'s `as_date()` function to convert, but **instead of supplying a format as above, supply an origin date**. This will not work if the excel date is read as a character type, so be sure to ensure the date is a numeric class (or convert it to one)!

<span style="color: black;">**_NOTE:_** You should provide the origin date in R's default date format ("YYYY-MM-DD").</span>


```{r, eval = FALSE}
library(lubridate)
library(dplyr)

# An example of providing the Excel 'origin date' when converting Excel number dates
data_cleaned <- data %>% 
  mutate(date_onset = as_date(as.double(date_onset), origin = "1899-12-30")) # convert to numeric, then convert to date
```


<!-- ======================================================= -->
## Date display  

Once dates are the correct class, you often want them to display differently (e.g. in a plot, graph, or table). For example, to display as "Monday 05 Jan" instead of 2018-01-05. You can do this with the **base** R function `format()`, which works in a similar way as `as.Date()`. Read more [in this online tutorial](https://www.statmethods.net/input/dates.html).  

Remember that the output from `format()` is a character type, so is generally used for display purposes only!

%d = Day # (of the month e.g. 16, 17, 18...)
%a = abbreviated weekday (Mon, Tues, Wed, etc.)  
%A = full weekday (Monday, Tuesday, etc.)  
%m = # of month (e.g. 01, 02, 03, 04)  
%b = abbreviated month (Jan, Feb, etc.)  
%B = Full Month (January, February, etc.)  
%y = 2-digit year  (e.g. 89)  
%Y = 4-digit year  (e.g. 1989)  
%h = hours (24-hr clock)  
%m = minutes  
%s = seconds
%z = offset from GMT  
%Z = Time zone (character)

An example of formatting today's date:  

```{r}
# today's date, with formatting
format(Sys.Date(), format = "%d %B %Y")

# easy way to get full date and time (no formatting)
date()

# formatted date, time, and time zone (using paste0() function)
paste0(
  format(Sys.Date(), format = "%A, %b %d '%y, %z  %Z, "), 
  format(Sys.time(), format = "%H:%M:%S")
)
```

<!-- ======================================================= -->
## Calculate distance between dates

The difference between dates can be calculated by:  
  
  
1. Correctly formating *both* date column as class date (see instructions above)  
2. Creating a new column that is defined as one date column subtracted from the other
3. Converting the result to numeric class (default is class "datediff"). This ensures that subsequent mathematical calculations can be performed.  


```{r, eval = TRUE}

# define columns as date classes
date_of_onset <- ymd("2020-03-16")
date_lab_confirmation <- ymd("2020-03-20")

# find the delay between onset and lab confirmation
days_to_lab_conf <- as.double(date_lab_confirmation - date_of_onset)
days_to_lab_conf

```

In a dataframe format (i.e. when working with a linelist), if either of the above dates is missing, the operation will fail for that row. This will result in an `NA` instead of a numeric value. When using this column for calculations, be sure to set the `na.rm` option to `TRUE`. For example:

```{r, eval = FALSE}

# add a new column
# calculating the number of days between symptom onset and patient outcome
linelist_delay <- linelist_cleaned %>%
  mutate(
    days_onset_to_outcome = as.double(date_of_outcome - date_of_onset)
  )

# calculate the median number of days to outcome for all cases where data are available
med_days_outcome <- median(linelist_delay$dats_onset_to_outcome, na.rm = T)

# often this operation might be done only on a subset of data cases, e.g. those who died
# this is easy to look at and will be explained later in the handbook

```

<!-- ======================================================= -->
## Converting dates/time zones

When data is present in different time time zones, it can often be important to standardise this data in a unified time zone. This can present a further challenge, as the time zone component of data must be coded manually in most cases.

In R, each *datetime* object has a timezone component. By default, all datetime objects will carry the local time zone for the computer being used - this is generally specific to a *location* rather than a named timezone, as time zones will often change in locations due to daylight savings time. It is not possible to accurately compensate for time zones without a time component of a date, as the event a date column represents cannot be attributed to a specific time, and therefore time shifts measured in hours cannot be reasonably accounted for.

To deal with time zones, there are a number of helper functions in lubridate that can be used to change the time zone of a datetime object from the local time zone to a different time zone. Time zones are set by attributing a valid tz database time zone to the datetime object. A list of these can be found here - if the location you are using data from is not on this list, nearby large cities in the time zone are available and serve the same purpose. 

https://en.wikipedia.org/wiki/List_of_tz_database_time_zones


```{r}
# assign the current time to a column
time_now <- Sys.time()
time_now

# use with_tz() to assign a new timezone to the column, while CHANGING the clock time
time_london_real <- with_tz(time_now, "Europe/London")

# use force_tz() to assign a new timezone to the column, while KEEPING the clock time
time_london_local <- force_tz(time_now, "Europe/London")


# note that as long as the computer that was used to run this code is NOT set to London time, there will be a difference in the times (the number of hours difference from the computers time zone to london)

time_london_real - time_london_local

```

This may seem largely abstract, and is often not needed if the user isn't working across time zones. One simple example of its implementation is:

```{r, eval = FALSE}
# TODO add when time column is here
# set the time column to time zone for ebola outbreak 

# "Africa/Lubumbashi" is the time zone for eastern DRC/Kivu Nord


```


<!-- ======================================================= -->
## Epidemiological weeks  

Use the `floor_date()` function from **lubridate**, with `unit = "week"`. See example below for specifying the week start day. The returned output is the start date of the week, in Date class.  

For example, to create a new column that is weeks, then use `group_by()` with `summarize()` to get weekly case counts.  

To aggregate into weeks and show ALL weeks (even ones with no cases), do this:  


1) Create a new 'week' column within `mutate()`, using `floor_date()` from the **lubridate** package:  
    + use `unit = ` to set the desired time unit, e.g. "week`  
    + use `week_start = ` to set the weekday start of the week (7 = Sunday, 1 = Monday)  

2) Follow with `complete()` to ensure that all weeks appear - even those with no cases.  


For example:  

```{r}
# Make dataset of weekly case counts
weekly_counts <- linelist %>% 
  mutate(
    week = lubridate::floor_date(date_onset,
                                 unit = "week")) %>%  # new column of week of onset
  count(week) %>%                                     # group data by week and count rows per group
  filter(!is.na(week)) %>%                            # remove entries for cases missing date_onset
  complete(week = seq.Date(from = min(week),          # fill-in all weeks with no cases reported
                           to = max(week),
                           by="week"))
```

Here are the first 20 rows of the resulting dataframe:  

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_counts, 20), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```

You can also use the package **aweek** to set epidemiological weeks. You can read more about it [on the RECON website](https://www.repidemicsconsortium.org/aweek/)


<!-- ======================================================= -->
## Dates in Epicurves 

See the section on [Epidemic curves].


<!-- ======================================================= -->
## Lagging and leading calculations  

`lead()` and `lag()` are functions from the **dplyr** package which help find previous (lagged) or subsequent (leading) values in a vector - typically a numeric or date vector. This is useful when doing calculations of change/difference between time units.  


```{r, echo=F}
counts <- import(here("data", "district_count_data.xlsx")) %>% 
  filter(District == "Nibari") %>% 
  mutate(Date = as.Date(Date),
         week_start = lubridate::floor_date(Date, "week")) %>%
  group_by(week_start) %>% 
  summarize(cases_wk = sum(Cases, na.rm=T)) %>% 
  complete(week_start = seq.Date(min(week_start), max(week_start), by = "week"))
```

Let's say you want to calculate the difference in cases between a current week and the previous one. The data are initially provided in weekly counts as shown below. To learn how to aggregate counts from daily to weekly see the page on aggregating (LINK).  

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```

**When using `lag()` or `lead()` the order of rows in the dataframe is very important! - pay attention to whether your dates/numbers are ascending or descending**  

First, create a new column containing the value of the previous (lagged) week.  

* Control the number of units back/forward with `n = ` (must be a non-negative integer)  
* Use `default = ` to define the value placed in non-existing rows (e.g. the first row for which there is no lagged value). By default this is `NA`.  
* Use `order_by = TRUE` if your reference column is not ordered  

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1))
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```
Next, create a new column which is the difference between the two cases columns:  

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1),
         case_diff = cases_wk - cases_prev_wk)
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T) )
```

You can read more about `lead()` and `lag()` in the documentation [here](https://dplyr.tidyverse.org/reference/lead-lag.html) or by entering `?lag` in your console.  

<!-- ======================================================= -->
## Dates miscellaneous  

* `Sys.Date( )` from **base** R returns the current date of your computer  
* `Sys.Time()` from **base** R returns the current time of your computer
* `date()` from **lubridate** returns the current date and time.  

<!-- ======================================================= -->
## Resources  

**lubridate** [tidyverse page](https://lubridate.tidyverse.org/)  
**lubridate** RStudio [cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)  
R for Data Science page on [dates and times](https://r4ds.had.co.nz/dates-and-times.html)  
[Online tutorial](https://www.statmethods.net/input/dates.html)


