\#データクリーニングと主要関数　{\# Cleaning data and core functions}

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

　このページでは、データセットのクリーニングで使用する一般的な手順を示し、Rのデータ管理に不可欠な多くの機能を説明します。

　データクリーニングを実演するために、このページでは未加工の症例ラインリスト データセットのインポートから開始し、クリーニングを段階的に進めていきます。Rコードでは上図の処理は"pipe"チェーンとして明示されます。"パイプ"　演算子 `%>%`を参照し、データセットをある操作から次の操作に渡すことが出来ます。

### **主要関数** {.unnumbered}

　このハンドブックでは、Rパッケージの [tidyverse](https://www.tidyverse.org/)ファミリーの関数を使用することに重点を置いています。このページで紹介されている基本のR関数を以下に示します。

　関数の多くは、データ操作の課題を解決するための"動詞" 関数を提供するRパッケージ [dplyr](https://dplyr.tidyverse.org/) に属しています（名前は"data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)%22)." にちなんでいます。 **dplyr** は、Rパッケージの**tidyverse**ファミリー（**ggplot2**、**tidyr**、**stringr**、**tibble**、**purrr**、**magrittr**、**forcats**なども含まれています）の一部です。)

+-----------------------------------------------------+------------------------------------------------+---------------------------+
| **関数**                                            | 効用                                           | パッケージ                |
+=====================================================+================================================+===========================+
| `%>%`                                               | ある関数から次の関数へデータを"パイプ"（渡す） | **magrittr**              |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `mutate()`                                          | 列の作成、変換、再定義                         | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `select()`                                          | 列の保持、削除、選択、名前の変更               | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `rename()`                                          | 列名の変更                                     | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `clean_names()`                                     | 列名の構文を標準化                             | **janitor**               |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | 列のクラスを変換                               | **base** R                |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `across()`                                          | 複数の列を一度に変換                           | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| **tidyselect** functions                            | 論理条件を使った列の選択                       | **tidyselect**            |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `filter()`                                          | 特定の行を選択                                 | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `distinct()`                                        | 重複する行の削除                               | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `rowwise()`                                         | 各行の中での操作                               | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `add_row()`                                         | 手動で行を追加                                 | **tibble**                |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `arrange()`                                         | 行の並べ替え                                   | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `recode()`                                          | 列の値を再定義                                 | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `case_when()`                                       | 複数の論理基準を使用し列値を再コーディング     | **dplyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `replace_na()`, `na_if()`, `coalesce()`             | 再コーティングのための専用関数                 | **tidyr**                 |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `age_categories()` and `cut()`                      | 数値列からカテゴリーグループを作成             | **epikit** and **base** R |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `clean_variable_spelling()`                         | データ辞書を使用した値の再定義/処理            | **linelist**              |
+-----------------------------------------------------+------------------------------------------------+---------------------------+
| `which()`                                           | 論理的基準を適用し、インデックスを抽出         | **base** R                |
+-----------------------------------------------------+------------------------------------------------+---------------------------+

　これらの関数を Stata や SAS のコマンドと比較したい場合は、[[Transition to R]](https://epirhandbook.com/transition-to-r.html#transition-to-r) のページを参照してください。

　Rパッケージの **data.table** では、`:=`のような演算子や括弧`[ ]`が頻繁に使用されており、別のデータ管理フレームワークを目にすることがあるかもしれません。この手法と構文については、[[Data Table]](https://epirhandbook.com/data-table.html#data-table) のページで簡単に説明しています。

\#\#**用語体系**

　このハンドブックでは、一般的に "変数" や"観測値" の代わりに"列" や"行"を使用します。["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html) の入門で説明したように、ほとんどの疫学統計データセットは、行、列、値の構造で構成されています。

　"変数"は、同じ基本属性を測定する値（年齢層、転帰、発症日など）を示しています。"観測値"は、同じ単位（人、サイト、ラボのサンプルなど）で測定されたすべての値を示します。そのため、これら値を明確に定義することは困難です。

　"tidy" データセットでは、各列が変数、各行が観測値、そして各セルが1つの値です。しかし、データセットの中には、この型に当てはまらないものもあります。"wide" フォーマットのデータセットでは、変数が複数の列に分かれていることがあります（[Pivoting data](https://epirhandbook.com/pivoting-data.html#pivoting-data) ページの例を参照）。同様に、観測値が複数の行に分かれていることもあります。

　このハンドブックのほとんどがデータの管理と変換に関するものですので、抽象的な観測値や変数よりも、行や列といった具体的なデータ構造を示す方が適切です。例外として、データ分析のページでは、変数や観測値を取り上げることがあります。

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

**パイプラインのデータクリーニング**

**このページでは、代表的なデータクリーニングの手順を実行し、パイプに処理を順次追加しながら進めていきます。**

　疫学的な分析やデータ処理では、クリーニングの手順ががしばしば連続して実行され、互いに関連しています。Rでは、これは多くの場合、クリーニングのパイプラインとして示されます。このパイプラインでは、未加工のデータセットが1つのデータ処理ステップから別のデータ処理ステップに渡されます。

　このような連続処理は、**dplyr** の"動詞"関数と **magrittr** のパイプ演算子 `%>%`を利用します。このパイプ処理は未加工データ ( "linelist_raw.xlsx" )から開始し、使用、保存、エクスポートなどが行えるクリーニングされたRデータフレーム（`linelist`）を目標とします。

　パイプラインのデータ処理は、ステップの順番が重要です。クリーニングのステップには以下のようなものがあります。

-   データのインポート\

-   列名の修正または変更\

-   重複の排除\

-   列の作成と変換（例：値の再定義または標準化）。\

-   行のフィルタリングまたは追加\

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

**パッケージの読み込み**

　このコード群は、分析に必要なパッケージの読み込みを示しています。このハンドブックでは **pacman** の `p_load()` を重視しています。p_load() は必要に応じてパッケージをインストールし、ロードします。インストールされたパッケージは**base** Rの`library()` で読み込むことができます。Rのパッケージに関する詳細は [R basics](https://epirhandbook.com/r-basics.html#r-basics) のページをご覧ください。

```{r, message = F}
pacman::p_load(
  rio,        # データの読み込みのパッケージ  
  here,       # 相対ファイルパスウェイ のパッケージ  
  janitor,    # データクリーニングとテーブルのパッケージ  
  lubridate,  # 日付の操作のパッケージ  
  epikit,     # age_categories() 関数のパッケージ  
  tidyverse   # データ管理と可視化のパッケージ  
  )
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

**インポートデータ**

インポート

　ここでは、**rio** パッケージの `import()`関数を使って、未加工の症例リストExcelファイルをインポートします。**rio** パッケージは、さまざまな種類のファイル（.xlsx、.csv、.tsv、.rdsなど）を柔軟に扱うことができます。詳しい情報や、通常とは異なる状況（行のスキップ、欠損値の設定、Googleシートのインポートなど）でのヒントについては、[Import and export](https://epirhandbook.com/import-and-export.html#import-and-export) のページをご覧ください。

　ご覧になりたい方は、クリックして ["未加工 "のラインリスト](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx)をダウンロードしてください（.xlsxファイルとして出力）。

　データセットが大きく、インポートに時間がかかる場合は、インポートコマンドをパイプチェーンとは別に用意し、未加工データを別のファイルとして保存すると便利です。これにより、未加工データと前処理したデータの比較が容易になります。

```{r, echo=F, message=F}
# HIDDEN FROM READER
# 実際にデータをロードするには here() を使用する。
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

以下に、データフレームの最初の50行を見ることができます。

注：Rの基本関数である `head(n)` を使うと，Rコンソールで最初の`n`行だけを表示することができます．

```{r message=FALSE, echo=F}
# ラインリストのデータを表形式で表示する。
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**レビュー**

**skimr** パッケージの関数`skim()` を使うと、データフレーム全体の概要を把握することができます（詳しくは [Descriptive tables](https://epirhandbook.com/descriptive-tables.html#descriptive-tables) のページを参照）。カラムは、character, numeric などのクラス/タイプ別にまとめられています。注："POSIXct "は未加工の日付クラスの一種です（ [Working with dates](https://epirhandbook.com/working-with-dates.html#working-with-dates-1) を参照してください。

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## **列名**

　Rでは、列名は列の"ヘッダー"または"一番上"の値です。コード内では列を参照するために使用され、図ではデフォルトのラベルとして使用されます。

　SASやSTATAなどの他の統計ソフトでは、短い列名を長く表示した"ラベル"が共存しています。Rではデータに列ラベルを追加することができますが、実際にはあまり重視されていません。列名を図の表示に適したものにするには、通常、出力を作成するプロットコマンドの中でその表示を調整します（例えば、プロットの軸や凡例のタイトル、表示される表の列ヘッダーなどです-[scales section of the ggplot tips](https://epirhandbook.com/ggplot-tips.html#ggplot_tips_scales)と[Tables for presentation](https://epirhandbook.com/tables-for-presentation.html#tables-for-presentation) のページを参照してください）。データに列ラベルを付けたい場合は、[こちら](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html)と[こちら](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html)をご覧ください。

Rの列名は非常に頻繁に使用されるため、"きれいな"構文である必要があります。以下のように提案します：

-   短い名前

-   スペースを使わない（アンダースコア \_ に置き換えてください）

-   特殊な文字は使用しない (&, \#, \<, \>,など)

-   似たようなスタイルの用語体系（例：すべての日付カラムの名前が date_onset, date_report, date_deathなど）

`linelist_raw`の列名は、**base R**の `names()`を使って以下のように表示されています。

-   スペースを含む名前がある(例: `infection date`)

-   日付には異なる命名パターンが使用されている(`date onset` と. `infection date`)

-   .xlsxの最後の2列には、マージされたヘッダがあったはずです。これは、2つのマージされた列の名前（"merged_header"）がRによって最初の列に割り当てられ、2番目の列にはセルを保持するため"...28" が割り当てられていることが分かります（当初は空欄であり、28番目の列であったため）。

```{r}
names(linelist_raw)
```

[**注**：スペースを含む列名を参照するには、その名前をバックスティックで囲みます。例：linelist\$`` ` '\x60infection date\x60'` ``　キーボードでは、バックティック（\`）とシングルクォーテーションマーク（'）は異なりますのでご注意ください。]{style="color: black;"}

### ラベル {.unnumbered}

　SASなどの他の統計ソフトでは、変数のラベルが付いています。

### 自動クリーニング {.unnumbered}

**janitor** パッケージの関数`clean_names()`は、以下のように列名を標準化し、ユニークにします：

-   すべての名前をアンダーライン、数字、文字のみで構成されるように変換します。\

-   アクセント記号付きの文字はASCIIに音訳されます（例：ドイツ語のoにウムラウト記号を付けると "o"、スペイン語の "enye "は "n "になります）。\

-   新しい列名の大文字小文字の区別は、 `case =` 引数を使って指定できます（ "snake"がデフォルトで、他に "sentence"、"title"、"small_camel"などがあります）。\

-   `replace =` 引数にベクトルを与えることで、特定の名前の置換を指定することができます（例：`replace = c(onset = "date_of_onset")`)

-   ここでは、 [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning)を紹介します。

　以下では、前処理のパイプラインは、未加工のラインリストに対して`clean_names()`を使用することから開始します。

```{r clean_names}
# 未加工のデータセットを関数にパイプする
clean_names(), assign result as "linelist"  
linelist <- linelist_raw %>% 
  janitor::clean_names()

# see the new column names
names(linelist)
```

[***NOTE:*** The last column name "...28" was changed to "x28".]{style="color: black;"}

注：最後の列名"...28"を"x28" に変更しました。

### 手動による名前のクリーニング {.unnumbered}

　上記の標準化ステップの後でも、列の名前を手動で変更することはしばしば必要です。 `rename()`は `NEW = OLD` というスタイルを採用しており、新しい列名が既存の列名の前に与えられます。

　以下では、クリーニング・パイプラインに名前変更コマンドを追加しています。読みやすいようにコードを並べるため、戦略的にスペースを追加しています。

```{r}
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################
linelist <- linelist_raw %>%
    
    # 列名構文の標準化
    janitor::clean_names() %>% 
    
    # 手動で列名を変更
           # 新しい列名            # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```

これで、列名が変更されていることがわかります。

```{r message=FALSE, echo=F}
names(linelist)
```

列の位置による名前の変更

列名ではなく、列の位置で名前を変更することもできます。

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### `select()`および`summarise()`による名前の変更 {.unnumbered}

　ショートカットとして、**dplyr**の `select()`関数や `summarise()`関数でも列の名前を変更することができます。`select()`は特定の列だけを残すために使用します（このページで後述します）。`summarise()`については、[Grouping data](https://epirhandbook.com/grouping-data.html#grouping-data) や[Descriptive tables](https://epirhandbook.com/descriptive-tables.html#descriptive-tables) のページで説明します。これらの関数は、`new_name = old_name` というフォーマットも使用します。以下はその例です。

```{r, eval=F}
linelist_raw %>% 
  select(#新しい列名             # 既存の列名
         date_infection       = `infection date`,    # rename and KEEP ONLY these columns#列名を変更して変更した列だけを残す。
         date_hospitalisation = `hosp date`)
```

### **その他の課題** {.unnumbered}

#### 空白のExcelカラム名 {.unnumbered}

　Rは、列名（ヘッダー）のないデータセット列を持つことはできません。したがって、データはあるが列のヘッダーがないExcelデータセットをインポートした場合、Rは"...1"や"...2"といった名前でヘッダーを埋めることになります。数字は列番号を表します（例：データセットの4列目にヘッダーがない場合、Rはその列を"...4"と命名します）。

　付与された名前は、ポジション番号（上記の例を参照）または割り当てられた名前(`linelist_raw$...1`)を参照することで、手動でクリーニングすることができます。

#### **Excelの列名とセルの結合** {.unnumbered}

　Excelファイル中のマージセルは、データを受け取る際によく見られます。[Transition to R](https://epirhandbook.com/transition-to-r.html#transition-to-r) で説明したように、マージされたセルは、人間がデータを読むときには良いのですが、 "整頓されたデータ" ではない場合、機械がデータを読むときに多くの問題が発生します。Rはマージされたセルに対応できないからです。

　人間が読めるデータと機械が読めるデータは別物であることをデータ入力をした担当者に伝えてください。また、整頓されたデータの原則をユーザーに教えるよう努めてください。可能な限り、セルが結合されていない整頓されたフォーマットでデータが手元に届くように手順を変更しましょう。

-   各変数はそれぞれの列を持たなければなりません。\
-   各観測値は、それぞれの行を持つ必要があります。\
-   それぞれの値は、それぞれのセルを持っていなければなりません。

**rio**の`import()`関数を使用した場合、マージされたセルの値は最初のセルに割り当てられ、それ以降のセルは空になります。

　結合されたセルを処理するための一つの解決策は、**openxlsx** パッケージの関数`readWorkbook()`でデータをインポートすることです。引数`fillMergedCells = TRUE`を設定します。これにより、マージされたセルの値を、マージ範囲内のすべてのセルに入れることができます。

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[要注意：`readWorkbook()`で列名をマージすると、列名が重複してしまうので、手動で修正する必要があります - Rは列名が重複するとうまく動作しません! 手動での列名のクリーニングのセクションで説明したように、その位置（例えば5列目）を参照して列名を再設定することができます。]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 列の選択と並び替え

dplyrの`select()`を使って、残したい列を選択し、データフレーム内の順番を指定します。

[***注意：***以下の例では、`linelist`データフレームを `select()`で変更して表示していますが、保存はしていません。これはデモンストレーションのためです。変更された列名は、データフレームを`names()`にパイプすることで表示されます。]{style="color: orange;"}

ここでは、クリーニングパイプチェーンのこの時点での[`linelist`]{style="color: orange;"}の全列名を示しています:

```{r}
names(linelist)
```

### **列を保持** {.unnumbered}

残しておきたい列のみを選択します。

`select()`コマンドの中で、列の名前を引用符を使わずに記述します。これらの列は、指定した順序でデータフレームに表示されます。存在しない列を入れた場合、Rはエラーを返すことに注意してください（このような場合にエラーを出さないようにするには、後述の`any_of()`の使い方を参照してください）。

```{r}
# ラインリストのデータセットはselect()コマンドに渡され、name()は列名だけを表示する。
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # display the column names
```

### **"tidyselect" ヘルパー関数** {#clean_tidyselect .unnumbered}

　**tidyselect"** ヘルパー関数は、保持、破棄、または変換する列を簡単に指定するためにあります。これらは、**tidyverse** に含まれる **tidyselect** パッケージのもので、**dplyr** 関数で列を選択する方法の基礎となっています。

　例えば、列の順番を変えたい場合、`everything()`は"まだ記載されていない他のすべての列"を意味する便利な関数です。以下のコマンドは、`date_onset`と`date_hospitalisation`の列をデータセットの最初（左）に移動させますが、それ以降の他の列はすべてそのままにします。`everything()`は空の括弧で書かれていることに注意してください。

```{r}
# date_onsetとdate_hospitalisationを先頭に移動させる。
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

ここでは、`select()`、`across()`、`summary()`などの**dplyr**関数内でも動作する他の"tidyselect"ヘルパー関数を紹介します。

-   `everything()`- 記載されていない他のすべての列を指定します。\

-   `last_col()`- 最後の列を指定します。\

-   `where()` - すべての列に関数を適用し、TRUEとなるものを選択します。\

-   `contains()` - ある文字列を含む列を指定します。\

    -   例：`select(contains("time"))`\

-   starts_with() - 指定された接頭語を指定します。

    -   例：`select(starts_with("date_"))`\

-   `ends_with()`- 指定された接尾語を指定します。\

    -   例：`select(ends_with("_post"))`\

-   `matches()` - 正規表現(regex)を適用し指定します。\

    -   例：`select(matches("[pt]al"))`\

-   `num_range()` - x01, x02, x03のような数値の範囲を指定します。\

-   `any_of()`- 列が存在する場合は指定できます。見つからない場合でもエラーを表示しません。\

    -   例：`select(any_of(date_onset, date_death, cardiac_arrest))`\

　さらに、複数の列を列挙するには`c()`、連続した列には`:`、反対の列には`!`,`AND`には `&`, `OR`には `|`などの通常の演算子を使用します。

　列の論理的な条件を指定するには、`where()`を使用します。`where()`の中に関数を入れる場合は、関数の空の括弧は入れないでください。以下のコマンドは、 数値クラスの列を選択します。

```{r}
# 数値クラスの列を選択する。
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

　列名に指定した文字列が含まれている列のみを選択するには、`contains()`を使用します。 `ends_with()`や `starts_with()`を使用すると、より詳細な情報が得られます。

```{r}
# 特定の文字を含む列を選択する。
linelist %>% 
  select(contains("date")) %>% 
  names()
```

関数 `matches()`は、`contains()`と同様の動作をしますが、括弧内のORバーで区切られた複数の文字列などの正規表現（[Characters and strings](https://epirhandbook.com/characters-and-strings.html#characters-and-strings) のページを参照）を指定することができます。

```{r}
# 複数の文字にマッチするものを検索する。
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[た列名がデータに存在しない場合、エラーを返してコードを停止させることがあります。存在するかどうかわからない列を引用するために、`any_of()`を使用することを検討してください。これは、特に否定的な（削除）選択において有用です。]{style="color: orange;"}

　列のうち1つだけが存在しますが、エラーは発生せず、コードは前処理を停止させることなく実行されます。

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### **列の削除** {.unnumbered}

　削除する列を示すには、列名の前にマイナス記号 "-" を付けるか（例：`select(-outcome)`）、列名のベクトルを付けます（以下のように）。その他の列は全て維持されます。

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>%
     # date_onsetとfeverからvomitまでの全ての列を削除する。
  names()
```

　Rの基本的な構文を使って、NULLと定義して列を削除することもできます。例えば、以下のようになります。

```{r, eval=F}
linelist$date_onset <- NULL   # Rの基本的な構文で列を削除する。
```

### **独立型** {.unnumbered}

`select()`は、独立したコマンドとして使用することもできます（パイプ中ではなく）。この場合、最初の引数は操作対象となる元のデータフレームです。

```{r}
# IDと年齢に関連した列を持つ新しいラインリストを作成する
linelist_age <- select(linelist, case_id, contains("age"))

# 列名の表示
names(linelist_age)
```

#### パイプチェーンに追加 {.unnumbered}

`linelist_raw`には、`row_num`、`merged_header`、`x28`という必要のない列があります。これらをクリーニングパイプチェーンの `select()`コマンドで削除します。

```{r}
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプチェーンのクリーニング開始
###########################
linelist <- linelist_raw %>%
    

     #列名構文の標準化
    janitor::clean_names() %>% 
    

     # 手動で列名を変更
     
     　　　#新しい列名　　　　　　#既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # 上記は、すでに説明した上流側の処理手順
    #####################################################

 　 #列の除去
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## **重複削除**

　重複削除の方法については、ハンドブックの [De-duplication](https://epirhandbook.com/en/de-duplication.html#de-duplication) のページを参照してください。ここでは、非常に簡単な行の重複削除の例のみを紹介します。

**dplyr**パッケージには、`distinct()`関数があります。この関数は、すべての行を調べ、データフレームをユニークな行のみに削減します。つまり、100%重複している行を削除します。

　重複する行を評価する際には、列の範囲を考慮しますが、デフォルトではすべての列を行います。de-duplication のページにあるように、この列の範囲を調整して、特定の列に関してのみ行の一意性が評価されるようにすることができます。

　この単純な例では、空のコマンドdistinct()をパイプチェーンに追加するだけです。これにより、他の行と100%重複している行がないことが保証されます（すべての列で評価されます）。

まず `linelist` の行数を `nrow(linelist)`とします。

```{r}
linelist <- linelist %>% 
  distinct()
```

　重複削除後の行数は `nrow(linelist)`です。削除された行は、他の行と100%重複しています。

以下では、パイプチェーンに`distinct()`コマンドを追加しています。

```{r}
# クリーニングパイプチェーン(未加工データ開始し、クリーニングステップを経てパイプに送られる)
##################################################################################

# パイプチェーンの処理開始
###########################
linelist <- linelist_raw %>%
    

     # 列名の構文の標準化
    janitor::clean_names() %>% 
    
     # 手動でカラム列を変更
           # 新しい列名            # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # 列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
    #上記は、すでに説明した上流側のクリーニング手順
    #####################################################
    
    # 重複除去
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## **列の作成と変換**

　新しい列を追加したり、既存の列を修正したりするには、**dplyr**の関数 `mutate()`を使うことをお勧めします。

　以下は、`mutate()`を使って新しい列を作成する例です。構文は次のとおりです： `mutate(new_column_name = value or transformation)`

　Stataでは、これは`generate`コマンドに似ていますが、Rの`mutate()`は既存の列を修正するためにも使用できます。

**新しいカラム**

　新しい列を作成する最も基本的な`mutate()`コマンドは次のようになります。以下では、すべての行の値が10である新しい列`new_col`を作成します。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

　また、他の列の値を参照して、計算を行うこともできます。以下では、新しい列 `bmi`が作成され、各ケースのBody mass index（BMI）を格納しています。これは、列`ht_cm`と列`wt_kg`を使用して、BMI = kg/m\^2の式で計算されたものです。

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

　複数の新しい列を作成する場合は、それぞれをコンマで区切って改行します。以下は、**stringr**パッケージの `str_glue()`を使って他列の値を組み合わせたものなど、新しい列の例です（[Characters and strings](https://epirhandbook.com/en/characters-and-strings.html#characters-and-strings) のページを参照）。

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             #新しい列＝重複削/存在する他の列をコピー
    new_var_static = 7,                   # 新しい列＝全ての値が同じ
    new_var_static = new_var_static + 5,  # 列を上書きしたり、他の変数を使って計算したりすることがでる。
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") 
    # 新しい列 = 他の列の値を貼り付ける
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        
# デモ用に新しい列のみを表示
```

　新しい列を確認します。デモのために、新しい列とそれを作成するために使用された列のみが表示されています。

```{r message=FALSE, echo=F}
# ラインリストのデータを表にして表示する。
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***ヒント:*** `mutate()`のバリエーションとして、`transmute()`という関数があります。この関数は、`mutate()`と同じように新しい列を追加しますが、括弧の中に書かれていない他のすべての列を削除または取り除きます。]{style="color: darkgreen;"}

```{r, eval=F}
# HIDDEN FROM READER
# removes new demo columns created above

# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

**列クラスの変換**

　日付、数字、理論値（TRUE/FALSE）を含む列は、正しく分類されれば期待通の動きをします。文字クラスの"2"と数字クラスの2は異なります。

　インポートコマンド中に列クラスを設定する方法もありますが、扱いにくい場合が多いです。オブジェクトや列のクラスを変換する方法については、[R Basics](https://epirhandbook.com/en/r-basics.html#r-basics) のオブジェクトクラスの項を参照してください。

　まず、重要な列について、正しいクラスであるかどうかのチェックを行ってみましょう。これは最初に`skim()`を実行したときに確認しました。

　現在、`age`の列のクラスはcharacter型です。定量的な分析を行うためには、これらの数字が数値として認識される必要があります!

```{r}
class(linelist$age)
```

`date_onset`列のクラスも文字です! 分析を行うには、これらの日付を日付として認識する必要があります。

```{r}
class(linelist$date_onset)
```

　これを解決するには、mutate()の機能を使って、変換で列を再定義します。列をそれ自体として定義し、異なるクラスに変換します。ここでは、基本的な例として、列`age`がクラスNumeric型に変換または適正化します。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

　同様に、`as.character()`や`as.logical()`を使うこともできます。factor型に変換するには、**base R**の`factor()`やforcatsの`as_factor()`が使えます。詳しくは [ Factors](https://epirhandbook.com/en/factors.html#factors) のページをご覧ください。

Date型 への変換には注意が必要です。いくつかの方法は [Working with dates](https://epirhandbook.com/en/working-with-dates.html#working-with-dates-1) のページで説明されています。通常、変換が正しく行われるためには、未加工の日付値がすべて同じ形式である必要があります (例: "MM/DD/YYYY"、または "DD MM YYYY")。クラスの日付に変換した後、データをチェックして、各値が正しく変換されたことを確認してください。

### **グループ化されたデータ** {.unnumbered}

　 データフレームがすでにグループ化されている場合（[Grouping data](https://epirhandbook.com/en/grouping-data.html#grouping-data)のページを参照）、`mutate()`の動作はグループ化されていない場合とは異なるかもしれません。`mean()`、`median()`、`max()`などの要約関数は、すべての行ではなく、グループごとに計算されます。

```{r, eval=F}
# 全行の平均値で正規化された年齢
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# 年齢を病院グループの平均値で正規化
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

　グループ化されたデータフレームでの `mutate ()`の使用については、この [tidyverse mutate documentation](https://dplyr.tidyverse.org/reference/mutate.html) ドキュメントで詳しく説明しています。

### **複数のカラムの変換** {#clean_across .unnumbered}

　簡潔なコードを書くために、同じ変換を複数の列に一度に適用したいことがあります。**dplyr**パッケージ（ **Tidyverse** パッケージにも含まれています）の `across()` 関数を使用して、変換を複数の列に一度に適用することができます。 `across()`はどの **dplyr** 関数で使用することができますが、一般的には`select()`、`mutate()`、`filter()`、`summarise()`内で使用されます。`summarise()`にどのように適用されるかは、[Descriptive tables](https://epirhandbook.com/en/descriptive-tables.html#descriptive-tables) のページを参照してください。

　引数`.cols =`には列を指定し、`.fns =`には適用する関数を指定します。`.fns`関数に与える追加の引数は、カンマの後に含めることができます。

#### `cross()`列選択 {.unnumbered}

　引数`.cols =` に列を指定します。 個別に名前を付けることもできますし、"tidyselect" ヘルパー関数を使用することもできます。関数を`.fns =`に指定します。 以下に示す関数機能を使用すると、関数はその括弧（ ）なしで記述することに注意してください。

ここでは、`as.character()`という変換が、 `across()`で指定された特定の列に適用されています。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

　"tidyselect"ヘルパー関数は、列の指定する際に参考になります。これらの関数は上記の列の選択と並び替えのセクションで詳述されており、次のものが含まれます：`everything()`、`last_col()`、`where()`、`starts_with()`、`ends_with()`、`contains()`、`matches()`、`num_range()`、`any_of()`。

ここでは、すべての列をcharacter型に変更する例を示します。

```{r, eval=F}
#全ての列をcharactor型に変換する。
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

　名前に "date "という文字列が含まれるすべての列を文字に変換します（カンマと括弧の配置に注意してください）。

```{r, eval=F}
#全ての列をcharactor型に変換する。
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

　以下は、現在POSIXct型（タイムスタンプを示す未加工のdatetime型）である列、つま `is.POSIXct()`関数の評価値が`TRUE`である列を変換する例です。次に、これらの列に `as.Date()`という関数を適用して、通常のDate型に変換したいと思います。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   is.POSIXctがTRUEまたはFALSEに評価されるように、`across()`内では`where()`という関数も使用していることに注意してください。

-   `is.POSIXct()`は **lubridate** パッケージのものであることに注意してください。`is.character()`、`is.numeric()`、`is.logical()`のような他の類似した"is"関数は **base R** のものです。

#### **`across()`関数** {.unnumbered}

`across()`に関数を提供する方法の詳細については、`?across`のドキュメントをお読みください。要約すると、列に対して実行する関数を指定する方法はいくつかあり、独自の関数を定義することもできます。

-   関数名のみを指定することができます（例：`mean`または `as.character`）。

-   関数を **purrr** スタイルで提供することができます（例：`~ mean(.x, na.rm = TRUE))`( [本ページ](https://epirhandbook.com/en/iteration-loops-and-lists.html#iteration-loops-and-lists)参照 )

-   リストを指定することで，複数の関数を指定することができます（例：`list(mean = mean, n_miss = ~ sum(is.na(.x)))`）．

-   複数の関数を指定した場合は、入力列ごとに複数の変換後の列が返され、`col_fn`という形式で一意の名前が付けられます。新しい列の名前を調整するには、`.names =` 引数で**glue**の構文（[Characters and strings](https://epirhandbook.com/en/characters-and-strings.html#characters-and-strings) のページを参照）を使用します。`{.col}`と`{.fn}`は入力列と関数の省略形です。

### `coalesce()` {.unnumbered}

　この **dplyr** 関数は、各位置で最初の欠損値ではない値を見つけます。この関数は、指定された順序で、取得可能な最初の値で欠損値を埋めます。

　ここでは、データフレーム以外の例を示します。2つのベクトルがあるとします。1つは患者の発見された村、もう1つは患者の居住地の村です。coalesceを使って、各インデックスの最初の非欠損値を選ぶことができます。

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    #表示
```

　これは、データフレームの列を指定した場合にも同じように動作します。この関数は、各行ごとに、指定した列の中で最初に欠落していない値を新しい列の値として割り当てます（指定した順に）。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

　これは "row-wise "演算の一例です。より複雑な行単位の計算については、下記の "行単位の計算" の項をご覧ください。

### **累積計算** {.unnumbered}

　データフレーム行を計算し、その時点までの累積和/平均/最小/最大などを列に反映させたい場合は、以下の関数を使用します。

cumsum()は、以下のように、累積和を返します。

```{r}
sum(c(2,4,15,10))     # 1つの数字のみを返す。
cumsum(c(2,4,15,10))  # 各ステップでの累積和を返す。
```

　これは、データフレームで新しい列を作るときに使用できます。例えば、アウトブレイクにおける1日あたりの累積症例数を計算するには、次のようなコードを考えます。

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # 症例ラインリスト 
  count(date_onset) %>%                 #一日当たりの行数をカウント 　　
  mutate(cumulative_cases = cumsum(n))  #累積の新しい列
```

以下は、最初の10行です。

```{r}
head(cumulative_case_counts, 10)
```

　エピカーブで累積罹患率をプロットする方法については、[Epidemic curves](https://epirhandbook.com/en/epidemic-curves.html#epidemic-curves) のページを参照してください。

関連項目： `cumsum()`, `cummean()`,`cummin()`, `cummax()`, `cumany()`, `cumall()`

### **base** R**の使い方** {.unnumbered}

**base** Rを使って新しい列を定義する（または列を再定義する）。新しい列（または修正する列）にデータフレームの名前を\$でつないで書きます。代入演算子`<-`を使って新しい値を定義します。**base** R を使用する際には、毎回、列名の前にデータフレーム名を指定しなければならないことを覚えておいてください（例：dataframe\$column ）。ここでは、**base** R を使って`bmi`カラムを作成する例を示します。

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### **パイプチェーンへの追加** {.unnumbered}

**以下では、パイプチェーンに新しい列を追加し、いくつかの型を変換しています。**

```{r }
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプチェーンのクリーニング開始
###########################
linelist <- linelist_raw %>%
    
　　# 列カラム名の構文の標準化
    janitor::clean_names() %>% 
    
     #手動で列名を変更

     　　　#　新しい列名　　　　　　#既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    

　　#　列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
　　#重複削除
    distinct() %>% 
  
    #  上記は、すでに説明した上流側のクリーニング手順
    ###################################################
　　#新しい列の追加
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
　　#列の型を変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## **値の再定義**

値を再定義（変更）する必要があるいくつかの方法があります。

-   特定の値を編集する場合（例：日付の年号や書式が間違っている場合など）。

-   同じ綴りでない値を調整する場合。

-   カテゴリー値の新しい列を作成する場合。

-   数値カテゴリーの新しい列を作成する（例：年齢カテゴリー）。

### **特定の値** {.unnumbered}

　値を手動で変更するには、`mutate()`関数の中の`recode()`関数を使用します。

　データの中に意味のない日付（例："2014-14-15"）があるとします。未加工のソースデータの中で手動で日付を修正することもできますし、`mutate()`と `recode()`を介してクリーニングパイプラインに変更を書き込むこともできます。後者の方がより透明性が高く、分析を理解しようとする他者や同じように分析しようとする人にとって再現性があります。

```{r, eval=F}
#不正な値の修正　　　　　　　　　　　　　　#既存の値　　　　　#新しい値
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

　上記の`mutate()`の行は、次のように読むことができます。OLD VALUE が NEW VALUE に変更されるように再定義された列 `date_onset`と同じになるように列date_onsetを変異させる "と読めます。`recode()`のこのパターン(OLD = NEW)は、ほとんどのRのパターン(new = old)とは逆であることに注意してください。Rの開発コミュニティでは、この点の修正に取り組んでいます。

**ここでは、1つの列の中の複数の値を再定義する別の例を紹介します。**

`linelist`では、列 "hospital "の値をクリーンアップする必要があります。いくつかの異なる記載があり、多くの欠損値があります。

```{r}
table(linelist$hospital, useNA = "always")  
 # 欠損値を含むすべてのユニークな値のテーブルを表示。
```

　以下の`recode()`コマンドは、列 "hospital "を現在の列 "hospital "として再定義しますが、指定されたrecodeの変更があります。それぞれの後にカンマを忘れないでください。

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # 参照　　　　: 既存 = 新
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

　現在、 `hospital`のスペルが修正され、統合されているのがわかります。

```{r}
table(linelist$hospital, useNA = "always")
```

[**ヒント**：等号の前後のスペースの数は関係ありません。コードを読みやすくするために、すべての行またはほとんどの行で = を揃えてください。また、ハッシュ化されたコメント行を追加して、どちらが古いか、どちらが新しいかを将来の読み手に明確にすることも検討してください。]{style="color: darkgreen;"}

[**ヒント**：データセットの中に空白文字の値が存在することがあります（R の missing の値である NA として認識されません）。この値を参照するには、スペースを空けずに2つのクォーテーションマーク（""）を使用します。]{style="color: darkgreen;"}

### **論理条件** {.unnumbered}

以下では、論理条件と条件を使って列の値を再定義する方法を示します。

-   単純な論理条件には`replace()`、`ifelse()`、`if_else()`を使う

-   より複雑な論理条件には`case_when()`を使う

### **シンプルな論理条件** {.unnumbered}

#### `replace()` {.unnumbered}

`replace()`は**base** Rの関数で、論理条件を使って変更する行を指定します。一般的な構文は次のとおりです。

`mutate(col_to_change = replace(col_to_change, criteria for rows, new value))`です。

`replace()`を使用する一般的な状況としては、一意の行識別子を使用して、1つの行の1つの値だけを変更する場合です。下の例では、`case_id`が "2195 "である行で、性別を "Female "に変更しています。

```{r, eval=F}
# 例：ある特定の観測データの性別を "Female "に変更する。
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

　Rの基本的な構文と索引括弧[ ]を使った同等のコマンドは以下の通りです。データフレームの `linelist`の列 `gender`の値を（`linelist`の列 `case_id`の値が'2195'である行について）'Female'に変更する"と読めます。

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` and `if_else()` {.unnumbered}

　 簡潔な論理条件のためのツールとして、`ifelse()`とそのパートナーである`if_else()`があります。しかし、ほとんどの場合、再定義のためには`case_when()`（以下に詳述）を使ったほうがわかりやすいでしょう。これらの"if else"コマンドは、`if`と`else`のプログラミング文を簡略化したものです。一般的な構文は次のとおりです： `ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)`

　下の例では、`source_known`という列が定義されています。ある行の列 `source`の値が欠損していなければ、その値は "known" に設定されます。sourceの値が欠落している場合、`source_known`の値は "unknown " に設定されます。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

`if_else()`は、日付を扱う **dplyr** の特別バージョンです。真の値が日付の場合、"偽"の値も日付でなければならないことに注意してください。そのため、単に NA ではなく NA_real\_ という特別な値を使用しています。

```{r, eval=F}
#  患者が死亡していない場合はNAとなる死亡日列を作成。
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**ifelseコマンドをたくさん並べるのは避けましょう...**代わりに`case_when()`を使ってください！`case_when()`はずっと読みやすく、エラーも少なくなります。

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

　データフレーム以外で、コード内で使用するオブジェクトの値を切り替えたい場合は、**base** R の`switch()`の使用を検討してください。

### **複雑な論理条件** {#clean_case_when .unnumbered}

　多数の新しいグループに再定義する場合や、複雑な論理条件文を使って値を再定義する必要がある場合は、**dplyr** の `case_when()`を使用します。この関数は、データフレーム内のすべての行を計算し、その行が指定された基準を満たしているかどうかを評価して、正しい新しい値を割り当てます。

`case_when()`コマンドは、右手側(RHS)と左手側(LHS)を"チルダ"～で区切ったステートメントで構成されています。各ステートメントの左側には論理条件が、右側には準拠値が記述されています。ステートメントはコンマで区切られています。

例えば、ここでは`age`と`age_unit`の列を利用して`age_years`の列を作成しています。

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # 年齢が年単位の場合
            age_unit == "months" ~ age/12,    # 年齢が月単位の場合
            is.na(age_unit)      ~ age,       #年齢の単位が見つからない場合は、年を仮定
            TRUE                 ~ NA_real_)) #その他の状況では、不足分を割り当る。
```

　データの各行が計算されるとき、基準は `case_when()`ステートメントが書かれた順に、上から下へと適用/評価されます。ある行で一番上の基準が `TRUE`と評価された場合、RHSの値が割り当てられ、残りの基準はその行では確認されません。したがって、最も明確な基準を最初に書き、最も一般的な基準を最後に書くのがよいでしょう。

　このようにして、最後の文では、左側に`TRUE`を置くことで、前の基準のどれにも当てはまらない行を捕捉することができます。この文の右側には、 "check me!" や missing のような値を割り当てることができます。

[要注意：右辺のVvalues はすべて同じクラスでなければなりません。欠落（NA）を割り当てるには、`NA_character_`、`NA_real_`（数値やPOSIXの場合）、`as.Date(NA)`など、NAの特別なバリエーションを使用する必要があるかもしれません。詳しくは[Working with dates](https://epirhandbook.com/en/working-with-dates.html#working-with-dates-1)をご覧ください]{style="color: red;"}

### **欠損値** {.unnumbered}

　以下は、データクリーニングの観点から欠損値を処理するための特別な関数です。

　欠損値の識別と処理に関するより詳細なヒントは、[Missing data](https://epirhandbook.com/en/missing-data.html#missing-data) のページを参照してください。例えば、論理的に欠損をテストする`is.na()`関数などです。

**`replace_na()`**

欠損値（NA）を"Missing"などの特定の値に変更するには、`mutate()`内の**dply**r関数`replace_na()`を使用します。これは、上記の`recode`と同じ方法で使用されることに注意してください 。変数の名前は`replace_na()`内で繰り返されなければなりません。

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

　これは、**forcats** パッケージの関数です。**forcats** パッケージはFactor型の列を扱います。ファクターは、`c("First", "Second", "Third")`のような順序付きの値を扱うためのRの方法であり、表やプロットに表示される値（病院など）の順序を設定します。[Factors](https://epirhandbook.com/en/factors.html#factors)のページを参照してください。

データがFactor型で、`replace_na()`を使ってNAを "Missing "に変換しようとすると、次のようなエラーが表示されます： `invalid factor level, NA generated.` 因子の可能なレベルとして定義されていない "Missing" を値として追加しようとしたため、拒否されます。

この問題を解決する最も簡単な方法は、forcats の関数`fct_explicit_na()`を使用することです。この関数は、列をFactor型に変換し、NA値を文字"(Missing)"に変換します。

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

　よりゆっくりとした方法としては、`fct_expand()`を用いてFactor型を追加し、その後、欠損値を変換する方法があります。

**`na_if()`**

　特定の値を NA に変換するには、**dplyr** の `na_if()`を使います。以下のコマンドは `replace_na()`の逆の操作を行います。以下の例では、列 `hospital` の "Missing" の値はすべて `NA`に変換されます。

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

　注意： `na_if()`は論理的条件（例：" "all values \> 99""）には使用できません。これには`replace()`または`case_when()`を使用してください。

```{r, eval=F}
#40以上の温度をNAに変換。 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# 2000年1月1日以前の発症日を欠損に変換する。
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### **クリーニング辞書**  {.unnumbered}

　Rパッケージ **linelist** とその関数 `clean_variable_spelling()`を使って、データフレームをクリーニング辞書でクリーニングします。 **linelis**t は[RECON](https://github.com/reconhub/linelist) - the R Epidemics Consortiumによって開発されたパッケージです。

1.  3つの列でクリーニング辞書を作成します。

-   from "カラム（不正な値）

-   to "カラム（正しい値）

-   変更を適用する列を指定する列（または、すべての列に適用する場合は".global"）。

注意：.globalの辞書項目は、列固有の辞書項目によって上書きされます。

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  この例題は、[Download handbook and data](https://epirhandbook.com/en/download-handbook-and-data.html#download-handbook-and-data)のページにある手順でダウンロードできます。

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  未加工のラインリストを `clean_variable_spelling()`に渡し、wordlists = クリーニング辞書データフレームに指定します。spelling_vars = 引数は、辞書のどの列を参照するかを指定するために使用することができます（デフォルトでは3番目）。また、辞書をすべてのcharactor列とfactor列に適用するためにNULLを設定することもできます。この関数の実行には時間がかかることに注意してください。

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        
     #列名を含むdict列、デフォルトではdictの3番目の列になる。
  )
```

　右側にスクロールすると、値がどのように変化したかがわかります。特に性別（小文字→大文字）や、すべての症状の列がYes/noから1/0に変化しています。

```{r message=FALSE, echo=F}
# ラインリストのデータを表として表示する
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

　クリーニング辞書の列名は、クリーニングスクリプトのこの時点での名前に対応していなければならないことに注意してください。詳細については、linelistパッケージの[online reference for the linelist package](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html)を参照してください。

#### パイプチェーンへの追加 {.unnumbered}

以下では、いくつかの新しい列と列変換がパイプチェーンに追加されています。

```{r}
#クリーニングパイプチェーン (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################

# パイプチェーンの処理開始
###########################
linelist <- linelist_raw %>%
    
 
     # 列名の構文の標準化
    janitor::clean_names() %>% 

     # 手動で列名を変更
           # 新しい列名             # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
     # 列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
　　#　重複除去
    distinct() %>% 
  
    # add column
　　#　列を追加
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

      # 列の型を変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
  
     
     # 列の追加: 入院の遅れ
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
     # 上記は、すでに説明した上流側のクリーニング方法です。
   ###################################################

　　# 病院の列の値をきれいにする。
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

       # age_yearsカラムの作成(from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## **数値カテゴリー** {#num_cats}

　ここでは、数値列からカテゴリを作成するための特別なアプローチを説明します。一般的な例としては、年齢のカテゴリー、検査値のグループなどがあります。ここでは、以下について説明します。

-   `age_categories()`( **epikit** パッケージより)

-   `cut()`, base Rより

-   `case_when(`)

-   `quantile()`と`ntile()`を使った分位値分割

**レビュー分布**

この例では、`age_years`列を使って`age_cat`列を作成します。

```{r}
#linelist変数ageの列をチェックする。
class(linelist$age_years)
```

　まず、データの分布を調べて、適切なカットポイントを作ります。[ggplot basics](https://epirhandbook.com/en/ggplot-basics.html#ggplot-basics) のページをご覧ください。

```{r, out.height='50%'}
# 分布を調べる。
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[**注意**：数値の変数型が"character"としてインポートされることがあります。これは、値の一部に数字以外の文字が含まれている場合に発生します。例えば、年齢を"2ヶ月"と入力した場合や、（Rのロケール設定にもよりますが）小数点以下の位置にコンマが使用されている場合などです（例："4.5"は4年半の意味）。]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

**epikit** パッケージでは、`age_categories()`関数を使って、数値列の分類やラベル付けを簡単に行うことができます（注：この関数は、年齢以外の数値変数にも適用できます）。その結果、出力される列は自動的に順序付けられたカテゴリーとなります。

必要な入力は以下の通りです。

-   数字のベクトル（列）

-   `breakers =` 引数 - 新しいグループのブレークポイントの数値ベクトルを提供する。

まず、最も簡単な例を示します。

```{r}
# Simple example
# 簡単な例
################
pacman::p_load(epikit)                    　#パッケージのロード

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             
         　　　　　　　　　　　　　　　　　# 新しい列の作成
      age_years,                            # グループを作るための数値列
      breakers = c(0, 5, 10, 15, 20,        # ブレークポイント
                   30, 40, 50, 60, 70)))

# テーブルを表示
table(linelist$age_cat, useNA = "always")
```

　指定したブレーク値は、デフォルトでは下限含めます。つまり、"上位"のグループに含まれ、グループが下/左に"開いて"いる状態になります。下図のように、各ブレーク値に1を加えることで、上/右で開いたグループにすることができます。

```{r}
# 同じカテゴリーの上端を含める
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

#　テーブルを表示
table(linelist$age_cat, useNA = "always")
```

`separator =` で、ラベルの表示方法を調整できます。 デフォルトは "-" です。

`ceiling =`で、上位の数字の扱い方を調整できます。上限値を設定するには `ceiling = TRUE` とします。この使用方法では、提供された最も高いブレーク値は"上限"であり、カテゴリー"XX+"は作成されません。ブレーク値の上限（または定義されている場合は上限＝）を超える値は、`NA`に分類されます。以下は、`ceiling = TRUE`の例で、XX+のカテゴリーはなく、70（最も高いブレーク値）を超える値は`NA`として割り当てられます。

```{r}
# 上限をTRUEに設定した場合
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 is ceiling, all above become NA

# テーブルを表示
table(linelist$age_cat, useNA = "always")
```

また、`breakers＝`の代わりに、`lower＝`、`upper＝`、`by＝`のすべてを指定することもできます。

-   `lower =`考慮したい最低の数値 - デフォルトは0

-   `upper =`考慮したい最も高い数値

-   `by =`グループ間の年の数

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# テーブルの表示
table(linelist$age_cat, useNA = "always")
```

詳細は、この関数のヘルプページをご覧ください（Rコンソールで`?age_categories`と入力してください）。

<!-- ======================================================= -->

### `cut()` {.unnumbered}

`cut()`は`age_categories()`に代わる R のベースとなるものですが、この処理を簡単にするために `age_categories()`が開発された理由がわかります。`age_categories()`との注目すべき違いは以下のとおりです。

-   別のパッケージをインストール/ロードする必要がない。

-   グループが右か左に開いているか閉じているかを指定できる。

-   正確なラベルを自分で用意する必要がある。

-   一番下のグループに"0"を入れたい場合は、このように指定する必要がある。

`cut()`の基本的な構文は、まずカットしたい数値列 `(age_years)`を指定し、次に breaks の引数として分割ポイントの数値ベクトル`c()`を指定します。`cut()`を使用すると、結果として列は順序付けられたカテゴリーとなります。

　デフォルトでは、右/上側が"オープン"で包括的（左/下側が"クローズ"で排他的）になるように分類されます。これは、`age_categories()`関数とは逆の動作です。デフォルトのラベルでは"(A, B] "という表記が使われていますが、これは"Aは含まれないがBは含まれる"という意味です。`right = TRUE`という引数を与えることで、この動作を逆にします。したがって、デフォルトでは、"0 "の値は低いグループから除外され、`NA`に分類されます。"0 "の値は、乳幼児が0歳としてコード化される可能性があるので、注意が必要です。これを変更するには、引数 `include.latest = TRUE`を追加して、"0 "の値が最低グループに含まれるようにします。この場合、自動的に作成される低いカテゴリーのラベルは "[A],B]" となります。なお、`include.latest = TRUE`を指定し、かつ`right = TRUE`を指定した場合、含まれるのは最低値ではなく最高値の分割ポイント値とカテゴリーに適用されます。

`labels =` 引数を使って、カスタマイズされたラベルのベクトルを提供することができます。これらは手作業で書かれているので、正確さには十分注意してください。後述するように、クロス集計を用いて作業を確認してください。

`age_years`に`cut()`を適用して、新しい変数`age_cat`を作成した例を以下に示します。

```{r}
# 年齢という数字の変数を切り取って新しい変数を作る。
# 下限値のブレイクは除外されるが、上限のブレイクは各カテゴリーに含まれる。
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         
      ))　　　　　　　　　　　　　　# 一番下のグループに0を入れる。

# グループごとの観測値の数を集計。
table(linelist$age_cat, useNA = "always")
```

　**作業を確認してください!!!** 数値列とカテゴリー列をクロス集計して、各年齢値が正しいカテゴリーに割り当てられていることを確認します。境界値の割り当てを検証します（例：隣接するカテゴリーが 10-15 と 16-20 の場合、15の値）。

```{r}
# 数値列とカテゴリー列のクロス集計。
table("Numeric Values" = linelist$age_years,   clarity.　　　　　　　
      # 分かりやすくするために、表の中に名前を入れる。
      "Categories"     = linelist$age_cat,
      useNA = "always")                       # NA値の検証を忘れずに
```

`NA`値の再ラベル付け

`NA`値に "Missing "などのラベルを付けたい場合があります。新しい列はFactor型(制限付き値)なので、この値は拒否されるので、単純に`replace_na()`で変異させることはできません。代わりに、[Factors](https://epirhandbook.com/en/factors.html#factors) ページで説明されているように、`forcats`の `fct_explicit_na()`を使用してください。

```{r}
linelist <- linelist %>% 
  
   # cut()すると、Factor型スのage_catが自動的に作成される。 
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # 欠損値を明示する
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  
  )    # ラベルを指定することができる。

# テーブルからビューカウント
table(linelist$age_cat, useNA = "always")
```

**切れ目やラベルを素早く作る**

　ベクトルの改行やラベルを素早く作成するには、以下のような方法があります。`seq()`や`rep()`については、[basics](https://epirhandbook.com/en/r-basics.html#r-basics) のページを参照してください。

```{r, eval=F}
# 0から90までのブレークポイントを5で割る。
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# デフォルトのcut()の設定を前提に、上記のカテゴリのラベルを作成する。
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# 両方のベクトルが同じ長さであることを確認する。
length(age_seq) == length(age_labels)
```

`cut()`の詳細については、Rコンソールで`?cut`と入力して、ヘルプページを参照してください。

**分位値ブレーク**

　一般的な理解では、"クォンタイル"または"パーセンタイル"は、通常、値の割合が下になる値を指します。例えば、`linelist`の年齢の95パーセンタイルは、年齢の95%が該当する年齢になります。

しかし、一般的には、"4分位値"や"10分位値"は、データのグループを4つまたは10のグループに均等に分けたものを指すことがあります（グループよりも分割ポイントが1つ多いことに注意してください）。

　分位点を取得するには、Rの基本パッケージである **stats** の `quantile()`を使用します。データセットの列などの数値ベクトルと、0から1.0までの確率の数値ベクトルを指定します。分割ポイントは、数値ベクトルとして返されます。`?quantile`を入力すると、統計的手法の詳細を調べることができます。

入力された数値ベクトルに欠損値がある場合は、`na.rm = TRUE` を設定することをお勧めします。

`names = FALSE`を設定すると、名前のない数値ベクトルが得られます。

```{r}
quantile(linelist$age_years,           　　# 演算する数値ベクトルを指定。
  probs = c(0, .25, .50, .75, .90, .95),  # 欲しいパーセンタイルを指定。
  na.rm = TRUE)                         　# 欠損値を無視する。 
```

`quantile()`の結果は、`age_categories()`や`cut()`の分割ポイントとして使用できます。以下では、`cut()`を使って新しい列`deciles`を作成し、`age_years`に対して`quantiles()`を使って区切りを定義しています。**janitor**の`tabyl()`を使って結果を表示し、パーセンテージを見ることができます（[Descriptive tables](https://epirhandbook.com/en/descriptive-tables.html#descriptive-tables) ページを参照）。各グループで正確に10%ではないことに注意してください。

```{r}
linelist %>%                              #linelistから開始。
  mutate(deciles = cut(age_years,        # 新しい列を作る。 age_years列をcut()でdecileに格納。
    breaks = quantile(                   # quantile()を使ってカットオフを定義する。
      age_years,                         # age_yearsの操作。
      probs = seq(0, 1, by = 0.1),       # 0.0から1.0へ0.1倍。
      na.rm = TRUE),                  　 # 欠損値を無視する
    include.lowest = TRUE)) %>%          # cut()でage 0を含む。
  janitor::tabyl(deciles)                # 表示するテーブルへのパイプ。
```

### **均等な大きさのグループ** {.unnumbered}

　数値グループを作成するもう1つのツールは、**dplyr** の関数 `ntile()`で、データをn個の均等な大きさのグループに分けようとします。数値ベクトルとグループの数を指定します。作成される新しい列の値は、グループの"番号"（例：1から10）だけで、`cut()`を使ったときのように値の範囲そのものではありません。

```{r}
# ntile()でグループを作る。
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# グループ別の数と割合の表を作る。
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# 範囲を示すために最小値と最大値を添付する。
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# 結合して表示 - 値が複数のグループに存在することに注意。
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

**dplyr**の関数 `case_when()`を使って数値列からカテゴリを作成することは可能ですが、**epikit** の`age_categories()`や`cut()`を使った方が、自動的に順序付けられた要素を作成してくれるので、より簡単です。

`case_when()`を使用する場合は、このページの"値の再定義"で前述した適切な使用方法を確認してください。また、すべての右辺の値は同じクラスでなければならないことに注意してください。したがって、右辺の値を`NA`にしたい場合は、"Missing "と書くか、特別な`NA`値`NA_character_`を使用する必要があります。

**パイプチェーンへの追加**

以下では、2つのカテゴリー化された年齢列を作成するコードを、クリーニング・パイプ・チェーンに追加しています。

```{r}
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプチェーンのクリーニング開始
###########################
linelist <- linelist_raw %>%
    
    #列名の構文の標準化
    janitor::clean_names() %>% 

     
     # 手動で列名を変更
           # 新しい列名             # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
     # 列を削除
    select(-c(row_num, merged_header, x28)) %>% 
  
     # 重複除去
    distinct() %>% 

     # 列の追加
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
     # 列の型を変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
     # 列の追加:入院の遅延
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
     # 病院の列の値をきれいにする
    mutate(hospital = recode(hospital,
                      　　　　　　　# 既存 = 新
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

     # age_yearsカラムの作成（from age and age_unit）
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 

     # 上記は、すでに説明した上流側のクリーニング方法です
    ###################################################   
    mutate(
         # 年齢別カテゴリー: 慣習
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # 年齢カテゴリー 0～85歳までの5段階
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## **列の追加**

**一行ずつ**

　手作業で一行ずつ追加するのは面倒ですが、**dplyr** の `add_row()`を使えば可能です。各列は1つの型（factor型、numeric型、logic型など）の値のみを含む必要があることを覚えておいてください。そのため、行の追加にはこれを維持するための微妙な差異が必要です。

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

`.before`と`.after.`を使って、追加したい行の配置を指定します。`.before = 3`は、新しい行を現在の3行目の前に配置します。デフォルトの動作では、行を最後に追加します。指定されていない列は空欄（NA）になります。

　新しい行番号は奇妙に見えるかもしれませんが（"...23"）、既存の行の行番号は変更されています。そのため、このコマンドを2回使用する場合は、挿入を慎重に検討/テストしてください。

用意したクラスが外れている場合は、以下のようなエラーが表示されます。

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(日付の値を持つ行を挿入する際には、as.Date("2020-10-10")のようにas.Date()という関数で日付を囲うことを忘れないでください)。

**行の結合**

あるデータフレームの行を別のデータフレームの下部に結合してデータセットを結合するには、**dplyr**の `bind_rows()`を使用します。これについては、[Joining data](https://epirhandbook.com/en/joining-data.html#joining-data) のページで詳しく説明しています。

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## **行のフィルタリング**

　列を整理し、値を再定義した後の典型的なクリーニングステップは、**dplyr**の動詞 `filter()`を使ってデータフレームの特定の行をフィルタリングすることです。

`filter()`では、データセット内のある行を抜き出すために`TRUE`でなければならない論理を指定します。以下では、単純な論理条件と複雑な論理条件に基づいて行をフィルタリングする方法を示します。

<!-- ======================================================= -->

### **単純なフィルタ** {.unnumbered}

　この単純な例では、論理的な条件を満たすように行をフィルタリングした上で、データフレームのラインリストを自分自身として再定義します。括弧内の論理条件が評価されて`TRUE`となる行のみが保持されます。

この例では、論理条件は`gender == "f "`で、列`gender`の値が`"f "`に等しいかどうかを問いています（大文字小文字を区別します）。

フィルタを適用する前の `linelist`の行数は `nrow(linelist)`です。

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # 性別が "f "である行だけを残す。
```

フィルタを適用した後の `linelist`の行数は`linelist %>% filter(gender == "f") %>% nrow()` となります。

### **欠損値のフィルタリング** {.unnumbered}

　欠損値のある行をフィルタリングしたいというのはよくあることです。`filter(!is.na(column) & !is.na(column))`と書きたい気持ちを抑えて、代わりにこの目的のためにカスタマイズされた **tidyr** の関数、`drop_na()`を使いましょう。空の括弧をつけて実行すると、欠損値のある行を削除します。あるいは、欠落を評価する特定の列の名前を指定したり、[上述の](https://epirhandbook.com/en/cleaning-data-and-core-functions.html#clean_tidyselect)"tidyselect "ヘルパー関数を使用することもできます。

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  
# case_idやage_yearsの値が欠損している行を削除する。
```

　データの欠落を分析・管理するための多くのテクニックについては、[Missing data](https://epirhandbook.com/en/missing-data.html#missing-data) のページをご覧ください。

### **行番号によるフィルタリング** {.unnumbered}

　データフレームや Tibble では、各行には通常"行番号"があり、R Viewerで見ると最初の列の左側に表示されます。これは、それ自体はデータの真の列ではありませんが、`filter()`のステートメントで使用することができます。

"行番号"に基づいてフィルタリングするには、論理的なフィルタリング文の一部として、**dplyr**の関数`row_number()`を開いた括弧で囲んで使用します。多くの場合、以下のように、論理的なステートメントの一部として、`%in%`演算子と数値の範囲を使用します。最初のN行を表示するには、特別な **dplyr** 関数 `head()`を使用することもできます。

```{r, eval=F}
# 最初の100行を表示。
linelist %>% head(100)     
# またはtail()を使って最後のn行を見る。

# 5列目のみ表示。
linelist %>% filter(row_number() == 5)

# 2行目から20行目までと、3つの特定の列を見る。
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

また、データフレームを tibble関数 `rownames_to_column()`にパイプすることで、行番号を真の列に変換することができます（括弧の中には何も入れないでください）。

<!-- ======================================================= -->

### **複雑なフィルタ** {.unnumbered}

　括弧（`）`、OR`｜`、ネゲート`！`、`％in％`、AND`＆`の各演算子を使って、より複雑な論理条件を作ることができます。その例を以下に示します。

注： 論理的条件の前に`!` 演算子を使うと、それを否定することができます。例えば、`！is.na(column)`は、列の値が欠損していない場合に真と評価されます。同様に、`！column %in% c("a", "b", "c")`は、列の値がベクトルに含まれていない場合に真と評価されます。

#### **データを調べる** {.unnumbered}

　以下は、発症日のヒストグラムを作成するためのシンプルな1のコマンドです。2012～2013年に発生した2つ目の小規模なアウトブレイクもこの未加工データセットに含まれていることがわかります。今回の分析では、この初期アウトブレイクを削除したいと思います。

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

**数値や日付の欠損をフィルターで処理する方法**

　date_onsetで2013年6月以降の行をフィルタリングすることはできるでしょうか。注意してください。`filter(date_onset > as.Date("2013-06-01")))`というコードを適用すると、発症日が欠落している後期流行の行がすべて削除されてしまいます!

[要注意：日付や数値の"大"（\>）または"小"（\<）にフィルタリングすると、欠損値（NA）のある行が削除されてしまいます。これは、NAが無限に大きい、または小さいものとして扱われるためです。]{style="color: red;"}

(日付とパッケージ**lubridate**を使った作業については、[*Working with dates*](https://epirhandbook.com/en/working-with-dates.html#working-with-dates-1)のページを参照してください）。

#### フィルターの設計 {.unnumbered}

　クロス集計を見て、正しい行だけを除外していることを確認して下さい。

```{r}
table(Hospital  = linelist$hospital,                     #病院名
      YearOnset = lubridate::year(linelist$date_onset),  #発症した年
      useNA     = "always")                              #欠損値の表示
```

　データセットから最初の発生（2012年と2013年）を除外するために、他にどのような基準でフィルタリングできるでしょうか。次のことがわかりました。

-   2012年と2013年に発生した最初の流行は、A病院とB病院で発生し、ポート病院でも10件の症例がいます。

-   2回目の流行では、A病院とB病院には患者がいませんでしたが、ポート病院には患者がいました。

除外したい項目：

-   病院A、B、Portのいずれかで2012年と2013年に発症した`nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))` の行。

-   2012年および2013年に発症した`nrow(linelist %>% filter(date_onset < as.Date("2013-06-01"))` の行。

-   `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`発症日が欠落している病院AおよびBの行。

-   `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))`発症日が見つからない他の行。

nrow(linelist)\`のラインリストを用意から始めます。これがフィルター文です。

```{r}
linelist <- linelist %>% 
 # 発症日が2013年6月1日以降の行、または発症日が不明でA病院またはB病院以外の病院であった行を残す。
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

　クロス集計を作り直すと、A病院とB病院が完全に取り除かれ、2012年と2013年の港区の病院の10件が取り除かれ、その他の値はすべて同じになっていることがわかります。

```{r}
table(Hospital  = linelist$hospital,                     # 病院名
      YearOnset = lubridate::year(linelist$date_onset),  # 発症した年
      useNA     = "always")                              # 欠損値の表示
```

　複数のステートメントを1つのfilterコマンドの中に含めることができます（カンマで区切ってください）。また、分かりやすくするために、常に別のfilter()コマンドにパイプすることもできます。

注：読者の中には、`date_hospitalisation`でフィルタリングする方が簡単だと思われる方もいるかもしれません。これは事実です。しかし、`date_onset`は複雑なフィルタを実際に見せる目的で使用されています。

### 独立型 {.unnumbered}

　フィルタリングは、（パイプチェーンの一部ではなく）独立したコマンドとしても実行できます。他の`dplyr`の動詞と同様に、この場合、第1引数はデータセットそのものでなければなりません。

```{r, eval=F}
# dataframe <- filter(dataframe, condition(s) for rows to keep)

linelist <- filter(linelist, !is.na(case_id))
```

**base** Rを使って、保持したい[行、列]を反映した角括弧を使ってサブセットすることもできます。

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### **レコードを素早く確認** {.unnumbered}

　数列だけのレコードを素早く確認したいことがよくあります。R の基本関数である `View()`は、RStudio で表示できるようにデータフレームを表示します。

RStudio でラインリストを表示します。

```{r, eval=F}
View(linelist)
```

特定のセル（特定の行、特定の列）を表示する2つの例を紹介します。

**dplyrの関数**`filter()`と`select()`を使用します。

`View()`の中で、データセットを　`filter()`にパイプして特定の行を残し、`select()`にパイプして特定の列を残します。例えば、3つの特定のケースの発症日と入院日を確認する場合です。

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

Rの基本的な構文でも同じことができ、見たいサブセットには[ ]を使ってください。

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

パイプチェーンに追加

```{r}
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプチェーンのクリーニング開始
###########################
linelist <- linelist_raw %>%
    
     #列名構文の標準化
    janitor::clean_names() %>% 
    
    # 手動で列名を変更
           #新しい列名            　　# 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # 列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
    # 重複除去
    distinct() %>% 

    # 列を追加する
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # 列のクラスを変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # 列の追加: 入院までの時間
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
     # 病院列の値を整える
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
      # age_years 列を作成 (ageとage_unit列から)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    mutate(
         # 年齢別カテゴリー: 慣例
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
　　　# 年齢カテゴリー 0～85歳までの5段階
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))%>% 
    
      # 上記は既に説明した上流側のクリーニング方法です。
   
    ###################################################
    filter(
         # case_idが欠落していない行のみを残す
          !is.na(case_id),  
          
           #2回目の感染発生分だけを残すようにフィルターをかける
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## **行単位の計算**

　行内で計算を行いたい場合は、**dplyr** の`rowwise()`を利用することができます。例えば、このコードでは `rowwise()`を適用し、行リストの各行について、値が"はい"である指定された症状の列の数を合計する新しい列を作成しています。`rowwise()`は本質的に特別な種類の `group_by()`であるため、終わったら `ungroup()を`使うのがベストです（ [Grouping data](https://epirhandbook.com/en/grouping-data.html#grouping-data) ページを参照）。

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # 表示のため
```

　評価する列を指定する際に、このページの `select()`セクションで説明されている "tidyselect" ヘルパー関数を使用したいと思うかもしれません。1つだけ調整が必要です（ `select()`や `summarise()`のような dplyr関数内で使用していないため）。

　列指定の基準を **dply**r 関数の`c_across()`の中に入れます。これは、`c_across（`[documentation](https://dplyr.tidyverse.org/reference/c_across.html)`）`が、特に`rowwise()`と連動するように設計されているからです。例えば、次のようなコードです。

-   `rowwise()`を適用して、各行の中で以下の演算(`sum()`)が適用されます(列全体の合計ではありません)。

-   新しい列 `num_NA_dates` を作成します。これは、各行について、`is.na()` が TRUE と評価された列 (名前が "date" を含むもの) の数として定義されます (これらはデータが欠損しています)。

-   `ungroup()`により、後続のステップで `rowwise()`の影響を取り除きます。

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # for display
```

また、max() のような他の関数を用意して、各行の最新または直近の日付を取得することもできます。

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # for display
```

## **アレンジとソート**

**dplyr**の関数 `arrange()`を使って、列の値で行を並べ替えたり、順番に並べたりします。

　単純に、ソートされるべき順に列を列挙します。データに適用されたグループ化によって最初にソートを行いたい場合は、`.by_group = TRUE` を指定します（ [Grouping data](https://epirhandbook.com/en/grouping-data.html#grouping-data) のページを参照）。

デフォルトでは、列は "昇順 "でソートされます（これは、数字や文字の列にも適用されます）。変数を`desc()`で囲むと、"降順"でソートできます。

`arrange()`によるデータのソートは、[プレゼンテーション用のテーブル]を作成するときや、`slice()`を使ってグループごとに"上位"の行を取り出すとき、あるいはファクタレベルの順序を出現順に設定するときなどに特に便利です。

例えば、linelistの行を病院別にソートし、次にdate_onsetで降順にソートするには、次のようにします。

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# HIDDEN
#
# 残りの既存の感染発生行を簡単にmissingに変換します。
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# エクスポート用に列を再配置
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}

# クリーニングされたラインリストファイルを "data "フォルダにエクスポートする
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"))
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
