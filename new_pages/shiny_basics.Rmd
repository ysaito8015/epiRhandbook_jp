
# Shiny で作るダッシュボード {#shiny-basics}  

ダッシュボードは多くの場合、他の人と分析の結果を共有する場合に非常に良い方法です。**Shiny** を利用してダッシュボードを作成することは、R 言語について、比較的高度な知識が必要ですが、大いなる可能性と自由を与えてくれます。

<!-- One of the largest drawbacks of `R` is its usability for people who are new to or have no experience with programming languages. While these skills are very valuable, most people will find that this represents a barrier to sharing analyses, especially in multidisciplinary environments. It requires some work to maintain an `R` installation, and not everyone will be comfortable running shared code, even if it's well documented and easy to read. This is *especially* true when users have to change parameters of code!  -->

<!-- R based dashboards are also advantageous in that they centralise how code is run - when the same code is run on different machines, often people will have to deal with differing file paths, different R versions, and different package installations. For this reason, dashboards are a great way to share code with others in a user friendly way! -->

**Shiny** によるダッシュボードについて学ぶ人は、データの加工と可視化についてある程度理解していることが必要です。また、コードのデバッグや関数を書くことについても慣れている必要があります。ダッシュボードの作成は、最初は分かりにくく、ときに理解することが難しいでしょう。しかし、このスキルは学ぶ価値のあるもので、習熟とともに簡単になっていきます！

このページでは、**shiny** とその拡張によるダッシュボード作成について短く概要をお伝えします。
別の速く簡単で、しかし自由度は低い方法でのダッシュボード作成方法については **flextable** のページ([R Markdownで作るダッシュボード](#flexdashboard))を参考にしてください。  



## 準備  


### パッケージの読み込み {.unnumbered}  

このハンドブックでは、**pacman** パッケージの `p_load()`を利用します。これは、パッケージのインストールが必要であればインストールしてくれて、<ul>かつ</ul>使えるように読み込んでくれます。あるいは、**base**の`library()`を利用してインストールされたパッケージを読み込んでもよいでしょう。より詳しくは[Rの基礎](#basics)のページを確認してください。

まずは、R パッケージの **shiny** をインストールするところからはじめていきます：

```{r, eval = FALSE}
pacman::p_load("shiny")
```


### データのインポート {.unnumbered}  

もしあなたがこのページのコードを追いたいのであれば[ハンドブックとデータのダウンロード](#data_shiny)を見てください。そこには最終的な Shiny アプリを作成するための R のスクリプトとデータファイルへのリンクがあります。  

これらのファイルを利用してアプリを再現したい場合は、R のプロジェクトがあるフォルダ構造が解説のなかでどのように作成されたかについて注意してください（例 "data" フォルダや "funcs" フォルダ）。



<!-- ======================================================= -->
## Shiny アプリの構造 {  }

### 基本的なファイル構造 {.unnumbered}  

`shiny` について理解するためには、まずアプリのファイル構造をどのようにすればうごくかを理解するひつようがあります！まず、真新しいディレクトリを作るところからはじめる必要があります。これは、<ul>R Studio</ul>で、<ul>New Project</ul>を選び、<ul>Shiny Web Application</ul>を選択することで簡単に作成できます。この操作で、 shiny アプリの基本的な構造が作成されます。

このプロジェクトをひらくと、すでに<ul>app.R</ul>という名前の `.R` ファイルが作成されています。次の二つのうちのいずれか一つのファイル構造をとることが<ul>ul</ul>必須です：

1. 一つのファイルが _app.R_、という名前をもつ *あるいは*  
2. 二つのファイルのうち一つが _ui.R_ でもう一つが _server.R_ という名前をもつ  

このページでは、*app.R* という名前をつける一つ目の方法を利用します。次が例となるスクリプトです：

```{r, eval = FALSE}
# app.R の例

library(shiny)

ui <- fluidPage(

    # アプリのタイトル
    titlePanel("My app"),

    # スライダーインプットウィジェットを含むサイドバー
    sidebarLayout(
        sidebarPanel(
            sliderInput("input_1")
        ),

        # グラフを表示する
        mainPanel(
           plotOutput("my_plot")
        )
    )
)

# ヒストグラムを描画するためのサーバー関数ロジックを定義
server <- function(input, output) {
     
     plot_1 <- reactive({
          plot_func(param = input_1)
     })
     
    output$my_plot <- renderPlot({
       plot_1()
    })
}


# アプリを走らせる
shinyApp(ui = ui, server = server)


```


ファイルを開くと、二つのオブジェクトが定義されています - 一つは `ui` でもう一つは `server` です。これらのオブジェクトは<u>全ての</ul> shiny アプリで定義される必要があり、アプリそのものの中心的な構造体です！実際には、上で説明した二つのファイル構造の違いは、構造 1 では、`ui` と `server` が一つのファイルで定義されているのに対して、構造 2 では別々のファイルで定義されているだけです。注意：他の .R ファイルを `source()` を利用してアプリで利用することも可能です（これは大きなアプリでは必須となります）。



### server と ui {.unnumbered}

次に、実際に `server` と `ui` オブジェクトが何を<ul>する</ul>かを理解しなければなりません。<ul>単純に説明するなら、shiny アプリをユーザーが操作すると、常に二つのオブジェクトが互いに影響しあう状態となります。</ul>

Shiny アプリの UI 要素は、基本的なレベルにおいては、HTML インターフェイスを作る R のコードです。これは、アプリの UI に<ul>表示</ul>されているものすべてです。これは、一般的に次のようなものを含みます：

* 「ウィジェット」 - ドロップダウンメニュー、チェックボックス、スライダーなどユーザーが操作できるもの
* 図、表など - R のコードで作成できる出力
* アプリのナビゲーションに関する要素 - タブ、ペーンなど 
* テキスト、ハイパーリンクなど
* HTML と CSS 要素 (後に解説します)

UI において最も大切なことは、UI は入力をユーザーから<ul>受け</ul>、サーバー関数から出力を受け取り<ul>表示する</ul>ということです。<ul>どのような時<ul>でも、コードが ui のなかで<ul>能動的</ul>に動くことはありません。UI における全ての変化は（多かれ少なかれ）サーバー関数を経由したものです。そのため、図の表示やダウンロードなどの処理はサーバー関数の中で行わなければなりません。

Shiny アプリのサーバー関数はアプリが立ち上がれば、すべてのコードが実行される場所となります。この挙動は少し混乱しやすいです。サーバー関数は効果的に UI のユーザーインターフェースに対して<ul>react</ul>（反応）し、対応してコードの塊を実行します。もしサーバー関数内でなにかが変われば、その変化は ui に再度渡され、その変化が目に見える形になります。大切なのは、サーバー関数内のコードが<u>非連続的</ul>に実行される（と考えておくことが良いでしょう）という点です。 基本は、ui がサーバー関数内のコードの塊に影響を与えた場合は常に、自動的にそのコードが実行されて、出力が作成・表示されます。

この一連の動作は、今は難解に聞こえると思います。なので、これが実際にどのように動くかをいくつか例を体験して明快にしましょう。


### アプリを作成する前に {.unnumbered}

アプリを作る前に、<ul>何</ul>を作りたいかを知ることはとても助けになります。あなたが作る UI はコードで書かれるため、何か具体的なものを狙って作成しなければ、何を作っているかを可視化することができません。このような理由から、何が Shiny アプリとして作れるか、沢山の例を見てのアイデアを得ておくことは非常に有効です。もし、それらのアプリのソースコードを見ることができればもっと良いでしょう！この目的のための素晴らしいリソースは次のリンクにあります：

* [Rstudio アプリギャラリー](https://shiny.rstudio.com/gallery/)  

どんなことができるかのイメージを持つことができれば、どのような見た目のアプリを作りたいかを描いてみることも助けになります。 - これは、紙に書いても、絵を描くソフトを利用してもよいでしょう (パワーポイント、 MS ペイント、 など)。 最初のアプリは、単純なもので開始するのもよいでしょう！ネットでみつけたすごいアプリのコードをひな型として利用することを恥ずかしがる必要はありません - 全くのゼロから作ることに比べればはるかに楽に作ることができます！



## UI の作成 

アプリを作成する際には、最初にUIを作成した方が、何を作っているのかがわかりやすく、サーバー関数のエラーでアプリがうまく動かなくなるリスクもありません。前述したように、UI を作成する際にはテンプレートを使用するのが良いでしょう。Shiny で利用できる標準的なレイアウトが沢山、基本となる shiny パッケージに含まれています、また、`shinydashboard` のような拡張パッケージが沢山存在することも注目しておいてもよいでしょう。まずは shiny の例を使って説明します。 

Shiny の UI は、一般的に次のような順序でネスト（入れ子になった）した関数として定義されます。

1. 一般的なレイアウトを定義する関数（最も基本的なものとしては `fluidPage()` があるが、他にも沢山存在）
2. レイアウトの中のパネル群
     - サイドバー (`sidebarPanel()`)
     - 「メイン」パネル (`mainPanel()`)
     - タブ (`tabPanel()`)
     - 一般的な「コラム」 (`column()`)
3. ウィジェットとアウトプット - これらは入力をサーバー関数に送ったり（ウィジェット）、出力をサーバー関数から送ったり（アウトプット）する
     - ウィジェットは一般的には `xxxInput()` のような名前となっています 例 `selectInput()`
     - アウトプットは一般的には `xxxOutput()` のような名前となっています 例 `plotOutput()`

繰り返しになりますが、これらは抽象的で、可視化することは簡単ではありません、そのため、例を見るのが一番です！ マラリア施設数のデータを地区ごとに視覚化する基本的なアプリを作ってみましょう。 このデータは多くのパラメータを持っているので、ユーザーが自分で抽出して、年齢層や地区別にデータを見ることができれば素晴らしいです。とても単純な shiny のレイアウトを利用しましょう ― サイドバーレイアウトです。これは、左側のサイドバーにウィジェットを配置し、右側にプロットを配置したレイアウトです。

どのようなアプリにするかを計画しましょう。まずは、可視化したい地区を選択することができるセレクターからはじめましょう。次いで、別のセレクターを利用して興味のある年齢のグループ可視化します。これらの抽出条件を用いて、これらのパラメーターを反映したエピカーブを表示することを目指しましょう。このために必要なのは：

1. 望む地区と興味のある年齢を選ぶことができるドロップダウンメニュー二つ。
2. 結果として出力されるエピカーブを表示する領域

これは次のようなものです:

```{r, eval = FALSE}

library(shiny)

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # 地区を選択するためのインプット
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # 年齢を選択するためのインプット
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # エピカーブはここに描画されます
      plotOutput("malaria_epicurve")
    )
    
  )
)


```


上の UI を伴って（`server` 部分に何もコードがない状態で）app.R が実行されると、レイアウトは次のようになります - グラフはサーバー関数部分がないため描画されていませんが入力部分は動いていることに注意してください！

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "simple_UI_view.png"))
```

ここで、ウィジェットがどのように機能するかを議論する良い機会です。 - それぞれのウィジェットは `inputId`、`label`、それぞれのウィジェットに特有のオプションを設定することができます。 `inputId` は非常に重要です。これらは UI からサーバー関数に情報を渡すIDとして扱われます。そのため、ID は他と重複しないことが必要です。大規模なアプリの場合には、感覚的に理解できる名前をつけるように努力する必要がありますし、何を扱うのかを具体的に示す必要があります。

それぞれのウィジェットがどのような動作をするのかについて、完全な詳細を把握するにはドキュメント（公式文書）を注意深く読む必要があります。ウィジェットはその種類に応じて、特定のデータをサーバー関数に渡し、このことについて完全に理解していなければなりません。例えば、`selectInput()` は文字型をサーバー関数に渡します：

- もし、<ul>Spring</ul>を最初のウィジェットで選択したら、それは、文字オブジェクトである `"Spring"` をサーバー関数に渡します。
- もし、ドロップダウンメニューから二項目を選択した場合、それらは文字ベクトルとして渡されます（例 `c("Spring", "Bolo")`）。

他のウィジェットは違う種類のオブジェクトをサーバー関数に渡します！例えば：

- `numericInput()` は数字オブジェクトをサーバー関数に渡します
- `checkboxInput()` はロジカルオブジェクト（`TRUE` か `FALSE`）をサーバー関数に渡します

また、ここで年齢データに<ul>名前付きのベクトル</ul>を利用していることに注目してみることは価値があるでしょう。 多くのウィジェットでは、名前付きベクトルを選択として利用すると、ベクトルの<ul>名前</ul>が選択できる表示として利用されますが、ベクトルの<ul>値</ul>がサーバー関数に渡されます。つまり、誰かが "15+" をドロップダウンメニューから選択した場合、UI は`"malaria_rdt_15"` をサーバー関数に渡します。これは、処理などで利用したいデータの列名そのものです！


アプリで様々なことを行うために使用できるウィジェットがたくさんあります。 ウィジェットはファイルのアプリへのアップロードとダウンロードも可能にします。基本の shiny に含まれるウィジェットを拡張してくれる素晴らしいパッケージもあり、**shinyWidgets** はこのような拡張例の一つです。使用例を見るには次のリンクを確認してください：

- [基本の shiny ウィジェットギャラリー](https://shiny.rstudio.com/gallery/widget-gallery.html)
- [shinyWidgets ギャラリー](https://github.com/dreamRs/shinyWidgets)



## アプリにデータを読み込む

アプリ開発の次のステップはサーバー関数を動かすことです。これをするには、何らかのデータをアプリに入れなければなりません。また、実行するべき全ての処理を把握する必要があります。Shiny アプリのデバッグは、エラーの発生している場所が明確がないことが多いため簡単にはいきません。そのため、データの加工と可視化のコードが問題なく動くようにしてからサーバー関数を作り始められると理想的です。

そのため、ユーザーの入力に応じて変化するエピカーブを表示するアプリを作る状況では、これを通常の R スクリプトで実行するにはどのようなコードが必要かを考える必要があります。必要な工程は：

1. パッケージの読み込み
2. データの読み込み
3. データの加工
4. ユーザーの入力に応じてデータを可視化する<ul>関数</ul>の作成

このリストは非常にわかりやすく、それほど難しいことではないはずです。ここで重要なのは、このプロセスのうち、どの部分が<ul>一度だけ</ul>実行が必要で、どの部分が<ul>ユーザーの入力に応じて</ul>実行が必要なのかを考えることです。なぜなら、Shiny アプリは一般的には実行される前にコードの一部分が一度だけ実行されるためです。大部分のコードをこの一度だけ実行される部分に移動することができれば、アプリのパフォーマンスが大きく改善するでしょう。この例では、データとパッケージの読み込みと基本的なデータの加工は一度だけしか必要ありません。そのため、これらのコードを<ul>サーバー関数の外</ul>に置くことができます。これが意味するところは、サーバー関数の中に必要なコードは可視化に関するコードだけということです。まず、これらの構成要素をすべてスクリプトとして開発してみましょう。しかし、今回は関数を使ってデータを可視化しているので、<ul>可視化をする関数のコード</ul>をサーバー関数の外に置くことで、アプリの実行時に関数が実行環境中に存在するようにすることもできます。

最初に、データを読み込みましょう。新しいプロジェクトで作業を行っていることと、そのデータをキレイな形にしたいので、新しい data というディレクトリを作成してマラリアデータをそこに保存しましょう。次の、最終的にはアプリの構造を整える際に削除するテスト用のコードを実行してください。

```{r, echo = TRUE}
pacman::p_load("tidyverse", "lubridate")

# read data
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

print(malaria_data)


```


Tidy な形のデータで作業する方が楽にとりくめるため、このデータを縦持ちのデータに変換する必要があります。年齢群が列になり、ケースも別の列になpivotingる形です。[Pivoting data](#pivoting)のページで学んだようにこの処理は簡単にできます。 


```{r, echo = TRUE}

malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")

print(malaria_data)

```

これでデータの準備は終了しました！これで、「テスト用の R スクリプト」の項目１、２、３を終えたことになります。最後の、そして最も難しいタスクが、ユーザーが指定したパラメータを利用してエピカーブを描画する関数作成です。以前にもお伝えしたように、shiny を学ぶ全ての人が関数型プログラミングのセクション（[関数の作成](#writing-functions)）を一読して、これがどのように動作するのかを理解しておくことを<ul>強く推奨します</ul>！

関数を定義する際に、どのパラメータを含みたいかを考えることは難しいかもしれません。Shiny における関数型プログラミングでは、全てのパラメータは一般的にはそれに関連したウィジェットがあるずです。そのため、これは通常すごく簡単です！現在とりくんでいるアプリを例にすると、地区でデータを絞り込めるようにしたいのですが、そのためのウィジェットはあります。そのため、これを反映する地区のパラメータを足しましょう。（現状では、）施設で絞り込む機能は<ul>ない</ul>ので、これをパラメータとして追加する必要はありません。次の三つのパラメータを含む関数を作るところからはじめましょう！

1. 核となるデータセット
2. 選んだ地区
3. 選んだ年齢区分

```{r}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}

```


この関数の働きは比較的単純なため、関数の詳細な解説には踏み込みません。一点だけ注意することとしては、エラーを発生させないために `NULL` を返すことで対応しているということです。これは、shiny サーバー関数がグラフオブジェクトではなくて `NULL` オブジェクトを生成すると ui には何も表示されないからです！この処理を行わなければアプリは頻繁に動きを止めてしまうため、この処理を入れることは大切です。

追加で注意するべき点としては、地区のインプットを評価する場合の`%in%` 演算子の利用です。前述の通り、入力は複数の値を含む文字ベクトルとなる可能性があります。そのため、`%in%` の方が、`==` より柔軟に対応できます。

それでは、関数をテストしてみましょう！

```{r, echo = TRUE, warning = FALSE}

plot_epicurve(malaria_data, district = "Bolo", agegroup = "malaria_rdt_0-4")

```

関数がうまく動作した後は、これらの機能がどのようにして shiny アプリに組み込まれていくのかを理解する必要があります。「スタートアップコード」<!--nishida: 注釈がいらなければ削除します。-->（訳者注：サーバー関数の外にコードをおいて実行を1回だけに制限する）の概念を前述しました。この概念をここではどのように実際にアプリに組み込むのかを見ていきましょう。これを行う方法は二通りあります！

1. このコードを<ul>app.R</ul>ファイルの一番最初（UI の前）におく、か
2. global.R という名前の新しいファイルをアプリのディレクトにおいて、スタートアップコードをそのファイルの中に記述する

特筆すべき点としては、一般的には大きいアプリでは二つ目の方法をとることがより楽です。この方法は、簡単にファイル構造をシンプルな方法で分割することができるからです。それでは、ここでは global.R スクリプトを完成させてみましょう。次のような形になるはずです：


```{r, eval = F}
# global.R スクリプト

pacman::p_load("tidyverse", "lubridate", "shiny")

# データの読み込み
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

# データをキレイにして縦持ちデータへ変換する
malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")


# グラフの描画をする関数を定義する
plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  # グラフのタイトルを作成する
  if (!("All" %in% district)) {            
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  # 年齢群で抽出する
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}



```


簡単ですね！Shiny の良い点の一つは、<ul>app.R</ul>、<ul>servver.R</ul>、<ul>ui.R</ul>、<ul>global.R</ul>と名前がついたファイルを認識してくれることです。そのため、これらのファイルを関係させるためのコードを一切書く必要がありません。このコードを<ul>global.R</ul>に直接記載しておくだけで、アプリの開始時に自動的に実行されます！

また、アプリの構成はグラフの描画をする関数を別の独自のファイルに移動させると改善します。これは、アプリが大きくなると非常に役立ちます。これをするには、funcs という名前の別のディレクトリを作成して<ul>plot_epicurve.R</ul>という名前のファイルを作成してそこに関数を保存します。その後、<ul>global.R</ul>から次のコードを利用して関数を読み込みましょう。

```{r, eval = F}

source(here("funcs", "plot_epicurve.R"), local = TRUE)

```

注：Shiny アプリでは常に`local = TRUE` と設定しなくてはなりません。なぜなら、サーバー上にアプリを公開した際ソースの動作に影響を及ぼすからです。

## アプリのサーバー関数を作成する

大半のコードが出来上がったので、残りはサーバー関数を作るだけです。これはアプリの最後のパーツです。そして最も理解することが難しいでしょう。サーバー関数は大規模な R の関数ですが、より小さい関数、あるいは、アプリの機能の集合体であると考えると理解しやすいかもしれません。これらの関数が頭から順番に実行されるわけではないということを理解することが大切です。それらには実行される順番はありますが、shiny においてはいつ実行が開始されるかを完全に理解する必要はありません。非常に基本的な理解としては、タスクあるいは関数は、ユーザーが<ul>特別にそうでないようにふるまう設定を行った状況を除き</ul>、それらに影響を与えるインプットに何か変更が加えられた時に動き始めます。繰り返しになりますが、この説明は非常に抽象的ですが、とりあえず基本的な3つの shiny <ul>オブジェクト</ul>を解説していきましょう。

1. リアクティブソース - これはユーザーインプットの別の呼び方です。shiny サーバー関数は作成したウィジェットを通じて UI の出力を受け取ることができます。UI の値が変更されるたびに、その出力がサーバー関数に渡されます。

2. リアクティブコンダクター - これは shiny サーバー関数の中で<ul>しか</ul>存在しない関数です。単純なアプリでは必要ではありませんが、他の処理で利用されるサーバー関数のなかでしか利用できないオブジェクトを作成します。一般的にはリアクティブコンダクターはリアクティブソースに依存します。

3. エンドポイント - これはサーバー関数から UI に渡されるアウトプットです。ここで作成しているアプリの例では、エピカーブが該当します。

これらのオブジェクトを念頭に置いて、サーバー関数を順番に作成していきましょう。参考のためにもう一度 UI のコードを表示しておきます：

```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # 地区を選択するウィジェット
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # 年齢群を選択するウィジェット
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # エピカーブはここに描画
      plotOutput("malaria_epicurve")
    )
    
  )
)


```

この UI のコードは次のものを含みます：

- インプット二つ:
  - 地区の選択用ウィジェット（`select_district` という inputId）
  - 年齢の選択用ウィジェット（`select_agegroup`という inputId）
- アウトプット一つ:
  - エピカーブ（`malaria_epicurve`というoutputId）

以前ものべたように、インプットとアウトプットに設定したユニークな（重複がない）名前（inputId と outputId）は必須です。これらは、<ul>ユニークである必要</ul>があり、 UI と サーバー関数の間の情報のやり取りに利用されます。サーバー関数の中では、`input$inputID` という構文でインプットを参照することができ、`output$outputID` という構文にアウトプットを渡すことができます。このことを理解することは難しいので、まずは例を見てみましょう！

```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
}


```


今回のような単純なアプリのサーバー関数は非常にわかりやすいです！サーバー関数は三つのパラメーター ― 
`input`、`output`、`session`（これは現時点ではそれほど重要ではありませんが、これを含むことは大切です！） ― をもつ関数であることに気づきましたか？こんかいのサーバー関数のタスクは一つだけです。それは、先に作成した関数とサーバー関数の `input` に基づいてグラフを描画することです。インプットとアウトプットオブジェクトの名前がUI で設定したものと完全に一致していることに注意してみてください。

サーバー関数がユーザーのインプットにどのように反応するかの基本を理解するためには、インプットの変化をアウトプットが（基礎となるパッケージを通じて）理解し、インプットが変化するたびに、この関数を再実行してグラフが作成されることに注意する必要があります。ここでは、`renderPlot()` 関数も使用していることに注意してください。これは、これらのオブジェクトを ui アウトプットに渡すクラス固有の関数群の1つです。似たような動作をする関数はいくつかありますが、使用する関数が ui に渡すオブジェクトのクラスと一致していることを確認する必要があります。例えば：

- `renderText()` - ui にテキストを送る
- `renderDataTable` - ui にインタラクティブなテーブルを送る。

これらは、UI で使用されるアウトプット<ul>関数</ul>と一致する必要があることを覚えておいてください。つまり、`renderPlot()` は `plotOutput()` と対になり、`renderText()` は `textOutput()` と対になります。

やっとちゃんと機能するアプリをつくることができました！ Rstudio のスクリプトウィンドウの右上にある「Run App」ボタンを押して実行することができます。 また、アプリを（Rstudio ではなく）デフォルトのブラウザで実行するように選択することもできます。ブラウザで実行することで他の人にどのように見えるかがより正確に反映されます。  


```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_simple_view.gif"))
```


R コンソールでは、アプリが「反応を待っている」状態になっているのが楽しいですね。なにか入力してみましょう！

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "listening.png"))
```


<!-- TO DO: *ADD SOMETHING ON DOWNLOADING A ZIP FILE OF THE APP?*  -->


## もっと沢山の機能を追加する

この時点で、ようやくアプリが動き出しましたが、機能はほとんどありません。また、shiny ができることのほんの一部しか知ることができていません。このアプリに、さらに機能を追加していきましょう。追加すると良い機能は次のようなものです：

1. いくつかの説明文
2. グラフをダウンロードするためのボタン - これにより、ユーザーにアプリで生成した画像の高画質版を提供します
3. 特定の施設を指定できるウィジェット
4. ダッシュボードの追加ページ - ここにはデータの表を掲載しましょう

追加することはたくさんありますが、これを通して shiny の様々な機能を学ぶことができます。Shiny について学ぶことは本当に沢山あります（Shiny は非常に<ul>高度</ul>なものになる可能性もありますが、皆さんが使い方の理解を深めれば、外部の学習ソースをより快適に使用できるようになることを期待しています。).



### 静的なテキストの追加 {.unnumbered}  

まず、shiny アプリに静的なテキストを追加することについて考えましょう。基本的な知識を一度身につければ、アプリに静的なテキストを追加することはものすごく簡単です。静的なテキストは shiny アプリの中で変化しないため、一般的には静的なテキストはアプリの ui に記載されます（もし、テキストの内容を変化させたければ、<ul>テキストレンダリング</ul>関数をサーバー関数内で利用しましょう）。ここでは詳しく説明しませんが、R を *HTML* や *css* と連携させることで、UI に様々な要素を追加することができます（カスタム要素の追加も可能です）。

HTML や css は、ユーザーインターフェイスのデザインに明示的に関わる言語です。これらを深く理解する必要はありませんが、*HTML* は UI のオブジェクト（テキストボックスやテーブルなど）を作成し、<ul>css</ul> は一般的にそれらのオブジェクトのスタイルや見た目を変更するために使用されます。 Shiny は膨大な数の<ul>HTML タグ</ul>にアクセスできます。これらは、ヘッダー、テキストの段落、改行、テーブルなど、特定の方法で動作するオブジェクトとして存在します。これらは、次のように利用できます：

- `h1()` - これは *見出し* のタグです。これにより、囲まれたテキストが自動的に大きくなり、フォントフェイスや色などのデフォルトが変更されます（アプリの全体的なテーマに応じて変更されます）。`h2()`から `h6()`までどんどん副見出しを小さくしていくこともできます。使用例はこんな感じです：
  * `h1("ヘッダー - セクション 1")`

- `p()` - これは、*段落*のタグです。これは、囲まれたテキストを、テキスト本文と同様にするものです。このテキストは自動的に折り返され、比較的小さなサイズで表示されます。（フッターは、もっと小さいかもしれません。）ワード文書のテキスト本文のようなものだと思ってください。使用例はこのような形です:  

  * `p("これは、私が自分のアプリの機能を説明するためのテキストです。")`
  
- `tags$b()` と `tags$i()` - これらはテキストが中に記載された場合に、太字 `tags$b()` や斜体 `tags$i()` で表現されます。

- tags$ul()`、`tags$ol()`、`tags$li()` - これらは、*リスト*を作成する際に使用されるタグです。 これらはすべて以下の構文で使用され、ユーザーは順序付きのリスト（`tags$ol()`； 数字がふられている）か、順序なしのリスト（`tags$ul()`、中点がつけられている)を作成できます。tags$li()`は、どちらのタイプのリストであっても、リスト内の項目を表すのに使われます。 例：

```{r, eval = F}

tags$ol(
  
  tags$li("Item 1"),
  
  tags$li("Item 2"),
  
  tags$li("Item 3")
  
)

```

- `br()` と `hr()` - これらのタグは、*改行*と*水平線* (改行あり)を作成します。アプリやテキストのセクションを区切るのに使いましょう！これらのタグにアイテムを渡す必要はありません（括弧は空のままでかまいません）。


- `div()` -これは、何でも含むことができる*汎用*のタグで、*好きな名前*にすることができます。UI の設計が進むと、これらを利用して UI を区分けしたり、特定のセクションに特定のスタイルを与えたり、サーバーと UI 要素の間に相互作用を持たせたりすることができます。 詳細は省きますが、知っておいて損はありません。

なお、これらのオブジェクトはすべて、`tags$...`でアクセスできますし、いくつかは関数として呼び出すだけでアクセスできるものもあります。これらは事実上、同義語ですがが、より明確に、誤って関数を上書きしないようにしたい場合には、`tags$...`スタイルを使用するとよいでしょう。また、これは利用可能なタグのすべてを網羅しているわけではありません。シャイニーで利用可能なすべてのタグの完全なリストは [ここ](https://shiny.rstudio.com/articles/tag-glossary.html)にあり、また、HTML を直接 UI に挿入することで、さらに多くの機能を利用することもできます。


自信のある方は、HTMLタグの`style`引数に、任意の *cssスタイリング要素*を追加することもできます。この仕組みについては詳しく説明しませんが、UI の視覚的特性をテストするためのヒントとして、chrome（あるいは、ブラウザで実行しているshiny アプリ）の HTML インスペクタモードを使用して、オブジェクトのスタイルを自分で編集するという方法があります！

アプリにテキストを追加してみましょう

```{r, eval = F}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         h4("Options"),
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
    tags$ul(
      tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
      tags$li(tags$b("data_date"), " - the date the data were collected at"),
      tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
      tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
      tags$li(tags$b("District"), " - the district the data were collected at"),
      tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
      tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
    )
    
  )
)
)



```

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_text_view.png"))
```


### リンクの追加 {.unnumbered}

リンクを貼るには、`tags$a()`にリンクと表示テキストを入れて、以下のように使います。独立した段落を表示するには`p()`の中に記載します。文章中の数語をリンクとして表示させたい場合は、ハイパーリンクとなる部分に`tags$a()`を使用します。 リンクを<ul>新しい</ul>ブラウザウィンドウで開くようにするには、引数として`target = "_blank"`を追加してください。  

```{r, eval=F}
tags$a(href = "www.epiRhandbook.com", "Visit our website!")
```



### ダウンロードボタンを追加する {.unnumbered}

それでは、3つの機能のうち2つ目の機能を紹介しましょう。ダウンロードボタンは、アプリに追加するものとしてはかなり一般的なもので、簡単に作ることができます。ui  に別のウィジェットを追加し、サーバーに別のoutputを追加してそれと結合する必要があります。また、この例では、 <ul>リアクティブコンダクター</ul>を追加します。


まずは ui を更新しましょう。Shiny には `downloadButton()` というウィジェットがあるためこれは簡単です。これに inputId とラベルを追加しましょう。

```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # 地域のセレクター
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = FALSE
         ),
         # 年齢のセレクター
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # 水平線
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # エピカーブはここに表示されます
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```
 
Note that we've also added in a `hr()` tag - this adds a horizontal line separating our control widgets from our download widgets. This is another one of the HTML tags that we discussed previously.

Now that we have our ui ready, we need to add the server component. Downloads are done in the server with the `downloadHandler()` function. Similar to our plot, we need to attach it to an output that has the same inputId as the download button. This function takes two arguments - `filename` and `content` - these are both functions. As you might be able to guess, `filename` is used to specify the name of the downloaded file, and `content` is used to specify what should be downloaded. `content` contain a function that you would use to save data locally - so if you were downloading a csv file you could use `rio::export()`. Since we're downloading a plot, we'll use `ggplot2::ggsave()`. Lets look at how we would program this (we won't add it to the server yet). 

```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
  output$download_epicurve <- downloadHandler(
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```


Note that the `content` function always takes a `file` argument, which we put where the output file name is specified. You might also notice that we're repeating code here - we are using our `plot_epicurve()` function twice in this server, once for the download and once for the image displayed in the app. While this wont massively affect performance, this means that the code to generate this plot will have to be run when the user changes the widgets specifying the district and age group, *and* again when you want to download the plot. In larger apps, suboptimal decisions like this one will slow things down more and more, so it's good to learn how to make our app more efficient in this sense. What would make more sense is if we had a way to run the epicurve code when the districts/age groups are changes, *and let that be used by* the renderPlot() and downloadHandler() functions. This is where reactive conductors come in! 

Reactive conductors are objects that are created in the shiny server in a *reactive* way, but are not outputted - they can just be used by other parts of the server. There are a number of different kinds of *reactive conductors*, but we'll go through the basic two.

1.`reactive()` - this is the most basic reactive conductor - it will react whenever any inputs used inside of it change (so our district/age group widgets)  
2. `eventReactive()`- this rective conductor works the same as `reactive()`, except that the user can specify which inputs cause it to rerun. This is useful if your reactive conductor takes a long time to process, but this will be explained more later.  

Lets look at the two examples:

```{r, eval = FALSE}

malaria_plot_r <- reactive({
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})


# only runs when the district selector changes!
malaria_plot_er <- eventReactive(input$select_district, {
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})



```

When we use the `eventReactive()` setup, we can specify which inputs cause this chunk of code to run - this isn't very useful to us at the moment, so we can leave it for now. Note that you can include multiple inputs with `c()`

Lets look at how we can integrate this into our server code:


```{r, eval = FALSE}

server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  })
  
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```

You can see we're just calling on the output of our reactive we've defined in both our download and plot rendering functions. One thing to note that often trips people up is you have to use the outputs of reactives as if they were functions - so you *must add empty brackets at the end of them* (i.e. `malaria_plot()` is correct, and `malaria_plot` is not). Now that we've added this solution our app is a little tidyer, faster, and easier to change since all our code that runs the epicurve function is in one place.


```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "download_button_view.png"))
```


### Adding a facility selector {.unnumbered}  

Lets move on to our next feature - a selector for specific facilities. We'll implement another parameter into our function so we can pass this as an argument from our code. Lets look at doing this first - it just operates off the same principles as the other parameters we've set up. Lets update and test our function.


```{r, echo = TRUE}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot", facility = "All") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
    if (!("All" %in% facility)) {
    data <- data %>%
      filter(location_name == facility)
    
    plot_title_facility <- facility
    
  } else {
    
    plot_title_facility <- "all facilities"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }

  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}; {plot_title_facility}"),
      subtitle = agegroup_title
    )
  
  
  
}
```

Let's test it:  

```{r, warning=F, message=F}

plot_epicurve(malaria_data, district = "Spring", agegroup = "malaria_rdt_0-4", facility = "Facility 1")

```


With all the facilites in our data, it isn't very clear which facilities correspond to which districts - and the end user won't know either. This might make using the app quite unintuitive. For this reason, we should make the facility options in the UI change dynamically as the user changes the district - so one filters the other! Since we have so many variables that we're using in the options, we might also want to generate some of our options for the ui in our _global.R_ file _from the data_. For example, we can add this code chunk to _global.R_ after we've read our data in:



```{r, , message =  FALSE}

all_districts <- c("All", unique(malaria_data$District))

# data frame of location names by district
facility_list <- malaria_data %>%
  group_by(location_name, District) %>%
  summarise() %>% 
  ungroup()

```

Let's look at them:  

```{r}
all_districts
```


```{r}
facility_list
```


We can pass these new variables to the ui without any issue, since they are globally visible by both the server and the ui! Lets update our UI:


```{r, eval = FALSE}


ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = all_districts,
              selected = "All",
              multiple = FALSE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # selector for facility
         selectInput(
           inputId = "select_facility",
           label = "Select Facility",
           choices = c("All", facility_list$location_name),
           selected = "All"
         ),
         
         # horizontal line
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```


Notice how we're now passing variables for our choices instead of hard coding them in the ui! This might make our code more compact as well! Lastly, we'll have to update the server. It will be easy to update our function to incorporate our new input (we just have to pass it as an argument to our new parameter), but we should remember we also want the ui to update dynamically when the user changes the selected district. It is important to understand here that we *can change the parameters and behaviour of widgets* while the app is running, but this needs to be done *in the server*. We need to understand a new way to output to the server to learn how to do this.

The functions we need to understand how to do this are known as *observer* functions, and are similar to *reactive* functions in how they behave. They have one key difference though:

- Reactive functions do not directly affect outputs, and produce objects that can be seen in other locations in the server
- Observer functions *can* affect server outputs, but do so via side effects of other functions. (They can also do other things, but this is their main function in practice)

Similar to reactive functions, there are two flavours of observer functions, and they are divided by the same logic that divides reactive functions:

1. `observe()` - this function runs whenever any inputs used inside of it change
2. `observeEvent()` - this function runs when a *user-specified* input changes

We also need to understand the shiny-provided functions that update widgets. These are fairly straightforward to run - they first take the `session` object from the server function (this doesn't need to be understood for now), and then the `inputId` of the function to be changed. We then pass new versions of all parameters that are already taken by `selectInput()` - these will be automatically updated in the widget. 

Lets look at an isolated example of how we could use this in our server. When the user changes the district, we want to filter our tibble of facilities by district, and update the choices to *only reflect those that are available in that district* (and an option for all facilities)

```{r, eval = FALSE}

observe({
  
  if (input$select_district == "All") {
    new_choices <- facility_list$location_name
  } else {
    new_choices <- facility_list %>%
      filter(District == input$select_district) %>%
      pull(location_name)
  }
  
  new_choices <- c("All", new_choices)
  
  updateSelectInput(session, inputId = "select_facility",
                    choices = new_choices)
  
})


```

And that's it! we can add it into our server, and that behaviour will now work. Here's what our new server should look like:

```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  
  
}

```


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_menu_view.gif"))
```







### Adding another tab with a table {.unnumbered}

Now we'll move on to the last component we want to add to our app. We'll want to separate our ui into two tabs, one of which will have an interactive table where the user can see the data they are making the epidemic curve with. To do this, we can use the packaged ui elements that come with shiny relevant to tabs. On a basic level, we can enclose most of our main panel in this general structure:

```{r, eval = FALSE}


# ... the rest of ui

mainPanel(
  
  tabsetPanel(
    type = "tabs",
    tabPanel(
      "Epidemic Curves",
      ...
    ),
    tabPanel(
      "Data",
      ...
    )
  )
)


```

Lets apply this to our ui. We also will want to use the **DT** package here - this is a great package for making interactive tables from pre-existing data. We can see it being used for `DT::datatableOutput()` in this example.

```{r, echo = FALSE}
library(DT)
```

```{r, eval = FALSE}
ui <- fluidPage(
     
     titlePanel("Malaria facility visualisation app"),
     
     sidebarLayout(
          
          sidebarPanel(
               # selector for district
               selectInput(
                    inputId = "select_district",
                    label = "Select district",
                    choices = all_districts,
                    selected = "All",
                    multiple = FALSE
               ),
               # selector for age group
               selectInput(
                    inputId = "select_agegroup",
                    label = "Select age group",
                    choices = c(
                         "All ages" = "malaria_tot",
                         "0-4 yrs" = "malaria_rdt_0-4",
                         "5-14 yrs" = "malaria_rdt_5-14",
                         "15+ yrs" = "malaria_rdt_15"
                    ), 
                    selected = "All",
                    multiple = FALSE
               ),
               # selector for facility
               selectInput(
                    inputId = "select_facility",
                    label = "Select Facility",
                    choices = c("All", facility_list$location_name),
                    selected = "All"
               ),
               
               # horizontal line
               hr(),
               downloadButton(
                    outputId = "download_epicurve",
                    label = "Download plot"
               )
               
          ),
          
          mainPanel(
               tabsetPanel(
                    type = "tabs",
                    tabPanel(
                         "Epidemic Curves",
                         plotOutput("malaria_epicurve")
                    ),
                    tabPanel(
                         "Data",
                         DT::dataTableOutput("raw_data")
                    )
               ),
               br(),
               hr(),
               p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
               tags$ul(
                    tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
                    tags$li(tags$b("data_date"), " - the date the data were collected at"),
                    tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
                    tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
                    tags$li(tags$b("District"), " - the district the data were collected at"),
                    tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
                    tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
               )
               
               
          )
     )
)


```


Now our app is arranged into tabs! Lets make the necessary edits to the server as well. Since we dont need to manipulate our dataset at all before we render it this is actually very simple - we just render the malaria_data dataset via DT::renderDT() to the ui!


```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  # render data table to ui
  output$raw_data <- DT::renderDT(
    malaria_data
  )
  
  
}


```


```{r, out.width=c('100%', '100%'), fig.show='hold', echo = F, fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_table_view.gif"))
```


## Sharing shiny apps

Now that you've developed your app, you probably want to share it with others - this is the main advantage of shiny after all! We can do this by sharing the code directly, or we could publish on a server. If we share the code, others will be able to see what you've done and build on it, but this will negate one of the main advantages of shiny - *it can eliminate the need for end-users to maintain an R installation*. For this reason, if you're sharing your app with users who are not comfortable with R, it is much easier to share an app that has been published on a server. 

If you'd rather share the code, you could make a .zip file of the app, or better yet, *publish your app on github and add collaborators.* You can refer to the section on github for further information here.

However, if we're publishing the app online, we need to do a little more work. Ultimately, we want your app to be able to be accessed via a web URL so others can get quick and easy access to it. Unfortunately, to publish you app on a server, you need to have access to a server to publish it on! There are a number of hosting options when it comes to this:

- _shinyapps.io_: this is the easiest place to publish shiny apps, as it has the smallest amount of configuration work needed, and has some free, but limited licenses.

- _RStudio Connect_: this is a far more powerful version of an R server, that can perform many operations, including publishing shiny apps. It is however, harder to use, and less recommended for first-time users.

For the purposes of this document, we will use _shinyapps.io_, since it is easier for first time users. You can make a free account here to start - there are also different price plans for server licesnses if needed. The more users you expect to have, the more expensive your price plan may have to be, so keep this under consideration. If you're looking to create something for a small set of individuals to use, a free license may be perfectly suitable, but a public facing app may need more licenses.

First we should make sure our app is suitable for publishing on a server. In your app, you should restart your R session, and ensure that it runs without running any extra code. This is important, as an app that requires package loading, or data reading not defined in your app code won't run on a server. Also note that you can't have any *explicit* file paths in your app - these will be invalid in the server setting - using the `here` package solves this issue very well. Finally, if you're reading data from a source that requires user-authentication, such as your organisation's servers, this will not generally work on a server. You will need to liase with your IT department to figure out how to whitelist the shiny server here.

*signing up for account*

Once you have your account, you can navigate to the tokens page under _Accounts_. Here you will want to add a new token - this will be used to deploy your app. 

From here, you should note that the url of your account will reflect the name of your app - so if your app is called _my_app_, the url will be appended as _xxx.io/my_app/_. Choose your app name wisely! Now that you are all ready, click deploy - if successful this will run your app on the web url you chose!

*something on making apps in documents?*

## Further reading

So far, we've covered a lot of aspects of shiny, and have barely scratched the surface of what is on offer for shiny. While this guide serves as an introduction, there is loads more to learn to fully understand shiny. You should start making apps and gradually add more and more functionality


## Recommended extension packages

The following represents a selection of high quality shiny extensions that can help you get a lot more out of shiny. In no particular order:

- **shinyWidgets** - this package gives you many many more widgets that can be used in your app. Run `shinyWidgets::shinyWidgetsGallery()` to see a selection of available widgets with this package. See examples [here](https://github.com/dreamRs/shinyWidgets)  

- **shinyjs** - this is an excellent package that gives the user the ability to greatly extend shiny's utility via a series of javascript. The applications of this package range from very simple to highly advanced, but you might want to first use it to manipulate the ui in simple ways, like hiding/showing elements, or enabling/disabling buttons. Find out more [here](https://deanattali.com/shinyjs/basic)

- **shinydashboard** - this package massively expands the available ui that can be used in shiny, specifically letting the user create a complex dashboard with a variety of complex layouts. See more [here](https://rstudio.github.io/shinydashboard/)

- **shinydashboardPlus** - get even more features out of the **shinydashboard** framework! See more [here](https://rinterface.github.io/shinydashboardPlus/articles/shinydashboardPlus.html)

- **shinythemes** - change the default css theme for your shiny app with a wide range of preset templates! See more [here](https://rstudio.github.io/shinythemes/)


There are also a number of packages that can be used to create interactive outputs that are shiny compatible. 

- **DT** is semi-incorporated into base-shiny, but provides a great set of functions to create interactive tables.

- **plotly** is a package for creating interactive plots that the user can manipulate in app. You can also convert your plot to interactive versions via `plotly::ggplotly()`! As alternatives, **dygraphs** and **highcharter** are also excellent.


## Recommended resources



