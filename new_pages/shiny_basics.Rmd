
# Shiny で作るダッシュボード {#shiny-basics}  

ダッシュボードは多くの場合、他の人と分析の結果を共有する場合に非常に良い方法です。**Shiny** を利用してダッシュボードを作成することは、R 言語について、比較的高度な知識が必要ですが、大いなる可能性と自由を与えてくれます。

<!-- One of the largest drawbacks of `R` is its usability for people who are new to or have no experience with programming languages. While these skills are very valuable, most people will find that this represents a barrier to sharing analyses, especially in multidisciplinary environments. It requires some work to maintain an `R` installation, and not everyone will be comfortable running shared code, even if it's well documented and easy to read. This is *especially* true when users have to change parameters of code!  -->

<!-- R based dashboards are also advantageous in that they centralise how code is run - when the same code is run on different machines, often people will have to deal with differing file paths, different R versions, and different package installations. For this reason, dashboards are a great way to share code with others in a user friendly way! -->

**Shiny** によるダッシュボードについて学ぶ人は、データの加工と可視化についてある程度理解していることが必要です。また、コードのデバッグや関数を書くことについても慣れている必要があります。ダッシュボードの作成は、最初は分かりにくく、ときに理解することが難しいでしょう。しかし、このスキルは学ぶ価値のあるもので、習熟とともに簡単になっていきます！

このページでは、**shiny** とその拡張によるダッシュボード作成について短く概要をお伝えします。
別の速く簡単で、しかし自由度は低い方法でのダッシュボード作成方法については **flextable** のページ([R Markdownで作るダッシュボード](#flexdashboard))を参考にしてください。  



## 準備  


### パッケージの読み込み {.unnumbered}  

このハンドブックでは、**pacman** パッケージの `p_load()`を利用します。これは、パッケージのインストールが必要であればインストールしてくれて、<ul>かつ</ul>使えるように読み込んでくれます。あるいは、**base**の`library()`を利用してインストールされたパッケージを読み込んでもよいでしょう。より詳しくは[Rの基礎](#basics)のページを確認してください。

まずは、R パッケージの **shiny** をインストールするところからはじめていきます：

```{r, eval = FALSE}
pacman::p_load("shiny")
```


### データのインポート {.unnumbered}  

もしあなたがこのページのコードを追いたいのであれば[ハンドブックとデータのダウンロード](#data_shiny)を見てください。そこには最終的な Shiny アプリを作成するための R のスクリプトとデータファイルへのリンクがあります。  

これらのファイルを利用してアプリを再現したい場合は、R のプロジェクトがあるフォルダ構造が解説のなかでどのように作成されたかについて注意してください（例 "data" フォルダや "funcs" フォルダ）。



<!-- ======================================================= -->
## Shiny アプリの構造 {  }

### 基本的なファイル構造 {.unnumbered}  

`shiny` について理解するためには、まずアプリのファイル構造をどのようにすればうごくかを理解するひつようがあります！まず、真新しいディレクトリを作るところからはじめる必要があります。これは、<ul>R Studio</ul>で、<ul>New Project</ul>を選び、<ul>Shiny Web Application</ul>を選択することで簡単に作成できます。この操作で、 shiny アプリの基本的な構造が作成されます。

このプロジェクトをひらくと、すでに<ul>app.R</ul>という名前の `.R` ファイルが作成されています。次の二つのうちのいずれか一つのファイル構造をとることが<ul>ul</ul>必須です：

1. 一つのファイルが _app.R_、という名前をもつ *あるいは*  
2. 二つのファイルのうち一つが _ui.R_ でもう一つが _server.R_ という名前をもつ  

このページでは、*app.R* という名前をつける一つ目の方法を利用します。次が例となるスクリプトです：

```{r, eval = FALSE}
# app.R の例

library(shiny)

ui <- fluidPage(

    # アプリのタイトル
    titlePanel("My app"),

    # スライダーインプットウィジェットを含むサイドバー
    sidebarLayout(
        sidebarPanel(
            sliderInput("input_1")
        ),

        # グラフを表示する
        mainPanel(
           plotOutput("my_plot")
        )
    )
)

# ヒストグラムを描画するためのサーバー関数ロジックを定義
server <- function(input, output) {
     
     plot_1 <- reactive({
          plot_func(param = input_1)
     })
     
    output$my_plot <- renderPlot({
       plot_1()
    })
}


# アプリを走らせる
shinyApp(ui = ui, server = server)


```


ファイルを開くと、二つのオブジェクトが定義されています - 一つは `ui` でもう一つは `server` です。これらのオブジェクトは<u>全ての</ul> shiny アプリで定義される必要があり、アプリそのものの中心的な構造体です！実際には、上で説明した二つのファイル構造の違いは、構造 1 では、`ui` と `server` が一つのファイルで定義されているのに対して、構造 2 では別々のファイルで定義されているだけです。注意：他の .R ファイルを `source()` を利用してアプリで利用することも可能です（これは大きなアプリでは必須となります）。



### server と ui {.unnumbered}

次に、実際に `server` と `ui` オブジェクトが何を<ul>する</ul>かを理解しなければなりません。<ul>単純に説明するなら、shiny アプリをユーザーが操作すると、常に二つのオブジェクトが互いに影響しあう状態となります。</ul>

Shiny アプリの UI 要素は、基本的なレベルにおいては、HTML インターフェイスを作る R のコードです。これは、アプリの UI に<ul>表示</ul>されているものすべてです。これは、一般的に次のようなものを含みます：

* 「ウィジェット」 - ドロップダウンメニュー、チェックボックス、スライダーなどユーザーが操作できるもの
* 図、表など - R のコードで作成できる出力
* アプリのナビゲーションに関する要素 - タブ、ペーンなど 
* テキスト、ハイパーリンクなど
* HTML と CSS 要素 (後に解説します)

UI において最も大切なことは、UI は入力をユーザーから<ul>受け</ul>、サーバー関数から出力を受け取り<ul>表示する</ul>ということです。<ul>どのような時<ul>でも、コードが ui のなかで<ul>能動的</ul>に動くことはありません。UI における全ての変化は（多かれ少なかれ）サーバー関数を経由したものです。そのため、図の表示やダウンロードなどの処理はサーバー関数の中で行わなければなりません。

Shiny アプリのサーバー関数はアプリが立ち上がれば、すべてのコードが実行される場所となります。この挙動は少し混乱しやすいです。サーバー関数は効果的に UI のユーザーインターフェースに対して<ul>react</ul>（反応）し、対応してコードの塊を実行します。もしサーバー関数内でなにかが変われば、その変化は ui に再度渡され、その変化が目に見える形になります。大切なのは、サーバー関数内のコードが<u>非連続的</ul>に実行される（と考えておくことが良いでしょう）という点です。 基本は、ui がサーバー関数内のコードの塊に影響を与えた場合は常に、自動的にそのコードが実行されて、出力が作成・表示されます。

この一連の動作は、今は難解に聞こえると思います。なので、これが実際にどのように動くかをいくつか例を体験して明快にしましょう。


### アプリを作成する前に {.unnumbered}

アプリを作る前に、<ul>何</ul>を作りたいかを知ることはとても助けになります。あなたが作る UI はコードで書かれるため、何か具体的なものを狙って作成しなければ、何を作っているかを可視化することができません。このような理由から、何が Shiny アプリとして作れるか、沢山の例を見てのアイデアを得ておくことは非常に有効です。もし、それらのアプリのソースコードを見ることができればもっと良いでしょう！この目的のための素晴らしいリソースは次のリンクにあります：

* [Rstudio アプリギャラリー](https://shiny.rstudio.com/gallery/)  

どんなことができるかのイメージを持つことができれば、どのような見た目のアプリを作りたいかを描いてみることも助けになります。 - これは、紙に書いても、絵を描くソフトを利用してもよいでしょう (パワーポイント、 MS ペイント、 など)。 最初のアプリは、単純なもので開始するのもよいでしょう！ネットでみつけたすごいアプリのコードをひな型として利用することを恥ずかしがる必要はありません - 全くのゼロから作ることに比べればはるかに楽に作ることができます！



## UI の作成 

アプリを作成する際には、最初にUIを作成した方が、何を作っているのかがわかりやすく、サーバー関数のエラーでアプリがうまく動かなくなるリスクもありません。前述したように、UI を作成する際にはテンプレートを使用するのが良いでしょう。Shiny で利用できる標準的なレイアウトが沢山、基本となる shiny パッケージに含まれています、また、`shinydashboard` のような拡張パッケージが沢山存在することも注目しておいてもよいでしょう。まずは shiny の例を使って説明します。 

Shiny の UI は、一般的に次のような順序でネスト（入れ子になった）した関数として定義されます。

1. 一般的なレイアウトを定義する関数（最も基本的なものとしては `fluidPage()` があるが、他にも沢山存在）
2. レイアウトの中のパネル群
     - サイドバー (`sidebarPanel()`)
     - 「メイン」パネル (`mainPanel()`)
     - タブ (`tabPanel()`)
     - 一般的な「コラム」 (`column()`)
3. ウィジェットとアウトプット - これらは入力をサーバー関数に送ったり（ウィジェット）、出力をサーバー関数から送ったり（アウトプット）する
     - ウィジェットは一般的には `xxxInput()` のような名前となっています 例 `selectInput()`
     - アウトプットは一般的には `xxxOutput()` のような名前となっています 例 `plotOutput()`

繰り返しになりますが、これらは抽象的で、可視化することは簡単ではありません、そのため、例を見るのが一番です！ マラリア施設数のデータを地区ごとに視覚化する基本的なアプリを作ってみましょう。 このデータは多くのパラメータを持っているので、ユーザーが自分で抽出して、年齢層や地区別にデータを見ることができれば素晴らしいです。とても単純な shiny のレイアウトを利用しましょう ― サイドバーレイアウトです。これは、左側のサイドバーにウィジェットを配置し、右側にプロットを配置したレイアウトです。

どのようなアプリにするかを計画しましょう。まずは、可視化したい地区を選択することができるセレクターからはじめましょう。次いで、別のセレクターを利用して興味のある年齢のグループ可視化します。これらの抽出条件を用いて、これらのパラメーターを反映したエピカーブを表示することを目指しましょう。このために必要なのは：

1. 望む地区と興味のある年齢を選ぶことができるドロップダウンメニュー二つ。
2. 結果として出力されるエピカーブを表示する領域

これは次のようなものです:

```{r, eval = FALSE}

library(shiny)

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # 地区を選択するためのインプット
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # 年齢を選択するためのインプット
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # エピカーブはここに描画されます
      plotOutput("malaria_epicurve")
    )
    
  )
)


```


上の UI を伴って（`server` 部分に何もコードがない状態で）app.R が実行されると、レイアウトは次のようになります - グラフはサーバー関数部分がないため描画されていませんが入力部分は動いていることに注意してください！

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "simple_UI_view.png"))
```

ここで、ウィジェットがどのように機能するかを議論する良い機会です。 - それぞれのウィジェットは `inputId`、`label`、それぞれのウィジェットに特有のオプションを設定することができます。 `inputId` は非常に重要です。これらは UI からサーバー関数に情報を渡すIDとして扱われます。そのため、ID は他と重複しないことが必要です。大規模なアプリの場合には、感覚的に理解できる名前をつけるように努力する必要がありますし、何を扱うのかを具体的に示す必要があります。

それぞれのウィジェットがどのような動作をするのかについて、完全な詳細を把握するにはドキュメント（公式文書）を注意深く読む必要があります。ウィジェットはその種類に応じて、特定のデータをサーバー関数に渡し、このことについて完全に理解していなければなりません。例えば、`selectInput()` は文字型をサーバー関数に渡します：

- もし、<ul>Spring</ul>を最初のウィジェットで選択したら、それは、文字オブジェクトである `"Spring"` をサーバー関数に渡します。
- もし、ドロップダウンメニューから二項目を選択した場合、それらは文字ベクトルとして渡されます（例 `c("Spring", "Bolo")`）。

他のウィジェットは違う種類のオブジェクトをサーバー関数に渡します！例えば：

- `numericInput()` は数字オブジェクトをサーバー関数に渡します
- `checkboxInput()` はロジカルオブジェクト（`TRUE` か `FALSE`）をサーバー関数に渡します

また、ここで年齢データに<ul>名前付きのベクトル</ul>を利用していることに注目してみることは価値があるでしょう。 多くのウィジェットでは、名前付きベクトルを選択として利用すると、ベクトルの<ul>名前</ul>が選択できる表示として利用されますが、ベクトルの<ul>値</ul>がサーバー関数に渡されます。つまり、誰かが "15+" をドロップダウンメニューから選択した場合、UI は`"malaria_rdt_15"` をサーバー関数に渡します。これは、処理などで利用したいデータの列名そのものです！


アプリで様々なことを行うために使用できるウィジェットがたくさんあります。 ウィジェットはファイルのアプリへのアップロードとダウンロードも可能にします。基本の shiny に含まれるウィジェットを拡張してくれる素晴らしいパッケージもあり、**shinyWidgets** はこのような拡張例の一つです。使用例を見るには次のリンクを確認してください：

- [基本の shiny ウィジェットギャラリー](https://shiny.rstudio.com/gallery/widget-gallery.html)
- [shinyWidgets ギャラリー](https://github.com/dreamRs/shinyWidgets)



## アプリにデータを読み込む

アプリ開発の次のステップはサーバー関数を動かすことです。これをするには、何らかのデータをアプリに入れなければなりません。また、実行するべき全ての処理を把握する必要があります。Shiny アプリのデバッグは、エラーの発生している場所が明確がないことが多いため簡単にはいきません。そのため、データの加工と可視化のコードが問題なく動くようにしてからサーバー関数を作り始められると理想的です。

そのため、ユーザーの入力に応じて変化するエピカーブを表示するアプリを作る状況では、これを通常の R スクリプトで実行するにはどのようなコードが必要かを考える必要があります。必要な工程は：

1. パッケージの読み込み
2. データの読み込み
3. データの加工
4. ユーザーの入力に応じてデータを可視化する<ul>関数</ul>の作成

このリストは非常にわかりやすく、それほど難しいことではないはずです。ここで重要なのは、このプロセスのうち、どの部分が<ul>一度だけ</ul>実行が必要で、どの部分が<ul>ユーザーの入力に応じて</ul>実行が必要なのかを考えることです。なぜなら、Shiny アプリは一般的には実行される前にコードの一部分が一度だけ実行されるためです。大部分のコードをこの一度だけ実行される部分に移動することができれば、アプリのパフォーマンスが大きく改善するでしょう。この例では、データとパッケージの読み込みと基本的なデータの加工は一度だけしか必要ありません。そのため、これらのコードを<ul>サーバー関数の外</ul>に置くことができます。これが意味するところは、サーバー関数の中に必要なコードは可視化に関するコードだけということです。まず、これらの構成要素をすべてスクリプトとして開発してみましょう。しかし、今回は関数を使ってデータを可視化しているので、<ul>可視化をする関数のコード</ul>をサーバー関数の外に置くことで、アプリの実行時に関数が実行環境中に存在するようにすることもできます。

最初に、データを読み込みましょう。新しいプロジェクトで作業を行っていることと、そのデータをキレイな形にしたいので、新しい data というディレクトリを作成してマラリアデータをそこに保存しましょう。次の、最終的にはアプリの構造を整える際に削除するテスト用のコードを実行してください。

```{r, echo = TRUE}
pacman::p_load("tidyverse", "lubridate")

# read data
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

print(malaria_data)


```


Tidy な形のデータで作業する方が楽にとりくめるため、このデータを縦持ちのデータに変換する必要があります。年齢群が列になり、ケースも別の列になpivotingる形です。[Pivoting data](#pivoting)のページで学んだようにこの処理は簡単にできます。 


```{r, echo = TRUE}

malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")

print(malaria_data)

```

これでデータの準備は終了しました！これで、「テスト用の R スクリプト」の項目１、２、３を終えたことになります。最後の、そして最も難しいタスクが、ユーザーが指定したパラメータを利用してエピカーブを描画する関数作成です。以前にもお伝えしたように、shiny を学ぶ全ての人が関数型プログラミングのセクション（[関数の作成](#writing-functions)）を一読して、これがどのように動作するのかを理解しておくことを<ul>強く推奨します</ul>！

関数を定義する際に、どのパラメータを含みたいかを考えることは難しいかもしれません。Shiny における関数型プログラミングでは、全てのパラメータは一般的にはそれに関連したウィジェットがあるずです。そのため、これは通常すごく簡単です！現在とりくんでいるアプリを例にすると、地区でデータを絞り込めるようにしたいのですが、そのためのウィジェットはあります。そのため、これを反映する地区のパラメータを足しましょう。（現状では、）施設で絞り込む機能は<ul>ない</ul>ので、これをパラメータとして追加する必要はありません。次の三つのパラメータを含む関数を作るところからはじめましょう！

1. 核となるデータセット
2. 選んだ地区
3. 選んだ年齢区分

```{r}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}

```


この関数の働きは比較的単純なため、関数の詳細な解説には踏み込みません。一点だけ注意することとしては、エラーを発生させないために `NULL` を返すことで対応しているということです。これは、shiny サーバー関数がグラフオブジェクトではなくて `NULL` オブジェクトを生成すると ui には何も表示されないからです！この処理を行わなければアプリは頻繁に動きを止めてしまうため、この処理を入れることは大切です。

追加で注意するべき点としては、地区のインプットを評価する場合の`%in%` 演算子の利用です。前述の通り、入力は複数の値を含む文字ベクトルとなる可能性があります。そのため、`%in%` の方が、`==` より柔軟に対応できます。

それでは、関数をテストしてみましょう！

```{r, echo = TRUE, warning = FALSE}

plot_epicurve(malaria_data, district = "Bolo", agegroup = "malaria_rdt_0-4")

```

関数がうまく動作した後は、これらの機能がどのようにして shiny アプリに組み込まれていくのかを理解する必要があります。「スタートアップコード」<!--nishida: 注釈がいらなければ削除します。-->（訳者注：サーバー関数の外にコードをおいて実行を1回だけに制限する）の概念を前述しました。この概念をここではどのように実際にアプリに組み込むのかを見ていきましょう。これを行う方法は二通りあります！

1. このコードを<ul>app.R</ul>ファイルの一番最初（UI の前）におく、か
2. global.R という名前の新しいファイルをアプリのディレクトにおいて、スタートアップコードをそのファイルの中に記述する

特筆すべき点としては、一般的には大きいアプリでは二つ目の方法をとることがより楽です。この方法は、簡単にファイル構造をシンプルな方法で分割することができるからです。それでは、ここでは global.R スクリプトを完成させてみましょう。次のような形になるはずです：


```{r, eval = F}
# global.R スクリプト

pacman::p_load("tidyverse", "lubridate", "shiny")

# データの読み込み
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

# データをキレイにして縦持ちデータへ変換する
malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")


# グラフの描画をする関数を定義する
plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  # グラフのタイトルを作成する
  if (!("All" %in% district)) {            
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  # 年齢群で抽出する
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}



```


簡単ですね！Shiny の良い点の一つは、<ul>app.R</ul>、<ul>servver.R</ul>、<ul>ui.R</ul>、<ul>global.R</ul>と名前がついたファイルを認識してくれることです。そのため、これらのファイルを関係させるためのコードを一切書く必要がありません。このコードを<ul>global.R</ul>に直接記載しておくだけで、アプリの開始時に自動的に実行されます！

また、アプリの構成はグラフの描画をする関数を別の独自のファイルに移動させると改善します。これは、アプリが大きくなると非常に役立ちます。これをするには、funcs という名前の別のディレクトリを作成して<ul>plot_epicurve.R</ul>という名前のファイルを作成してそこに関数を保存します。その後、<ul>global.R</ul>から次のコードを利用して関数を読み込みましょう。

```{r, eval = F}

source(here("funcs", "plot_epicurve.R"), local = TRUE)

```

注：Shiny アプリでは常に`local = TRUE` と設定しなくてはなりません。なぜなら、サーバー上にアプリを公開した際ソースの動作に影響を及ぼすからです。

## アプリのサーバー関数を作成する

大半のコードが出来上がったので、残りはサーバー関数を作るだけです。これはアプリの最後のパーツです。そして最も理解することが難しいでしょう。サーバー関数は大規模な R の関数ですが、より小さい関数、あるいは、アプリの機能の集合体であると考えると理解しやすいかもしれません。これらの関数が頭から順番に実行されるわけではないということを理解することが大切です。それらには実行される順番はありますが、shiny においてはいつ実行が開始されるかを完全に理解する必要はありません。非常に基本的な理解としては、タスクあるいは関数は、ユーザーが<ul>特別にそうでないようにふるまう設定を行った状況を除き</ul>、それらに影響を与えるインプットに何か変更が加えられた時に動き始めます。繰り返しになりますが、この説明は非常に抽象的ですが、とりあえず基本的な3つの shiny <ul>オブジェクト</ul>を解説していきましょう。

1. リアクティブソース - これはユーザーインプットの別の呼び方です。shiny サーバー関数は作成したウィジェットを通じて UI の出力を受け取ることができます。UI の値が変更されるたびに、その出力がサーバー関数に渡されます。

2. リアクティブコンダクター - これは shiny サーバー関数の中で<ul>しか</ul>存在しない関数です。単純なアプリでは必要ではありませんが、他の処理で利用されるサーバー関数のなかでしか利用できないオブジェクトを作成します。一般的にはリアクティブコンダクターはリアクティブソースに依存します。

3. エンドポイント - これはサーバー関数から UI に渡されるアウトプットです。ここで作成しているアプリの例では、エピカーブが該当します。

これらのオブジェクトを念頭に置いて、サーバー関数を順番に作成していきましょう。参考のためにもう一度 UI のコードを表示しておきます：

```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # 地区を選択するウィジェット
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # 年齢群を選択するウィジェット
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # エピカーブはここに描画
      plotOutput("malaria_epicurve")
    )
    
  )
)


```

この UI のコードは次のものを含みます：

- インプット二つ:
  - 地区の選択用ウィジェット（`select_district` という inputId）
  - 年齢の選択用ウィジェット（`select_agegroup`という inputId）
- アウトプット一つ:
  - エピカーブ（`malaria_epicurve`というoutputId）

以前ものべたように、インプットとアウトプットに設定したユニークな（重複がない）名前（inputId と outputId）は必須です。これらは、<ul>ユニークである必要</ul>があり、 UI と サーバー関数の間の情報のやり取りに利用されます。サーバー関数の中では、`input$inputID` という構文でインプットを参照することができ、`output$outputID` という構文にアウトプットを渡すことができます。このことを理解することは難しいので、まずは例を見てみましょう！

```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
}


```


今回のような単純なアプリのサーバー関数は非常にわかりやすいです！サーバー関数は三つのパラメーター ― 
`input`、`output`、`session`（これは現時点ではそれほど重要ではありませんが、これを含むことは大切です！） ― をもつ関数であることに気づきましたか？こんかいのサーバー関数のタスクは一つだけです。それは、先に作成した関数とサーバー関数の `input` に基づいてグラフを描画することです。インプットとアウトプットオブジェクトの名前がUI で設定したものと完全に一致していることに注意してみてください。

サーバー関数がユーザーのインプットにどのように反応するかの基本を理解するためには、インプットの変化をアウトプットが（基礎となるパッケージを通じて）理解し、インプットが変化するたびに、この関数を再実行してグラフが作成されることに注意する必要があります。ここでは、`renderPlot()` 関数も使用していることに注意してください。これは、これらのオブジェクトを ui アウトプットに渡すクラス固有の関数群の1つです。似たような動作をする関数はいくつかありますが、使用する関数が ui に渡すオブジェクトのクラスと一致していることを確認する必要があります。例えば：

- `renderText()` - ui にテキストを送る
- `renderDataTable` - ui にインタラクティブなテーブルを送る。

これらは、UI で使用されるアウトプット<ul>関数</ul>と一致する必要があることを覚えておいてください。つまり、`renderPlot()` は `plotOutput()` と対になり、`renderText()` は `textOutput()` と対になります。

やっとちゃんと機能するアプリをつくることができました！ Rstudio のスクリプトウィンドウの右上にある「Run App」ボタンを押して実行することができます。 また、アプリを（Rstudio ではなく）デフォルトのブラウザで実行するように選択することもできます。ブラウザで実行することで他の人にどのように見えるかがより正確に反映されます。  


```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_simple_view.gif"))
```


R コンソールでは、アプリが「反応を待っている」状態になっているのが楽しいですね。なにか入力してみましょう！

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "listening.png"))
```


<!-- TO DO: *ADD SOMETHING ON DOWNLOADING A ZIP FILE OF THE APP?*  -->


## もっと沢山の機能を追加する

この時点で、ようやくアプリが動き出しましたが、機能はほとんどありません。また、shiny ができることのほんの一部しか知ることができていません。このアプリに、さらに機能を追加していきましょう。追加すると良い機能は次のようなものです：

1. いくつかの説明文
2. グラフをダウンロードするためのボタン - これにより、ユーザーにアプリで生成した画像の高画質版を提供します
3. 特定の施設を指定できるウィジェット
4. ダッシュボードの追加ページ - ここにはデータの表を掲載しましょう

追加することはたくさんありますが、これを通して shiny の様々な機能を学ぶことができます。Shiny について学ぶことは本当に沢山あります（Shiny は非常に<ul>高度</ul>なものになる可能性もありますが、皆さんが使い方の理解を深めれば、外部の学習ソースをより快適に使用できるようになることを期待しています。).



### 静的なテキストの追加 {.unnumbered}  

まず、shiny アプリに静的なテキストを追加することについて考えましょう。基本的な知識を一度身につければ、アプリに静的なテキストを追加することはものすごく簡単です。静的なテキストは shiny アプリの中で変化しないため、一般的には静的なテキストはアプリの ui に記載されます（もし、テキストの内容を変化させたければ、<ul>テキストレンダリング</ul>関数をサーバー関数内で利用しましょう）。ここでは詳しく説明しませんが、R を *HTML* や *css* と連携させることで、UI に様々な要素を追加することができます（カスタム要素の追加も可能です）。

HTML や css は、ユーザーインターフェイスのデザインに明示的に関わる言語です。これらを深く理解する必要はありませんが、*HTML* は UI のオブジェクト（テキストボックスやテーブルなど）を作成し、<ul>css</ul> は一般的にそれらのオブジェクトのスタイルや見た目を変更するために使用されます。 Shiny は膨大な数の<ul>HTML タグ</ul>にアクセスできます。これらは、ヘッダー、テキストの段落、改行、テーブルなど、特定の方法で動作するオブジェクトとして存在します。これらは、次のように利用できます：

- `h1()` - これは *見出し* のタグです。これにより、囲まれたテキストが自動的に大きくなり、フォントフェイスや色などのデフォルトが変更されます（アプリの全体的なテーマに応じて変更されます）。`h2()`から `h6()`までどんどん副見出しを小さくしていくこともできます。使用例はこんな感じです：
  * `h1("ヘッダー - セクション 1")`

- `p()` - これは、*段落*のタグです。これは、囲まれたテキストを、テキスト本文と同様にするものです。このテキストは自動的に折り返され、比較的小さなサイズで表示されます。（フッターは、もっと小さいかもしれません。）ワード文書のテキスト本文のようなものだと思ってください。使用例はこのような形です:  

  * `p("これは、私が自分のアプリの機能を説明するためのテキストです。")`
  
- `tags$b()` と `tags$i()` - これらはテキストが中に記載された場合に、太字 `tags$b()` や斜体 `tags$i()` で表現されます。

- tags$ul()`、`tags$ol()`、`tags$li()` - これらは、*リスト*を作成する際に使用されるタグです。 これらはすべて以下の構文で使用され、ユーザーは順序付きのリスト（`tags$ol()`； 数字がふられている）か、順序なしのリスト（`tags$ul()`、中点がつけられている)を作成できます。tags$li()`は、どちらのタイプのリストであっても、リスト内の項目を表すのに使われます。 例：

```{r, eval = F}

tags$ol(
  
  tags$li("Item 1"),
  
  tags$li("Item 2"),
  
  tags$li("Item 3")
  
)

```

- `br()` と `hr()` - これらのタグは、*改行*と*水平線* (改行あり)を作成します。アプリやテキストのセクションを区切るのに使いましょう！これらのタグにアイテムを渡す必要はありません（括弧は空のままでかまいません）。


- `div()` -これは、何でも含むことができる*汎用*のタグで、*好きな名前*にすることができます。UI の設計が進むと、これらを利用して UI を区分けしたり、特定のセクションに特定のスタイルを与えたり、サーバーと UI 要素の間に相互作用を持たせたりすることができます。 詳細は省きますが、知っておいて損はありません。

なお、これらのオブジェクトはすべて、`tags$...`でアクセスできますし、いくつかは関数として呼び出すだけでアクセスできるものもあります。これらは事実上、同義語ですがが、より明確に、誤って関数を上書きしないようにしたい場合には、`tags$...`スタイルを使用するとよいでしょう。また、これは利用可能なタグのすべてを網羅しているわけではありません。シャイニーで利用可能なすべてのタグの完全なリストは [ここ](https://shiny.rstudio.com/articles/tag-glossary.html)にあり、また、HTML を直接 UI に挿入することで、さらに多くの機能を利用することもできます。


自信のある方は、HTMLタグの`style`引数に、任意の *cssスタイリング要素*を追加することもできます。この仕組みについては詳しく説明しませんが、UI の視覚的特性をテストするためのヒントとして、chrome（あるいは、ブラウザで実行しているshiny アプリ）の HTML インスペクタモードを使用して、オブジェクトのスタイルを自分で編集するという方法があります！

アプリにテキストを追加してみましょう

```{r, eval = F}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         h4("Options"),
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
    tags$ul(
      tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
      tags$li(tags$b("data_date"), " - the date the data were collected at"),
      tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
      tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
      tags$li(tags$b("District"), " - the district the data were collected at"),
      tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
      tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
    )
    
  )
)
)



```

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_text_view.png"))
```


### リンクの追加 {.unnumbered}

リンクを貼るには、`tags$a()`にリンクと表示テキストを入れて、以下のように使います。独立した段落を表示するには`p()`の中に記載します。文章中の数語をリンクとして表示させたい場合は、ハイパーリンクとなる部分に`tags$a()`を使用します。 リンクを<ul>新しい</ul>ブラウザウィンドウで開くようにするには、引数として`target = "_blank"`を追加してください。  

```{r, eval=F}
tags$a(href = "www.epiRhandbook.com", "Visit our website!")
```



### ダウンロードボタンを追加する {.unnumbered}

それでは、3つの機能のうち2つ目の機能を紹介しましょう。ダウンロードボタンは、アプリに追加するものとしてはかなり一般的なもので、簡単に作ることができます。ui  に別のウィジェットを追加し、サーバーに別のoutputを追加してそれと結合する必要があります。また、この例では、 <ul>リアクティブコンダクター</ul>を追加します。


まずは ui を更新しましょう。Shiny には `downloadButton()` というウィジェットがあるためこれは簡単です。これに inputId とラベルを追加しましょう。

```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # 地域のセレクター
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = FALSE
         ),
         # 年齢のセレクター
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # 水平線
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # エピカーブはここに表示されます
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```
 
`hr()` タグを追加したことに注意してください。これは、ダウンロードウィジェットを操作ウィジェットから分離させる水平線を追加します。これは、先に紹介した HTML タグの一つです。

ui が準備できたので、サーバー関数に要素を追加しなければなりません。ダウンロードは、サーバー関数内の `downloadHandler()` 関数を利用して行われます。図でやったように、ダウンロードボタンと同じ inputId をもつ output に割り当てなければなりません。この関数は引数を二つ必要とします。`filename` と `content` です。これら二つとも関数として指定します。推測することが可能かもしれませんが、`filename` はダウンロードするファイルの名前を指定し、`content` は何がダウンロードするかを指定します。`content` はローカル環境に保存するデータを含みます。そのため、 csv ファイルをダウンロードする場合は、`rio::export()` を利用します。ここでは、図をダウンロードするので、`ggplot2::ggsave() `を利用します。これをどのようにプログラムするか見ていきましょう（サーバーにはまだ追加しません）。

```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
  output$download_epicurve <- downloadHandler(
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```


なお、`content` 関数は常に `file` という引数を取り、出力するファイルを指定された場所に保存します。また、ここではコードを繰り返していることに気づいたかもしれません。`plot_epicurve()` 関数をサーバー関数内で、ダウンロードのためと描画のために二回利用しています。このことはアプリのパフォーマンスを劇的に低下させるようなことはありませんが、ユーザーが地区と年齢の設定をウィジェットから変更した場合<ul>と</ul>、ダウンロードをした場合にコードが実行されてしまいます。大規模なアプリでは、このような最適でないコードが繰り返されることで、じょじょにアプリ全体が重くなっていきます。そのため、この観点からアプリをより効率化する方法を学んでおくことは推奨されます。この方法をより理解しやすく言い換えるとすると、地区／年齢が変更されたときにエピカーブを描画するコードを実行させて、 renderPlot() と downloadHandler() 関数に<ul>その結果を利用させる</ul>ということです。ここで、リアクティブコンダクターが登場します！

リアクティブコンダクターは shiny サーバー関数内のリアクティブなオブジェクトです。しかし、それは出力はされません。ただ、サーバー関数内の別の部分に利用されるだけです。<ul>リアクティブコンダクター</ul>には沢山の種類がありますが、ここでは、基本となる二種類だけを見ていきます。

1.`reactive()` - これが最も基本的なリアクティブコンダクターです。これはこの中の input が変更されるたびに反応します（今作成しているアプリでの例では地区／年齢を指定するウィジェットです）。  
2. `eventReactive()`- これは `reactive()` と同様な機能をもつリアクティブコンダクターです。違う点は、どの input がこれを反応させるかを指定できるという点です。これは、リアクティブコンダクターの処理に時間がかかるような場合に便利ですが、後で詳しく説明します。  

二つの例をみてみましょう：

```{r, eval = FALSE}

malaria_plot_r <- reactive({
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})


# 地区の選択が変更されたときにのみ実行
malaria_plot_er <- eventReactive(input$select_district, {
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})



```

`eventReactive()` を使う場合、どの input がこの関数ないのコードを実行させるかを指定できます。今の状況ではそれほど便利ではないので、置いておきましょう。注：`c()` を利用して複数の input を指定することもできます。

この機能をサーバー関数内に組み込む方法を見てみましょう：


```{r, eval = FALSE}

server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  })
  
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```

ダウンロード関数とプロットレンダリング関数の両方で reactive で定義したものの結果を呼び出しているだけであることがわかります。注意しなければならない、多くの人が引っかかるのが、 reactive の結果の使い方で、関数のように利用しなければならないということです。呼び出すには、<ul>空のカッコを最後につける</ul>ことが必須です（例：`malaria_plot()`は正しく、`malaria_plot` は間違いです）。この部分を追加したことで、アプリは少し整理され、速くなり、epicurve 関数を実行するすべてのコードが一つの場所にあるため、変更も容易になりました。


```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "download_button_view.png"))
```


### 施設の選択を追加する {.unnumbered}  

次の機能に進みましょう。施設を選択するためのセレクターの追加です。`plot_epicurve` 関数が、施設を選択した結果を受け取ることができるように、別のパラメターをとれるように実装していきます。これは、別のパラメターでやったことを繰り返せばよいです。新しくして、テストしてみましょう。


```{r, echo = TRUE}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot", facility = "All") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
    if (!("All" %in% facility)) {
    data <- data %>%
      filter(location_name == facility)
    
    plot_title_facility <- facility
    
  } else {
    
    plot_title_facility <- "all facilities"
    
  }
  
  # データが残っていなければNULLを返す
  if (nrow(data) == 0) {
    
    return(NULL)
  }

  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}; {plot_title_facility}"),
      subtitle = agegroup_title
    )
  
  
  
}
```

試して見ましょう：

```{r, warning=F, message=F}

plot_epicurve(malaria_data, district = "Spring", agegroup = "malaria_rdt_0-4", facility = "Facility 1")

```


全ての施設がデータに含まれているため、どの地区にどの施設が含まれているかは明確ではありません。これは、ユーザーももちろん同様です。このことは、このアプリの利用をひどく不親切なものとするかもしれません。そのため、ユーザーが地区を選択すると、施設の UI の内容が動的に変化するようにするべきです。選択肢として使用する変数が非常に多いので、ui の選択肢の一部を、<ul>global.R</ul> ファイルの中でデータから生成してもいいかもしれません。例えば、次のようなコードを <ul>global.R</ul> ファイルのデータを読み込んだ部分の後に追加してもよいでしよう：



```{r, , message =  FALSE}

all_districts <- c("All", unique(malaria_data$District))

# 地区毎の施設名
facility_list <- malaria_data %>%
  group_by(location_name, District) %>%
  summarise() %>% 
  ungroup()

```

眺めてみましょう：

```{r}
all_districts
```


```{r}
facility_list
```


この新しい変数は、サーバー関数と ui から見える状態となっているため、ui に特に問題なく渡すことができます。UI も更新しておきましょう：


```{r, eval = FALSE}


ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # 地区の選択
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = all_districts,
              selected = "All",
              multiple = FALSE
         ),
         # 年齢の選択
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # 施設の選択
         selectInput(
           inputId = "select_facility",
           label = "Select Facility",
           choices = c("All", facility_list$location_name),
           selected = "All"
         ),
         
         # 水平線
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # エピカーブ
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```


選択肢を UI の中に直接記載（ハードコーディング）するのではなく、変数を利用して指定していることに注目してください。これにより、コードがよりコンパクトになる可能性もあります。最後に、サーバー関数を更新しましょう。新しい入力を取り込むために関数を更新するのは簡単ですが（新しいパラメータに引数として渡すだけです）、ユーザーが選択した地区を変更したときに UI を動的に更新することも忘れてはなりません。ここで理解していただきたいのは、アプリの実行中にウィジェット<ul>のパラメータや動作を変更する</ul>ことはできますが、これは<ul>サーバー関数</ul>の中で行う必要があるということです。この方法を学ぶためには、サーバーに出力する新しい方法を理解する必要があります。

この方法を理解するために必要な関数は、<ul>observer</ul> 関数と呼ばれ、その振る舞いは <ul>reactive</ul> 関数と似ています。しかし、この二つには重要な違いが一つあります。

- reactive 関数は出力に直接影響を与えず、サーバー関数内の他の場所で呼び出すことができるオブジェクトを生成します
- observer 関数は サーバー関数の output に影響を与えることが<ul>できます</ul>が、それは他の関数の副作用によって行われます（他のこともできますが、実際にはこれが主な機能です）。

reactive 関数と同様に、oserver 関数にも二つの種類があり、reacive 関数と同じ仕組みで分けられています。

1. `observe()` - この関数は、内部で使用されている input が変化するたびに実行されます。
2. `observeEvent()` - この関数は<ul>設定された input</ul> が変化する度に実行されます。

Shiny で提供されているウィジェットを更新する関数についての理解も必要です。これらは、かなり簡単に実行できます。サーバー関数の `session` オブジェクト（今は理解できなくても問題ありません）を一つ目の引数としてとしてとり、二つ目に変更したい ui の `inputId`をとります。 そして、`selectInput()`によってすでに利用されているすべてのパラメータの更新された新しいバージョンを渡します。そのことにより、ウィジェットは自動的に更新されます。 

この機能をサーバー関数内で使用する場合の、例を見てみましょう。ユーザーが地区を変更した場合、施設の一覧を地区別に抽出し、選択肢を<ul>その地区で利用可能なものだけとする</ul>ように更新します（すべての施設を選択することもできます）。

```{r, eval = FALSE}

observe({
  
  if (input$select_district == "All") {
    new_choices <- facility_list$location_name
  } else {
    new_choices <- facility_list %>%
      filter(District == input$select_district) %>%
      pull(location_name)
  }
  
  new_choices <- c("All", new_choices)
  
  updateSelectInput(session, inputId = "select_facility",
                    choices = new_choices)
  
})


```

完成しました！これをサーバー関数内に足すことができ、動作します。新しいサーバー関数は次のようになっているはずです：

```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  
  
}

```


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_menu_view.gif"))
```







### 表を含んだタブを追加する {.unnumbered}

次に、アプリに追加したい最後の要素に移りましょう。 アプリの ui を二つのタブに分割します。一つのタブにはエピカーブを描画しているデータをインタラクティブに確認することができる表を挿入します。そのためには、タブに関連した、shiny に付属するパッケージ化された ui 要素を利用します。基本的には、この一般的な構造の中に、メインパネルのほとんどを収めることができます。

```{r, eval = FALSE}


# ... は残りのui部分を表す

mainPanel(
  
  tabsetPanel(
    type = "tabs",
    tabPanel(
      "Epidemic Curves",
      ...
    ),
    tabPanel(
      "Data",
      ...
    )
  )
)


```

この構造を今作成している ui に当てはめましょう。また、ここでは**DT**パッケージを使用しましょう。 - これは、既存のデータからインタラクティブな表を作成するための素晴らしいパッケージです。この例では、`DT::datatableOutput()`で使用されているのを見ることができます。

```{r, echo = FALSE}
library(DT)
```

```{r, eval = FALSE}
ui <- fluidPage(
     
     titlePanel("Malaria facility visualisation app"),
     
     sidebarLayout(
          
          sidebarPanel(
               # 地区の選択
               selectInput(
                    inputId = "select_district",
                    label = "Select district",
                    choices = all_districts,
                    selected = "All",
                    multiple = FALSE
               ),
               # 年齢の選択
               selectInput(
                    inputId = "select_agegroup",
                    label = "Select age group",
                    choices = c(
                         "All ages" = "malaria_tot",
                         "0-4 yrs" = "malaria_rdt_0-4",
                         "5-14 yrs" = "malaria_rdt_5-14",
                         "15+ yrs" = "malaria_rdt_15"
                    ), 
                    selected = "All",
                    multiple = FALSE
               ),
               # 施設の選択
               selectInput(
                    inputId = "select_facility",
                    label = "Select Facility",
                    choices = c("All", facility_list$location_name),
                    selected = "All"
               ),
               
               # 水平線
               hr(),
               downloadButton(
                    outputId = "download_epicurve",
                    label = "Download plot"
               )
               
          ),
          
          mainPanel(
               tabsetPanel(
                    type = "tabs",
                    tabPanel(
                         "Epidemic Curves",
                         plotOutput("malaria_epicurve")
                    ),
                    tabPanel(
                         "Data",
                         DT::dataTableOutput("raw_data")
                    )
               ),
               br(),
               hr(),
               p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
               tags$ul(
                    tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
                    tags$li(tags$b("data_date"), " - the date the data were collected at"),
                    tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
                    tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
                    tags$li(tags$b("District"), " - the district the data were collected at"),
                    tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
                    tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
               )
               
               
          )
     )
)


```


これで、アプリがタブを持つ形になりました！サーバー関数にも必要な編集を加えてみましょう。表としてレンダリングする前にデータを加工する必要がないので、これは非常に簡単です。malaria_data データを DT::renderDT() 経由で ui に描画するだけです！


```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  # データテーブルをuiに描画する
  output$raw_data <- DT::renderDT(
    malaria_data
  )
  
  
}


```


```{r, out.width=c('100%', '100%'), fig.show='hold', echo = F, fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_table_view.gif"))
```


## shiny アプリの共有

アプリが完成したので、他の人と共有したいと思うこともあるでしょう。これが shiny の最大の利点です。そのためには、コードを直接共有することもできますし、サーバーで公開することもできます。コードを共有すれば、他の人があなたのやったことを見て、それに基づいてさらに機能を構築することができますが、これは shiny の主な利点の1つを否定することになります。Shiny は、<ul>ユーザーがRを維持する必要をなくすことができます。</ul>このため、 R が苦手なユーザーとアプリを共有する場合は、サーバーで公開されているアプリの方がはるかに簡単に共有できます。

もし、コードを直接共有したいのであれば、アプリの .zip ファイルを作成するか、あるいは、<ul>github にアプリを公開して、協力者を追加することもできます。</ul> 詳細は<!--nishida:リンクの付け忘れ？-->こちらのgithubのセクションを参照してください。

しかし、アプリをオンラインで公開する場合は、もう少し作業が必要です。最終的には、あなたのアプリをウェブ  URL からアクセスできるようにして、他の人が素早く簡単に到達できるようにしたいと思います。残念ながら、アプリをサーバーで公開するには、公開するためのサーバーが必要です！これに関しては、いくつかのホスティングするための選択肢があります。

- <ul>shinyapps.io</ul>：ここは shiny アプリを公開するのに最も簡単な場所です。設定の量は最小限です。無料でも利用できますが、いくつかの制限があります。

- <ul>RStudio Connect</ul>：これは、Rサーバーのはるかに強力なバージョンで、Shiny アプリの公開を含む多くの操作を行うことができます。しかし、使い方が難しく、初めての方にはあまりお勧めできません。

本書では、初めての方でも利用しやすいように、<ul>shinyapps.io</ul> を使用します。無料のアカウントを作成してスタートすることもできますし、また、必要に応じてサーバーの増設などの料金プランもあります。利用するユーザー数が増えれば増えるほど、料金プランも高額になる可能性がありますので、ご注意ください。少数が使用するためのものだけを作りたい場合は、無料のライセンスが最適かもしれませんが、一般向けのアプリの場合はより高額のライセンスが必要になるかもしれません。

まず、アプリがサーバーでの公開に適していることを確認します。Rセッションを再起動して、余分なコードを実行せずにアプリが実行されることを確認してください。アプリが、コードで定義されていないパッケージのロードやデータの読み取りを必要とする場合、サーバー上で実行されないため、このことは非常に重要です。また、アプリ内では<ul>明示的な</ul>ファイルパスを持つことができないことにも注意してください。サーバーの環境では、これらはエラーの原因になります。`here` パッケージを使用することで、この問題は非常によく解決されます。最後に、組織のサーバーなど、ユーザー認証を必要とするソースからデータを読み取る場合は、一般的にサーバー上では動作しません。Shiny サーバーをホワイトリストに登録する方法については、IT部門と相談する必要があります。

<ul>アカウントへのサインアップ</ul>

アカウントを取得したら、<ul>Accounts</ul>にあるトークンのページに移動できます。ここでは、新しいトークンを追加します。これは、アプリのデプロイ<!--nishida：後に訳者注としてデプロイの説明を追加したい-->に使用されます。 

ここからは、アカウントのURLにアプリの名前が反映されることに注意してください。つまり、アプリの名前が「my app」であれば、URLは「xxx.io/my_app/」となります。アプリの名前は賢く選びましょう！全ての準備が完了です。デプロイをクリックしましょう。成功していれば、選んだ url でアプリが実行されているはずです。

*something on making apps in documents?*<!--nishida:ここの訳が思いつきませんでした。-->

## 参考資料

ここまでは、shiny の様々な側面を紹介してきましたが、shiny の機能の「さわり」に触れただけです。このガイドは入門編ですが、shiny を完全に理解するためには、さらに多くのことを学ぶ必要があります。アプリを作り始めて、徐々に機能を増やしていくのが良いでしょう。


## 推奨される機能を拡張するパッケージ

以下に、高品質な shiny の機能を拡張できるパッケージを集めました。順番にとくに意味はありません：

- **shinyWidgets** - このパッケージは、アプリで使用できるウィジェットを追加で多数提供します。`shinyWidgets::shinyWidgetsGallery()`を実行すると、このパッケージで利用可能なウィジェットのセレクションが表示されます。 例は [ここ](https://github.com/dreamRs/shinyWidgets)にあります。  

- **shinyjs** - これは、javascript を利用することで shiny の実用性を大幅に向上させることができる優れたパッケージです。このパッケージの用途は非常にシンプルなものから高度なものまで様々ですが、まずは要素の非表示/表示、ボタンの有効化/無効化など、簡単な方法で UI を操作するために使ってみてはいかがでしょうか。[ここ](https://deanattali.com/shinyjs/basic)により沢山の例があります。

- **shinydashboard** - このパッケージは、shiny で使用可能な UI を大幅に拡張し、特に、様々な複雑なレイアウトのダッシュボードを作成できるようにします。[ここ](https://rstudio.github.io/shinydashboard/)に詳細があります。

- **shinydashboardPlus** - **Shinydashboard**フレームワークの機能をさらに充実させます！ [ここ](https://rinterface.github.io/shinydashboardPlus/articles/shinydashboardPlus.html)で詳しく内容を確認できます。

- **shinythemes** - 豊富なテンプレートを利用して、 Shiny アプリのデフォルト CSS テーマを変更できます。 詳細は[ここ](https://rstudio.github.io/shinythemes/)


Shiny に対応したインタラクティブな出力を作成するために使用できるパッケージも多数あります。 

- **DT** は base-shiny に半統合されていますが、インタラクティブなテーブルを作成するための素晴らしい関数群を提供しています。

- **plotly** は、ユーザーがアプリで操作できるインタラクティブなグラフを作成するためのパッケージです。 また、`plotly::ggplotly()`を使って、プロットをインタラクティブなバージョンに変換することもできます。**dygraphs**と**highcharter**も同様に優れています。


## 推奨されるリソース



