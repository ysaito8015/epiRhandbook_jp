# 関数の作成 {#writing-functions}

<!-- ======================================================= -->

## 準備

### パッケージの読み込み {.unnumbered}

このコードチャンクは、分析に必要なパッケージの読み込みを示しています。このハンドブックでは **pacman** の `p_load()` を重視しています。`p_load()` は必要に応じてパッケージをインストールし、使用するために読み込みます。インストールされたパッケージは R の **base** パッケージの `library()` でも読み込めます。R のパッケージに関する詳細は [R の基礎](#basic) のページをご覧ください。

```{r, echo=F, warning=F, message=F}
pacman::p_load(
  rio,          # ファイルのインポート
  here,         # ファイルロケータ
  skimr,        # データの概要の把握
  tidyverse,    # データマネジメントとggplot2によるグラフィックス 
  gtsummary,    # 要約統計と検定
  janitor,      # テーブルに合計値とパーセンテージを加える
  scales,       # 割合をパーセンテージに簡単に変換  
  flextable,     # テーブルをhtmlに変換
  purrr,          # 関数プログラミングを容易にする
  readr,          # csvファイルの読み込み
  highcharter     # HighChartオブジェクトを作成し、特定のプロットを描く
  )
```

### データのインポート {.unnumbered}

エボラ流行熱のシミュレーションケースのデータセットをインポートします。データをダウンロードし同じように行いたい場合、\[ハンドブックとデータのダウンロード\](#data-used) ページをご覧ください。このデータセットは **rio** パッケージの `import()` 関数を使ってインポートされます。データをインポートする様々な方法については [データのインポート・エクスポート](#importing) をご覧ください。

また、このページの最後では、2013年のH7N9インフルエンザのデータを使用します。

```{r, echo=F}
# linelistをRに取り込む
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

flu_china <- rio::import(here::here("data", "case_linelists", "fluH7N9_China_2013.csv"))

```

## 関数

関数はコードを理解しやすく、短く、エラーを起こしにくくすることができるため、プログラミングにおいて役立ちます(関数自体にエラーがない場合)。

このハンドブックをここまで読んでくださった方は、無数の関数に出会ったことになります。というのも、Rでは `+, for, if, [, $, { …` と、すべての操作が関数呼び出しになるからです。例えば、 `x + y` は `'+'(x, y)` と同じです。

Rは、関数を扱う可能性が最も高い言語の1つであり、ユーザが簡単に関数を書けるように十分なツールを提供しています。私たちはプログラミングチェーンの最初から最後までを考える必要はなく、Rではこれらをベクトルのように使用したり、他の関数やリストの中で使用することもできます。

関数型プログラミングに関する非常に高度な資料は数多く存在しますが、ここでは短い実用的な例を用いて、関数型プログラミングを始めるためのヒントを提供するにとどめます。その後、参考文献のリンクを参照して、さらに詳しい情報を得ることをお勧めします。

## なぜ関数を使うのか?

この質問に答える前に、このハンドブックの [ループと反復処理・リストの操作](#iteration) のページで、最初のR関数を書くためのヒントをすでに得ていることにに気付くことが重要です。実際、if/else や loops の使用は、関数の中で多くの機能の中核をなしています。なぜなら、複数の条件を可能にすることでコードの適用範囲を広げたり、反復作業のためにコードを繰り返したりするのに役立つからです。

-   同じコードブロックを複数回繰り返して、別の変数やデータに適用するか？

-   これを取り除くことで、コード全体が大幅に短縮され、実行速度が速くなるか？

-   書いたコードが再び使用されるが、コードの多くの場所で異なる値が使用されている可能性はあるか？

前述の質問の答えが YES であれば、おそらく関数を書く必要があるでしょう。

## R でどのように関数を作成するか?

Rの関数は主に3つの要素で構成されています:

-   関数の呼び出し方を制御する引数のリストである`formals()`。

-   関数内のコードである`body()`、つまり大括弧の中や括弧の後など、書き方に応じた要素です。

-   `environment()` は、関数の変数を見つけたり、関数がどのように値を見つけるかを決定するのに役立ちます。

関数を作成したら、関連する関数を呼び出すことで、これらの各構成要素を検証することができます。

## 基本的な構文と構造

-   関数には適切な名前を付ける必要があり、名前を読んだだけでその内容が容易に理解できるようにしなければなりません。実際、Rの基本的な関数の大部分ですでに実現されています。`mean()`、`print()`、`summary()` のような関数は、非常にわかりやすい名前となっています。

-   関数には、処理するデータや静的な値を取ることができるオブジェクトなどの引数が必要です。

-   そして最後に、関数はその中核となるタスクと与えられた引数に基づいて出力を行います。通常、出力を得るためには、`print()` や `return()` などの組み込み関数を使用します。出力は、論理値、数値、文字、データフレームなど、要するにあらゆる種類のRオブジェクトです。

基本的にこちらが関数の構成です:

```{r, eval=FALSE}

function_name <- function(argument_1, argument_2, argument_3){
  
           function_task
  
           return(output)
}


```

`contain_covid19()` という名前の最初の関数を作ります。

```{r}

contain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){
  
                            if(barrier_gest == "yes" & wear_mask == "yes" & get_vaccine == "yes" ) 
       
                            return("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


```

そして、新しく作成した関数のコンポーネントを検証します。

```{r}

formals(contain_covid19)
body(contain_covid19)
environment(contain_covid19)

```

では、作成した関数をテストしてみましょう。作成した関数を呼び出すには、他のR関数と同様に、関数名を記述し、必要な引数を追加します。

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "yes")

```

念のため、各引数の名前をもう一度書いておくことも出来ます。しかし、それらを指定しなくても、Rは各引数の位置を記憶しているので、このコードは動作するはずです。つまり、引数の値を正しい順序で書く限り、関数を呼び出すときに引数の名前を省略できるのです。

```{r}

contain_covid19("yes", "yes", "yes")

```

次に、片方の値が `"no"` または **not** `"yes"` の場合はどうなるかを見てみましょう。

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "no")
```

認識されない引数を与えると、エラーが発生します:

```{r, eval=F}
contain_covid19(barrier_gest = "sometimes", wear_mask = "yes", get_vaccine = "no")
```

`Error in contain_covid19(barrier_gest = "sometimes", wear_mask = "yes",  :    could not find function "contain_covid19"`

[***備考:*** 関数の中には、名前を必要としないものもあり、コード上で直接使用したり、他の関数の中で使用したりして、簡単な作業を行うことができます(多くは非常に短くわかりやすい関数です)。 これらは **無名関数** と呼ばれています。]{style="color: black;"}

例えば、以下は、データセットの文字変数のみを保持する最初の無名関数です。

```{r, eval=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #Rの基本関数である "head " に相当し，データセットの最初のn個の観測データを返す
  select(function(x) is.character(x)) 
```

```{r, echo=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #Rの基本関数である "head " に相当し，データセットの最初のn個の観測データを返す
  select(function(x) is.character(x)) %>%  
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

次に、2つ目の観測データを選択する関数です(例えば、患者ごとに多くのレコードを持つ縦断的データがある場合、日付や訪問で順番に並べた後などに適切なことがあります)。 この場合、dplyrの外部で書く適切な関数は、すべての行番号を含むベクトルに適用する `function (x) (x%%2 == 0)` となります。

```{r, eval=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>% #最終的な選択を明確にするために、各観測のインデックスを行名として追加する
   filter(row_number() %%2 == 0)
```

```{r, echo=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>% #最終的な選択を明確にするために、各観測のインデックスを行名として追加する
   filter(row_number() %%2 == 0) %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```

base R だと以下のように書くことができます:

```{r, eval = F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]
```

```{r, echo=F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),] %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```

[***注意:*** 関数を使うことがコードの手助けになるのは事実ですが、十分に考えず適切に書かれていない場合、結果としてエラーを返し、書いたり修正したりするのに時間がかかることがあります。そのため、まずRのコードを書き、それが意図したとおりに動作することを確認してから、上記のような3つの主要な要素を持つ関数に変換することが推奨されます。]{style="color: orange;"}

## 例

### それぞれの列の割合を返す {.unnumbered}

確かに、多くのパッケージには、情報を非常に簡単かつ良い方法で要約することができる素晴らしい関数がすでにあります。しかし、私たちは関数を書くことに慣れるための最初のステップとして自分で作ってみることにします。

この例では、シンプルな関数を書くことで、同じコードを何度もコピーペーストする必要がないことを示したいと思います。

```{r}

proptab_multiple <- function(my_data, var_to_tab){
  
  #表にする前に各変数の名前を表示する
  print(var_to_tab)

  with(my_data,
       rbind( #次の2つの関数の結果を行ごとに結合する
        #関心のある変数を表にする: 数値のみ
          table(my_data[[var_to_tab]], useNA = "no"),
          #興味のある変数ごとに比率を計算し、その値を小数第2位に丸める
         round(prop.table(table(my_data[[var_to_tab]]))*100,2)
         )
       )
}


proptab_multiple(linelist, "gender")

proptab_multiple(linelist, "age_cat")

proptab_multiple(linelist, "outcome")


```

[***ヒント:*** 以上のように、一般的なプログラミングと同様に、関数にコメントを付けることが非常に重要です。関数の目的は、コードを読みやすく、短く、効率的にすることであることを覚えておいてください。関数の名前を読んだだけで、その関数が何をするのか理解できるようにし、コメントを読むことでより詳細な情報を得られるようにします。]{style="color: darkgreen;"}

もう一つの方法は、この関数をループを介して使用し、一度に処理を行うことです。:

```{r}


for(var_to_tab in c("gender","age_cat",  "outcome")){
  
  print(proptab_multiple(linelist, var_to_tab))
  
}

```

よりシンプルな方法としては、"for loop" の代わりに base R の "apply" を使用することで、以下のように表現できます:

```{r, include= FALSE, eval=FALSE}

base::lapply(linelist[,c("gender","age_cat", "outcome")], table)

```

[***ヒント:*** Rは関数型プログラミング言語として定義されており、コードを実行する際にはほとんどの場合、組み込み関数を使用しています。関数の書き方に慣れるための良い習慣は、日常的に使用している基本的な関数がどのように作られているかを内部的に確認することです。そのためのショートカットは、関数名を選択してから `Ctrl+F2` または `fn+F2` または`Cmd+F2`(お使いのコンピュータによって異なります)をクリックすることです。]{style="color: darkgreen;"}

## **purrr** の使用: 繰り返し利用可能な関数の作成

### データセット内の複数のカラムのクラスを変更する {.unnumbered}

例えば、分析やプロットのために、元の `linelist` データに含まれる多くの文字変数を "factor" に変更する必要があるとします。このようなステップを何度も繰り返す代わりに、`lapply()`を使えば、1行のコードですべての変数の変換を行うことができます

[***注意:*** lapply()\`はリストを返すので、使用の際には最後のステップとして追加の修正が必要になるかもしれません。]{style="color: orange;"}

```{r, include=FALSE}

linelist_factor1 <- linelist %>%
      lapply(
          function(x) if(is.character(x)) as.factor(x) else x) %>%
      as.data.frame() %>% 
      glimpse()

```

同じことは **purrr** パッケージの `map_if()` 関数を使って行うことができます。

```{r}

linelist_factor2 <- linelist %>%
  purrr::map_if(is.character, as.factor)


linelist_factor2 %>%
        glimpse()

```

### 異なる変数で繰り返しグラフを作成する {.unnumbered}

ここでは、中国でH7N9が発生した際の患者の転帰の分布を各省ごとに見ていくための円グラフを作成します。それぞれにコードを繰り返すのではなく、これから作成する関数を適用するだけです。

```{r}

#highchartを使用するためのオプションの設定
options(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))


#"chart_outcome_province"という関数を作成する。この関数はデータセットと、結果の分布をプロットする州の名前を引数として取る。

chart_outcome_province <- function(data_used, prov){
  
  tab_prov <- data_used %>% 
    filter(province == prov,
           !is.na(outcome))%>% 
    group_by(outcome) %>% 
    count() %>%
    adorn_totals(where = "row") %>% 
    adorn_percentages(denominator = "col", )%>%
    mutate(
        perc_outcome= round(n*100,2))
  
  
  tab_prov %>%
    filter(outcome != "Total") %>% 
  highcharter::hchart(
    "pie", hcaes(x = outcome, y = perc_outcome),
    name = paste0("Distibution of the outcome in:", prov)
    )
  
}

chart_outcome_province(flu_china, "Shanghai")
chart_outcome_province(flu_china,"Zhejiang")
chart_outcome_province(flu_china,"Jiangsu")


```

### 異なる変数で繰り返しテーブルを作成する {.unnumbered}

ここでは、3つの指標を作成して表にまとめ、この表を各州ごとに作成したいと思います。指標は、発症から入院までの期間、回復の割合、症例の年齢の中央値です。

```{r}


indic_1 <- flu_china %>% 
  group_by(province) %>% 
  mutate(
    date_hosp= strptime(date_of_hospitalisation, format = "%m/%d/%Y"),
    date_ons= strptime(date_of_onset, format = "%m/%d/%Y"), 
    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,
    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%
  select(province, mean_delay_onset_hosp)  %>% 
  distinct()
     

indic_2 <-  flu_china %>% 
            filter(!is.na(outcome)) %>% 
            group_by(province, outcome) %>% 
            count() %>%
            pivot_wider(names_from = outcome, values_from = n) %>% 
    adorn_totals(where = "col") %>% 
    mutate(
        perc_recovery= round((Recover/Total)*100,2))%>% 
  select(province, perc_recovery)
    
    
    
indic_3 <-  flu_china %>% 
            group_by(province) %>% 
            mutate(
                    median_age_cases = median(as.numeric(age), na.rm = TRUE)
            ) %>% 
  select(province, median_age_cases)  %>% 
  distinct()

#3つの指標データセットの結合

table_indic_all <- indic_1 %>% 
  dplyr::left_join(indic_2, by = "province") %>% 
        left_join(indic_3, by = "province")


#指標を flextable で表示する


print_indic_prov <-  function(table_used, prov){
  
  #まず、表示しやすいようにデータフレームを少し変換する
  indic_prov <- table_used %>%
    filter(province==prov) %>%
    pivot_longer(names_to = "Indicateurs", cols = 2:4) %>% 
   mutate( indic_label = factor(Indicateurs,
   levels= c("mean_delay_onset_hosp","perc_recovery","median_age_cases"),
   labels=c("Mean delay onset-hosp","Percentage of recovery", "Median age of the cases"))
   ) %>% 
    ungroup(province) %>% 
    select(indic_label, value)
  

    tab_print <- flextable(indic_prov)  %>%
    theme_vanilla() %>% 
    flextable::fontsize(part = "body", size = 10) 
    
    
     tab_print <- tab_print %>% 
                  autofit()   %>%
                  set_header_labels( 
                indic_label= "Indicateurs", value= "Estimation") %>%
    flextable::bg( bg = "darkblue", part = "header") %>%
    flextable::bold(part = "header") %>%
    flextable::color(color = "white", part = "header") %>% 
    add_header_lines(values = paste0("Indicateurs pour la province de: ", prov)) %>% 
bold(part = "header")
 
 tab_print <- set_formatter_type(tab_print,
   fmt_double = "%.2f",
   na_str = "-")

tab_print 
    
}




print_indic_prov(table_indic_all, "Shanghai")
print_indic_prov(table_indic_all, "Jiangsu")


```

## 関数をよりよく使うためのヒントとベストプラクティス

関数型プログラミングは、コードを簡単にし、その読み取りを容易にするためのものです。それはつくるべきものです。以下のヒントは、きれいなコードと読みやすいコードを持つことに役立つでしょう。

### 名付けと構文 {.unnumbered}

-   あなたの環境に存在する他の関数に容易に取られてしまう可能性のある名前の使用は避けてください。

-   関数名は短く、他の方が理解しやすいようにすることをお勧めします。

-   関数名には動詞を使い、引数名には名詞を使うのが好ましいです。

### カラム名と整頓された評価 {.unnumbered}

引数としてコードに与えられた[列名]{.ul}を参照する方法を知りたい場合は、こちらの[tidyverse programming guidance](https://dplyr.tidyverse.org/articles/programming.html)を読んでください。トピックの中には、[整然とした評価]{.ul}と[包括演算子]{.ul} `{{ }}` (二重括弧)の使用が含まれています。

例えば、こちらが上で引用したチュートリアルにある、簡単に中を確認できるテンプレートコードです:

```{r, eval=F}

var_summary <- function(data, var) {
  data %>%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %>% 
  group_by(cyl) %>% 
  var_summary(mpg)

```

### テストとエラー処理 {.unnumbered}

関数のタスクが複雑であればあるほど、エラーが発生する可能性は高くなります。そのため、エラーの原因がどこにあるのかを素早く理解し、修正方法を見つけるために、関数内で検証を加えることが必要な場合があります。

-   `missing(引数)`を用いて引数の欠落を確認することは推奨されています。この簡単な確認は "TRUE" もしくは "FALSE" を返します。

```{r , error=TRUE}

contain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){
  
  if (missing(barrier_gest)) (print("please provide arg1"))
  if (missing(wear_mask)) print("please provide arg2")
  if (missing(get_vaccine)) print("please provide arg3")


  if (!barrier_gest == "yes" | wear_mask =="yes" | get_vaccine == "yes" ) 
       
       return ("you can do better")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_missing(get_vaccine = "yes")

```

-   より検出可能なエラーには、`stop()`を使用します。

```{r, error=TRUE}

contain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){
  
  if(!is.character(barrier_gest)) (stop("arg1 should be a character, please enter the value with `yes`, `no` or `sometimes"))
  
  if (barrier_gest == "yes" & wear_mask =="yes" & get_vaccine == "yes" ) 
       
       return ("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_stop(barrier_gest=1, wear_mask="yes", get_vaccine = "no")

```

-   ほとんどの組み込み関数を実行すると分かるように、特定の条件でポップアップするメッセージや警告があります。関数 `message()` や `warning()` を使って、これらを自分の書いた関数に組み込むことができます。

-   関数を引数にとり，それを安全な方法で実行する`safely()`を使うことで，エラーを処理することもできます。実際，この関数は，エラーが発生しても停止することなく実行されます。`safely()`は出力として、結果とスキップしたエラーの2つのオブジェクトを持つ**list**を返します。

まず`mean()`を関数として実行し、次に`safely()`で実行することで検証できます。

```{r, warning=FALSE}

map(linelist, mean)
```

```{r, warning=FALSE}
safe_mean <- safely(mean)
linelist %>% 
  map(safe_mean)

```

先ほど述べたように、コードにコメントをつけることは、私たちの仕事を文書化するための良い方法です。

<!-- ======================================================= -->

## 資料

[R for Data Science link](https://r4ds.had.co.nz/functions.html)

[Cheatsheet advance R programming](https://www.rstudio.com/wp-content/uploads/2016/02/advancedR.pdf)

[Cheatsheet purr Package](https://purrr.tidyverse.org/)

[Video-ACM talk by Hadley Wickham: The joy of functional programming (how does map_dbl work)](https://youtube.videoken.com/embed/bzUmK0Y07ck)
