# R Basics {.tabset .tabset-fade}

<!-- ======================================================= -->
## Overview

**This section is not meant as a comprehensive "learn basic R" tutorial**. However, it does cover some of the fundamentals that can be useful for reference or for refreshing your memory. 

See the tab on recommended training for more comprehensive tutorials.  

```{r, echo=F}
# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))
pacman::p_load(apyramid)
```

<!-- ======================================================= -->
## Why use R?

As stated on the [R project website](https://www.r-project.org/about.html), R is a programming language and environment for statistical computing and graphics. It is highly versatile, extensible, and community-driven.  

**Cost**

R is free to use! There is a strong ethic in the community of free and open-source material.  

**Reproducibility**  

Conducting your data management and analysis through a programming language (compared to Excel or other primarily manual tool) enhances **reproducibility**, makes **error-detection** easier, and eases your workload.  

**Community**  

The broad R community is enormous and collaborative. New packages and tools are developed daily, and vetted by the community. Perhaps the largest organization of R users is [R-Ladies](https://rladies.org/), which likely has a chapter near you.   




<!-- ======================================================= -->
## Installation {#install .tabset .tabset-fade }

**How to install R**  

Visit this website [https://www.r-project.org/](https://www.r-project.org/) and download the latest version of R suitable for your computer.  

**How to install R Studio**  

Visit this website [https://rstudio.com/products/rstudio/download/](https://rstudio.com/products/rstudio/download/) and download the latest free Desktop version of RStudio suitable for your computer.

**How to update R and RStudio**  


**Other things you may need to install:**  

* TinyTeX (*for compiling an RMarkdown document to PDF*)  
* Pandoc  (*for compiling RMarkdown documents*)  
* RTools  (*for building packages for R*)  


### TinyTex {.tabset .tabset-fade }

TinyTex is a custom LaTeX distribution, useful when trying to produce PDFs from R.  
See [https://yihui.org/tinytex/](https://yihui.org/tinytex/)  

To install from R:  

```{r, eval=F}
install.packages('tinytex')
tinytex::install_tinytex()
# to uninstall TinyTeX, run tinytex::uninstall_tinytex()
```


### Pandoc {.tabset .tabset-fade }

Pandoc is a document converter, a separate software from R. **It comes bundled with RStudio.** It helps the process of converting Rmarkdown documents to formats like .pdf and adding complex functionality.  


### RTools {.tabset .tabset-fade }

RTools is a collection of software for building packages for R

Install from this website: [https://cran.r-project.org/bin/windows/Rtools/](https://cran.r-project.org/bin/windows/Rtools/)  




<!-- ======================================================= -->
## RStudio {#rstudio .tabset .tabset-fade }


### RStudio Orientation
**First, open RStudio.** As their icons can look very similar, be sure you are opening *RStudio* and not R.  


For RStudio to function you must also have R installed on the computer (see [this section](#install) for installation instructions).  

**RStudio** is an interface (GUI) for easier use of **R**. You can think of R as being the engine of a vehicle, doing the crucial work, and RStudio as the body of the vehicle (with seats, accessories, etc.) that helps you actually use the engine to move forward!  

By default RStudio displays four rectangle panes. 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```


<span style="color: black;">**_TIP:_** If your RStudio displays only one left pane it is because you have no scripts open yet.</span>


**The R Console Pane**  

The R Console, by default the left or lower-left pane in R Studio, is the home of the R "engine". This is where the commands are actually run and non-graphic outputs and error/warning messages appear. You can directly enter and run commands in the R Console, but realize that these commands are not saved as they are when running commands from a script.  

If you are familiar with Stata, the R Console is like the Command Window and also the Results Window.

**The Source Pane**  
This pane, by default in the upper-left, is space to edit and run your scripts. This pane can also display datasets (data frames) for viewing.  

For Stata users, this pane is similar to your Do-file and Data Editor windows.


**The Environment Pane**  
This pane, by default the upper-right, is most often used to see brief summaries of objects in the R Environment in the current session. These [objects](#objects) could include imported, modified, or created datasets, parameters you have defined (e.g. a specific epi week for the analysis), or vectors or lists you have defined during analysis (e.g. names of regions). Click on the arrow next to a dataframe name to see its variables.  

In Stata, this is most similar to Variables Manager window.


**Plots, Packages, and Help Pane**  
The lower-right pane includes several tabs including plots (display of graphics including maps), help, a file library, and available R packages (including installation/update options).  

This pane contains the Stata equivalents of the Plots Manager and Project Manager windows.

### RStudio settings  

Change RStudio settings and appearance in the *Tools* drop-down menu, by selecting *Global Options*. There you can change the default settings, including appearance/background color.  

```{r basics_RStudio, out.width = "75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_tools_options.png"))
```



<!-- ======================================================= -->
## Scripts {#scripts .tabset .tabset-fade }

Scripts are a fundamental part of programming. Storing your code in a script (vs. typing in the console) has many advantages:  

* Reproducibility  
* Version control  
* Commenting  


<!-- ======================================================= -->
### Rmarkdown {#rmd .tabset .tabset-fade }

Rmarkdown is a type of script in which the script itself *becomes* a document (PDF, Word, HTML, Powerpoint, etc.). See the handbook page on Rmarkdown documents.  


<!-- ======================================================= -->
### R notebooks {#rnotebooks .tabset .tabset-fade }

There is no difference between writing in a Rmarkdown vs an R notebook. However the execution of the document differs slightly. See this [site](http://uc-r.github.io/r_notebook) for more details.

<!-- ======================================================= -->
### R Shiny {#shinyscripts .tabset .tabset-fade }

Shiny apps are contained within one script, which must be named `app.R`. This file has three components:  

1) A user interface (ui)  
2) A server function  
3) A call to the `shinyApp` function  

See the handbook page on Shiny basics, or this online tutorial: [Shiny tutorial](https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/)

*In older times, the above file was split into two files (`ui.R` and `server.R`)*




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Working directory {#workingdirectory}

**The working directory is the root folder location used by R for your work - where R looks for and saves files by default.**  

By default, it will save new files and outputs to this location, and will look for files to import (e.g. datasets) here as well.  

The working directory appears in grey text at the top of the RStudio Console pane. You can also return the current working directory with `getwd()` (do not put anything in the parentheses).  

*NOTE: If using an R project, the working directory will default to the R project root folder **IF** you open RStudio by clicking open the R project (the file with .rproj extension))*



<!-- ======================================================= -->
### Filepaths  

Perhaps the most common source of frustration for an R beginner on a Windows machine - typing in a filepath to import data.  

1) Use **here** - Avoid these problems altogether by using relative pathways from the root of an R project that uses the **here** package. See the **here** tab in this Basics page for more details.  

2) **Slashes** - If typing in a filepath, beware the direction of the slashes. Enter them using *forward slashes* to separate components ("data/provincial.csv"). For Windows users, the default way that filepaths are displayed and copied is with *backslashes* ("\\") - so this means you must go change the direction of each slash. Or just use **here** and an R project as noted above.  

3) Avoid using "absolute" paths - these are "full address" paths that direct to the same place regardless of the user's working directory. For example:  

```
C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  
```
This path **will break** if the script is sent to someone on another computer! Instead, consider using an R project and having the filepath begin at that root directory (i.e. the working directory of the R project).  

One possible exception is if working in a larger organization where you need to pull data from across several networked drives and don't have permission to re-save the data in your R project. This can get tenuous, but it may be best to use these full absolute filepaths.  




<!-- ======================================================= -->
### Set by command

Use the command `setwd()` with the filepath in quotations, for example: `setwd("C:/Documents/R Files")`


<span style="color: orange;">**_CAUTION:_** If using an RMarkdown script be aware of the following:</span>

In an [R Markdown](#rmarkdown) script, the default working directory is the folder the Rmarkdown file (`.Rmd`) is saved to. If you want to change this, you can use `setwd()` as above, but know the change will only apply to that specific code chunk.  

To change the working directory for all code chunks in an R markdown, edit the setup chunk to add the `root.dir = ` parameter, such as below:

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/filepath/here')
```


<!-- ======================================================= -->
### Set Manually

Setting your working directory manually (point-and-click)  

From RStudio click: Session / Set Working Directory / Choose Directory (you will have to do this each time you open RStudio)


<!-- ======================================================= -->
### In an R project

If you are working in an R project, your working directory will by default be the root folder. This is convenient to maximize with the **here** package (LINK).  





<!-- ======================================================= -->
## Objects {#objects .tabset .tabset-fade }

Everything in R is an object. These sections will explain:  

* How to create objects (`<-`) 
* Types of objects (e.g. data frames, vectors..)  
* How to access subparts of objects (e.g. variables in a dataset)  
* Classes of objects (e.g. numeric, logical, integer, double, character, factor)  



<!-- ======================================================= -->
### Everything is an object 

Everything you store in R - datasets, variables, a list of village names, a total population number, even outputs such as graphs - are **objects** which are **assigned a name** and **can be referenced** in later commands.  

An object exists when you have assigned it a value (see the assignment section below). When it is assigned a value, the object appears in the Environment (see the upper right pane of RStudio). It can then be operated upon, manipulated, changed, and re-defined.



<!-- ======================================================= -->
### Defining objects (`<-`)

**Create objects *by assigning them a value* with the <- operator.**  
You can think of the assignment operator `<-` as the words "is defined as". Assignment commands generally follow a standard order:
 
**object_name**  <-  **value** (or process/calculation that produce a value)

> **EXAMPLE:** You may want to record the current epidemiological reporting week as an object for reference in later code. In this example, the object `reporting_week` is created when it is assigned the character value `"2018-W10"` (the quote marks make these a character value).  
The object `reporting_week` will then appear in the RStudio Environment pane (upper-right) and can be referenced in later commands.  


See the R commands and their output in the boxes below. 

```{r basics_objects_assignment}
reporting_week <- "2018-W10"   # this command creates the object reporting_week by assigning it a value
reporting_week                 # this command prints the current value of reporting_week object in the console
```

<span style="color: black;">**_NOTE:_** Note the `[1]` in the R console output is simply indicating that you are viewing the first item of the output</span>


<span style="color: orange;">**_CAUTION:_** **An object's value can be over-written** at any time by running an assignment command to re-define its value. Thus, the **order of the commands run is very important**.</span>

The following command will re-define the value of `reporting_week`: 

```{r basics_objects_reassignment}
reporting_week <- "2018-W51"   # assigns a NEW value to the object reporting_week
reporting_week                 # prints the current value of reporting_week in the console
```

**Datasets are also objects ("dataframes") and must be assigned names when they are imported.**  

In the code below, the object `linelist` is created and assigned the value of a CSV file imported with the **rio** package.  

```{r basics_objects_dataframes, eval=FALSE}
# linelist is created and assigned the value of the imported CSV file
linelist <- rio::import("my_linelist.csv")
```

You can read more about importing and exporting datasets with the section on [importing data](#importdata).

<span style="color: orange;">**_CAUTION:_** A quick note on naming of objects:</span>

  * Object names must not contain spaces, but you should use underscore (_) or a period (.) instead of a space.  
  * Object names are case-sensitive (meaning that Dataset_A is different from dataset_A). 
  * Object names must begin with a letter (cannot begin with a number like 1, 2 or 3). 

 

<!-- ======================================================= -->
### Object structure {#objectstructure}  

**Objects can be a single piece of data (e.g. `my_number <- 24`), or they can consist of structured data.**  

The graphic below, sourced from [this online R tutorial](http://venus.ifca.unican.es/Rintro/dataStruct.html) shows some common data structures and their names. Not included in this image is spatial data, which is discussed in the [GIS section](#gis).  


```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```  

In epidemiology (and particularly field epidemiology), you will *most commonly* encounter data frames and vectors:  


Common structure | Explanation | Example
------------------- | ------------------------------------ | ------------------------  
Vectors | A container for a sequence of singular objects, all of the same class (e.g. numeric, character). | **"Variables" (columns) in data frames are vectors** (e.g. the variable `age_years`).  
Data Frames | Vectors (e.g. columns) that are bound together that all have the same number of rows. | `linelist` is a data frame.  

Note that to create a vector that "stands alone", or is not part of a data frame (such as a list of location names), the function `c()` is often used:  

`list_of_names <- c("Ruhengeri", "Gisenyi", "Kigali", "Butare")`  


<!-- ======================================================= -->
### Object classes  {#objectclasses}

All the objects stored in R have a *class* which tells R how to handle the object. There are many possible classes, but common ones include:

Class |	Explanation | Examples
------ | ------------------------------------------ |  -----------------------------
Character	| These are text/words/sentences **"within quotation marks"**. Math cannot be done on these objects.	| "Character objects are in quotation marks"  
Integer | Numbers that are **whole only** (no decimals) | -5, 14, or 2000  
Numeric	| These are numbers and **can include decimals**. If within quotation marks the will be considered character. | 23.1 or 14  
Factor | These are vectors that have a **specified order** or hierarchy of values | Variable `msf_involvement` with ordered values N, S, SUB, and U.  
Date | **Once R is told that certain data are Dates**, these data can be manipulated and displayed in special ways. See the page on Dates for more information. | 2018-04-12 or 15/3/1954 or Wed 4 Jan 1980  
Logical | Values must be one of the two special values TRUE or FALSE (note these are **not** "TRUE" and "FALSE" in quotation marks) | TRUE or FALSE  
data.frame | A data frame is how R stores a **typical dataset**. It consists of vectors (columns) of data bound together, that all have the same number of observations (rows). | The example AJS dataset named `linelist_raw` contains 68 variables with 300 observations (rows) each.  

**You can test the class of an object by feeding it to the function `class()`**. Note: you can reference a specific column within a dataset using the `$` notation to separate the name of the dataset and the name of the column.

```{r basics_objects_class, echo=TRUE, eval=T}
class(linelist$age)     # class should be numeric

class(linelist$gender)  # class should be character
```

Sometimes, a column will be converted to a different class automatically by R. Watch out for this! For example, if you have a vector or column of numbers, but a character value is substituted in... the entire column will change to class character.  

One common example is when working with a dataframe to print a table - if you make a total row and try paste/glue together percents in the same cell as numbers the entire columns above them will convert to character and can no longer be used for mathematical calculations.

```{r}
num_vector <- c(1,2,3,4,5) # define vector as all numbers
class(num_vector)          # vector is numeric class
num_vector[3] <- "three"   # convert the third element to a character
class(num_vector)          # vector is now character class
```


**Sometimes, you will need to convert objects or columns to another class.**

Function | Action  
----------------- | --------------------------------------------------------------    
`as.character()` | Converts to character class  
`as.numeric()` | Converts to numeric class  
`as.integer()` | Converts to integer class
`as.Date()` | Converts to Date class - Note: see section on [dates](#dates) for details  
`as.factor()` | Converts to factor - Note: re-defining order of value levels requires extra arguments

likewise, there are **base** R functions to check whether an object IS of a specific class, such as `is.numeric()`, `is.character()`, `is.double()`, `is.factor()`, `is.integer()`

Here is [more online material on classes and data structures in R](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/).


<!-- ======================================================= -->
### Columns/Variables (`$`) {#dollarsign}  

A column in a dataframe is known as a "vector", or a sequence of values that must all the same class
**Vectors within a data frame (variables in a dataset) can be called, referenced, or created using the `$` symbol.** The `$` symbol connects the name of the column to the name of its data frame. The `$` symbol must be used, otherwise R will not know where to look for or create the column.  

In this handbook, we use the word "column" instead of "variable".  


```{r basics_objects_call, eval=F}
# Retrieve the length of the vector age_years
length(linelist$age) # (age is a variable in the linelist data frame)

```

By typing the name of the data frame followed by `$` you will also see a list of all variables in the data frame. You can scroll through them using your arrow key, select one with your Enter key, and avoid spelling mistakes!  

```{r basics_objects_callGIF, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```  



<span style="color: darkgreen;">**_ADVANCED TIP:_** Some more complex objects (e.g. an `epicontacts` object may have multiple levels which can be accessed through multiple dollar signs. For example `epicontacts$linelist$date_onset`) .</span>



<!-- ======================================================= -->
### Access/index with brackets (`[]`) {#brackets}  

You may need to view parts of objects, also called "indexing", which is often done using the square brackets `[ ]`. Note: using `$` on a dataframe to access a column is also a type of indexing.  

```{r}
my_vector <- c("a", "b", "c", "d", "e", "f")  # define the vector
my_vector[5]                                  # print the 5th element
```

Square brackets also work to return specific parts of an returned output, such as output of a `summary()` function: 

```{r}
# All of the summary
summary(linelist$age)

#Just one part
summary(linelist$age)[2]  
```

To view specific rows and columns of a dataset, you can do this using the syntax `dataframe[rows, columns]`:  

```{r basics_objects_access, eval=F}
# View a specific row (2) from dataset, with all columns
linelist[2,]

# View all rows, but just one column
linelist[, "date_onset"]

# View values from row 2 and columns 5 through 10
linelist[2, 5:10] 

# View values from row 2 and columns 5 through 10 and 18
linelist[2, c(5:10, 18)] 

# View rows 2 through 20, and specific columns
linelist[2:20, c("date_onset", "outcome", "age")]

# View rows and columns based on criteria
# *** Note the dataframe must still be names in the criteria!
linelist[linelist$age > 25 , c("date_onset", "date_birth", "age")]

# Use View() to see the outputs in the RStudio Viewer pane (easier to read) 
# *** Note the capital "V" in View() function
View(linelist[2:20, "date_onset"])

# Save as a new object
new_table <- linelist[2:20, c("date_onset")] 
```

When indexing an object of class **list**, single brackets always return with with class list, even if only a single object is returned. Double brackets, however, can be used to access a single element and return a different class than list.  
Brackets can also be written after one another, as demonstrated below.  

This [visual explanation with pepper shakers](https://r4ds.had.co.nz/vectors.html#lists-of-condiments) is humorous and helpful.

```{r}
# define demo list
my_list <- list(
  # First element in the list is a character vector
  hospitals = c("Central", "Empire", "Santa Anna"),
  
  # second element in the list is a dataframe of addresses
  address   = data.frame(
    street = c("145 Medical Way", "1048 Brown Ave", "999 El Camino"),
    city   = c("Andover", "Hamilton", "El Paso")
    )
  )


my_list[1] # this returns the element in class "list"

my_list[[1]] # this is a character vector

my_list[["hospitals"]] # you can also index by name of the list element

my_list[[1]][3] # this returns the third element of the "hospitals" character vector

my_list[[2]][1] # This returns the first column ("street") of the address dataframe

```



<!-- ======================================================= -->
### Remove objects  

You can remove individual objects by putting the name in the `rm()` function (no quote marks):  

```{r, eval=F}
rm(object_name)
```

You can remove all objects (clear your workspace) by running:  

```{r, eval=F}
rm(list = ls(all = TRUE))
```


<!-- ======================================================= -->
## Functions and packages {#functions .tabset .tabset-fade }


This section on functions explains:  

* What a function is and how they work  
* What arguments are  
* What packages are  
* How to get help understanding a function  


<!-- ======================================================= -->
### Simple functions  

**A function is like a machine that receives inputs, does some action with those inputs, and produces an output.**  
What the output is depends on the function.    

**Functions typically operate upon some object placed within the function's parentheses**. 
For example, the function `sqrt()` calculates the square root of a number:  

```{r basics_function_sqrt}
sqrt(49)
```

Functions can also be applied to variables in a dataset. For example, when the function `summary()` is applied to the numeric variable `age` in the dataset `linelist` ([what's the `$` symbol?](#objects)), the output is a summary of the variable's numeric and missing values.

```{r basics_functions_summary}
summary(linelist$age)
```

<span style="color: black;">**_NOTE:_** Behind the scenes, a function represents complex additional code that has been wrapped up for the user into one easy command.</span>



<!-- ======================================================= -->
### Functions with multiple arguments  

Functions often ask for several inputs, called ***arguments***, located within the parentheses of the function, usually separated by commas. 

* Some arguments are required for the function to work correctly, others are optional.  
* Optional arguments have default settings if they are not specified.
* Arguments can take character, numeric, logical (TRUE/FALSE), and other inputs.  


```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```


**For example**, this `age_pyramid()` command produces an age pyramid graphic based on defined age groups and a binary split column, such as `gender`. The function is given three arguments within the parentheses, separated by commas. The values supplied to the arguments establish `linelist` as the data frame to use, `age_cat5` as the column to count, and `gender` as the binary column to use for splitting the pyramid by color.

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE, eval=T}
## create an age group variable by specifying categorical breaks
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

<span style="color: black;">**_NOTE:_** For this example, linelist comes with a pre-created column called "age_cat5". To learn how to create new variable see [that section of this handbook](#newvars) </span>


```{r basics_functions_pyramid, message=FALSE, warning=FALSE, eval=T, out.width = "75%", out.height="75%"}
# Creates an age pyramid by specifying the dataframe, age group variable, and a variable to split the pyramid
apyramid::age_pyramid(data = linelist, age_group = "age_cat5", split_by = "gender")
```

The first half of an argument assignment (e.g. `data = `) does not need to be specified if the arguments are written in a specific order (specified in the function's documentation). The below code produces the exact same pyramid as above, because the function expects the argument order: data frame, `age_group` variable, `split_by` variable.  

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# This command will produce the exact same graphic as above
apyramid::age_pyramid(linelist, "age_cat5", "gender")
```

**A more complex `age_pyramid()` command might include the *optional* arguments to:**  

* Show proportions instead of counts (set `proportional = TRUE` when the default is `FALSE`)  
* Specify the two colors to use (`pal = ` is short for "palette" and is supplied with a vector of two color names. See the [objects](#objectstructure) page for how the function `c()` makes a vector)  


<span style="color: black;">**_NOTE:_** For arguments specified with an equals symbol (e.g. `coltotals = ...`), their order among the arguments is not important (must still be within the parentheses and separated by commas).</span>


```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
apyramid::age_pyramid(linelist, "age_cat5", "gender", proportional = TRUE, pal = c("orange", "purple"))
```




<!-- ======================================================= -->
### Packages {#packages}  

**Packages contain functions.**  

An R package is a shareable bundle of code and documentation that contains pre-defined functions. Users in the R community develop and share packages all the time, so chances are likely that a solution exists for you! You will install and use hundreds of packages in your use of R.  

On installation, R contains **"base"** functions that perform common elementary tasks. But many R users create specialized functions, which are verified by the R community and which you can download as a **package** for your own use. In this handbook, package names are written in **bold**. One of the more challenging aspects of R is that there are often many functions or packages to choose from to complete a given task.  


**Install packages**  

*Functions* are contained within **packages** which can be downloaded ("installed") to your computer from the internet. Once a package is downloaded, you access its functions by loading the package with the `library()` command at the beginning of each R session.

Think of R as your personal library: When you download a package your library gains a book of functions, but each time you want to use a function in that book, you must borrow that book from your library.  


**CRAN**  

CRAN (Comprehensive R Archive Network) is a public warehouse of R packages that have been published by R community members. Most often, R users download packages from CRAN.  



**Install vs. Load**

To use a package, 2 steps must be implemented:  

1) The package must be **installed** (once), *and*  
2) The package must be **loaded** (each R session)  

The basic function for installing a package is `install.packages()`, where the name of the package is provided *in quotes*. This can also be accomplished point-and-click by going to the RStudio "Packages" pane and clicking "Install". 

```{r, eval=F}
install.packages("tidyverse")
```

The basic function to **load** a package for use (after it has been installed) is `library()`, with the name of the package *NOT in quotes*.  

```{r, eval=F}
library(tidyverse)
```



**Using pacman**  

This handbook uses the package **pacman** (abbreviation for "package manager"), which offers the useful function `p_load()`. This function combines the above two steps into one -  it *installs and/or loads packages*, depending on what is needed. If the package has not yet been installed, it will attempt to install from CRAN, and then load it.  

Below, we load some of the packages used in this R basics page:  

```{r}
pacman::p_load(tidyverse, rio, here)
```

The function `p_isinstalled()` will test whether packages are installed already.  




**Install from github**

Sometimes, you need to install the *development version* of a package, from a github repository. You can use `p_load_gh()` from **pacman** (this function is a wrapper around `install_github()` from **devtools**).  

The first name listed in the quotation marks is the Github ID of the repository owner, and after the slash is the name of the repository. If you want to install from a branch other than the main/master branch, add it after an "@".  


```{r, eval=F}
# install development version of package from github repository
p_install_gh("reconhub/epicontacts")

# load development version of package which you had downloaded from github repository
p_load_gh("reconhub/epicontacts")
```

Read more about **pacman** [here](http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html)


**Install from ZIP or TAR**

You could get the package from a URL:  

```{r, eval=F}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

Or download it to your computer in a zipped file:  

Option 1:  

```{r, eval=F}
library(devtools)
install_local("~/Downloads/dplyr-master.zip")
```

Option 2:  

```{r, eval=F}
install.packages(path_to_source, repos = NULL, type="source")

install.packages("~/Downloads/dplyr-master.zip", repos=NULL, type="source")
```




**Delete packages**

Use `p_delete()` from **pacman**, or `remove.packages()` from **base** R. Alternatively, go find the folder which contains your library and manually delete the folder.




**Dependencies**  

Packages often depend on other packages to work. These are called dependencies. If a dependency fails to install, then the package depending on it may also fail to install.  

See the dependencies of a package with `p_depends()`, and see which packages depend on it with `p_depends_reverse()`  


**Masked functions**  

It is not uncommon that two or more packages contain the same function name. For example, the package **dplyr** has a `filter()` function, but so does the package **stats**. The default `filter()` function depends on the order these packages are first loaded in the R session - the later one will be the default for the command `filter()`. 

You can check the order in your Environment pane of R Studio - click the drop-down for "Global Environment" and see the order of the packages. Functions from packages *lower* on that drop-down list will mask functions of the same name in packages that appear highest in the drop-down list. When first loading a package, R will warn you in the console if masking is occurring, but this can be easy to miss.  

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "masking_functions.png"))
```

Here are ways you can fix masking:  

1) Specify the package name in the command. For example, use `dplyr::filter()`  
2) Re-arrange the order in which the packages are loaded (e.g. within `library()` or `p_load()`), and start a new R session  

**Detach / unload**  

To detach a package, use this command, with the correct package name:  

```{r, eval=F}
detach(package:PACKAGE_NAME_HERE, unload=TRUE)
```



**Packages in code**  

For clarity in this handbook, functions are usually preceeded by the name of their package using the `::` symbol in the following way:  
`package_name::function_name()`  

Once a package is loaded for a session, this explicit style is not necessary. One can just use `function_name()`. However giving the package name is useful when a function name is common and may exist in multiple packages (e.g. `plot()`).  
Using the package name will also load the package if it is not already loaded.
 
```{r eval=FALSE}
# This command uses the package "rio" and its function "import()" to import a dataset
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```

**Installing older versions of packages**  

See this [guide](https://support.rstudio.com/hc/en-us/articles/219949047-Installing-older-versions-of-packages)  


**Function help**  

To read more about a function, you can search for it in the Help tab of the lower-right RStudio. You can also run a command like  `?thefunctionname` (put the name of the function after a question mark) and the Help page will appear in the Help pane. Finally, try searching online for resources.  




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Piping (`%>%`) {#piping .tabset .tabset-fade}

**Two general approaches to working with objects are:**  

1) **Tidyverse/piping** - sends an object from function to function - emphasizes the *action*, not the object  
2) **Define intermediate objects** - emphasis the object, as it is re-defined again and again  


<!-- ======================================================= -->
### **Pipes** 

**Simply explained, the pipe operator (`%>%`) passes an intermediate output from one function to the next.**  
You can think of it as saying "then". Many functions can be linked together with `%>%`.  

* **Piping emphasizes a sequence of actions, not the object the actions are being performed on**  
* Best when a sequence of actions must be performed on one object  
* Pipes come from the package **magrittr**, which is automatically included in packages **dplyr** and **tidyverse**
* Makes code more clean and easier to read, intuitive

Read more on this approach in the tidyverse [style guide](https://style.tidyverse.org/pipes.html)  

Example:

```{r piping_example_pipe, eval=F}
# A fake example of how to bake a care using piping syntax

cake <- flour %>%       # to define cake, start with flour, and then...
  left_join(eggs) %>%   # add eggs
  left_join(oil) %>%    # add oil
  left_join(water) %>%  # add water
  mix_together(utensil = spoon, minutes = 2) %>%                # mix together
  bake(degrees = 350, system = "fahrenheit", minutes = 35) %>%  # bake
  let_cool()            # let it cool down
```

Here is another [link](https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations) describing the utility of pipes.  

Piping is not a **base** function. To use piping, the **magrittr** package must be installed and loaded (this is typically done by loading **tidyverse** or **dplyr** package). You can [read more about piping in the magrittr documentation](https://magrittr.tidyverse.org/).

<span style="color: orange;">**_CAUTION:_** Remember that even when using piping to link functions, if the assignment operator (`<-`) is present, the object to the left will still be over-written (re-defined) by the right side.</span>


**`%<>%`**  
This is an "assignment pipe" from the **magritter** package, which pipes an object forward and also re-defines the object. It must be the first pipe operator in the chain. It is shorthand, so `object %<>% function() %>% function()` is the same as `object <- object %>% function() %>% function()`.  


<!-- ======================================================= -->
### Define intermediate objects

This approach to changing objects/dataframes may be better if:  

* You need to manipulate multiple objects  
* There are intermediate steps that are meaningful and deserve separate object names


**Risks:**  

* Creating new objects for each step means creating lots of objects. If you use the wrong one you might not realize it!  
*Naming all the objects can be confusing  
* Errors may not be easily detectable  

Either name each intermediate object, or overwrite the original, or combine all the functions together. All come with their own risks.  

Below are some examples:  


```{r piping_example_redefine, eval=F}
# a fake example of how to bake a cake using this method (defining intermediate objects)
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

Combine all functions together - also difficult to read  

```{r piping_example_wide, eval=F}
# an example of combining/nesting mutliple functions together - difficult to read
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```



<!-- ======================================================= -->
## Key operators and functions {#operators .tabset .tabset-fade }

This section details operators in R, such as:  

* Definitional operators  
* Relational operators (less than, equal too..)  
* Logical operators (and, or...)  
* Handling missing values  
* Mathematical operators and functions (+/-, >, sum(), median(), ...)  
* The `%in%` operator  



<!-- ======================================================= -->
### Assignment operators  

**`<-`**  

The basic assignment operator in R is `<-`. Such that `object_name <- value` (see R Basics tab on "Defining an Object").  
This assignment operator can also be written as `=`. We advise use of `<-` for general R use.  
We also advise surrounding operators with spaces, for readability.  


**`<<-`**  

If writing functions (LINK TO PAGE), or using R in an interactive way with sourced scripts (LINK TO PAGE), then you may need to use this assignment operator `<<-` (**base** R). This operator is used to define an object in a higher 'parent' R `Environment` (LINK to tab on R environments). Also see this [online reference](https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html).


**`%<>%`**  

This is an "assignment pipe" from the **magritter** package, which pipes an object forward and also re-defines the object. It must be the first pipe operator in the chain. It is shorthand, so `object %<>% function() %>% function()` is the same as `object <- object %>% function() %>% function()`.  


**`%<+%`**

Used to add data to phylogenetic trees with the **ggtree** package. See the (LINK TO PAGE) or this online [resource book](https://yulab-smu.top/treedata-book/).  


 

<!-- ======================================================= -->
### Relational and logical operators  

**Relational operators compare values** and are often used when defining new variables and subsets of datasets. Here are the common relational operators in R:  

Function                |Operator     |Example       |Example Result
------------------------|-------------|--------------|---------------------------
Equal to                |`==`         |`"A" == "a"`  |`FALSE` (because R is case sensitive) *Note that == (double equals) is different from = (single equals), which acts like the assignment operator `<-`*
Not equal to            |`!=`         |`2 != 0`      |`TRUE`
Greater than            |`>`          |`4 > 2`       |`TRUE`
Less than               |`<`          |`4 < 2`       |`FALSE`
Greater than or equal to|`>=`         |`6 >= 4`      |`TRUE`
Less than or equal to   |`<=`         |`6 <= 4`      |`FALSE`
Value is missing        |`is.na()`    |`is.na(7)`    |`FALSE` (see section on missing values)
Value is not missing    |`!is.na()`   |`!is.na(7)`   |`TRUE`

**Logical operators, such as AND and OR, are often used to connect relational operators and create more complicated criteria**. Complex statements might require parentheses ( ) for grouping and order of application.  

Function   |Operator
-----------|------------------------
AND        |`&`
OR         |`|` (vertical bar)
Parentheses|`( )` Used to group criteria together and clarify order


For example, below, we have a linelist with two variables we want to use to create our case definition, `hep_e_rdt`, a test result and `other_cases_in_hh`, which will tell us if there are other cases in the household. The command below uses the function `case_when()` to create the new variable `case_def` such that:

```{r basics_operators_casewhen, eval=FALSE}
linelist_cleaned <- linelist_cleaned %>%
  mutate(case_def = case_when(
    is.na(hep_e_rdt) & is.na(other_cases_in_hh)           ~ NA_character_,
    hep_e_rdt == "Positive"                               ~ "Confirmed",
    hep_e_rdt != "Positive" & other_cases_in_hh == "Yes"  ~ "Probable",
    TRUE                                                  ~ "Suspected"
  ))
```

Criteria in example above               | Resulting value in new variable "case_def"
----------------------------------------|-------------------------------------
If the value for variables `hep_e_rdt` and `other_cases_in_hh` are missing | `NA` (missing)  
If the value in `hep_e_rdt` is "Positive" | "Confirmed"  
If the value in `hep_e_rdt` is NOT "Positive" AND the value in `other_cases_in_hh` is "Yes" | "Probable"  
If one of the above criteria are not met | "Suspected"  


*Note that R is case-sensitive, so "Positive" is different than "positive"...*  

 
<!-- ======================================================= -->
### Missing values

**In R, missing values are represented by the special value `NA` (a "reserved" value)** (capital letters N and A - not in quotation marks). If you import data that records missing data in another way (e.g. 99, "Missing", or .), you may want to re-code those values to `NA`.
  
**To test whether a value is `NA`, use the special function `is.na()`**, which returns `TRUE` or `FALSE`.

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # two positive cases, one suspected, and one unknown
is.na(rdt_result)  # Tests whether the value of rdt_result is NA
```

Here is the [R documentation on missing values](https://stat.ethz.ch/R-manual/R-devel/library/base/html/NA.html)  

**Variations on `NA`**  

`NA` is actually a logical value of length 1. You may also encounter `NA_character_`, `NA_real_`, `NA_complex_`, and `NA_integer_`, which correspond to specific classes.  

The most prominent application of one of these variants in common epidemiology work is using `case_when()`. The Right-Hand Side (RHS) values must all be of the same class. Thus, if you have character outcomes on the RHS like "Confirmed", "Suspect", "Probable" and `NA` - you will get an error. Instead of `NA` you must have `NA_character_`. Likewise for integers, use `NA_integer_`.  


**`NULL`**  

`NULL` is the null object in R, often used to represent a list of 0 length. Use `is.null()` to evaluate this status.  

More detail on the difference between `NA` and `NULL` is [here](https://www.r-bloggers.com/2010/04/r-na-vs-null/)  




<!-- ======================================================= -->
### Mathematics and statistics  

All the operators and functions in this page is automatically available using **base** R.  

#### Mathematical operators  

These are often used to perform addition, division, to create new columns, etc. Below are common mathematical operators in R. Whether you put spaces around the operators is not important.  


Objective          |Example in R
-------------------|-------------
addition           | 2 + 3
subtraction        | 2 - 3
multiplication     | 2 * 3
division           | 30 / 5
exponent           | 2^3
order of operations| ( )



#### Mathematical functions

Objective          |Function
-------------------|-------------
rounding           | round(x, digits = n)  
rounding           | janitor::round_half_up(x, digits = n)
ceiling (round up) | ceiling(x)
floor (round down) | floor(x)
absolute value     | abs(x)
square root        | sqrt(x)
exponent           | exponent(x)
natural logarithm  | log(x)

<span style="color: red;">**_DANGER:_** `round()` uses "banker's rounding" which rounds up from a .5 only if the upper number is even. Use `round_half_up()` from **janitor** to consistently round halves up to the nearest whole number. See [this](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes) </span>  

```{r}
# use the appropriate rounding function for your work
round(c(2.5, 3.5))

janitor::round_half_up(c(2.5, 3.5))
```


#### Statistical functions:  

<span style="color: orange;">**_CAUTION:_** The functions below will by default include missing values in calculations. Missing values will result in an output of NA, unless the argument `na.rm=TRUE` is specified</span>


Objective                |Function
-------------------------|----------------------
mean (average)           | mean(x, na.rm=T)
median                   | median(x, na.rm=T)
standard deviation       | sd(x, na.rm=T)
quantiles*               | quantile(x, probs)
sum                      | sum(x, na.rm=T)
minimum value            | min(x, na.rm=T)
maximum value            | max(x, na.rm=T)
range of numeric values  | range(x, na.rm=T)
summmary**               | summary(x)

<span style="color: red;">**_DANGER:_** If providing a vector of numbers to one of the above functions, be sure to wrap the numbers within `c()` .</span>

```{r}
# If supplying raw numbers to a function, wrap them in c()
mean(1, 6, 12, 10, 5, 0)    # !!! INCORRECT !!!  

mean(c(1, 6, 12, 10, 5, 0)) # CORRECT
```

* `quantile()`: x is the numeric vector to examine, and probs is a numeric vector with probabilities within 0 and 1.0, e.g `c(0.5, 0.8, 0.85)`
** `summary()`: gives a summary on a numeric vector including mean, median, and common percentiles



#### Other useful functions:  


Objective                   |Function            |Example
----------------------------|--------------------|-----------------------------------------------
create a sequence           | seq(from, to, by)  |`seq(1, 10, 2)`
repeat x, n times           | rep(x, ntimes)     |`rep(1:3, 2)` or `rep(c("a", "b", "c"), 3)` 
subdivide a numeric vector  | cut(x, n)          |`cut(linelist$age, 5)`




<!-- ======================================================= -->
### `%in%`  

A very useful operator for matching values, and quickly assessing if a value is within a vector or dataframe.   

```{r}
my_vector <- c("a", "b", "c", "d")

"a" %in% my_vector
"h" %in% my_vector
```

To ask if a value is **not** `%in%`, put an exclamation mark (!) **in front** of the logic statement:  

```{r}
# to negate, put an exclamation in front
!"a" %in% my_vector
!"h" %in% my_vector
```

`%in%` is very useful when using the **dplyr** function `case_when()` to recode values in a column. For example:  

```{r eval=F}
linelist <- linelist %>% 
  mutate(hospital = case_when(
    hospital %in% c("St. Fr.", "Saint Francis") ~ "St. Francis")) # convert to correct spelling
```








<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Errors & Warnings {.tabset .tabset-fade }

This section explains:  

* General syntax for writing R code  
* Code assists  
* the difference between errors and warnings  

Common errors and warnings and their solutions can be found in X section (TODO).
See the handbook page on common errors and warnings.  





<!-- ======================================================= -->
### Error versus Warning  

When a command is run, the R Console may show you warning or error messages in red text.  

* A **warning** means that R has completed your command, but had to take additional steps or produced unusual output that you should be aware of.  

* An **error** means that R was not able to complete your command.  

Look for clues: 

* The error/warning message will often include a line number for the problem.  

* If an object "is unknown" or "not found", perhaps you spelled it incorrectly, forgot to call a package with library(), or forgot to re-run your script after making changes.  

If all else fails, copy the error message into Google along with some key terms - chances are that someone else has worked through this already!


<!-- ======================================================= -->
### General syntax tips

A few things to remember when writing commands in R, to avoid errors and warnings:  

* Always close parentheses - tip: count the number of opening "(" and closing parentheses ")" for each code chunk
* Avoid spaces in column and object names. Use underscore ( _ ) or periods ( . ) instead
* Keep track of and remember to separate a function's arguments with commas
* R is case-sensitive, meaning `Variable_A` is *different* from `variable_A`


<!-- ======================================================= -->
### Code assists  

Any script (RMarkdown or otherwise) will give clues when you have made a mistake. For example, if you forgot to write a comma where it is needed, or to close a parentheses, RStudio will raise a flag on that line, on the right side of the script, to warn you.  

(/images/Warnings_and_Errors.png)





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Recommended training {.tabset .tabset-fade }

<!-- ======================================================= -->
### Cheatsheets

This is an online R resource specifically for [Excel users](https://jules32.github.io/r-for-excel-users/vlookup.html)  


<!-- ======================================================= -->
### Courses




