# R の基礎 {#basics}

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "basics_header_close.png"))
```


ようこそ

このページでは、R の要点をおさらいします。これは、包括的なチュートリアルを意図するものではなく、基礎知識の提供と、あなたの記憶をリフレッシュするために有効なものです。[学習のためのリソース](#learning) セクションに、より包括的なチュートリアルへのリンク集があります。

このページの一部は、[R4Epis project（英語）](https://r4epis.netlify.app/) からの許諾を得て変更されています。

STATA、SAS、もしくは Excel から R への移行のヒントは、[Transition to R]{#transition-to-R}のページを参照してください。

```{r, echo=F}
# クリーニング済みのエボラ出血熱のラインリスト[^linelist]をインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
pacman::p_load(apyramid)
```

[^linelist]: 訳注: linelist アウトブレイクに関連する人の状況（名前、生年月日、性別、曝露日など）を記載した台帳


<!-- ======================================================= -->
## なぜ R を使うのか？

[R プロジェクトのウェブサイト（英語）](https://www.r-project.org/about.html)で述べられているように、R はプログラミング言語であり、統計的機械計算と視覚化のための環境です。この環境は、とても汎用性、拡張性があり、また、コミュニティ手動で開発されています。

**R の費用**

R は無料で利用できます！ この点においては、自由かつオープンソースを志向する人々のコミュニティにおける、強固な倫理的矜持があります。

**再現性**  

プログラミング言語を通したデータマネジメントと分析との総合管理は、（Excel や他の主にカーソルをポイントして、クリックしたり、手作業で管理するツールに比べて）、**再現性**を拡張し、**エラーの発見**を容易にし、作業の負荷を軽減します。

**コミュニティ**  

R 言語ユーザーのコミュニティは、巨大で協同的です。現実の問題を扱う新しいパッケージやツール群は、日々開発されています。そして、ユーザーコミュニティで検証されています。コミュニティの 1 つの例として、[R-Ladies（英語）](https://rladies.org/) は、R コミュニティでのジェンダーダイバーシティの推進をミッションとした世界的な組織です。また、大規模な R ユーザーコミュニティの 1 つでもあります。このコミュニティの支部はおそらくあなたの近くにもあるでしょう。


## キーワード

**RStudio** - RStudio は、**R** をより使いやすくするグラフィカルインタフェース（GUI）です。詳しくは、[RStudio のセクション](#rstudio)を参照してください。

**オブジェクト** - あなたが R に保存するすべて（データセット、変数、町の名前のリスト、合計人口や、グラフのようなアウトプットでさえも）は、<u>名前が割り当てられ</u>かつ、以降のコマンドで<u>参照可能な</u>、<u>オブジェクト</u>です。詳しくは、[オブジェクトのセクション](#objects)を参照してください。

**関数** - 関数とは、入力を受け入れる処理と処理され変化した内容を出力し返すコードのことをいいます。詳しくは、[関数のセクション](#functions)を参照してください。

**パッケージ** - R パッケージは、共有可能な関数の集まりです。詳しくは、[パッケージのセクション](#packages)を参照してください。

**スクリプト** - スクリプトとは、R のコマンドをまとめたドキュメントファイルです。詳しくは、[スクリプトのセクション](#scripts)を参照してください。



## 学習のためのリソース {#learning}  

### RStudio に含まれているリソース {.unnumbered}  

**ヘルプドキュメント**  

R パッケージや特定の関数のドキュメントについては、RStudio の "Help" タブをまず見つけてください。このタブは、Files、Plots、Packages タブを含むペインに含まれています。（一般的には右下のペインにあります。）関連するヘルプページを表示するショートカットとして、R コンソールに、クエスチョンマークに続けて、パッケージや特定の名前を入力することができます。カッコ（）は入力に含めないでください。

例えば、`?filter` や、`?diagrammeR` などです。

**インタラクティブチュートリアル**  

RStudio <u>の中で</u>インタラクティブに R を学ぶ方法はいくつかあります。

RStudio それ自身が [**learnr**](https://blog.rstudio.com/2020/02/25/rstudio-1-3-integrated-tutorials/) R パッケージによるチュートリアルペインを提供しています。このパッケージをインストールして、RStudio の右上に新たに現れる "Tutorilal" タブを開くだけです。（この右上のペインは、Environment、History タブも含みます。）

[**swirl**](https://swirlstats.com/) という R パッケージは、R コンソールでのインタラクティブコースを提供します。このパッケージをインストール後ロードし、そのあと、`swirl()` （空カッコをつけます）コマンドを R コンソール上で実行します。プロンプトがコンソール上に現れます。これは、コンソール上での入力に反応します。あなたの選択したコースを通して、このプロンプトがガイドします。


### チートシート {.unnumbered}

[RStudio ウェブサイト（英語）](https://rstudio.com/resources/cheatsheets/)上には、多くの "チートシート" PDF ファイルがあります。例えば：

* **forcats** パッケージとファクタ
* **lubridate** パッケージと日時
* **stringr** パッケージと文字列
* **purrr** パッケージと反復操作
* データインポート
* **dplyr** パッケージとデータ変換チートシート
* R Markdown（PDF, Word, Powerpoint のような文書を作るために）
* Shiny（インタラクティブなウェブアプリを作るために）
* **ggplot2** パッケージとデータビジュアライゼーション
* Cartography (GIS)
* **leaflet** パッケージ（インタラクティブマップ）
* R とともに使う Python（**reticulate** パッケージ）

特に[Excel ユーザー（英語）](https://jules32.github.io/r-for-excel-users/) のためのオンライン R リソースがあります。



### Twitter {.unnumbered}  

R には活発なコミュニティがあり、ティップスやショートカット、ニュースなどを知ることができます。以下のアカウントをフォローしてください：

* 我々のアカウントをフォローしてください！ [\@epiRhandbook](https://twitter.com/epirhandbook)  
* R Function A Day [\@rfuntionaday](https://twitter.com/rfunctionaday) は<u>驚くべき</u>情報量です
* R for Data Science [\@rstats4ds](https://twitter.com/rstats4ds?lang=en)  
* RStudio [\@RStudio](https://twitter.com/rstudio?lang=en)  
* RStudio Tips [\@rstudiotips](https://twitter.com/rstudiotips)  
* R-Bloggers [\@Rbloggers](https://twitter.com/Rbloggers)  
* R-ladies [\@RLadiesGlobal](https://twitter.com/RLadiesGlobal)  
* Hadley Wickham [\@hadleywickham](https://twitter.com/hadleywickham?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor)  


そして：

**#epitwitter** と **#rstats** のハッシュタグ 



### フリーのオンラインリソース {.unnumbered}  

最も信頼の置けるテキストは Garrett Grolemund と Hadley Wickham による書籍 [R for Data Science（英語）](https://r4ds.had.co.nz/) です

[R4Epis（英語）](https://r4epis.netlify.app/) プロジェクトのウェブサイトは、"MSF の緊急対応設定で実施される一般的なタイプのアウトブレイクと集団に基づく調査をカバーするための標準化されたデータクリーニング、分析、およびレポートツールを開発する" ことを目的にしています。 R の基本的なトレーニング資料、アウトブレイクと調査に関する RMarkdown レポートのテンプレート、およびそれらの設定に役立つチュートリアルがあります。


### 英語以外の言語 {.unnumbered}  

[Materiales de RStudio en Español](https://www.rstudio.com/collections/espanol/)

[Introduction à R et au tidyverse (Francais)](https://juba.github.io/tidyverse/index.html)  








<!-- ======================================================= -->
## インストール

### R と RStudio {.unnumbered}  

**R のインストール方法**  

[https://www.r-project.org/](https://www.r-project.org/) のウェブサイトにアクセスし、使用するコンピュータに適した R の直近のバージョンをダウンロードします。

**RStudio のインストール方法**  

[https://rstudio.com/products/rstudio/download/](https://rstudio.com/products/rstudio/download/) のウェブサイトにアクセスし、使用するコンピュータに適した RStudio の直近のバージョンをダウンロードします。

**パーミッション**  
R と RStudio は、読み取りと書き込みのアクセス許可があるディスクドライブにインストールする必要があることに注意してください。 そうしないと、（頻繁に発生する）R パッケージをインストールする機能が影響を受けます。 問題が発生した場合は、アイコンを右クリックして "管理者として実行" を選択して RStudio を開いてみてください。 その他のティップスは、[R on network drives](#network-drives)ページにあります。

**R と RStudio のアップデート方法**  

R のバージョンは、起動時に R コンソールに出力されます。 または、`sessionInfo()` を実行し確認できます。

R のアップデートは、上記のウェブサイトにアクセスして、R を再インストールします。または、（Windows の場合）**installr** パッケージを使用し、`installr::updateR()` を実行することもできます。 このコマンドにより、直近のバージョンの R をダウンロードし、新しいバージョンに対応するパッケージのアップデートを補助するダイアログボックスが開きます。 詳細については、**instrallr** の[ドキュメント（英語）](https://www.r-project.org/nosvn/pandoc/installr.html)を参照してください。

古いバージョンの R はまだコンピュータ上に存在することに注意してください。 RStudio で "Tools" -> "Global Options" をクリックし、R のバージョンを選択することで、R の古いバージョン（古い "インストール済み" のもの）を一時的に実行できます。 この操作は、最新バージョンの R で動作するようにアップデートされていないパッケージを使用する場合に役立ちます。

RStudio をアップデートするには、上記のウェブサイトにアクセスして、RStudio を再ダウンロードします。 他の選択肢は、RStudio 内の "Help" -> "Check for Updates" をクリックすることなのですが、この方法では最新のアップデートが表示されない場合があります。

このハンドブックの作成時に使用された R、RStudio、またはパッケージのバージョンを確認するには、[Editorial and technical notes](#editorial-style)のページを参照してください。


### <u>おそらく</u>インストールが必要となるその他のソフトウェア {.unnumbered} 

* TinyTeX (<u>RMarkdown ドキュメント を PDF ファイルへコンパイルするため</u>)  
* Pandoc  (<u>RMarkdown ドキュメントをコンパイルするために</u>)  
* RTools  (<u>R パッケージのビルドのため</u>)  
* phantomjs (<u>トランスミッションチェーンのような、動きのあるネットワークの静止画の保存のため</u>)  


#### TinyTex {.unnumbered}  

TinyTex は カスタム化された LaTeX ディストリビューションの 1 つです。R から PDF を生成しようとするときに便利です。
より詳しい情報は、[https://yihui.org/tinytex/](https://yihui.org/tinytex/) を参照してください。

TinyTex を R コンソールからインストールする：

```{r, eval=F}
install.packages('tinytex')
tinytex::install_tinytex()
# TinyTex をアンインストールする場合, tinytex::uninstall_tinytex() を実行する
```


#### Pandoc {.unnumbered}

Pandoc は、ドキュメントコンバータであり、R とは切り離されたソフトウェアです。**RStudio にバンドルされていて、ダウンロードの必要はありません**。Rmarkdown ドキュメントを .pdf のようなフォーマットに変換する手続きや、複雑な機能の追加を助けてくれます。


#### RTools {.unnumbered}  

RTools は、R のパッケージをビルドするためのソフトウェアの集合です。

次のウェブサイトからインストールしてください： [https://cran.r-project.org/bin/windows/Rtools/](https://cran.r-project.org/bin/windows/Rtools/)  


#### phantomjs {.unnumbered}  

このソフトウェアは、ウェブページの "スクリーンショット" を取得するためによく使われます。例えば、**epicontacts** パッケージでトランスミッションチェインを作ろうとするとき、インタラクティブかつ動的な HTML ファイルが生成されます。もし、静的な画像が必要な場合、この作業を自動化するために [**webshot**](https://wch.github.io/webshot/articles/intro.html) パッケージを使うと便利なことがあります。こういった自動化には、"phantomjs" という外部プログラムが必要です。phantomjs は **webshot** パッケージの `webshot::install_phatomjs()` コマンドでインストール可能です。




<!-- ======================================================= -->
## RStudio {#rstudio}


### RStudio オリエンテーション {.unnumbered}  

**まず最初に、RStudio をたちあげます。** R とアイコンが非常に似ているので、R ではなく <u>RStudio</u> を立ち上げていることを確認してください。

RStudio が動作するために、R もインストールされている必要があります。（上記のインストールインストラクションを参照してください）

**RStudio** は、**R** を簡単に使用するためのインタフェース（GUI）です。R を車のエンジン、つまり重要な働きを行っている機関と例えるならば、RStudio は、車の車体（シートやアクセサリなど）、つまりエンジンを前進させるために使えるものと考えることができます！完全な RStudio ユーザインタフェースのチートシートは[こちら（英語）](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)で参照いただけます。

デフォルトでは、RStudio は 4 つの四角いペインを表示します。

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```


<span style="color: black;">**_ヒント:_** もし RStudio が 1 つのみの左側ペインを表示している場合、それは、まだ R スクリプトを 1 つも開いていないからです。</span>


**Source ペイン**  
デフォルトでは左上に表示されるこのペインは、ファイルの編集、実行、[スクリプト](#scripts) の保存に使うスペースです。スクリプトは、実行コマンドを含んでいます。このペインは、データセット（data frames）を表示させることもできます。

Stata ユーザには、このペインは Do-file and Data Editor ウィンドウと似ています。



**R Console ペイン**  

RStudio ではデフォルトで左下に表示される R コンソールは、R の "エンジン" に相当するポジションです。コマンドを実際に実行したりノングラフィック出力や、エラーや警告メッセージが現れます。R コンソールに直接コマンドを入力、実行することができます。しかし、スクリプトからコマンドを実行したときと違い、コンソールから実行したコマンドは保存されないとご理解ください。

Stata に慣れている方ならば、R コンソールは Command ウィンドウや Results ウィンドウに似ています。


**Environment ペイン**  
デフォルトで右上に表示されるこのペインでは、現在のセッションにおける R 環境の[オブジェクト](#objects)の簡単な要約としてよく利用されます。オブジェクトは、インポート、変更、または生成されたデータセット、定義したパラメータ（たとえば、分析の特定の疫学週）、または分析中に定義したベクトルまたはリスト（例えば、地域の名前）などが含まれます。データフレーム名の横にある矢印をクリックすると、その変数を確認できます。

Stata では、Variables Manager ウィンドウに最もよく似ています。

このペインには、過去に実行したコマンドを閲覧できる <u>History</u> タブも含んでいます。もし **learnr** パッケージをインストール済みであれば、インタラクティブな R チュートリアルを完結させることのできる "Tutorial" タブもこのペインにあります。また、外部接続のための "Connections" ペインと、Github インタフェースを選択した場合に "Git" タブもあります。


**Plots、Viewer、Packages と Help ペイン**  
右下にあるペインはいくつかの重要なタブを含んでいます。地図を含む典型的なプロット画像は、Plot ペインに表示されます。インタラクティブ出力や、HTML 出力は Viewer ペインに表示されます。Help ペインはドキュメントやヘルプファイルを表示することができます。Files ペインは、ファイルを開いたり削除したりするために使われるブラウザです。Package ペインでは、R パッケージのインストール、アップデート、削除、読み込みとアンロードが可能です。また、どのバージョンのパッケージがインストール済みか確認できます。R パッケージについてより詳しい情報は以降の[パッケージセクション](#packages)を参照してください。

このペインは、Stata の Plots Manager と Project Manager ウィンドウに相当する機能が含まれます。

### RStudio の設定 {.unnumbered}  

<u>Tools</u> ドロップダウンメニューにある <u>Global Options</u> を選択し、RStudio の設定や外観の変更します。外観や、背景の色を含めてデフォルトの設定を変更することができます。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "RStudio_tools_options_1.png"))

knitr::include_graphics(here::here("images", "RStudio_tools_options.png"))
```

**再起動**  

R が固まってしまった場合、Session メニューの "Restart R" をクリックすることで R を再起動することができます。RStudio を閉じたり開いたりする手間を省くことができます。もしこの操作を実行した場合、R 環境のすべてが削除されます。


### キーボード・ショートカット {.unnumbered}  

いくつかの便利なキーボード・ショートカットを下記に示します。Windows、Max、Linux のすべてのキーボード・ショートカットを参照する場合は、RStudio [ユーザインタフェースチートシート（英語）](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)の２ページ目を参照してください。


Windows/Linux     |Mac             |動作
------------------|----------------|-----------------------------------------
Esc               |Esc             |現在動作中のコマンドを中断する（誤って不十分なコマンドを実行してしまった場合や、R コンソール内に "+" が見えている状態でエスケープできない場合に有用）
Ctrl+s            |Cmd+s           |保存する (スクリプト)
Tab               |Tab             |自動補完する
Ctrl + Enter      |Cmd + Enter     |現在行または、選択したコードを実行する
Ctrl + Shift + C  |Cmd + Shift + c |ハイライトされた行をコメントまたはアンコメントする
Alt + -           |Option + -      |`<-` を挿入する
Ctrl + Shift + m  |Cmd + Shift + m |`%>%` を挿入する
Ctrl + l          |Cmd + l         |R コンソールの表示をクリアする
Ctrl + Alt + b    |Cmd + Option + b|第一行から現在行まで実行する
Ctrl + Alt + t    |Cmd + Option + t|現在のコードセクションを実行する (R Markdown)
Ctrl + Alt + i    |Cmd + Shift + r |コードチャンクを挿入する (R Markdown 内へ)
Ctrl + Alt + c    |Cmd + Option + c|現在のコードチャンクを実行する (R Markdown)
R コンソール内での 上下 矢印キー |同左 |最近実行したコマンドを切り替える
スクリプト内で Shift + 上下矢印キー|同左|複数行の選択
Ctrl + f |Cmd + f|現在のスクリプト内の検索と置き換え
Ctrl + Shift + f|Cmd + Shift + f|ファイルをまたいだ検索 (複数のスクリプトをまたいだ検索／置き換え)
Alt + l |Cmd + Option + l|選択したコードの折りたたみ
Shift + Alt + l|Cmd + Shift + Option+l|選択したコードの展開



<span style="color: darkgreen;">**_ヒント:_** RStudio の自動補完機能を利用するには、入力時に Tab キーを押します。スペルミスによるエラーを防ぐことができます。入力中に Tab キーを押すことで、これまでに入力した内容に基づいて、可能性のある関数とオブジェクトのドロップダウンメニューが表示されます。</span>  

  



<!-- ======================================================= -->
## 関数 {#functions}  

関数は R を使う上で核となるものです。関数は、タスクや操作を実行する方法です。多くの関数は、R のインストールとともに用意されます。さらに多くの関数は<u>パッケージ</u>をダウンロードすることで利用可能です。（[パッケージ](#packages)セクションで説明されます）また、自身でカスタム関数を定義することもできます。

この関数について基礎的なセクションで説明することは：

* 関数とは何であるか、どのように機能するか
* 関数の<u>引数</u>とはなにか
* 関数を理解するための方法

<u>シンタクスについての備考：</u>このハンドブックでは、関数は `filter()` のようにカッコつきのコードテキストスタイルで書かれています。[パッケージ](#packages)セクションで説明されているように、関数は<u>パッケージ</u>とともにダウンロードされます。このハンドブックでは、パッケージの名前は **dplyr** にように**強調体**で書かれています。ときおり、サンプルコードでは、`dplyr::filter()` のように、関数名をパッケージ名と 2 つのコロン（`::`）でつなげている場合があります。この記法の目的はパッケージセクションで説明されています。


<!-- ======================================================= -->
### 単純な関数 {.unnumbered}  

**関数とは、入力を受付け、入力に基づいて動作し、出力を生成する機械のようなものです。** 出力がなんであるかは関数に依存します。

**関数は通常、関数のカッコ内に書かれた何らかのオブジェクトに対して動作します。** 例えば、`sqrt()` 関数は、数値の平方根を計算します。

```{r basics_function_sqrt}
sqrt(49)
```

関数に渡されるオブジェクトは、データセットの列を指定することもできます。（すべての種類のオブジェクトの詳細については、[オブジェクト](#objects)セクションを参照してください。）R は複数のデータセットを格納できるため、データセット名と列の両方を指定する必要があります。1 つの方法は、`$` 表記を使用して、データセット名と列名をつなげることです（`dataset$column`）。以下の例では、`summary()` 関数を `lineliset` データセットの数値を含む列 `age` 列に適用し、列内の数的サマリと欠損値の要約を出力しています。


```{r basics_functions_summary}
# `linelist` データセットの `age` 列の統計的要約を出力
summary(linelist$age)
```

<span style="color: black;">**_備考:_** 関数実行を裏から見ると、関数とは複雑なコードをユーザが簡単に使えるように 1 つのコマンドにまとめたものです。</span>



<!-- ======================================================= -->
### 複数の引数を取る関数 {.unnumbered}  

関数は、たいてい***引数***と呼ばれる複数の入力を要求します。引数は関数のカッコ内にあり、通常はカンマで区切られています。

* いくつかの引数は関数が正しく機能するために必須ですが、任意の引数もあります
* 任意の引数は、デフォルトの値を持っています
* 文字列、数値、論理値（TRUE/FALSE）、更に他の入力などを引数に取ることができます

典型的な関数の例として、`oven_bake()` という架空の関数を考えます。入力オブジェクト（データセット、この例では "dough"）を受け取り、追加の引数（`minutes = ` と `temperature = `）で指定された操作を実行します。出力はコンソールに出力するか、代入演算子 `<-` を使用してオブジェクトとして保存できます。

```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```


**より現実的な例**として、以下の `age_pyramid()` コマンドは、定義された年齢グループと、`genger` のような二値分類された列に基づいて、年齢ピラミッドプロットを生成します。関数には、カッコ内にカンマで区切られた 3 つの引数が与えられます。引数に指定された値は、使用するデータフレームとして `linelist` を、カウントする列として `age_cat5` を、ピラミッドを色で分割するために使用する二値分類列として `gender` を設定します。

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE,}
## カテゴリの区切りを指定して年齢グループ変数を作成する
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# 年齢ピラミッドを作成する
age_pyramid(data = linelist, age_group = "age_cat5", split_by = "gender")
```

上記のコマンドは、以下のように、引数ごとに改行した長い書式で書くことができます。この書式は読みやすく、各部分を説明するための "コメント" を `#` を使って簡単に書くことができます。（広範囲にコメントを書くことは良い習慣です！）この長いコマンドを実行するには、コマンド全体をハイライトして "Run" をクリックするか、最初の行にカーソルを合わせて、 Ctrl キーと Enter キーを同時押すだけです。

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# 年齢ピラミッドを作成する
age_pyramid(
  data = linelist,        # 症例ラインリストを使用
  age_group = "age_cat5", # 年齢層別列を与える
  split_by = "gender"     # ピラミッドの両翼に、性別列を使用
  )
```

引数が特定の順序で記述されている場合（関数のドキュメントで指定されている場合）は、引数の代入部分の前半（`data = ` など）を指定する必要はありません。以下のコードでは、データフレーム、`age_group` 変数、`spilit_by` 変数という引数の順序を関数が予測しているため、前述のコマンドと全く同じピラミッドを生成します。

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# このコマンドは前述のピラミッドを全く同じものを生成する
age_pyramid(linelist, "age_cat5", "gender")
```

**より複雑な `age_pyramid()` コマンドには、次のような<u>任意の</u>引数が含まれます：**

* カウント数の代わりに割合を表示します（デフォルトは、`FALSE` ですが、`proportional = TRUE` と設定します）
* 両翼それぞれの色を指定します（`pal = ` は、"palette" の略で、2 つの色名のベクトル型として渡されます。`c()` 関数でベクトル型を作成する方法については、[オブジェクト](#objectstructure) ページを参照してください）


<span style="color: black;">**_備考:_** 引数名と値の両方の部分を指定した場合（例：`proportional = TRUE`）については、引数すべての中での位置指定は問題になりません。</span>


```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
age_pyramid(
  linelist,                    # 症例ラインリストを使用
  "age_cat5",                  # 年齢層別列
  "gender",                    # 性別で分類
  proportional = TRUE,         # カウント数に代わりパーセンテージを使用
  pal = c("orange", "purple")  # 色の指定
  )
```



<!-- ======================================================= -->

### 関数を記述する {.unnumbered}  

R は関数志向のプログラミング言語であるため、自分で関数を書くことができるようになっています。関数を作成すると次のような利点があります：

* モジュールプログラミング（コードを、独立した管理可能な部分に分離すること）を促進します
* エラーが発生しやすい、コピー＆ペーストの繰り返しを解消します
* コードに覚えやすい名前をつけられます

関数の書き方については、[Writing functions]{#writing-functions}のページで詳しく説明しています。

<!-- 関数には名前がつけられ、代入演算子 `<-` を使って、`function()` という特別な R の **base** パッケージ（以下、base R）の関数に定義されます。カッコの中には、その関数が受け取ることのできる引数が定義されています。その後に中カッコ `{}` が続き、その中に関数の実際のコードが書かれます。     -->

```{r, eval=F, echo=F}
my_function <- function( 引数 ){ コードブロック }
```

<!-- 引数は、カンマで区切って、`argument = default` の構文で指定してください。   -->

<!-- ここでは、COVID-19 の症例調査やコンタクトトレーシングのための人員計算として、`staff_calc()` 関数を作成する例を紹介します。   -->

<!-- 引数（入力値）とそのデフォルト値は次のようになります：   -->

<!-- * `dails_cases = NULL` 一日の COVID-19 新規症例数   -->
<!-- * `contacts_each = 5` 各症例の濃厚接触者数 -->
<!-- * `time_case = 0.5` 電話での症例調査が完了するまでの時間 -->
<!-- * `time_contact = 0.25` 電話での接触調査が完了するまでの時間 -->
<!-- * `time_daty = 8` 一人のスタッフが一日あたり働く時間 -->

<!-- 以下で、関数を作成します。コードの最後には関数の戻り値を生成する特別な関数 `return()` があります。 -->

<!-- ```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"} -->
<!-- staff_calc <- function(daily_cases = NULL, contacts_each = 5, -->
<!--                        time_case = 0.5, time_contact = 0.25, time_day = 8){ -->

<!--   # 症例調査のための一日あたりの合計時間を定義する -->
<!--   case_hours <- daily_cases * time_case  -->

<!--   # 接触調査のための一日あたりの合計時間を定義する -->
<!--   contact_hours <- daily_cases * contacts_each * time_contact -->

<!--   # 必要とされるスタッフの数を計算する -->
<!--   staff_required <- (case_hours + contact_hours)/time_day -->

<!--   return(staff_required) -->
<!-- } -->
<!-- ``` -->

<!-- このコードを実行すると、関数が定義され、R 環境に表示されるようになります。この関数を実行してみましょう。以下では、すべてデフォルト値が適用され、`daily_cases = ` が 150 に設定されています。 -->

<!-- ```{r eval=F, echo=F, message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"} -->
<!-- staff_calc(daily_cases = 150) -->
<!-- ``` -->

<!-- ```{r, eval=F, echo=F} -->
<!-- case_incidence <- tibble( -->
<!--  dates = seq.Date(from = as.Date("2020-05-01"), to = as.Date("2020-05-21"), by = 1), -->
<!--  projected_incidence = c(102,110,50,37,106,190,146,138,135,111,60,43,189,184,185,80,44,97,254,291,288), -->
<!--  staff_needed = staff_calc(projected_incidence) -->
<!-- ) -->

<!-- ggplot(case_incidence, aes(x = dates))+ -->
<!--  geom_line(aes(y = projected_incidence))+ -->
<!--  geom_line(aes(y = staff_needed)) -->
<!-- ``` -->

<!-- 関数を記述する際には、[Writing functions]{#writing-functions}のページで説明したように、他にも様々な差異があります。 -->


<!-- ======================================================= -->
<!-- ======================================================= -->
## パッケージ {#packages}  

**パッケージは関数を内包します。**  

R パッケージとは、予め定義された関数を含む、コードとドキュメントをまとめた共有可能なかたまりです。R コミュニティのユーザは、特定の問題に対応したパッケージを常に開発しており、その特化したパッケージが業務に役立つ可能性があります！R を活用する際には、何百ものパッケージをインストールして使用することになります。

R のインストール時には、基本的な作業を実行する **base** パッケージと関数が含まれています。しかし、多くの R ユーザが特殊な関数を作成しており、それらは R コミュニティによって検証され、自分で使用するために**パッケージ**としてダウンロードすることができます。このハンドブックでは、パッケージ名を**強調体**で表記しています。R を難しくしている点の 1 つは、ある作業を行うために選択できる関数またはパッケージが、多数あることです。


### インストールと読み込み {.unnumbered}  

<u>関数</u>は、インターネットを通じてコンピュータにダウンロード（"インストール"）できる**パッケージ**に含まれています。パッケージがダウンロードされると、"ライブラリ" に保存されます。その後、パッケージを "読み込む" ことで、実行中の R セッションの間、関数にアクセスできます。

<u>R を個人用のライブラリ（図書館）と捉えてください</u>：パッケージをダウンロードすると、新しい関数の本をライブラリに保存しますが、その本に含まれる関数を使用する際に、ライブラリから本を借りる（"読み込む"）必要があります。

要約：R パッケージで利用可能な関数を使用するには、次の 2 つの手順を実行する必要があります：

1) パッケージは（1 回だけ）**インストール**される必要があり、<u>かつ</u>
2) パッケージは（各 R セッションにおいて）**読み込む**必要があります


#### 個人のライブラリ {.unnumbered}  

"ライブラリ"は、実際にはコンピュータ上のフォルダであり、インストールされている各パッケージのフォルダが含まれています。 R がコンピュータのどこにインストールされているかを調べ、"win-library" というフォルダを探します。例：`R\win-library\4.0` （4.0 は R のバージョンです。ダウンロードした R バージョンごとに異なるライブラリがあります。）

`.libPaths()`（空のカッコ）を入力すると、ライブラリへのファイルパスを出力できます。これは、[R on network drives]{#network-drives}を使用するときに特に重要です。


#### CRAN からのインストール {.unnumbered}  

ほとんどの場合、R ユーザは CRAN からパッケージをダウンロードします。CRAN（Comprehensive R Archive Network）は、R コミュニティメンバーによる R パッケージのオンライン公開用の場所です。

CRAN からパッケージをダウンロードするときに、ウイルスとセキュリティについて懸念がありますか？このトピックに関する[記事（英語）](https://support.rstudio.com/hc/en-us/articles/360042593974-R-and-R-Package-Security)を参照してください。
 

#### インストールと読み込みの方法 {.unnumbered}  

このハンドブックでは、**packman** パッケージ（"package manager" の省略）の使用を推奨しています。このパッケージは、必要であればパッケージのインストールを行い、<u>かつ</u>現在の R セッションに読み込む便利な `p_load()` 関数を提供します。

シンタクスは非常にシンプルです。`p_load()` 関数のカッコに、カンマで区切られたパッケージ名を記述するだけです。このコマンドは、下記のコマンドは、まだインストールされていなければ、**rio**、**tidyverse**、**here** パッケージを、インストールします。そして、使用のために読み込みます。他の人とスクリプトを共有する場合に `p_load()` の利用は、便利で簡潔です。パッケージ名は大文字と小文字が区別されることに注意してください。

```{r}
# （必要であれば）インストールし、使用のために読み込む
pacman::p_load(rio, tidyverse, here)
```

ここでは、関数名（`p_load()`）の前に、パッケージ名（**pacman**）を明示的に記述し、これらを 2 つのコロンでつなぐ構文 `pacman::p_load()` を使用していることに注意してください。このシンタクスは、（すでにインストールされていると仮定して）**pacman** パッケージの読み込みにも便利です。

R の **base** パッケージ（以下、base R）内に、よく見かける、代替の関数があります。パッケージをインストールするための **base** R の関数は `install.packages()` 関数です。インストールするパッケージの名前は、カッコの中で<u>二重引用符</u>で囲まれている必要があります。1 つのコマンドで複数のパッケージをインストールしたい場合は、文字ベクトルとして、`c()` の中にリスト化される必要があります。

備考：このコマンドは、パッケージを<u> インストール</u>しますが、現在のセッションでの使用のためには<u>読み込みしません</u>。

```{r, eval=F}
# base R の関数で 1 つのパッケージをインストールする
install.packages("tidyverse")

# base R の関数で複数のパッケージをインストールする
install.packages(c("tidyverse", "rio", "here"))
```

インストールは、 ポイント＆クリックで行うことも可能です。RStudio の "Packages" ペインに移動して、"Install" をクリックし、目的のパッケージ名を検索することで実行できます。

インストールしたパッケージを使用するために**読み込む** **base** R パッケージの関数は、`library()` です。この関数は、一度に 1 つのパッケージしか読み込みできません（これが `p_loard()` を使用するもう 1 つの理由です）。パッケージ名は、二重引用符つきでも、なしでも指定できます。

```{r, eval=F}
# base R パッケージの関数で複数のパッケージを読み込む
library(tidyverse)
library(rio)
library(here)
```

パッケージがインストールまたは読み込まれているかどうかを確認するには、RStudio で Packages ペインを表示します。パッケージがインストールされている場合は、バージョン番号とともに表示されます。このボックスにチェックマークがついていた場合、現在のセッションで読み込まれています。



**Github からのインストール**

場合によっては、CRAN からまだ入手できないパッケージをインストールする必要があります。あるいは、パッケージは CRAN で入手可能だけれど、より安定し、また、公開されている CRAN バージョンではまだ提供されていない新機能を備えた<u>開発バージョン</u>が必要な場合もあります。これらは、多くの場合、[github.com](https://github.com/)ウェブサイトに無料で公開されているコード "リポジトリ" としてホストされています。Github については、ハンドブックの[Version control and collaboration with Git and Github]{#collaboration}のページで詳しく説明しています。

Github から R パッケージをダウンロードするには、**pacman** から、`p_load_gh()` 関数を使用できます。必要に応じてパッケージをインストールし、現在の R セッションで使用できるように読み込みます。インストールの代わりに、**remotes** や **devtools** パッケージを使用することもできます。すべての **pacman** に含まれる関数については [package documentation（英語）](https://cran.r-project.org/web/packages/pacman/pacman.pdf) を参照してください。

Github からインストールするために、より多くの情報が必要です。必要な情報とは：

1) リポジトリ所有者の Github ID
2) パッケージを内包するリポジトリの名前
3) <u>（任意選択）ダウンロードしようとする "branch" 名（特定の開発バージョン）</u>

下記の例では、二重引用符で囲まれたうちの最初の単語がリポジトリ所有者の Github ID であり、スラッシュの後がリポジトリの名前（パッケージ名）です。

```{r, eval=F}
# Github リポジトリから epicontacts パッケージをインストールまたは読み込み
p_load_gh("reconhub/epicontacts")
```

main ブランチ以外の "branch" （バージョン）からインストールする場合は、リポジトリ名の後に続けて、"@" とブランチ名を追加します。

```{r, eval=F}
# Github から epicontacts パッケージの "timeline" ブランチをインストールする
p_load_gh("reconhub/epicontacts@timeline")
```

手元のコンピュータにあるバージョンと Github にあるバージョンに差異がない場合は何も起こりません。`p_load_current_gh()` 関数に `update =TRUE` オプションを指定することで、「強制的に」再インストールすることができます。**packman** パッケージについての詳細は、使用方法のドキュメントである[オンラインビニエット（vignette）](http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html)を参照してください。


**ZIP や TAR からのインストール**

URL からパッケージをインストールすることもできます：

```{r, eval=F}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

または、zip ファイルでコンピュータにダウンロードします：

選択肢 1：**remotes** パッケージの `install_local()` を使う

```{r, eval=F}
remotes::install_local("~/Downloads/dplyr-master.zip")
```

選択肢 2：ZIP ファイルへのファイルパスを指定し、`type = "source"` と `repos = NULL` オプションを設定した **base** R パッケージの `install.packages()` を使用します

```{r, eval=F}
install.packages("~/Downloads/dplyr-master.zip", repos=NULL, type="source")
```


### コードシンタクス {.unnumbered}  

このハンドブックでは、わかりやすくするために、関数の前に、次のように `::` 記号を使用してパッケージの名前を付加することがあります：`package_name::function_name()`

起動中のセッションにパッケージが読み込まれると、このような明示的な関数呼び出しは必要ありません。単に `function_name()` を使用するだけです。しかしながら、関数名が一般的な名前で、複数のパッケージに存在する可能性がある場合（例：`plot()`）には、パッケージ名を併記すると便利です。パッケージ名を併記すると、そのパッケージがまだ読み込まれていない場合には、そのパッケージを読み込みます。

```{r eval=FALSE}
# このコマンドは、"rio" パッケージと "import()" 関数を使用してデータセットをインポートする
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```



### 関数のヘルプ {.unnumbered}  

関数について詳しく知りたい場合は、右下の RStudio の Help タブで検索することができます。また、`?thefunctionname`（クエスチョンマークの後に関数名を入力する）のようにコマンドを実行すると、ヘルプページが Help ペインに表示されます。最後に、オンラインでリソースを検索してみてください。



### パッケージのアップデート {.unnumbered}  

パッケージは、再インストールすることでアップデートできます。また、RStudio の Packages ペインにある緑色の "Update" ボタンをクリックし、インストールする新しいバージョンのパッケージを確認することもできます。関数の動作に大きな変更があった場合、古いコードを更新する必要があることに注意してください。


### パッケージの削除 {.unnumbered}
パッケージの削除には、**packman** から `p_delete()` を使用するか、**base** R パッケージから `remove.packages()` を使用します。または、ライブラリを含むフォルダを見つけて手動でフォルダを削除します。



### 依存関係 {.unnumbered}  

多くの場合、パッケージは他のパッケージに依存して機能します。これを依存関係と呼びます。依存関係にあるパッケージのインストールに失敗した場合、そのパッケージに依存しているパッケージのインストールにも失敗することがあります。

`p_depends()` でパッケージの依存関係を確認し、`p_depends_reverse()` でどのパッケージがそれに依存しているかを確認します。



### マスクされた関数 {.unnumbered}  

2 つ以上のパッケージに同じ関数名が含まれていることは珍しくありません。例えば、**dplyr** パッケージには `filter()` 関数がありますが、**stats** パッケージにも同名関数があります。これらのパッケージが R セッションで最初に読み込まれる順番によって、デフォルトで呼び出される `filter()` 関数は異なります。後に読み込まれたパッケージの関数がデフォルトの `filter()` コマンドになります。

RStudio の Environment ペインで順番を確認できます。"Global Environment" のドロップダウンメニューをクリックして、パッケージの読み込み順序を確認してください。このドロップダウンリストの<u>下位</u>にあるパッケージの関数は、ドロップダウンリストの上位に表示されるパッケージ内の同名関数をマスクします。パッケージを読み込む時に、R はマスキングが発生しているかどうかをコンソール上で警告しますが、この警告は簡単に見逃されます。

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "masking_functions.png"))
```

マスキングを外す方法は下記です：

1) コマンド実行時にパッケージ名を指定します。例えば、`dplyr::filter()`
2) パッケージが読み込まれる順序を再調整して（例：`p_load()` 内）、**新しい R セッションを開始します**。



### デタッチ、アンロード {.unnumbered}  

パッケージをデタッチ（アンロード）するには、正しいパッケージ名とコロンを 1 つだけ指定して、下記のコマンドを使用します。なお、このコマンドでは、マスキングが解決されない場合があります。

```{r, eval=F}
detach(package:パッケージ名, unload=TRUE)
```


### 過去のバージョンをインストールする {.unnumbered}  

特定のパッケージの過去のバージョンをインストールするには、この[ガイド（英語）](https://support.rstudio.com/hc/en-us/articles/219949047-Installing-older-versions-of-packages)を参照してください。


### 推奨パッケージ {.unnumbered}  

日常の疫学業務に推奨されるパッケージのリストについては、[推奨パッケージ]{#packages-suggested}のページを参照してください。







<!-- ======================================================= -->
## スクリプト {#scripts}

スクリプトはプログラミングの基本的なパーツです。スクリプトは、コマンド（例えば、データセットの作成や更新、ビジュアライゼーションの出力などを行う関数）を格納するドキュメントです。スクリプトを保存し、後で実行することができます。スクリプトからコマンドを保存して実行するということには、多くの利点があります。（R コンソールの "command line" にコマンドを 1 つずつ入力するのとは異なります）：

* ポータビリティ、移植性 - スクリプトを送信することで、共同作業者と作業を共有できます
* リプロデューシビリティ、再現性 - 何を実行したか、自分や共同作業者が正確に知るために
* バージョンコントロール - 自分や共同作業者が行った変更を追跡できるように
* コメント付加／注釈 - 共同作業者に自分が何を行ったかを説明するために

### コメント付加 {.unnumbered}  

スクリプト内で、R のコードに注釈（"コメント"）を付加することもできます。コメントは、自分自身や他の読み手に、コードが何を行っているかを説明するのに役立ちます。コメントを付加するには、ハッシュ記号（#）を入力し、そのうしろにコメント内容を記述します。コメントは、R コードとは別の文字色で表示されます。

この # のうしろに書かれたコードは実行されません。したがって、コードの前に # を置くと、コードを削除したくない場合に、一時的にその行の実行をブロックする（"コメントアウト"）のに便利な方法でもあります。複数行を選択して Ctrl + Shift + c (Mac では Cmd + Shift + c）を押すと、一度に複数行をコメントアウト／非コメントアウトすることができます。


```{r, eval = F}
# コメントは 1 行にまとめることができる
# データのインポート
linelist <- import("linelist_raw.xlsx") %>%   # コード行の終わりにコメントを付加できる
# filter(age > 50)                          # コード行の不活化／削除にも使用できる
  count()

```

* コメントには<u>何を</u>しているかを残し、また、<u>**なぜ**実行するかについても残しましょう</u>
* 論理的なサイズにコードを分割しましょう
* コードとともに、何をしているかをステップごとにテキストで説明しましょう（例えば、番号付きステップ）

### コーディングスタイル {.unnumbered}  

特にチームで作業する場合は、コーディングスタイルを意識することが必要です。私達は、**tidyverse** [スタイルガイド（英語）](https://style.tidyverse.org/)を提唱しています。このスタイルに住居するのに役立つ、**styler** や **lintr** などのパッケージもあります。

コードを他の人が読めるようにするためのいくつかの非常に基本的なポイント：
  * オブジェクトに名前をつける時、使用するのは英小文字、数字、アンダースコア `_` のみに限る。例、`my_data`
  * 演算子の前後を含めてスペースを挿入すること。例、`n = 1` や `age_new <- age_old + 3`


### スクリプト例 {.unnumbered}  

 下記は、短い R スクリプトの例です。コメントでコードを簡潔に説明すればするほど、共同作業者に喜ばれることを覚えておいてください。

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "example_script.png"))
```

<!-- ======================================================= -->
### R markdown {.unnumbered}

R markdown スクリプトは、スクリプト自体が出力用のドキュメント（PDF、Word ファイル、HTML、Powerpoint ファイルなど）に<u>なる</u> R スクリプトの一種です。このウェブサイトやハンドブックも R のマークダウンスクリプトで作られています。

R 初心者の方でも、R Markdown を使うことができます。もっと詳しく知りたい方は、ハンドブックの[Reports with R Markdown]{#rmarkdown}ドキュメントのページを参照してください。


<!-- ======================================================= -->
### R notebooks {.unnumbered}

R markdown と R notebook に違いはありません。しかし、ドキュメントの実行方法は若干異なります。詳しくはこちらの[サイト（英語）](http://uc-r.github.io/r_notebook)を参照してください。

<!-- ======================================================= -->
### Shiny {.unnumbered}

Shiny アプリ／ウェブサイトは、`app.R` という 1 つの R スクリプトで構成されています。このファイルは 3 のコンポネントで構成されており：

1) ユーザインタフェース（ui）
2) サーバ関数
3) `shinyApp` 関数の呼び出し

ハンドブックの [Dashboards with Shiny]{#shiny-basics} のページを参照していただくか、こちらのオンラインチュートリアル [Shiny チュートリアル（英語）](https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/)を参照してください。

<u>過去、上記のファイルは、2 つのファイル（`ui.R` と `server.R`）に分かれていました。</u>


### コードの折りたたみ {.unnumbered}  

コードの一部を折りたたんで, スクリプトを読みやすくすることができます。

折りたたみを行うには、# でテキストヘッダを書き始め、ヘッダを記述し、半角スペースをあけて、ダッシュ（-）、ハッシュ（#）、イコール（=）のいずれかの記号を少なくとも 4 つ続けて記述します。この記述により、左列（行番号のそば）の "すき間" に小さな下三角が現れます。この三角クリックすると次のヘッダまだのこれ以降のコードが折り畳まれ、折り畳まれたことを示す左右矢印のアイコンが表示されます。

コードを展開するには、すき間の下三角をもう一度クリックするか、左右矢印アイコンをクリックします。また、このページの [RStudio セクション](#rstudio)で説明されているように、キーボード・ショートカットもあります。

記号 # を使用してヘッダを作成すると、スクリプトの下部にある目次（下記参照）もアクティブになり、スクリプトのナビゲートに使用できます。サブヘッダを作成するには、# シンボルを連続させます。見出し 1 の場合は #、見出し 2 の場合は、##、見出し 3 の場合は、### となります。

下記は、サンプルスクリプトの 2 つのバージョンです。左側は、コメント付きのヘッダがついたオリジナルです。右側では、各ヘッダの後に 4 つのダッシュが記述されており、折りたたみ可能になっています。そのうちの 2 つが折り畳まれており、下部の目次に各セクションが表示されていることがわかります。

```{r, out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "code_folding1.png"))
knitr::include_graphics(here::here("images", "code_folding2.png"))
```

その他、自動的に折りたたみの対象となるコード領域は、関数定義や、条件ブロック（if else 文）など、大かっこ `{ }` で囲まれた "ブレース" 領域です。コード折りたたみについての詳細は、RStudio [サイト（英語）](https://support.rstudio.com/hc/en-us/articles/200484568-Code-Folding-and-Sections)を参照してください。



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## 作業ディレクトリ

作業ディレクトリとは、R が入出力に使用するルートフォルダの場所です。つまり、R がデフォルトで、ファイルを参照したり保存したりする場所です。 デフォルトでは、新しいファイルや出力はこの場所に保存され、インポートするファイル（データセットなど）もこの場所から検索されます。

作業ディレクトリは、RStudio Console ペインの上部に灰色のテキストで表示されます。`getwd()` を実行して現在の作業ディレクトリを出力することもできます。（カッコ内はカラのままにします）

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "working_directory_1.png"))
```


### 推奨される方法 {.unnumbered}  

**作業ディレクトリを関するための推奨される方法の詳細については、[R projects]{#r-projects}のページを参照してください。**
作業ディレクトリとファイルパスを管理するための一般的で、効率的かつ、トラブルのない方法は、これら 3 つの要素を [R projects]{#r-projects}ー指向のワークフローで組み合わせることです：

1) 1 つの R プロジェクトにすべてのファイルを集約します（[R projects]{#r-projects}を参照してください）
2) **here** パッケージでファイルの位置を指定します（[インポートとエクスポート]{#importing}のページを参照してください）
3) **rio** パッケージでファイルのインポートとエクスポートを行います（[インポートとエクスポート]{#importing}のページを参照してください）


<!-- ======================================================= -->
### コマンドによる設定 {.unnumbered}

最近まで、R の学習者の多くは、スクリプトを `setwd()` コマンドで始めるよう教えられていました。代わりに [R projects]{#r-projects}ー指向のワークフローの使用を検討してください。あわせて、[`setwd()` を使用しない理由（英語）](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)を参照してください。簡単に述べると、行っている作業が手元のコンピュータ独自のものとなり、ファイルのインポートやエクスポートに使われるファイルパスは、"当てにならない" ものになります。これが、他のコンピュータでの共同作業やコードの仕様を阻害します。簡単な代替手段を提案します！

前述のように、ほとんどの場合、この方法はおすすめできませんが、例えば、目的のフォルダのファイルパスを二重引用符で囲んで、`setwd()` コマンドに渡すことができます。例えば：

```{r, eval=F}
setwd("C:/Documents/R Files/My analysis")
```

<span style="color: red;">**_注意：_** `setwd()` で作業ディレクトリを設定することは、そのファイルパスがある 1 台のコンピュータに特有の場合、"当てにならない" ものに<u>なりえます</u>。代わりに、（**here** パッケージを使用して）R プロジェクトのルートディレクトリからの相対的なファイルパスを使用してください。 </span>  



<!-- ======================================================= -->
### 手動での設定 {.unnumbered}  

作業ディレクトリを手動で設定するには、（`setwd()` に相当するポイント＆クリック操作）メニューバーから、Session をクリックし、ドロップダウンメニューから、"Set Working Directory" をポイントし、"Choose Directory" をクリックします。この操作で、特定の R セッション用の作業ディレクトリが設定されます。 注意：この方法を使用する場合、RStudio を開くたびに手動で設定する必要があります。


<!-- ======================================================= -->
### R プロジェクト内で {.unnumbered}

R プロジェクト内で実行している場合、作業ディレクトリのデフォルトは、".rproj" ファイルを含む R プロジェクトのルートフォルダになります。これは、R プロジェクトファイル（拡張子が ".rproj" ）をクリックして、RStudio を開いた場合に適用されます。


<!-- ======================================================= -->
### R markdown における作業ディレクトリ {.unnumbered}

R markdown スクリプトでは、 R markdown ファイル（`.Rmd`）が保存されているフォルダが、デフォルトの作業ディレクトリとなります。R プロジェクトと **here** パッケージを使用している場合には、デフォルトは適用されず、[R projects]{#r-projects} ページで説明されているように、作業ディレクトリは `here()` となります。

単独ファイルの R markdown の作業ディレクトリを変更したい場合、`setwd()` を使用すると、その特定のコードチャンクのみ適用されます。R markdown 内のすべてのコードチャンクに変更を加えるには、下記のように `root.dir = ` パラメータを追加するするために設定用のチャンクを追加します。

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/directorypath')
```

この方法より、R プロジェクト内で R markdown を使用し、**here** パッケージを使用するほうが遥かに簡単です。



<!-- ======================================================= -->
### ファイルパスの設定 {.unnumbered}  

おそらく R 初心者が共通で感じるフラストレーションのもとは（少なくとも Windows 機上では）、データのインポート、エクスポートのためのファイルパスを打ち込むことです。[インポートとエクスポート]{#importing}のページにファイルパスを最適に入力する方法の詳細な説明がありますが、下記にいくつかの重要なポイントを記載します：

**機能しないファイルパス**  

下記に、" 絶対パス " もしくは、" フルアドレス " ファイルパスのサンプルを記載しています。これらは、他のコンピュータ上では簡単に機能しなくなります。例外の 1 つは、共有ドライブもしくは、ネットワークドライブを使用している場合です。

```
C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  
```

**ディレクトリの区切り記号**  

<u>ファイルパスを入力する場合は、スラッシュの向きに注意してください。</u> フォルダとファイル名の区切り（例えば、"data/provincial.csv"）には、<u>スラッシュ記号</u>（`/`）を使用してください。Windows ユーザは、デフォルトのファイルパスの表示方法は、<u>バックスラッシュ</u>（`\\`）です。そのため、各バックスラッシュをスラッシュに変える必要があります。[R projects]{#r-projects} ページで詳細を説明している **here** パッケージを使用していれば、スラッシュ記号は問題になりません。

**相対パス**  

通常、絶対パスの代わりに、" 相対 " ファイルパスの記述をおすすめします。つまり、R プロジェクトのルートからの<u>相対的な</u>パスです。[R projects]{#r-projects} のページで説明されているように、**here** パッケージを使って相対パスの記述が可能です。相対的なファイルパスは下記のようになります：

```{r, eval=F}
# R プロジェクトの data/linelist/clean サブフォルダ空のラインリストの csv をインポートする
linelist <- import(here("data", "clean", "linelists", "marin_country.csv"))
```

R プロジェクト内で相対パスを使用していても、R プロジェクト外でデータをインポートやエクスポートする際には、絶対パスを使用することができます。





<!-- ======================================================= -->
## オブジェクト {#objects}

R のすべてはオブジェクトです。R は " オブジェクト指向 " 言語です。このセクションで説明します：

* どのようにしてオブジェクトを生成するか（`<-`）
* オブジェクトの型（例：データフレーム、ベクトル...）
* どのようにしてオブジェクトの構成要素にアクセスするか（例：データ・セット中の変数）
* オブジェクトのクラス（例：numeric, logical, integer, double, character, factor）



<!-- ======================================================= -->
### オブジェクトに関するすべてのこと {.unnumbered} 

<u>このセクションは、[R4Epis プロジェクト（英語）](https://r4epis.netlify.app/training/r_basics/objects/)から引用したものです。</u>
データセット、変数、村の名前のリスト、総人口の数、さらにはグラフのような出力など、R に保存するものは**すべて**オブジェクトであり、**名前が割り当てられ**、後のコマンドから**参照可能です。**

オブジェクトは、値を割り当てられた時点で存在します。（後述の割り当てのセクションを参照してください）値が割り当てられると、オブジェクトは Environment に表示されます。（RStudio の右上のペインにあります）割り当てにより、オブジェクトの操作、変更、再定義が可能になります。


<!-- ======================================================= -->
### オブジェクトを（`<-`）で定義する {.unnumbered}

**<- 演算子によって<u>値を割り当てることで</u>オブジェクトを生成します。**
割り当て用の演算子 `<-` を、"〜と定義する" と解釈できます。割り当てコマンドは、通常下記のように記述します：
 
**オブジェクト名** <- **値** （もしくは、値を生成するプロセスや計算を右辺に）

例えば、値を後のコードで参照するためのオブジェクトとして保存したい場合があります。下記の例では、`current_week` というオブジェクトに `"2018-w10"` という値が割り当てられ生成されています（値は二重引用符で character 値になっています）。`current_week` オブジェクトは、 RStudio の（右上にある）Environment ペインに表示され、以降のコマンドで参照できます。

以下のチャンクにある R コマンドと出力を参照してください。

```{r basics_objects_assignment}
current_week <- "2018-W10"   # このコマンドは、値を割り当てることで current_week オブジェクトを生成する
current_week                 # このコマンドは、コンソールへ current_week オブジェクトの現在の値を出力する
```

<span style="color: black;">**_備考:_** R コンソールでの `[1]` という出力は、これが出力の最初の項目であることを単に示しているだけということに注意してください。</span>


<span style="color: orange;">**_注意:_** オブジェクトの値を再定義する割り当てコマンドを実行することによって、**オブジェクトに格納されている値は、上書きされます。** そのため、**コマンドの実行順序は非常に重要になります。**</span>

下記のコマンドは、`current_week` の値を再定義します：

```{r basics_objects_reassignment}
current_week <- "2018-W51"   # current_week オブジェクトに新しい値を割り当てる
current_week                 # current_week の現在の値をコンソールへ出力する
```

**等号記号 `=`**  

R コード中に等号記号を見かけることもあります：

* 2 つのオブジェクトや値の間に置かれた二重等号 `==` は、論理的な<u>問いかけ</u>を示します： "左辺と右辺は等しいか"。
* 関数の引数の値を定義するために、関数内で等号が使われている場合もあります（下記のセクションを参照してください）。例えば、`max(age, na.rm = TRUE)`
* オブジェクトを生成する際に、`<-` の代わりに単独の等号 `=` を使うことも<u>できます</u>。しかし、この方法はおすすめできません。[こちら（英語）](https://renkun.me/2014/01/28/difference-between-assignment-operators-in-r/)に、なぜ推奨されないかの理由が記載されています。


**データセット**

データセットもオブジェクト（通常は、"データフレーム"）であり、インポート時に名前を割り当てる必要があります。下記のコードでは、**rio** パッケージの `import()` 関数でインポートされた CSV ファイルの値が割り当てられ、`linelist` オブジェクトが生成されます。

```{r basics_objects_dataframes, eval=FALSE}
# インポートされた CSV ファイルの値が割り当てられ linelist が生成される
linelist <- import("my_linelist.csv")
```

[インポートとエクスポート]{#importing}のセクションで、データセットのインポートとエクスポートについて説明しています。

<span style="color: orange;">**_注意：_** オブジェクトの名前付けに関する備考：</span>

  * オブジェクトの名前は、スペースを含んではいけません。スペースの代わりに、アンダースコア（_）やピリオド（.）を使用するべきです
  * オブジェクトの名前は、大文字と小文字を区別します。（つまり、Dataset_A と dataset_A は別のオブジェクトです）
  * オブジェクトの名前は、英字で始めなければいけません。（1, 2, 3 のような数値で始めることはできません）

**出力**

表形式やプロットのような出力は、出力がオブジェクトとして保存される、または、保存されずに単純に出力される良い例です。**base** R パッケージの `table()` 関数を利用した、性別とアウトカムののクロス集計表は、R コンソールに（保存されること<u>無しで</u>）直接出力することもできます。

```{r}
# R コンソールのみに出力
table(linelist$gender, linelist$outcome)
```

また、同じ集計表を名前付きオブジェクトとして保存することもできます。その後、選択肢として、出力もできます。

```{r}
# 保存
gen_out_table <- table(linelist$gender, linelist$outcome)

# 出力
gen_out_table
```

**列**  

データセット内の列も、オブジェクトであり、定義、上書き、生成などが可能です。下記の列セクションで詳しく説明されています。

**base** R パッケージの割り当て演算子を新しい列を作成するために使用できます。下記例では、`bmi` （Body Mass index）という名前の列を作成しています。そして、各行には、`wt_kg` 列と `ht_cm` 列の値から計算された結果が値として割り当てられます。

```{r, eval=F}
# base R パッケージのシンタクスを利用して、新たに "bmi" 列を生成する
linelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2
```

しかし、このハンドブックでは、列を定義するための別のアプローチに重点を置きます。それは、**dplyr** パッケージの `mutate()` 関数とパイプ演算子（`%>%`）を使用した<u>パイプ処理</u>を用います。このシンタクスは読みやすく、また、[Cleaning data and core functions]{#cleaning} のページで説明されているような利点があります。<u>パイプ処理</u>については、以降のパイプ処理セクションで詳しく説明しています。

```{r, eval=F} 
# dplyr シンタクスを用いて、新たに "bmi" 列を生成する
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```


<!-- ======================================================= -->
### オブジェクトの構造 {.unnumbered}  

**オブジェクトは一片のデータ（例、`my_number <- 24`）もしくは、構造化されたデータからなります。**

下記の画像は[こちらのオンライン R チュートリアル（英語）](http://venus.ifca.unican.es/Rintro/dataStruct.html)からお借りしました。いくつかの共通のデータ構造とその名前を示しています。[GIS の基本]{#gis} ページで説明される空間データについては、ここに含まれていません。


```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```  

疫学領域（疫学の特定の領域）において、<u>とても高頻度に</u>データフレームとベクトルに出会うでしょう。


データ構造          | 説明                                 | 例示
------------------- | ------------------------------------ | ------------------------  
Vectors             | 一連の単独オブジェクトのまとまり。すべての要素のクラスは等しい。（例、numeric クラスや character クラス） | **データフレームにおいて "変数"（列）はベクトルである**（例、`age_years` 列）
Data Frames         | すべて同じ数の行を持つベクトル（例、列）を束ねたもの | `linelist` はデータフレームである

なお、（データフレームに属さない）"独立した" ベクトルを作成するには、`c()` 関数を使用し異なる要素を結合する必要があります。例えば、プロットのカラースケール用の色のベクトルを作成する場合は次のように記述します：
`vector_of_colors <- c("blue", "red2", "orange", "grey")`  


<!-- ======================================================= -->
### オブジェクトのクラス  {.unnumbered}

R に保存されているすべてのオブジェクトは、<u>クラス</u>を持ちます。クラスは、R に対してオブジェクトの扱いを示します。取り得るクラスは無数にありますが、通常は下記に示す範囲です：

クラス     | 説明                                       | 例示
---------- | ------------------------------------------ | -----------------------------
Character  | **" 二重引用符に囲まれた "** テキスト／文章／センテンス。このオブジェクトに対して計算はできない。	| "二重引用符に囲まれた Character クラス"
Integer    | **整数のみ** （小数は含まない） | -5、14 や 2000
Numeric    | 実数 **小数を含む**。二重引用符に囲まれていた場合は、 character クラスとして扱われる。| 23.1 や 14  
Factor     | **特定の順番** あるいは、階層構造を持つベクトル | 順序付けられた値を持つ経済状態の変数
Date       | **あるデータが、日付であると R に示すと**、そのデータは特別な方法で操作や表示が可能。[日付の操作]{#dates}ページを参照。 | 2018-04-12、15/3/1954 や Wed 4 Jan 1980  
Logical    | 値は、2 つの特別な値 TRUE もしくは FALSE である。（二重引用符付きの "TRUE" や "FALSE" **ではない**ことに注意） | TRUE あるいは FALSE
data.frame | data.frame クラスは、R が**典型的なデータセット**を保存する方法。このクラスは、同じ数の観測値（行）を持つデータのベクトル（列）をまとめたもの。 | 例えば、AJS データセットには、`linelist_raw` を言う名前で、 68 個の変数と 300 個の観測値（行）が含まれる
tibble     | tibbles は、データフレームのバリエーションの 1 つで、動作上の違いは、コンソールに整った形で出力されること。（最初の 10 行と、画面に収まる列のみを表示） | 任意の data.frame, list, matrix は、`as_tibble()` で tibble クラスに変換できる
list       | list クラスは、ベクトルと似ているが、別のクラスのオブジェクトを要素に含むことができる | list クラスには、1 つの数値、データフレーム、ベクトル、list クラスそのものも内包できる


**`class()` 関数にオブジェクトの名前を渡すことで、オブジェクトのクラスを確認できます。** 備考：データセット内の特定の列を参照するには、データセット名と列名を `$` 記号で区切って記述します。

```{r, echo=TRUE,}
class(linelist)         # クラスは、data.frame クラスもしくは tibble クラス

class(linelist$age)     # クラスは、numeric クラス

class(linelist$gender)  # クラスは、character クラス
```

ときには、列が R によって自動的に別のクラスに変換されることがありますが、この変換には注意が必要です！例えば、数値を含む列やベクトルがあって、そこに文字列が挿入されると…列全体が character クラスに変わります。

```{r}
num_vector <- c(1,2,3,4,5) # すべてが数値のベクトルを定義
class(num_vector)          # ベクトルのクラスは numeric クラス
num_vector[3] <- "three"   # 3 番目の要素を、character クラスの文字列に変更
class(num_vector)          # ベクトルのクラスは、character クラスに変わってしまう
```

よくある例としては、データフレームを操作して表を印刷するときに、合計の行を作り、同じセルにパーセンテージを数字として貼り付けようとすると（例、`23 (40%)`）、数字の列全体が character クラスに変換され、数学的な計算に使用できなくなります。**場合によっては、オブジェクトや列を別のクラスに変換する必要があります。**

関数              | 動作
----------------- | --------------------------------------------------------------
`as.character()`  | character クラスに変換する
`as.numeric()`    | numeric クラスに変換する
`as.integer()`    | integer クラスに変換する
`as.Date()`       | Date クラスに変換する。備考：詳細は[日付](#dates)セクションにて
`factor()`        | factor クラスに変換する。備考：引数で値の水準の順番を再定義する

同様にして、次のようなオブジェクトが特定のクラスであるかどうかを調べる、**base** R パッケージの関数があります。 `is.numeric()`, `is.character()`, `is.double()`, `is.factor()`, `is.integer()`

[さらなるクラスやデータ構造に関するオンラインマテリアル（英語）](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/)があります。


<!-- ======================================================= -->
### 列／変数（`$`）{.unnumbered}  

**データフレーム中の列は、技術的には、"ベクトル"（上記、表を参照）です**。ベクトルとはすべてが同じクラス（character, numeric, logical クラスなど）でなければならない一連の値です。

ベクトルは、データフレームとは独立して存在できます。例えば、モデルに説明変数として含めたい列名のベクトルなどがあります。"独立した" ベクトルを作成するには、下記のように `c()` 関数を使います。

```{r, warning=F, message=F}
# character クラスの値を持つ独立したベクトルを定義する
explanatory_vars <- c("gender", "fever", "chills", "cough", "aches", "vomit")

# 名前付きベクトルの値を出力する
explanatory_vars
```

**データフレーム内の列もベクトルであり、`$` 記号を使用して、呼び出し、参照、抽出、生成などができます。** `$` 記号は、列の名前をそのデータフレームの名前をつなげるものです。このハンドブックでは、"変数" の代わりに "列" という言葉を使うようにしています。


```{r basics_objects_call, eval=F}
# age_years ベクトルの長さを取得する
length(linelist$age) # （age は linelist データフレーム中の列）

```

データフレームの名前の後に、`$` 記号を入力すると、データフレーム内のすべての列がドロップダウンメニューで表示されます。矢印キーで列をスクロールし、Enter キーで列を選択することができます。スペルミスも防げます！

```{r echo=F, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```  



<span style="color: darkgreen;">**_発展的なヒント：_** より複雑なオブジェクト（リストや、`epicontacts` オブジェクトなど）は、複数のドル記号でアクセスできる多階層水準を保持している場合があります。例えば、`epicontacts$lineline$date_onset` </span>



<!-- ======================================================= -->
### ブランケット記号（`[ ]`）でのアクセス／インデクス {.unnumbered}  

オブジェクトの一部を表示する必要がある時、よく角カッコ記号 `[ ]` が使用されます。これは、"インデクス（indexing）" とも呼ばれます。データフレーム上で `$` 記号を使って列にアクセスするのもインデクスの一種です。

```{r}
my_vector <- c("a", "b", "c", "d", "e", "f")  # ベクトルを定義する
my_vector[5]                                  # 5 番目の要素を出力する
```

角カッコ記号は、`summary()` 関数の出力のように、返された出力の特定の部分のみの表示にも使えます：

```{r}
# summary をすべて出力
summary(linelist$age)

# summary の 2 番目の要素のみを名前とともに出力（角カッコのペアを 1 つだけ使用）
summary(linelist$age)[2]

# 2 番目の要素のみを名前無しで出力（角カッコのペアを二重に使用）
summary(linelist$age)[[2]]

# 要素を名前をもとに抽出し、出力に名前を含めない
summary(linelist$age)[["Median"]]

```

ブラケット記号はデータフレームでも使用でき、特定の行や列を表示できます。`dataframe[rows, colums]` というシンタクスを使用します：

```{r basics_objects_access, eval=F}
# データセットから特定の行（2）のすべての列情報を表示（カンマを忘れずに！）
linelist[2,]

# すべての行のある一列の表示
linelist[, "date_onset"]

# 2 行目の 5 列目から 10 列目の値を表示
linelist[2, 5:10] 

# 2 行目の 5 列目から 10 列目および 18 列目の値を表示
linelist[2, c(5:10, 18)] 

# 2 行目から 20 列目の特定の列を表示
linelist[2:20, c("date_onset", "outcome", "age")]

# 条件式に基づいて行と列を表示
# *** データフレームの名前は条件式に含まれている必要がある！
linelist[linelist$age > 25 , c("date_onset", "outcome", "age")]

# View() を使用し、RStudio の Viewer ペインで出力を表示する（読みやすい表示）
# *** View() 関数は大文字 "V" であることに注意
View(linelist[2:20, "date_onset"])

# 新しいオブジェクトとして保存
new_table <- linelist[2:20, c("date_onset")] 
```

なお、上記の行／列インデクスは、**dplyr** の構文（行に対しては、`filter()` 関数、列に対しては、`select()` 関数）を用いても実現できます。これらの中核となる関数については、[Cleaning data and core functions]{#cleaning} ページを参照してください。

"行番号" に基づいてフィルタリングするには、**dplyr** パッケージの `row_number()` 関数と論理的な条件式の一部として、カッコを用います。多くの場合、以下に示すように、条件式の一部として、`%in%` 演算子と数値の範囲を使用します。<u>最初の</u> N 行を表示するには、**dplyr** の `head()` という特別な関数を用いることもできます。

```{r, eval=F}
# 最初の 100 行を表示
linelist %>% head(100)

# 5 行目のみを表示
linelist %>% filter(row_number() == 5)

# 2 行目から 20 行目までを特定列とともに表示（列名に二重引用符は不要ということに注意）
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

**list** クラスのオブジェクトをインデクスする場合、単一のオブジェクトしか返さない場合でも、1 つのペアのブラケット記号は常に list クラスを返します。しかし、2 つのペアのブラケット記号は、単一の要素にアクセスし、list クラスとは異なるクラスを返すために使用できます。
下記の例で示されるように、ブラケット記号は続けて記述することができます。

[コショウ瓶に例えたリスト・インデクスの図解解説（英語）](https://r4ds.had.co.nz/vectors.html#lists-of-condiments)は、ユーモアがあって参考になります。

```{r}
# 例示用のリストを定義
my_list <- list(
  # リストの最初の要素は、character クラスのベクトル
  hospitals = c("Central", "Empire", "Santa Anna"),
  
  # リストの 2 番目の要素は、住所のデータフレーム
  addresses   = data.frame(
    street = c("145 Medical Way", "1048 Brown Ave", "999 El Camino"),
    city   = c("Andover", "Hamilton", "El Paso")
    )
  )
```

このリストをコンソールに表示すると、以下のようになります。2 つの名前付きの要素があることがわかります：

* `hospitals`、character ベクトル
* `addresses`、住所のデータフレーム

```{r}
my_list
```
いくつかの方法を用いて、抽出してみましょう：

```{r}
my_list[1] # "list" クラスにある要素を返す - 要素名はまだ表示される

my_list[[1]] # （要素名のない）character ベクトルが返される

my_list[["hospitals"]] # リスト要素の名前でインデクス可能

my_list[[1]][3] # "hospitals" character ベクトルの 3 番目の要素を返す

my_list[[2]][1] # 住所データフレームの最初の列（"street"）を返す

```



<!-- ======================================================= -->
### オブジェクトの削除 {.unnumbered} 

`rm()` 関数の引数に個別のオブジェクトの名前を渡すことで（二重引用符無しで）、R 環境から削除できます。

```{r, eval=F}
rm(object_name)
```

すべてのオブジェクトを削除する（ワークスペースのクリア）には下記を実行します：

```{r, eval=F}
rm(list = ls(all = TRUE))
```



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## パイプ演算子とオブジェクト（`%>%`）  

**オブジェクトを使った作業の 2 つの一般的なアプローチとは：**

1) **パイプ演算子／tidyverse** - パイプ演算子は、関数から関数へオブジェクトを渡します - オブジェクトそのものではなく、その<u>アクション</u>に重点がおかれます。
2) **中間オブジェクトを定義する** - オブジェクトは何度も再定義されます - オブジェクトそのものに重点が置かれます。


<!-- ======================================================= -->
### **パイプ処理** {.unnumbered}

**単刀直入に説明すると、パイプ演算子（`%>%`）は、中間オブジェクトを 1 つの関数から次の関数へとわたします。**
会話時に、"そして" と話をつなげるような役割を持ちます。多く関数が、`%>%` 演算子で接続可能です。

* **パイプ処理は、アクションが実行されているオブジェクトではなくアクションのつながりに重点を置きます。**
* パイプ処理は、1 つのオブジェクトに対して、一連のアクションが実行されるときの使用が最適解になります。
* パイプ処理は、**dplyr** や **tidyverse** パッケージに同梱されている **magrittr** パッケージに含まれます。
* パイプ処理は、コードをよりクリーンで読みやすく、かつより直感的にします。

この手法のより詳しい情報は tidyverse [スタイルガイド（英語）](https://style.tidyverse.org/pipes.html)を参照してください。

下記は、比較のため架空の関数を使用して、"ケーキを焼く" アクションの例です。まずは、パイプ処理の例：

```{r piping_example_pipe, eval=F}
# パイプ処理シンタクスを使用して、ケーキを焼く架空の例

cake <- flour %>%       # ケーキを定義する。まず小麦粉を用意して…
  add(eggs) %>%   # 卵を追加
  add(oil) %>%    # 油を追加
  add(water) %>%  # 水を追加
  mix_together(         # 混ぜる
    utensil = spoon,
    minutes = 2) %>%    
  bake(degrees = 350,   # 焼成する
       system = "fahrenheit",
       minutes = 35) %>%  
  let_cool()            # 冷ます
```

また別に、パイプ処理の活用の説明ページの[リンク（英語）](https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations)があります。

パイプ処理は、**base** パッケージの関数ではありません。パイプ処理を使用するためには、**magrittr** パッケージがインストール、読み込まれている必要があります（典型的には、この操作は、**magritter** パッケージをその一部に含む **tidyverse** や **dplyr** パッケージを読み込むときに行われます）。[magrittr 公式ドキュメントでより詳しくパイプ処理について説明されています。（英語）](https://magrittr.tidyverse.org/)

他の R コマンドと同様に、パイプ処理は、代入演算子 `<-` が含まれているかどうかによって、結果を表示するためだけに使用したり、オブジェクトの保存や再保存などもできることに注意してください。下記の 2 つの例を参照してください：

```{r, eval=F}
# オブジェクトを作成または上書きし、年齢カテゴリ別の集計カウントとして利用する（出力されない）
linelist_summary <- linelist %>% 
  count(age_cat)
```

```{r}
# 集計カウント表をコンソールへ出力する。保存はされない。
linelist %>% 
  count(age_cat)
```


**`%<>%`**  
下記は、**magrittr** パッケージの "代入パイプ演算子" であり、<u>オプジェクトを前方にパイプ演算子で渡し、またオブジェクトを再定義します</u>。この演算子は、一連のパイプ処理の最初に置く必要があります。短縮表記として使用します。以下の 2 つのコマンドは等価です：

```{r, eval=F}
linelist <- linelist %>%
  filter(age > 50)

linelist %<>% filter(age > 50)
```


<!-- ======================================================= -->
### 中間オブジェクトの定義 {.unnumbered}

オブジェクト／データフレームを変更するこのアプローチは、以下の場合に適している可能性があります：

* 多数のオブジェクトを操作する必要がある場合
* 処理が意味を持ち、別のオブジェクト名にする必要がある中間処理がある場合


**リスク:**  

* 各処理ごとに新しいオブジェクトを作成するということは、たくさんのオブジェクトを作成することを意味します。間違ったオブジェクトを使ったとしても気づかない可能性があります！
* すべてのオブジェクトに名前をつけると混乱します
* エラーが発生しても簡単には発見できなくなるでしょう

それぞれの中間オブジェクトに名前をつけるか、もとのオブジェクトを上書きするか、あるいは、すべての関数を組み合わせるか、左記のいずれの選択肢もリスクを伴います。

下記は、前述の架空の "ケーキ" 関数の例です。今回は、中間オブジェクトを利用します：

```{r piping_example_redefine, eval=F}
# 中間オブジェクトを使用する方法を利用して、ケーキを焼く架空の例
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

すべての関数を組み合わせる手法 - この方法は非常に読みにくくなります：

```{r eval=F}
# 組み合わさった、あるいは、ネスト状になった多数の関数 - 判読困難
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```


<!-- ======================================================= -->
## 重要な演算子と関数 {#operators}

このセクションでは、R の演算子について説明します。たとえば：
This section details operators in R, such as:  

* 代入演算子
* 関係演算子
* 論理演算子（and, or...）
* 欠損値の扱い
* 数学的演算子と関数（+/-, >, sum(), median(), ...）
* `%in%` 演算子



<!-- ======================================================= -->
### 代入演算子 {.unnumbered}  

**`<-`**  

R において基本となる代入演算子は、`<-` です。`オブジェクト名 <- 値`
代入演算子は、`=` でも書き換え可能です。通常の R の使用では、`<-` 演算子の使用を推奨しています。
また、可読性向上のために、代入演算子の前後にスペースの挿入を推奨しています。


**`<<-`**  

[関数の作成]{#writing-function}時、または、ソーススクリプトでのインタラクティブな R の使用時に、`<<-` 代入演算子が必要になる可能性があります（**base** R パッケージに含まれます）。この演算子は、より高次の `parent` R 環境でオブジェクトを定義するために使われます。こちらの[オンラインリファレンス（英語）](https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html)を参照してください。


**`%<>%`**  

これは、**magrittr** に含まれる、"代入パイプ演算子" です。この演算子は、オブジェクトを演算子の前方に渡し、<u>また、前方のオブジェクトを再定義します</u>。パイプ処理の最初の演算子として使用しなければいけません。略式記法として機能します。下記に 2 つの等価な例を提示します：

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age_months = age_years * 12)
```  

上記は、下記と等価です：

```{r, eval=F}
linelist %<>% mutate(age_months = age_years * 12)
```

**`%<+%`**

この演算子は、**ggtree** パッケージを使用して、系統樹へデータを追加する際に使用します。[系統樹]{#phylogenetic-trees}のページもしくは、オンライン[リソースブック（英語）](https://yulab-smu.top/treedata-book/)を参照してください。


 

<!-- ======================================================= -->
### 関係演算子と論理演算子 {.unnumbered}  

関係演算子は、値の比較に用いられ、データセットのサブセットや、変数の定義時によく用いられます。R でよく用いられる関係演算子は下記です：

意味                    |演算子       |例            |結果
------------------------|-------------|--------------|---------------------------
〜と等しい              |`==`         |`"A" == "a"`  |`FALSE` （R は大文字小文字を区別するので） * 注意 ==（二重等号）は、代入演算子 `<-` として働く =（等号）とは区別されます
〜と等しくない          |`!=`         |`2 != 0`      |`TRUE`
〜より大きい            |`>`          |`4 > 2`       |`TRUE`
〜より小さい            |`<`          |`4 < 2`       |`FALSE`
〜以上                  |`>=`         |`6 >= 4`      |`TRUE`
〜以下                  |`<=`         |`6 <= 4`      |`FALSE`
値が欠損している        |`is.na()`    |`is.na(7)`    |`FALSE` （[Missing data]{#missing-data} ページを参照）
値が欠損していない      |`!is.na()`   |`!is.na(7)`   |`TRUE`

AND や OR などの論理演算子は、関係演算子とともによく用いられます。そして、より複雑な条件式を構築します。複雑な条件は、条件をグループに分けたり、処理順を明示するためにカッコ（ ）を必要とします。

意味       |演算子
-----------|------------------------
AND        |`&`
OR         |`|` (vertical bar)
カッコ     |`( )` 条件をグループにまとめたり、演算の処理順を明示したりするために使用されます


下記の例では、症例定義作成のために 2 つの変数を linelist から取得します。テスト結果を保持する `hep_e_rdt` 変数と、家庭内に他の症例があるかのフラグである `other_cases_in_hh` 変数です。下記のコマンドでは、`case_when()` 関数を新しい `case_def` 変数の生成のために使用しています：

```{r eval=FALSE}
linelist_cleaned <- linelist %>%
  mutate(case_def = case_when(
    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,
    rdt_result == "Positive"                                 ~ "Confirmed",
    rdt_result != "Positive" & other_cases_in_home == "Yes"  ~ "Probable",
    TRUE                                                     ~ "Suspected"
  ))
```

上記例での条件                                                   | 新しい "case_def" 変数内での結果
-----------------------------------------------------------------|-------------------------------------
`rdt_result` 変数と `other_cases_in_home` 変数の値が欠損している | `NA`（欠損）
`rdt_result` 変数の値が、"Positive" である                       | "Confirmed"
`rdt_result` 変数の値が、"Positive" ではなく、かつ、`other_cases_in_home` 変数の値が "Yes" である | "Probable"
上記の条件のいずれか 1 つに合致しない                            | "Suspected"


<u>R は大文字小文字を区別するので、"Positive" と "positive" は区別されることに注意してください…</u>

 
<!-- ======================================================= -->
### 欠損値 {.unnumbered}

R では、欠損している値は特別な値 `NA`（"予約" 語）で定義されています（二重引用符で囲まれた大文字の N と A ではありません）。もし欠損値が別の方法で表されたデータ（例、99, "Missing", や .）をインポートする場合、それらの値を `NA` に置き換えたくなるでしょう。この操作をどのように行うかは [Import and export]{#importing} ページを参照してください。

**値が `NA` であるかどうかを確認するには、`is.na()` という特別な関数を使用します**。戻り値は、 `TRUE` もしくは、`FALSE` になります。

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # 2 例の陽性症例、1 例の疑い症例、1 例の不明症例
is.na(rdt_result)  # rdt_result 変数の値が NA であるかを確認する
```

欠損値や、無限（infinite）、`NULL` や不可能値については、[Missing data]{#missing-data}のページを参照してください。データのインポート時に欠損値をコンバートする方法を学ぶには、[Import and export]{#importing} ページを参照してください。



<!-- ======================================================= -->
### 数学と統計 {.unnumbered}  

このセクションに記載しているすべての演算子と関数は、**base** R パッケージを使用することで自動的に利用可能になります。

#### 算術演算子 {.unnumbered} 

算術演算子は、加算や除算の際や、新しい列の追加の際などによく用いられます。下記は、R において共通に用いられる算術演算子です。演算子の前後に半角スペースを挿入するかどうかは、重要ではありません。


目的            | R での例
----------------|-------------
加算            | 2 + 3
減算            | 2 - 3
乗算            | 2 * 3
除算            | 30 / 5
べき乗          | 2^3
演算子の処理順  | ( )



#### 算術演算子 {.unnumbered}

目的                | 関数
--------------------|-------------
丸め                | round(x, digits = n)  
丸め（四捨五入）    | janitor::round_half_up(x, digits = n)
ceiling（切り上げ） | ceiling(x)
floor（切り捨て）   | floor(x)
絶対値              | abs(x)
二乗根              | sqrt(x)
べき乗              | exponent(x)
自然対数            | log(x)
log10（常用対数）   | log10(x)
log2（二進対数）    | log2(x)

備考：`round()` 関数の、`digits = ` 引数は、小数点以下の桁数を指定します。`signif()` 関数を使用して、有効数字に丸めます。


#### 科学的数法 {.unnumbered}

科学的数法が使われるかどうかは、`scipen` オプションの値に依存します。

`?options` のヘルプドキュメントより：scipen は、数値を固定記法または指数記法のいずれで出力するかを決定する際に適用されるペナルティ値です。正の値の場合は固定記法に、負の値の場合は科学的記法で出力されます：適用される数値が、`scipen` 桁幅以上ではない場合に固定記法が優先されます。

`scipen` オプションが少ない数値（例、0）に設定されている場合、常に "適用" されます。現在の R セッションで科学的数法を "適用しない" 場合は、このオプションの値を非常に大きい値に設定します。例えば：

```{r, eval=F}
# 科学的数法を適用しない
options(scipen=999)
```



#### 丸め {.unnumbered}  

<span style="color: red;">**_要注意：_** `round()` 関数は、"銀行型丸め" を適用します。つまり、1 つ上の桁が偶数である場合のみ、0.5 より大きい数を切り上げます。常に四捨五入するには、**junitor** パッケージの `round_half_up()` 関数を使用してください。[こちらの説明（英語）](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes)を参照してください。</span>

```{r}
# あなたの意図に適する丸めを実行する
round(c(2.5, 3.5))

janitor::round_half_up(c(2.5, 3.5))
```


#### 統計関数 {.unnumbered}  

<span style="color: orange;">**_注意：_** 下記の関数は、デフォルトの設定では、計算時に欠損値を含めます。欠損値は、`na.rm = TRUE` 引数を指定しない限り、出力時に `NA` が結果として出力されます。省略記法では、`na.rm = T` と記述されます。</span>


目的                | 関数
--------------------|----------------------
mean（平均）        | mean(x, na.rm=T)
メディアン          | median(x, na.rm=T)
標準偏差            | sd(x, na.rm=T)
分位数*             | quantile(x, probs)
総和                | sum(x, na.rm=T)
最小値              | min(x, na.rm=T)
最大値              | max(x, na.rm=T)
数値の範囲          | range(x, na.rm=T)
summary**           | summary(x)

備考：

* `*quantile()`： `x` 変数は、分位数を計算する対象の数値ベクトルです。`probs = ` オプションは、0 から 1.0 の範囲の確率に対応する数値ベクトルです。（例、`c(0.5, 0.8, 0.05)`
* `**summary()`： この関数は、数値ベクトルの平均、メディアン、共通のパーセンタイルを含む統計的要約を出力します。

<span style="color: red;">**_要注意：_** 上記の関数に数値ベクトルを渡す場合は、数値を `c()` 関数で囲んでいることを確認してください。</span>

```{r}
# 生の数値を関数に渡す場合、c() 関数で囲む
mean(1, 6, 12, 10, 5, 0)    # ！！！正しくない！！！

mean(c(1, 6, 12, 10, 5, 0)) # 正しい表記
```





#### その他に有用な関数 {.unnumbered}  


目的                        | 関数                  | 例示
----------------------------|-----------------------|-----------------------------------------------
連続する数値を作成する      | seq(開始, 終了, 間隔) |`seq(1, 10, 2)`
x を n 回繰り返す           | rep(x, n 回)          |`rep(1:3, 2)` or `rep(c("a", "b", "c"), 3)` 
数値ベクトルを区切る        | cut(x, n)             |`cut(linelist$age, 5)`
ランダムサンプルを取得する  | sample(x, size)       |`sample(linelist$id, size = 5, replace = TRUE)`




<!-- ======================================================= -->
### `%in%` {.unnumbered}  

値のマッチング、ベクトルやデータフレーム内に値があるかどうかをすばやく評価するために非常に有用な演算子です。

```{r}
my_vector <- c("a", "b", "c", "d")
```

```{r}
"a" %in% my_vector
"h" %in% my_vector
```

ある値がベクトル内 `%in%` に**無い**かどうかを確かめるためには、論理式の**直前に**エクスクラメーションマーク（！）をつけます。

```{r}
# 論理式を否定するには、直前にエクスクラメーションマークを置く
!"a" %in% my_vector
!"h" %in% my_vector
```

`%in%` は、**dplyr** パッケージの `case_when()` 関数を使用するときに有用です。前もってベクトルを定義しておき、後ほどそれを参照できます。例えば下記のようになります：

```{r eval=F}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")

linelist <- linelist %>% 
  mutate(child_hospitaled = case_when(
    hospitalized %in% affirmative & age < 18 ~ "Hospitalized Child",
    TRUE                                      ~ "Not"))
```

備考：**stringr** パッケージの `str_detect()` 関数を使用して、文字列の一部を検出したい場合、`c("1", "Yes", "yes", "y")` のような文字ベクトルは引数として渡せません。その代わりに、<u>正規表現</u> - "1|Yes|yes|y" のような、 OR バー演算子で構成された文字列 - を与えなければなりません。例えば、`str_detect(hospitalized, "1|Yes|yes|y")` のようにコンデンス記述します。詳しくは、[文字と文字列]{#characters-strings}のページを参照してください。

文字列ベクトルを、下記のコマンドで名前付き正規表現に変換可能です：

```{r}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")
affirmative

# コンデンスを実行
affirmative_str_search <- paste0(affirmative, collapse = "|")  # base R パッケージのオプション
affirmative_str_search <- str_c(affirmative, collapse = "|")   # stringr パッケージのオプション

affirmative_str_search
```









<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## エラーと警告

このセクションでは書きを解説します：

* エラーと警告の違い
* R コードを書く際の一般的なシンタクスのヒント
* コードアシスト

よくあるエラーと警告そしてトラブルシューティングのヒントは、[よくあるエラー]{#errors}のページにあります。



<!-- ======================================================= -->
### エラーと警告 {.unnumbered}

コマンドを事項する際に、R コンソールは赤い文字で警告やエラーメッセージを表示するかもしれません。

* **警告** は、R はコマンドの実行を完了したが、追加のステップが必要もしくは、実行者が知るべき、通常にはない出力があることを意味します。

* **エラー** は、R はコマンドの実行を完了できなかったことを意味します。

手がかりを探すために：

* エラー／警告メッセージは、通常、問題が発生している行数を含みます。

* オブジェクトが、"is unknown" や、"not found" と表示されているならば、オブジェクトのスペルを誤っている場合や、`library()` 関数でパッケージを読み込んでいない場合、スクリプトに変更を加えた後で再実行していない場合があります。

すべてがうまく行かない場合は、エラーメッセージをいくつかのキーワードとともに Google にコピーし検索を実行してください - 他の誰かがすでに解決しているかもしれません！


<!-- ======================================================= -->
### 一般的なシンタクスのヒント {.unnumbered}

R でコマンドを記述する際にエラーや警告の発生させないために、知っておくとよいいくつかのヒントは下記です：

* 常にカッコを閉じる - ヒント：各コードチャンクで開きカッコ "(" と閉じカッコ ")" の数を数える。
* 列とオブジェクトの間にスペースを入れない。代わりにアンダースコアと（ _ ）ピリオド（ . ）を使用する。
* 関数の引数をカンマで区切ることを意識し、追従する。
* R は大文字小文字を区別する。つまり `Variable_A` と `variable_A` は<u>区別される</u>。


<!-- ======================================================= -->
### コードアシスタント {.unnumbered}  

どんなスクリプトでも（RMarkdown やそれ以外でも）、もしコードに誤りがあった場合は、その手がかりを提示します。例えば、カンマが必要な箇所に入力を忘れた場合や、カッコを閉じ忘れた場合、RStudio は対象行の左側に警告用のフラグを立てます。








