<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>28 GIS basics | The Epidemiologist R Handbook</title>

    <meta name="author" content="the handbook team" />
  
  <!-- JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.2"></script>
  <script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script>
    <script src="libs/header-attrs-2.8/header-attrs.js"></script>
    <script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet" />
    <script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script>
    <script src="libs/bs3compat-0.2.5.1/tabs.js"></script>
    <script src="libs/bs3compat-0.2.5.1/bs3compat.js"></script>
    <link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet" />
    <script src="libs/bs4_book-1.0.0/bs4_book.js"></script>
    <script src="https://cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/mark.min.js"></script>

  <!-- CSS -->
    <link rel="stylesheet" href="style_bs4.css" />
    
</head>

<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book">
    <a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">The Epidemiologist R Handbook</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
      </form>

      <nav aria-label="Table of contents">
        <h2>Table of contents</h2>
        <div id="book-toc"></div>

        <div class="book-extra">
          <p><a id="book-repo" href="#">View book source <i class="fab fa-github"></i></a></li></p>
        </div>
      </nav>
    </div>
  </header>

  <main class="col-sm-12 col-md-9 col-lg-7" id="content">
<div id="gis-basics" class="section level1" number="28">
<h1><span class="header-section-number">28</span> GIS basics</h1>
<!-- ======================================================= -->
<div id="overview-6" class="section level2" number="28.1">
<h2><span class="header-section-number">28.1</span> Overview</h2>
<p>Spatial aspects of your data can provide a lot of insights into the situation of the outbreak, and to answer questions such as:</p>
<ul>
<li>Where are the current disease hotspots?</li>
<li>How have the hotspots have changed over time?</li>
<li>How is the access to health facilities? Are any improvements needed?</li>
</ul>
<p>The current focus of this GIS page to address the needs of applied epidemiologists in outbreak response. We will explore basic spatial data visualization methods using <strong>tmap</strong> and <strong>ggplot2</strong> packages. We will also walk through some of the basic spatial data management and querying methods with the <strong>sf</strong> package. Lastly, we will briefly touch upon concepts of <em>spatial statistics</em> such as spatial relationships, spatial autocorrelation, and spatial regression using the <strong>spdep</strong> package.</p>
</div>
<div id="key-terms-1" class="section level2" number="28.2">
<h2><span class="header-section-number">28.2</span> Key terms</h2>
<p>Below we introduce some key terminology. For a thorough introduction to GIS and spatial analysis, we suggest that you review one of the longer tutorials or courses listed in the References section.</p>
<p><strong>Geographic Information System (GIS)</strong> - A GIS is a framework or environment for gathering, managing, analyzing, and visualizing spatial data.</p>
<div id="gis-software" class="section level3 unnumbered">
<h3>GIS software</h3>
<p>Some popular GIS software allow point-and-click interaction for map development and spatial analysis. These tools comes with advantages such as not needing to learn code and the ease of manually selecting and placing icons and features on a map. Here are two popular ones:</p>
<p><strong>ArcGIS</strong> - A commercial GIS software developed by the company ESRI, which is very popular but quite expensive</p>
<p><strong>QGIS</strong> - A free open-source GIS software that can do almost anything that ArcGIS can do. You can <a href="https://qgis.org/en/site/forusers/download.html">download QGIS here</a></p>
<p>Using R as a GIS can seem more intimidating at first because instead of “point-and-click”, it has a “command-line interface” (you must code to acquire the desired outcome). However, this is a major advantage if you need to repetitively produce maps or create an analysis that is reproducible.</p>
</div>
<div id="spatial-data" class="section level3 unnumbered">
<h3>Spatial data</h3>
<p>The two primary forms of spatial data used in GIS are vector and raster data:</p>
<p><strong>Vector Data</strong> - The most common format of spatial data used in GIS, vector data are comprised of geometric features of vertices and paths. Vector spatial data can be further divided into three widely-used types:</p>
<ul>
<li><p><em>Points</em> - A point consists of a coordinate pair (x,y) representing a specific location in a coordinate system. Points are the most basic form of spatial data, and may be used to denote a case (i.e. patient home) or a location (i.e. hospital) on a map.</p></li>
<li><p><em>Lines</em> - A line is composed of two connected points. Lines have a length, and may be used to denote things like roads or rivers.</p></li>
<li><p><em>Polygons</em> - A polygon is composed of at least three line segments connected by points. Polygon features have a length (i.e. the perimeter of the area) as well as an area measurement. Polygons may be used to note an area (i.e. a village) or a structure (i.e. the actual area of a hospital).</p></li>
</ul>
<p><strong>Raster Data</strong> - An alternative format for spatial data, raster data is a matrix of cells (e.g. pixels) with each cell containing information such as height, temperature, slope, forest cover, etc. These are often aerial photographs, satellite imagery, etc. Rasters can also be used as “base maps” below vector data.</p>
</div>
<div id="visualizing-spatial-data" class="section level3 unnumbered">
<h3>Visualizing spatial data</h3>
<p>To visually represent spatial data on a map, GIS software requires you to provide sufficient information about where different features should be, in relation to one another. If you are using vector data, which will be true for most use cases, this information will typically be stored in a shapefile:</p>
<p><strong>Shapefiles</strong> - A shapefile is a common data format for storing “vector” spatial data consisting or lines, points, or polygons. A single shapefile is actually a collection of at least three files - .shp, .shx, and .dbf. All of these sub-component files must be present in a given directory (folder) for the shapefile to be readable. These associated files can be compressed into a ZIP folder to be sent via email or download from a website.</p>
<p>The shapefile will contain information about the features themselves, as well as where to locate them on the Earth’s surface. This is important because while the Earth is a globe, maps are typically two-dimensional; choices about how to “flatten” spatial data can have a big impact on the look and interpretation of the resulting map.</p>
<p><strong>Coordinate Reference Systems (CRS)</strong> - A CRS is a coordinate-based system used to locate geographical features on the Earth’s surface. It has a few key components:</p>
<ul>
<li><p><em>Coordinate System</em> - There are many many different coordinate systems, so make sure you know which system your coordinates are from. Degrees of latitude/longitude are common, but you could also see <a href="https://www.maptools.com/tutorials/utm/quick_guide">UTM</a> coordinates.</p></li>
<li><p><em>Units</em> - Know what the units are for your coordinate system (e.g. decimal degrees, meters)</p></li>
<li><p><em>Datum</em> - A particular modeled version of the Earth. These have been revised over the years, so ensure that your map layers are using the same datum.</p></li>
<li><p><em>Projection</em> - A reference to the mathematical equation that was used to project the truly round earth onto a flat surface (map).</p></li>
</ul>
<p>Remember that you can summarise spatial data without using the mapping tools shown below. Sometimes a simple table by geography (e.g. district, country, etc.) is all that is needed!</p>
</div>
</div>
<div id="getting-started-with-gis" class="section level2" number="28.3">
<h2><span class="header-section-number">28.3</span> Getting started with GIS</h2>
<p>There are a couple of key items you will need to have and to think about to make a map. These include:</p>
<ul>
<li><p>A <strong>dataset</strong> – this can be in a spatial data format (such as shapefiles, as noted above) or it may not be in a spatial format (for instance just as a csv).</p></li>
<li><p>If your dataset is not in a spatial format you will also need a <strong>reference dataset</strong>. Reference data consists of the spatial representation of the data and the related <strong>attributes</strong>, which would include material containing the location and address information of specific features.</p>
<ul>
<li><p>If you are working with pre-defined geographic boundaries (for example, administrative regions), reference shapefiles are often freely available to download from a government agency or data sharing organization. When in doubt, a good place to start is to Google “[regions] shapefile”</p></li>
<li><p>If you have address information, but no latitude and longitude, you may need to use a <strong>geocoding engine</strong> to get the spatial reference data for your records.</p></li>
</ul></li>
<li><p>An idea about <strong>how you want to present</strong> the information in your datasets to your target audience. There are many different types of maps, and it is important to think about which type of map best fits your needs.</p></li>
</ul>
<div id="types-of-maps-for-visualizing-your-data" class="section level3 unnumbered">
<h3>Types of maps for visualizing your data</h3>
<p><strong>Choropleth map</strong> - a type of thematic map where colors, shading, or patterns are used to represent geographic regions in relation to their value of an attribute. For instance a larger value could be indicated by a darker colour than a smaller value. This type of map is particularly useful when visualizing a variable and how it changes across defined regions or geopolitical areas.</p>
<p><strong>Case density heatmap</strong> - a type of thematic map where colours are used to represent intensity of a value, however, it does not use defined regions or geopolitical boundaries to group data. This type of map is typically used for showing ‘hot spots’ or areas with a high density or concentration of points.</p>
<p><strong>Dot density map</strong> - a thematic map type that uses dots to represent attribute values in your data. This type of map is best used to visualize the scatter of your data and visually scan for clusters.</p>
<p><strong>Proportional symbols map (graduated symbols map)</strong> - a thematic map similar to a choropleth map, but instead of using colour to indicate the value of an attribute it uses a symbol (usually a circle) in relation to the value. For instance a larger value could be indicated by a larger symbol than a smaller value. This type of map is best used when you want to visualize the size or quantity of your data across geographic regions.</p>
<p>You can also combine several different types of visualizations to show complex geographic patterns. For example, the cases (dots) in the map below are colored according to their closest health facility (see legend). The large red circles show <em>health facility catchment areas</em> of a certain radius, and the bright red case-dots those that were outside any catchment range:</p>
<p>Note: The primary focus of this GIS page is based on the context of field outbreak response. Therefore the contents of the page will cover the basic spatial data manipulations, visualizations, and analyses.</p>
<!-- ======================================================= -->
</div>
</div>
<div id="preparation-19" class="section level2" number="28.4">
<h2><span class="header-section-number">28.4</span> Preparation</h2>
<div id="load-packages-18" class="section level3 unnumbered">
<h3>Load packages</h3>
<p>This code chunk shows the loading of packages required for the analyses. In this handbook we emphasize <code>p_load()</code> from <strong>pacman</strong>, which installs the package if necessary <em>and</em> loads it for use. You can also load installed packages with <code>library()</code> from <strong>base</strong> R. See the page on <a href="r-basics.html#r-basics">R basics</a> for more information on R packages.</p>
<p>You can see an overview of all the R packages that deal with spatial data at the <a href="https://cran.r-project.org/web/views/Spatial.html">CRAN “Spatial Task View”</a>.</p>
</div>
<div id="sample-case-data" class="section level3 unnumbered">
<h3>Sample case data</h3>
<p>For demonstration purposes, we will work with a random sample of 1000 cases from the simulated Ebola epidemic <code>linelist</code> dataframe (computationally, working with fewer cases is easier to display in this handbook). If you want to follow along, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the “clean” linelist</a> (as .rds file).</p>
<p>Since we are taking a random sample of the cases, your results may look slightly different from what is demonstrated here when you run the codes on your own.</p>
<p>Import data with the <code>import()</code> function from the <strong>rio</strong> package (it handles many file types like .xlsx, .csv, .rds - see the <a href="import-and-export.html#import-and-export">Import and export</a> page for details).</p>
<p>Next we select a random sample of 1000 rows using <code>sample()</code> from <strong>base</strong> R.</p>
<p>Now we want to convert this <code>linelist</code> which is class dataframe, to an object of class “sf” (spatial features). Given that the linelist has two columns “lon” and “lat” representing the longitude and latitude of each case’s residence, this will be easy.</p>
<p>We use the package <strong>sf</strong> (spatial features) and its function <code>st_as_sf()</code> to create the new object we call <code>linelist_sf</code>. This new object looks essentially the same as the linelist, but the columns <code>lon</code> and <code>lat</code> have been designated as coordinate columns, and a coordinate reference system (CRS) has been assigned for when the points are displayed. 4326 identifies our coordinates as based on the <a href="https://gisgeography.com/wgs84-world-geodetic-system/">World Geodetic System 1984 (WGS84)</a> - which is standard for GPS coordinates.</p>
<p>This is how the original <code>linelist</code> dataframe looks like. In this demonstration, we will only use the column <code>date_onset</code> and <code>geometry</code> (which was constructed from the longitude and latitude fields above and is the last column in the data frame).</p>
</div>
<div id="admin-boundary-shapefiles" class="section level3 unnumbered">
<h3>Admin boundary shapefiles</h3>
<p><strong>Sierra Leone: Admin boundary shapefiles</strong></p>
<p>In advance, we have downloaded all administrative boundaries for Sierra Leone from the Humanitarian Data Exchange (HDX) <a href="https://data.humdata.org/dataset/sierra-leone-all-ad-min-level-boundaries">website here</a>. Alternatively, you can download these and all other example data for this handbook via our R package, as explained in the <a href="download-handbook-and-data.html#download-handbook-and-data">Download handbook and data</a> page.</p>
<p>Now we are going to do the following to save the Admin Level 3 shapefile in R:</p>
<ol style="list-style-type: decimal">
<li>Import the shapefile<br />
</li>
<li>Clean the column names<br />
</li>
<li>Filter rows to keep only areas of interest</li>
</ol>
<p>To import a shapefile we use the <code>read_sf()</code> function from <strong>sf</strong>. It is provided the filepath via <code>here()</code>. - in our case the file is within our R project in the “data”, “gis”, and “shp” subfolders, with filename “sle_adm3.shp” (see pages on <a href="import-and-export.html#import-and-export">Import and export</a> and <a href="r-projects.html#r-projects">R projects</a> for more information). You will need to provide your own file path.</p>
<p>Next we use <code>clean_names()</code> from the <strong>janitor</strong> package to standardize the column names of the shapefile. We also use <code>filter()</code> to keep only the rows with admin2name of “Western Area Urban” or “Western Area Rural”.</p>
<p>Below you can see the how the shapefile looks after import and cleaning. <em>Scroll to the right</em> to see how there are columns with admin level 0 (country), admin level 1, admin level 2, and finally admin level 3. Each level has a character name and a unique identifier “pcode”. The pcode expands with each increasing admin level e.g. SL (Sierra Leone) -&gt; SL04 (Western) -&gt; SL0410 (Western Area Rural) -&gt; SL040101 (Koya Rural).</p>
</div>
<div id="population-data" class="section level3 unnumbered">
<h3>Population data</h3>
<p><strong>Sierra Leone: Population by ADM3</strong></p>
<p>These data can again be downloaded from HDX (link <a href="https://data.humdata.org/dataset/sierra-leone-population">here</a>) or via our <strong>epirhandbook</strong> R package as explained <a href="download-handbook-and-data.html#download-handbook-and-data">in this page</a>. We use <code>import()</code> to load the .csv file. We also pass the imported file to <code>clean_names()</code> to standardize the column name syntax.</p>
<p>Here is what the population file looks like. Scroll to the right to see how each jurisdiction has columns with <code>male</code> population, <code>female</code> populaton, <code>total</code> population, and the population break-down in columns by age group.</p>
</div>
<div id="health-facilities" class="section level3 unnumbered">
<h3>Health Facilities</h3>
<p><strong>Sierra Leone: Health facility data from OpenStreetMap</strong></p>
<p>Again we have downloaded the locations of health facilities from HDX <a href="https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities">here</a> or via instructions in the <a href="download-handbook-and-data.html#download-handbook-and-data">Download handbook and data</a> page.</p>
<p>We import the facility points shapefile with <code>read_sf()</code>, again clean the column names, and then filter to keep only the points tagged as either “hospital”, “clinic”, or “doctors”.</p>
<p>Here is the resulting dataframe - <em>scroll right</em> to see the facility name and <code>geometry</code> coordinates.</p>
<!-- ======================================================= -->
</div>
</div>
<div id="plotting-coordinates" class="section level2" number="28.5">
<h2><span class="header-section-number">28.5</span> Plotting coordinates</h2>
<p>The easiest way to plot X-Y coordinates (longitude/latitude, points), in this case of cases, is to draw them as points directly from the <code>linelist_sf</code> object which we created in the preparation section.</p>
<p>The package <strong>tmap</strong> offers simple mapping capabilities for both static (“plot” mode) and interactive (“view” mode) with just a few lines of code. The <strong>tmap</strong> syntax is similar to that of <strong>ggplot2</strong>, such that commands are added to each other with <code>+</code>. Read more detail in this <a href="https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html">vignette</a>.</p>
<ol style="list-style-type: decimal">
<li>Set the <strong>tmap</strong> mode. In this case we will use “plot” mode, which produces static outputs.</li>
</ol>
<p>Below, the points are plotted alone.<code>tm_shape()</code> is provided with the <code>linelist_sf</code> objects. We then add points via <code>tm_dots()</code>, specifying the size and color. Because <code>linelist_sf</code> is an sf object, we have already designated the two columns that contain the lat/long coordinates and the coordinate reference system (CRS):</p>
<p>Alone, the points do not tell us much. So we should also map the administrative boundaries:</p>
<p>Again we use <code>tm_shape()</code> (see <a href="https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape">documentation</a>) but instead of providing the case points shapefile, we provide the administrative boundary shapefile (polygons).</p>
<p>With the <code>bbox =</code> argument (bbox stands for “bounding box”) we can specify the coordinate boundaries. First we show the map display without <code>bbox</code>, and then with it.</p>
<p>And now both points and polygons together:</p>
<p>To read a good comparison of mapping options in R, see this <a href="https://rstudio-pubs-static.s3.amazonaws.com/324400_69a673183ba449e9af4011b1eeb456b9.html">blog post</a>.</p>
<!-- ======================================================= -->
</div>
<div id="spatial-joins" class="section level2" number="28.6">
<h2><span class="header-section-number">28.6</span> Spatial joins</h2>
<p>You may be familiar with <em>joining</em> data from one dataset to another one. Several methods are discussed in the <a href="joining-data.html#joining-data">Joining data</a> page of this handbook. A spatial join serves a similar purpose but leverages spatial relationships. Instead of relying on common values in columns to correctly match observations, you can utilize their spatial relationships, such as one feature being <em>within</em> another, or <em>the nearest neighbor</em> to another, or within a <em>buffer</em> of a certain radius from another, etc.</p>
<p>The <strong>sf</strong> package offers various methods for spatial joins. See more documentation about the st_join method and spatial join types in this <a href="https://r-spatial.github.io/sf/reference/geos_binary_pred.html">reference</a>.</p>
<div id="points-in-polygon" class="section level3 unnumbered">
<h3>Points in polygon</h3>
<p><strong>Spatial assign administrative units to cases</strong></p>
<p>Here is an interesting conundrum: the case linelist does not contain any information about the administrative units of the cases. Although it is ideal to collect such information during the initial data collection phase, we can also assign administrative units to individual cases based on their spatial relationships (i.e. point intersects with a polygon).</p>
<p>Below, we will spatially intersect our case locations (points) with the ADM3 boundaries (polygons):</p>
<ol style="list-style-type: decimal">
<li>Begin with the linelist (points)<br />
</li>
<li>Spatial join to the boundaries, setting the type of join at “st_intersects”<br />
</li>
<li>Use <code>select()</code> to keep only certain of the new administrative boundary columns</li>
</ol>
<p>All the columns from <code>sle_adms</code> have been added to the linelist! Each case now has columns detailing the administrative levels that it falls within. In this example, we only want to keep two of the new columns (admin level 3), so we <code>select()</code> the old column names and just the two additional of interest:</p>
<p>Below, just for display purposes you can see the first ten cases and that their admin level 3 (ADM3) jurisdictions that have been attached, based on where the point spatially intersected with the polygon shapes.</p>
<p>Now we can describe our cases by administrative unit - something we were not able to do before the spatial join!</p>
<p>We can also create a bar plot of case counts by administrative unit.</p>
<p>In this example, we begin the <code>ggplot()</code> with the <code>linelist_adm</code>, so that we can apply factor functions like <code>fct_infreq()</code> which orders the bars by frequency (see page on <a href="factors.html#factors">Factors</a> for tips).</p>
<!-- ======================================================= -->
</div>
<div id="nearest-neighbor" class="section level3 unnumbered">
<h3>Nearest neighbor</h3>
<p><strong>Finding the nearest health facility / catchment area</strong></p>
<p>It might be useful to know where the health facilities are located in relation to the disease hot spots.</p>
<p>We can use the <em>st_nearest_feature</em> join method from the <code>st_join()</code> function (<strong>sf</strong> package) to visualize the closest health facility to individual cases.</p>
<ol style="list-style-type: decimal">
<li>We begin with the shapefile linelist <code>linelist_sf</code><br />
</li>
<li>We spatially join with <code>sle_hf</code>, which is the locations of health facilities and clinics (points)</li>
</ol>
<p>We can see below (first 50 rows) that the each case now has data on the nearest clinic/hospital</p>
<p>We can see that “Den Clinic” is the closest health facility for about ~30% of the cases.</p>
<p>To visualize the results, we can use <strong>tmap</strong> - this time interactive mode for easier viewing</p>
</div>
<div id="buffers" class="section level3 unnumbered">
<h3>Buffers</h3>
<p>We can also explore how many cases are located within 2.5km (~30 mins) walking distance from the closest health facility.</p>
<p><em>Note: For more accurate distance calculations, it is better to re-project your sf object to the respective local map projection system such as UTM (Earth projected onto a planar surface). In this example, for simplicity we will stick to the World Geodetic System (WGS84) Geograhpic coordinate system (Earth represented in a spherical / round surface, therefore the units are in decimal degrees). We will use a general conversion of: 1 decimal degree = ~111km.</em></p>
<p>See more information about map projections and coordinate systems at this <a href="https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/">esri article</a>. This <a href="http://www.geo.hunter.cuny.edu/~jochen/gtech201/lectures/lec6concepts/map%20coordinate%20systems/how%20to%20choose%20a%20projection.htm">blog</a> talks about different types of map projection and how one can choose a suitable projection depending on the area of interest and the context of your map / analysis.</p>
<p><strong>First</strong>, create a circular buffer with a radius of ~2.5km around each health facility. This is done with the function <code>st_buffer()</code> from <strong>tmap</strong>. Because the unit of the map is in lat/long decimal degrees, that is how “0.02” is interpreted. If your map coordinate system is in meters, the number must be provided in meters.</p>
<p>Below we plot the buffer zones themselves, with the :</p>
<p>**Second<em>, we intersect these buffers with the cases (points) using <code>st_join()</code> and the join type of </em>st_intersects*. That is, the data from the buffers are joined to the points that they intersect with.</p>
<p>Now we can count the results: <code>nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),])</code> out of 1000 cases did not intersect with any buffer (that value is missing), and so live more than 30 mins walk from the nearest health facility.</p>
<p>We can visualize the results such that cases that did not intersect with any buffer appear in red.</p>
</div>
<div id="other-spatial-joins" class="section level3 unnumbered">
<h3>Other spatial joins</h3>
<p>Alternative values for argument <code>join</code> include (from the <a href="https://r-spatial.github.io/sf/reference/st_join.html">documentation</a>)</p>
<ul>
<li>st_contains_properly<br />
</li>
<li>st_contains<br />
</li>
<li>st_covered_by<br />
</li>
<li>st_covers<br />
</li>
<li>st_crosses<br />
</li>
<li>st_disjoint<br />
</li>
<li>st_equals_exact<br />
</li>
<li>st_equals<br />
</li>
<li>st_is_within_distance<br />
</li>
<li>st_nearest_feature<br />
</li>
<li>st_overlaps<br />
</li>
<li>st_touches<br />
</li>
<li>st_within</li>
</ul>
</div>
</div>
<div id="choropleth-maps" class="section level2" number="28.7">
<h2><span class="header-section-number">28.7</span> Choropleth maps</h2>
<p>Choropleth maps can be useful to visualize your data by pre-defined area, usually administrative unit or health area. In outbreak response this can help to target resource allocation for specific areas with high incidence rates, for example.</p>
<p>Now that we have the administrative unit names assigned to all cases (see section on spatial joins, above), we can start mapping the case counts by area (choropleth maps).</p>
<p>Since we also have population data by ADM3, we can add this information to the <em>case_adm3</em> table created previously.</p>
<p>We begin with the dataframe created in the previous step <code>case_adm3</code>, which is a summary table of each administrative unit and its number of cases.</p>
<ol style="list-style-type: decimal">
<li>The population data <code>sle_adm3_pop</code> are joined using a <code>left_join()</code> from <strong>dplyr</strong> on the basis of common values across column <code>admin3pcod</code> in the <code>case_adm3</code> dataframe, and column <code>adm_pcode</code> in the <code>sle_adm3_pop</code> dataframe. See page on <a href="joining-data.html#joining-data">Joining data</a>).<br />
</li>
<li><code>select()</code> is applied to the new dataframe, to keep only the useful columns - <code>total</code> is total population<br />
</li>
<li>Cases per 10,000 populaton is calculated as a new column with <code>mutate()</code></li>
</ol>
<p>Join this table with the ADM3 polygons shapefile for mapping</p>
<p>Mapping the results</p>
<p>We can also map the incidence rates</p>
</div>
<div id="mapping-with-ggplot2" class="section level2" number="28.8">
<h2><span class="header-section-number">28.8</span> Mapping with ggplot2</h2>
<p>If you are already familiar with using <strong>ggplot2</strong>, you can use that package instead to create static maps of your data. The <code>geom_sf()</code> function will draw different objects based on which features (points, lines, or polygons) are in your data. For example, you can use <code>geom_sf()</code> in a <code>ggplot()</code> using <code>sf</code> data with polygon geometry to create a choropleth map.</p>
<p>To illustrate how this works, we can start with the ADM3 polygons shapefile that we used earlier. Recall that these are Admin Level 3 regions in Sierra Leone:</p>
<p>We can use the <code>left_join()</code> function from <strong>dplyr</strong> to add the data we would like to map to the shapefile object. In this case, we are going to use the <code>case_adm3</code> data frame that we created earlier to summarize case counts by administrative region; however, we can use this same approach to map any data stored in a data frame.</p>
<p>To make a column chart of case counts by region, using <strong>ggplot2</strong>, we could then call <code>geom_col()</code> as follows:</p>
<p>If we want to use <strong>ggplot2</strong> to instead make a choropleth map of case counts, we can use similar syntax to call the <code>geom_sf()</code> function:</p>
<p>We can then customize the appearance of our map using grammar that is consistent across <strong>ggplot2</strong>, for example:</p>
<p>For R users who are comfortable working with <strong>ggplot2</strong>, <code>geom_sf()</code> offers a simple and direct implementation that is suitable for basic map visualizations. To learn more, read the <a href="https://ggplot2.tidyverse.org/reference/ggsf.html">geom_sf() vignette</a> or the <a href="https://ggplot2-book.org/maps.html">ggplot2 book</a>.</p>
<!-- ======================================================= -->
</div>
<div id="basemaps" class="section level2" number="28.9">
<h2><span class="header-section-number">28.9</span> Basemaps</h2>
<div id="openstreetmap" class="section level3 unnumbered">
<h3>OpenStreetMap</h3>
<p>Below we describe how to achieve a basemap for a <strong>ggplot2</strong> map using OpenStreetMap features. Alternative methods include using <strong>ggmap</strong> which requires free registration with Google (<a href="https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/ggmap-basemap/">details</a>).</p>
<p><a href="https://en.wikipedia.org/wiki/OpenStreetMap"><strong>OpenStreetMap</strong></a> is a collaborative project to create a free editable map of the world. The underlying geolocation data (e.g. locations of cities, roads, natural features, airports, schools, hospitals, roads etc) are considered the primary output of the project.</p>
<p>First we load the <strong>OpenStreetMap</strong> package, from which we will get our basemap.</p>
<p>Then, we create the object <code>map</code>, which we define using the function <code>openmap()</code> from <strong>OpenStreetMap</strong> package (<a href="https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/openmap">documentation</a>). We provide the following:</p>
<ul>
<li><code>upperLeft</code> and <code>lowerRight</code> Two coordinate pairs specifying the limits of the basemap tile
<ul>
<li>In this case we’ve put in the max and min from the linelist rows, so the map will respond dynamically to the data<br />
</li>
</ul></li>
<li><code>zoom =</code> (if null it is determined automatically)<br />
</li>
<li><code>type =</code> which type of basemap - we have listed several possibilities here and the code is currently using the first one (<code>[1]</code>) “osm”<br />
</li>
<li><code>mergeTiles =</code> we chose TRUE so the basetiles are all merged into one</li>
</ul>
<p>If we plot this basemap right now, using <code>autoplot.OpenStreetMap()</code> from <strong>OpenStreetMap</strong> package, you see that the units on the axes are not latitude/longitude coordinates. It is using a different coordinate system. To correctly display the case residences (which are stored in lat/long), this must be changed.</p>
<p>Thus, we want to convert the map to latitude/longitude with the <code>openproj()</code> function from <strong>OpenStreetMap</strong> package. We provide the basemap <code>map</code> and also provide the Coordinate Reference System (CRS) we want. We do this by providing the “proj.4” character string for the WGS 1984 projection, but you can provide the CRS in other ways as well. (see <a href="https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/understand-epsg-wkt-and-other-crs-definition-file-types/">this page</a> to better understand what a proj.4 string is)</p>
<p>Now when we create the plot we see that along the axes are latitude and longitude coordinate. The coordinate system has been converted. Now our cases will plot correctly if overlaid!</p>
<p>See the tutorials <a href="http://data-analytics.net/cep/Schedule_files/geospatial.html">here</a> and <a href="https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/autoplot.OpenStreetMap">here</a> for more info.</p>
</div>
</div>
<div id="contoured-density-heatmaps" class="section level2" number="28.10">
<h2><span class="header-section-number">28.10</span> Contoured density heatmaps</h2>
<p>Below we describe how to achieve a contoured density heatmap of cases, over a basemap, beginning with a linelist (one row per case).</p>
<ol style="list-style-type: decimal">
<li>Create basemap tile from OpenStreetMap, as described above<br />
</li>
<li>Plot the cases from <code>linelist</code> using the latitude and longitude columns<br />
</li>
<li>Convert the points to a density heatmap with <code>stat_density_2d()</code> from <strong>ggplot2</strong>,</li>
</ol>
<p>When we have a basemap with lat/long coordinates, we can plot our cases on top using the lat/long coordinates of their residence.</p>
<p>Building on the function <code>autoplot.OpenStreetMap()</code> to create the basemap, <strong>ggplot2</strong> functions will easily add on top, as shown with <code>geom_point()</code> below:</p>
<p>The map above might be difficult to interpret, especially with the points overlapping. So you can instead plot a 2d density map using the <strong>ggplot2</strong> function <code>stat_density_2d()</code>. You are still using the linelist lat/lon coordinates, but a 2D kernel density estimation is performed and the results are displayed with contour lines - like a topographical map. Read the full <a href="https://ggplot2.tidyverse.org/reference/geom_density_2d.html">documentation here</a>.</p>
<!-- ======================================================= -->
<div id="time-series-heatmap" class="section level3 unnumbered">
<h3>Time series heatmap</h3>
<p>The density heatmap above shows <em>cumulative cases</em>. We can examine the outbreak over time and space by faceting the heatmap based on the <em>month of symptom onset</em>, as derived from the linelist.</p>
<p>We begin in the <code>linelist</code>, creating a new column with the Year and Month of onset. The <code>format()</code> function from <strong>base</strong> R changes how a date is displayed. In this case we want “YYYY-MM”.</p>
<p>Now, we simply introduce facetting via <strong>ggplot2</strong> to the density heatmap. <code>facet_wrap()</code> is applied, using the new column as rows. We set the number of facet columns to 3 for clarity.</p>
<!-- SPATIAL STATISTICS SECTION IS UNDER DEVELOPMENT -->
</div>
</div>
<div id="spatial-statistics" class="section level2" number="28.11">
<h2><span class="header-section-number">28.11</span> Spatial statistics</h2>
<p>Most of our discussion so far has focused on visualization of spatial data. In some cases, you may also be interested in using <em>spatial statistics</em> to quantify the spatial relationships of attributes in your data. This section will provide a very brief overview of some key concepts in spatial statistics, and suggest some resources that will be helpful to explore if you wish to do more comprehensive spatial analyses.</p>
<div id="spatial-relationships" class="section level3 unnumbered">
<h3>Spatial relationships</h3>
<p>Before we can calculate any spatial statistics, we need to specify the relationships between features in our data. There are many ways to conceptualize spatial relationships, but a simple and commonly-applicable model to use is that of <em>adjacency</em> - specifically, that we expect a geographic relationship between areas that share a border or “neighbour” one another.</p>
<p>We can quantify adjacency relationships between administrative region polygons in the <code>sle_adm3</code> data we have been using with the <strong>spdep</strong> package. We will specify <em>queen</em> contiguity, which means that regions will be neighbors if they share at least one point along their borders. The alternative would be <em>rook</em> contiguity, which requires that regions share an edge - in our case, with irregular polygons, the distinction is trivial, but in some cases the choice between queen and rook can be influential.</p>
<p>The matrix printed above shows the relationships between the 9 regions in our <code>sle_adm3</code> data. A score of 0 indicates two regions are not neighbors, while any value other than 0 indicates a neighbor relationship. The values in the matrix are scaled so that each region has a total row weight of 1.</p>
<p>A better way to visualize these neighbor relationships is by plotting them:</p>
<p>We have used an adjacency approach to identify neighboring polygons; the neighbors we identified are also sometimes called <strong>contiguity-based neighbors</strong>. But this is just one way of choosing which regions are expected to have a geographic relationship. The most common alternative approaches for identifying geographic relationships generate <strong>distance-based neighbors</strong>; briefly, these are:</p>
<ul>
<li><p><strong>K-nearest neighbors</strong> - Based on the distance between centroids (the geographically-weighted center of each polygon region), select the <em>n</em> closest regions as neighbors. A maximum-distance proximity threshold may also be specified. In <strong>spdep</strong>, you can use <code>knearneigh()</code> (see <a href="https://r-spatial.github.io/spdep/reference/knearneigh.html">documentation</a>).</p></li>
<li><p><strong>Distance threshold neighbors</strong> - Select all neighbors within a distance threshold. In <strong>spdep</strong>, these neighbor relationships can be identified using <code>dnearneigh()</code> (see <a href="https://www.rdocumentation.org/packages/spdep/versions/1.1-7/topics/dnearneigh">documentation</a>).</p></li>
</ul>
</div>
<div id="spatial-autocorrelation" class="section level3 unnumbered">
<h3>Spatial autocorrelation</h3>
<p>Tobler’s oft-cited first law of geography states that “everything is related to everything else, but near things are more related than distant things.” In epidemiology, this often means that risk of a particular health outcome in a given region is more similar to its neighboring regions than to those far away. This concept has been formalized as <strong>spatial autocorrelation</strong> - the statistical property that geographic features with similar values are clustered together in space. Statistical measures of spatial autocorrelation can be used to <em>quantify the extent of spatial clustering</em> in your data, <em>locate where clustering occurs</em>, and <em>identify shared patterns of spatial autocorrelation</em> between distinct variables in your data. This section gives an overview of some common measures of spatial autocorrelation and how to calculate them in R.</p>
<p><strong>Moran’s I</strong> - This is a global summary statistic of the correlation between the value of a variable in one region, and the values of the same variable in neighboring regions. The Moran’s I statistic typically ranges from -1 to 1. A value of 0 indicates no pattern of spatial correlation, while values closer to 1 or -1 indicate stronger spatial autocorrelation (similar values close together) or spatial dispersion (dissimilar values close together), respectively.</p>
<p>For an example, we will calculate a Moran’s I statistic to quantify the spatial autocorrelation in Ebola cases we mapped earlier (remember, this is a subset of cases from the simulated epidemic <code>linelist</code> dataframe). The <strong>spdep</strong> package has a function, <code>moran.test</code>, that can do this calculation for us:</p>
<p>The output from the <code>moran.test()</code> function shows us a Moran I statistic of <code>round(moran_i$estimate[1],2)</code>. This indicates the presence of spatial autocorrelation in our data - specifically, that regions with similar numbers of Ebola cases are likely to be close together. The p-value provided by <code>moran.test()</code> is generated by comparison to the expectation under null hypothesis of no spatial autocorrelation, and can be used if you need to report the results of a formal hypothesis test.</p>
<p><strong>Local Moran’s I</strong> - We can decompose the (global) Moran’s I statistic calculated above to identify <em>localized</em> spatial autocorrelation; that is, to identify specific clusters in our data. This statistic, which is sometimes called a <strong>Local Indicator of Spatial Association (LISA)</strong> statistic, summarizes the extent of spatial autocorrelation around each individual region. It can be useful for finding “hot” and “cold” spots on the map.</p>
<p>To show an example, we can calculate and map Local Moran’s I for the Ebola case counts used above, with the <code>local_moran()</code> function from <strong>spdep</strong>:</p>
<p><strong>Getis-Ord Gi*</strong> - This is another statistic that is commonly used for hotspot analysis; in large part, the popularity of this statistic relates to its use in the Hot Spot Analysis tool in ArcGIS. It is based on the assumption that typically, the difference in a variable’s value between neighboring regions should follow a normal distribution. It uses a z-score approach to identify regions that have significantly higher (hot spot) or significantly lower (cold spot) values of a specified variable, compared to their neighbors.</p>
<p>We can calculate and map the Gi* statistic using the <code>localG()</code> function from <strong>spdep</strong>:</p>
<p>As you can see, the map of Getis-Ord Gi* looks slightly different from the map of Local Moran’s I produced earlier. This reflects that the method used to calculate these two statistics are slightly different; which one you should use depends on your specific use case and the research question of interest.</p>
<p><strong>Lee’s L test</strong> - This is a statistical test for bivariate spatial correlation. It allows you to test whether the spatial pattern for a given variable <em>x</em> is similar to the spatial pattern of another variable, <em>y</em>, that is hypothesized to be related spatially to <em>x</em>.</p>
<p>To give an example, let’s test whether the spatial pattern of Ebola cases from the simulated epidemic is correlated with the spatial pattern of population. To start, we need to have a <code>population</code> variable in our <code>sle_adm3</code> data. We can use the <code>total</code> variable from the <code>sle_adm3_pop</code> dataframe that we loaded earlier.</p>
<p>We can quickly visualize the spatial patterns of the two variables side by side, to see whether they look similar:</p>
<p>Visually, the patterns seem dissimilar. We can use the <code>lee.test()</code> function in <strong>spdep</strong> to test statistically whether the pattern of spatial autocorrelation in the two variables is related. The L statistic will be close to 0 if there is no correlation between the patterns, close to 1 if there is a strong positive correlation (i.e. the patterns are similar), and close to -1 if there is a strong negative correlation (i.e. the patterns are inverse).</p>
<p>The output above shows that the Lee’s L statistic for our two variables was <code>round(lee_test$estimate[1],2)</code>, which indicates weak negative correlation. This confirms our visual assessment that the pattern of cases and population are not related to one another, and provides evidence that the spatial pattern of cases is not strictly a result of population density in high-risk areas.</p>
<p>The Lee L statistic can be useful for making these kinds of inferences about the relationship between spatially distributed variables; however, to describe the nature of the relationship between two variables in more detail, or adjust for confounding, <em>spatial regression</em> techniques will be needed. These are described briefly in the following section.</p>
</div>
<div id="spatial-regression" class="section level3 unnumbered">
<h3>Spatial regression</h3>
<p>You may wish to make statistical inferences about the relationships between variables in your spatial data. In these cases, it is useful to consider <em>spatial regression</em> techniques - that is, approaches to regression that explicitly consider the spatial organization of units in your data. Some reasons that you may need to consider spatial regression models, rather than standard regression models such as GLMs, include:</p>
<ul>
<li><p>Standard regression models assume that residuals are independent from one another. In the presence of strong <em>spatial autocorrelation</em>, the residuals of a standard regression model are likely to be spatially autocorrelated as well, thus violating this assumption. This can lead to problems with interpreting the model results, in which case a spatial model would be preferred.</p></li>
<li><p>Regression models also typically assume that the effect of a variable <em>x</em> is constant over all observations. In the case of <em>spatial heterogeneity</em>, the effects we wish to estimate may vary over space, and we may be interested in quantifying those differences. In this case, spatial regression models offer more flexibility for estimating and interpreting effects.</p></li>
</ul>
<p>The details of spatial regression approaches are beyond the scope of this handbook. This section will instead provide an overview of the most common spatial regression models and their uses, and refer you to references that may of use if you wish to explore this area further.</p>
<p><strong>Spatial error models</strong> - These models assume that the error terms across spatial units are correlated, in which case the data would violate the assumptions of a standard OLS model. Spatial error models are also sometimes referred to as <strong>simultaneous autoregressive (SAR) models</strong>. They can be fit using the <code>errorsarlm()</code> function in the <strong>spatialreg</strong> package (spatial regression functions which used to be a part of <strong>spdep</strong>).</p>
<p><strong>Spatial lag models</strong> - These models assume that the dependent variable for a region <em>i</em> is influenced not only by value of independent variables in <em>i</em>, but also by the values of those variables in regions neighboring <em>i</em>. Like spatial error models, spatial lag models are also sometimes described as <strong>simultaneous autoregressive (SAR) models</strong>. They can be fit using the <code>lagsarlm()</code> function in the <strong>spatialreg</strong> package.</p>
<p>The <strong>spdep</strong> package contains several useful diagnostic tests for deciding between standard OLS, spatial lag, and spatial error models. These tests, called <em>Lagrange Multiplier diagnostics</em>, can be used to identify the type of spatial dependence in your data and choose which model is most appropriate. The function <code>lm.LMtests()</code> can be used to calculate all of the Lagrange Multiplier tests. Anselin (1988) also provides a useful flow chart tool to decide which spatial regression model to use based on the results of the Lagrange Multiplier tests:</p>
<p><strong>Bayesian hierarchical models</strong> - Bayesian approaches are commonly used for some applications in spatial analysis, most commonly for <a href="https://pubmed.ncbi.nlm.nih.gov/15690999/">disease mapping</a>. They are preferred in cases where case data are sparsely distributed (for example, in the case of a rare outcome) or statistically “noisy”, as they can be used to generate “smoothed” estimates of disease risk by accounting for the underlying latent spatial process. This may improve the quality of estimates. They also allow investigator pre-specification (via choice of prior) of complex spatial correlation patterns that may exist in the data, which can account for spatially-dependent and -independent variation in both independent and dependent variables. In R, Bayesian hierarchical models can be fit using the <strong>CARbayes</strong> package (see <a href="https://cran.r-project.org/web/packages/CARBayes/vignettes/CARBayes.pdf">vignette</a>) or R-INLA (see <a href="https://www.r-inla.org/home">website</a> and <a href="https://becarioprecario.bitbucket.io/inla-gitbook/">textbook</a>). R can also be used to call external software that does Bayesian estimation, such as JAGS or WinBUGS.</p>
<!-- ======================================================= -->
</div>
</div>
<div id="resources-21" class="section level2" number="28.12">
<h2><span class="header-section-number">28.12</span> Resources</h2>
<ul>
<li><p>R Simple Features and sf package <a href="https://cran.r-project.org/web/packages/sf/vignettes/sf1.html">vignette</a></p></li>
<li><p>R tmap package <a href="https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html">vignette</a></p></li>
<li><p>ggmap: <a href="https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf">Spatial Visualization with ggplot2</a></p></li>
<li><p><a href="https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html">Intro to making maps with R, overview of different packages</a></p></li>
<li><p>Spatial Data in R <a href="https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/">(EarthLab course)</a></p></li>
<li><p>Applied Spatial Data Analysis in R <a href="https://link.springer.com/book/10.1007/978-1-4614-7618-4">textbook</a></p></li>
<li><p><strong>SpatialEpiApp</strong> - a <a href="https://github.com/Paula-Moraga/SpatialEpiApp">Shiny app that is downloadable as an R package</a>, allowing you to provide your own data and conduct mapping, cluster analysis, and spatial statistics.</p></li>
<li><p>An Introduction to Spatial Econometrics in R <a href="http://www.econ.uiuc.edu/~lab/workshop/Spatial_in_R.html">workshop</a></p></li>
</ul>

</div>
</div>



</div>
  </main>

  <div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page">
      <h2>On this page</h2>
      <div id="book-on-this-page"></div>

      <div class="book-extra">
        <ul class="list-unstyled">
          <li><a id="book-source" href="#">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="#">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
      </div>
    </nav>
  </div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5">
  <div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>The Epidemiologist R Handbook</strong>" was written by the handbook team. It was last built on 2021-05-30.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
