<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>10 Characters and strings | The Epidemiologist R Handbook</title>

    <meta name="author" content="the handbook team" />
  
  <!-- JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.2"></script>
  <script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script>
    <script src="libs/header-attrs-2.8/header-attrs.js"></script>
    <script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet" />
    <script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script>
    <script src="libs/bs3compat-0.2.5.1/tabs.js"></script>
    <script src="libs/bs3compat-0.2.5.1/bs3compat.js"></script>
    <link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet" />
    <script src="libs/bs4_book-1.0.0/bs4_book.js"></script>
    <script src="https://cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/mark.min.js"></script>

  <!-- CSS -->
    <link rel="stylesheet" href="style_bs4.css" />
    
</head>

<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book">
    <a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">The Epidemiologist R Handbook</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
      </form>

      <nav aria-label="Table of contents">
        <h2>Table of contents</h2>
        <div id="book-toc"></div>

        <div class="book-extra">
          <p><a id="book-repo" href="#">View book source <i class="fab fa-github"></i></a></li></p>
        </div>
      </nav>
    </div>
  </header>

  <main class="col-sm-12 col-md-9 col-lg-7" id="content">
<div id="characters-and-strings" class="section level1" number="10">
<h1><span class="header-section-number">10</span> Characters and strings</h1>
<p>This page demonstrates use of the <strong>stringr</strong> package to evaluate and handle character values (“strings”).</p>
<ol style="list-style-type: decimal">
<li>Combine, order, split, arrange - <code>str_c()</code>, <code>str_glue()</code>, <code>str_order()</code>, <code>str_split()</code><br />
</li>
<li>Clean and standardise
<ul>
<li>Adjust length - <code>str_pad()</code>, <code>str_trunc()</code>, <code>str_wrap()</code><br />
</li>
<li>Change case - <code>str_to_upper()</code>, <code>str_to_title()</code>, <code>str_to_lower()</code>, <code>str_to_sentence()</code><br />
</li>
</ul></li>
<li>Evaluate and extract by position - <code>str_length()</code>, <code>str_sub()</code>, <code>word()</code><br />
</li>
<li>Patterns
<ul>
<li>Detect and locate - <code>str_detect()</code>, <code>str_subset()</code>, <code>str_match()</code>, <code>str_extract()</code><br />
</li>
<li>Modify and replace - <code>str_sub()</code>, <code>str_replace_all()</code><br />
</li>
</ul></li>
<li>Regular expressions (“regex”)</li>
</ol>
<p>For ease of display most examples are shown acting on a short defined character vector, however they can easily be adapted to a column within a data frame.</p>
<p>This <a href="https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html">stringr vignette</a> provided much of the inspiration for this page.</p>
<!-- ======================================================= -->
<div id="preparation-1" class="section level2" number="10.1">
<h2><span class="header-section-number">10.1</span> Preparation</h2>
<div id="load-packages-2" class="section level3 unnumbered">
<h3>Load packages</h3>
<p>Install or load the <strong>stringr</strong> and other <strong>tidyverse</strong> packages.</p>
</div>
<div id="import-data-3" class="section level3 unnumbered">
<h3>Import data</h3>
<p>In this page we will occassionally reference the cleaned <code>linelist</code> of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the “clean” linelist</a> (as .rds file). Import data with the <code>import()</code> function from the <strong>rio</strong> package (it handles many file types like .xlsx, .csv, .rds - see the <a href="import-and-export.html#import-and-export">Import and export</a> page for details).</p>
<p>The first 50 rows of the linelist are displayed below.</p>
<!-- ======================================================= -->
</div>
</div>
<div id="unite-split-and-arrange" class="section level2" number="10.2">
<h2><span class="header-section-number">10.2</span> Unite, split, and arrange</h2>
<p>This section covers:</p>
<ul>
<li>Using <code>str_c()</code>, <code>str_glue()</code>, and <code>unite()</code> to combine strings<br />
</li>
<li>Using <code>str_order()</code> to arrange strings<br />
</li>
<li>Using <code>str_split()</code> and <code>separate()</code> to split strings</li>
</ul>
<!-- ======================================================= -->
<div id="combine-strings" class="section level3 unnumbered">
<h3>Combine strings</h3>
<p>To combine or concatenate multiple strings into one string, we suggest using <code>str_c</code> from <strong>stringr</strong>. If you have distinct character values to combine, simply provide them as unique arguments, separated by commas.</p>
<p>The argument <code>sep =</code> inserts a character value between each of the arguments you provided (e.g. inserting a comma, space, or newline <code>"\n"</code>)</p>
<p>The argument <code>collapse =</code> is relevant if you are inputting multiple <em>vectors</em> as arguments to <code>str_c()</code>. It is used to separate the elements of what would be an <em>output</em> vector, such that the output vector only has one long character element.</p>
<p>The example below shows the combination of two vectors into one (first names and last names). Another similar example might be jurisdictions and their case counts. In this example:</p>
<ul>
<li>The <code>sep =</code> value appears between each first and last name<br />
</li>
<li>The <code>collapse =</code> value appears between each person</li>
</ul>
<p>Note: Depending on your desired display context, when printing such a combined string with newlines, you may need to wrap the whole phrase in <code>cat()</code> for the newlines to print properly:</p>
<!-- ======================================================= -->
</div>
<div id="dynamic-strings" class="section level3 unnumbered">
<h3>Dynamic strings</h3>
<p>Use <code>str_glue()</code> to insert dynamic R code into a string. This is a very useful function for creating dynamic plot captions, as demonstrated below.</p>
<ul>
<li>All content goes between double quotation marks <code>str_glue("")</code><br />
</li>
<li>Any dynamic code or references to pre-defined values are placed within curly brackets <code>{}</code> within the double quotation marks. There can be many curly brackets in the same <code>str_glue()</code> command.<br />
</li>
<li>To display character quotes ’’, use <em>single</em> quotes within the surrounding double quotes (e.g. when providing date format - see example below)<br />
</li>
<li>Tip: You can use <code>\n</code> to force a new line<br />
</li>
<li>Tip: You use <code>format()</code> to adjust date display, and use <code>Sys.Date()</code> to display the current date</li>
</ul>
<p>A simple example, of a dynamic plot caption:</p>
<p>An alternative format is to use placeholders within the brackets and define the code in separate arguments at the end of the <code>str_glue()</code> function, as below. This can improve code readability if the text is long.</p>
<p><strong>Pulling from a data frame</strong></p>
<p>Sometimes, it is useful to pull data from a data frame and have it pasted together in sequence. Below is an example data frame. We will use it to to make a summary statement about the jurisdictions and the new and total case counts.</p>
<p>Use <code>str_glue_data()</code>, which is specially made for taking data from data frame rows:</p>
<p><strong>Combine strings across rows</strong></p>
<p>If you are trying to “roll-up” values in a data frame column, e.g. combine values from multiple rows into just one row by pasting them together with a separator, see the section of the <a href="de-duplication.html#de-duplication">De-duplication</a> page on <a href="de-duplication.html#str_rollup">“rolling-up” values</a>.</p>
<p><strong>Data frame to one line</strong></p>
<p>You can make the statement appear in one line using <code>str_c()</code> (specifying the data frame and column names), and providing <code>sep =</code> and <code>collapse =</code> arguments.</p>
<p>You could add the pre-fix text “New Cases:” to the beginning of the statement by wrapping with a separate <code>str_c()</code> (if “New Cases:” was within the original <code>str_c()</code> it would appear multiple times).</p>
</div>
<div id="str_unite" class="section level3 unnumbered">
<h3>Unite columns</h3>
<p>Within a data frame, bringing together character values from multiple columns can be achieved with <code>unite()</code> from <strong>tidyr</strong>. This is the opposite of <code>separate()</code>.</p>
<p>Provide the name of the new united column. Then provide the names of the columns you wish to unite.</p>
<ul>
<li>By default, the separator used in the united column is underscore <code>_</code>, but this can be changed with the <code>sep =</code> argument.<br />
</li>
<li><code>remove =</code> removes the input columns from the data frame (TRUE by default)<br />
</li>
<li><code>na.rm =</code> removes missing values while uniting (FALSE by default)</li>
</ul>
<p>Below, we define a mini-data frame to demonstrate with:</p>
<p>Here is the example data frame:</p>
<p>Below, we unite the three symptom columns:</p>
<!-- ======================================================= -->
</div>
<div id="split" class="section level3 unnumbered">
<h3>Split</h3>
<p>To split a string based on a pattern, use <code>str_split()</code>. It evaluates the string(s) and returns a <code>list</code> of character vectors consisting of the newly-split values.</p>
<p>The simple example below evaluates one string and splits it into three. By default it returns an object of class <code>list</code> with one element (a character vector) for each string initially provided. If <code>simplify = TRUE</code> it returns a character matrix.</p>
<p>In this example, one string is provided, and the function returns a list with one element - a character vector with three values.</p>
<p>If the output is saved, you can then access the nth split value with bracket syntax. To access a specific value you can use syntax like this: <code>the_returned_object[[1]][2]</code>, which would access the second value from the first evaluated string (“fever”). See the <a href="r-basics.html#r-basics">R basics</a> page for more detail on accessing elements.</p>
<p>If multiple strings are provided by <code>str_split()</code>, there will be more than one element in the returned list.</p>
<p>To return a “character matrix” instead, which may be useful if creating data frame columns, set the argument <code>simplify = TRUE</code> as shown below:</p>
<p>You can also adjust the number of splits to create with the <code>n =</code> argument. For example, this restricts the number of splits to 2. Any further commas remain within the second values.</p>
<p><em>Note - the same outputs can be achieved with <code>str_split_fixed()</code>, in which you do not give the <code>simplify</code> argument, but must instead designate the number of columns (<code>n</code>).</em></p>
</div>
<div id="split-columns" class="section level3 unnumbered">
<h3>Split columns</h3>
<p>If you are trying to split data frame column, it is best to use the <code>separate()</code> function from <strong>dplyr</strong>. It is used to split one character column into other columns.</p>
<p>Let’s say we have a simple data frame <code>df</code> (defined and united in the <a href="characters-and-strings.html#str_unite">unite section</a>) containing a <code>case_ID</code> column, one character column with many symptoms, and one outcome column. Our goal is to separate the <code>symptoms</code> column into many columns - each one containing one symptom.</p>
<p>Assuming the data are piped into <code>separate()</code>, first provide the column to be separated. Then provide <code>into =</code> as a vector <code>c( )</code> containing the <em>new</em> columns names, as shown below.</p>
<ul>
<li><code>sep =</code> the separator, can be a character, or a number (interpreted as the character position to split at)</li>
<li><code>remove =</code> FALSE by default, removes the input column<br />
</li>
<li><code>convert =</code> FALSE by default, will cause string “NA”s to become <code>NA</code><br />
</li>
<li><code>extra =</code> this controls what happens if there are more values created by the separation than new columns named.
<ul>
<li><code>extra = "warn"</code> means you will see a warning but it will drop excess values (<strong>the default</strong>)<br />
</li>
<li><code>extra = "drop"</code> means the excess values will be dropped with no warning<br />
</li>
<li><strong><code>extra = "merge"</code> will only split to the number of new columns listed in <code>into</code> - <em>this setting will preserve all your data</em></strong></li>
</ul></li>
</ul>
<p>An example with <code>extra = "merge"</code> is below - no data is lost. Two new columns are defined but any third symptoms are left in the second new column:</p>
<p>When the default <code>extra = "drop"</code> is used below, a warning is given but the third symptoms are lost:</p>
<p><span style="color: orange;"><strong><em>CAUTION:</em></strong> If you do not provide enough <code>into</code> values for the new columns, your data may be truncated.</span></p>
<!-- ======================================================= -->
</div>
<div id="arrange-alphabetically" class="section level3 unnumbered">
<h3>Arrange alphabetically</h3>
<p>Several strings can be sorted by alphabetical order. <code>str_order()</code> returns the order, while <code>str_sort()</code> returns the strings in that order.</p>
<p>To use a different alphabet, add the argument <code>locale =</code>. See the full list of locales by entering <code>stringi::stri_locale_list()</code> in the R console.</p>
<!-- ======================================================= -->
</div>
<div id="base-r-functions" class="section level3 unnumbered">
<h3>base R functions</h3>
<p>It is common to see <strong>base</strong> R functions <code>paste()</code> and <code>paste0()</code>, which concatenate vectors after converting all parts to character. They act similarly to <code>str_c()</code> but the syntax is arguably more complicated - in the parentheses each part is separated by a comma. The parts are either character text (in quotes) or pre-defined code objects (no quotes). For example:</p>
<p><code>sep =</code> and <code>collapse =</code> arguments can be specified. <code>paste()</code> is simply <code>paste0()</code> with a default <code>sep = " "</code> (one space).</p>
</div>
</div>
<div id="clean-and-standardise" class="section level2" number="10.3">
<h2><span class="header-section-number">10.3</span> Clean and standardise</h2>
<!-- ======================================================= -->
<div id="change-case" class="section level3 unnumbered">
<h3>Change case</h3>
<p>Often one must alter the case/capitalization of a string value, for example names of jursidictions. Use <code>str_to_upper()</code>, <code>str_to_lower()</code>, and <code>str_to_title()</code>, from <strong>stringr</strong>, as shown below:</p>
<p>Using *base** R, the above can also be achieved with <code>toupper()</code>, <code>tolower()</code>.</p>
<p><strong>Title case</strong></p>
<p>Transforming the string so each word is capitalized can be achieved with <code>str_to_title()</code>:</p>
<p>Use <code>toTitleCase()</code> from the <strong>tools</strong> package to achieve more nuanced capitalization (words like “to”, “the”, and “of” are not capitalized).</p>
<p>You can also use <code>str_to_sentence()</code>, which capitalizes only the first letter of the string.</p>
</div>
<div id="str_pad" class="section level3 unnumbered">
<h3>Pad length</h3>
<p>Use <code>str_pad()</code> to add characters to a string, to a minimum length. By default spaces are added, but you can also pad with other characters using the <code>pad =</code> argument.</p>
<p>For example, to pad numbers with leading zeros (such as for hours or minutes), you can pad the number to minimum length of 2 with <code>pad = "0"</code>.</p>
</div>
<div id="truncate" class="section level3 unnumbered">
<h3>Truncate</h3>
<p><code>str_trunc()</code> sets a maximum length for each string. If a string exceeds this length, it is truncated (shortened) and an ellipsis (…) is included to indicate that the string was previously longer. Note that the ellipsis <em>is</em> counted in the length. The ellipsis characters can be changed with the argument <code>ellipsis =</code>. The optional <code>side =</code> argument specifies which where the ellipsis will appear within the truncated string (“left”, “right”, or “center”).</p>
</div>
<div id="standardize-length" class="section level3 unnumbered">
<h3>Standardize length</h3>
<p>Use <code>str_trunc()</code> to set a maximum length, and then use <code>str_pad()</code> to expand the very short strings to that truncated length. In the example below, 6 is set as the maximum length (one value is truncated), and then one very short value is padded to achieve length of 6.</p>
</div>
<div id="remove-leadingtrailing-whitespace" class="section level3 unnumbered">
<h3>Remove leading/trailing whitespace</h3>
<p>Use <code>str_trim()</code> to remove spaces, newlines (<code>\n</code>) or tabs (<code>\t</code>) on sides of a string input. Add <code>"right"</code> <code>"left"</code>, or <code>"both"</code> to the command to specify which side to trim (e.g. <code>str_trim(x, "right")</code>.</p>
</div>
<div id="remove-repeated-whitespace-within" class="section level3 unnumbered">
<h3>Remove repeated whitespace within</h3>
<p>Use <code>str_squish()</code> to remove repeated spaces that appear <em>inside</em> a string. For example, to convert double spaces into single spaces. It also removes spaces, newlines, or tabs on the outside of the string like <code>str_trim()</code>.</p>
<p>Enter <code>?str_trim</code>, <code>?str_pad</code> in your R console to see further details.</p>
</div>
<div id="wrap-into-paragraphs" class="section level3 unnumbered">
<h3>Wrap into paragraphs</h3>
<p>Use <code>str_wrap()</code> to wrap a long unstructured text into a structured paragraph with fixed line length. Provide the ideal character length for each line, and it applies an algorithm to insert newlines (<code>\n</code>) within the paragraph, as seen in the example below.</p>
<p>The <strong>base</strong> function <code>cat()</code> can be wrapped around the above command in order to print the output, displaying the new lines added.</p>
<!-- ======================================================= -->
</div>
</div>
<div id="handle-by-position" class="section level2" number="10.4">
<h2><span class="header-section-number">10.4</span> Handle by position</h2>
<div id="extract-by-character-position" class="section level3 unnumbered">
<h3>Extract by character position</h3>
<p>Use <code>str_sub()</code> to return only a part of a string. The function takes three main arguments:</p>
<ol style="list-style-type: decimal">
<li>the character vector(s)<br />
</li>
<li>start position<br />
</li>
<li>end position</li>
</ol>
<p>A few notes on position numbers:</p>
<ul>
<li>If a position number is positive, the position is counted starting from the left end of the string.<br />
</li>
<li>If a position number is negative, it is counted starting from the right end of the string.<br />
</li>
<li>Position numbers are inclusive.<br />
</li>
<li>Positions extending beyond the string will be truncated (removed).</li>
</ul>
<p>Below are some examples applied to the string “pneumonia”:</p>
</div>
<div id="extract-by-word-position" class="section level3 unnumbered">
<h3>Extract by word position</h3>
<p>To extract the nth ‘word’, use <code>word()</code>, also from <strong>stringr</strong>. Provide the string(s), then the first word position to extract, and the last word position to extract.</p>
<p>By default, the separator between ‘words’ is assumed to be a space, unless otherwise indicated with <code>sep =</code> (e.g. <code>sep = "_"</code> when words are separated by underscores.</p>
</div>
<div id="replace-by-character-position" class="section level3 unnumbered">
<h3>Replace by character position</h3>
<p><code>str_sub()</code> paired with the assignment operator (<code>&lt;-</code>) can be used to modify a part of a string:</p>
<p>An example applied to multiple strings (e.g. a column). Note the expansion in length of “HIV”.</p>
</div>
<div id="evaluate-length" class="section level3 unnumbered">
<h3>Evaluate length</h3>
<p>Alternatively, use <code>nchar()</code> from <strong>base</strong> R</p>
<!-- ======================================================= -->
</div>
</div>
<div id="patterns" class="section level2" number="10.5">
<h2><span class="header-section-number">10.5</span> Patterns</h2>
<p>Many <strong>stringr</strong> functions work to detect, locate, extract, match, replace, and split based on a specified <em>pattern</em>.</p>
<!-- ======================================================= -->
<div id="detect-a-pattern" class="section level3 unnumbered">
<h3>Detect a pattern</h3>
<p>Use <code>str_detect()</code> as below to detect presence/absence of a pattern within a string. First provide the string or vector to search in (<code>string =</code>), and then the pattern to look for (<code>pattern =</code>). Note that by default the search <em>is case sensitive</em>!</p>
<p>The argument <code>negate =</code> can be included and set to <code>TRUE</code> if you want to know if the pattern is NOT present.</p>
<p>To ignore case/capitalization, wrap the pattern within <code>regex()</code>, and <em>within</em> <code>regex()</code> add the argument <code>ignore_case = TRUE</code> (or <code>T</code> as shorthand).</p>
<p>When <code>str_detect()</code> is applied to a character vector or a data frame column, it will return TRUE or FALSE for each of the values.</p>
<p>If you need to count the <code>TRUE</code>s, simply <code>sum()</code> the output. This counts the number <code>TRUE</code>.</p>
<p>To search inclusive of multiple terms, include them separated by OR bars (<code>|</code>) within the <code>pattern =</code> argument, as shown below:</p>
<p>If you need to build a long list of search terms, you can combine them using <code>str_c()</code> and <code>sep = |</code>, then define this is a character object, and then reference the vector later more succinctly. The example below includes possible occupation search terms for front-line medical providers.</p>
<p>This command returns the number of occupations which contain any one of the search terms for front-line medical providers (<code>occupation_med_frontline</code>):</p>
<p><strong>Base R string search functions</strong></p>
<p>The <strong>base</strong> function <code>grepl()</code> works similarly to <code>str_detect()</code>, in that it searches for matches to a pattern and returns a logical vector. The basic syntax is <code>grepl(pattern, strings_to_search, ignore.case = FALSE, ...)</code>. One advantage is that the <code>ignore.case</code> argument is easier to write (there is no need to involve the <code>regex()</code> function).</p>
<p>Likewise, the <strong>base</strong> functions <code>sub()</code> and <code>gsub()</code> act similarly to <code>str_replace()</code>. Their basic syntax is: <code>gsub(pattern, replacement, strings_to_search, ignore.case = FALSE)</code>. <code>sub()</code> will replace the first instance of the pattern, whereas <code>gsub()</code> will replace all instances of the pattern.</p>
<div id="convert-commas-to-periods" class="section level4 unnumbered">
<h4>Convert commas to periods</h4>
<p>Here is an example of using <code>gsub()</code> to convert commas to periods in a vector of numbers. This could be useful if your data come from parts of the world other than the United States or Great Britain.</p>
<p>The inner <code>gsub()</code> which acts first on <code>lengths</code> is converting any periods to no space "“. The period character”." has to be “escaped” with two slashes to actually signify a period, because “.” in regex means “any character”. Then, the result (with only commas) is passed to the outer <code>gsub()</code> in which commas are replaced by periods.</p>
</div>
</div>
<div id="replace-all" class="section level3 unnumbered">
<h3>Replace all</h3>
<p>Use <code>str_replace_all()</code> as a “find and replace” tool. First, provide the strings to be evaluated to <code>string =</code>, then the pattern to be replaced to <code>pattern =</code>, and then the replacement value to <code>replacement =</code>. The example below replaces all instances of “dead” with “deceased”. Note, this IS case sensitive.</p>
<p>Notes:</p>
<ul>
<li>To replace a pattern with <code>NA</code>, use <code>str_replace_na()</code>.<br />
</li>
<li>The function <code>str_replace()</code> replaces only the first instance of the pattern within each evaluated string.</li>
</ul>
<!-- ======================================================= -->
</div>
<div id="detect-within-logic" class="section level3 unnumbered">
<h3>Detect within logic</h3>
<p><strong>Within <code>case_when()</code></strong></p>
<p><code>str_detect()</code> is often used within <code>case_when()</code> (from <strong>dplyr</strong>). Let’s say <code>occupations</code> is a column in the linelist. The <code>mutate()</code> below creates a new column called <code>is_educator</code> by using conditional logic via <code>case_when()</code>. See the page on data cleaning to learn more about <code>case_when()</code>.</p>
<p>As a reminder, it may be important to add exclusion criteria to the conditional logic (<code>negate = F</code>):</p>
<!-- ======================================================= -->
</div>
<div id="locate-pattern-position" class="section level3 unnumbered">
<h3>Locate pattern position</h3>
<p>To locate the <em>first</em> position of a pattern, use <code>str_locate()</code>. It outputs a start and end position.</p>
<p>Like other <code>str</code> functions, there is an "_all" version (<code>str_locate_all()</code>) which will return the positions of <em>all</em> instances of the pattern within each string. This outputs as a <code>list</code>.</p>
<!-- ======================================================= -->
</div>
<div id="extract-a-match" class="section level3 unnumbered">
<h3>Extract a match</h3>
<p><code>str_extract_all()</code> returns the matching patterns themselves, which is most useful when you have offered several patterns via “OR” conditions. For example, looking in the string vector of occupations (see previous tab) for <em>either</em> “teach”, “prof”, or “tutor”.</p>
<p><code>str_extract_all()</code> returns a <code>list</code> which contains <em>all matches</em> for each evaluated string. See below how occupation 3 has two pattern matches within it.</p>
<p><code>str_extract()</code> extracts <em>only the first match</em> in each evaluated string, producing a character vector with one element for each evaluated string. It returns <code>NA</code> where there was no match. The <code>NA</code>s can be removed by wrapping the returned vector with <code>na.exclude()</code>. Note how the second of occupation 3’s matches is not shown.</p>
<!-- ======================================================= -->
</div>
<div id="subset-and-count" class="section level3 unnumbered">
<h3>Subset and count</h3>
<p>Aligned functions include <code>str_subset()</code> and <code>str_count()</code>.</p>
<p><code>str_subset()</code> returns the actual values which contained the pattern:</p>
<p><code>str_count()</code> returns a vector of numbers: the <strong>number of times</strong> a search term appears in each evaluated value.</p>
<!-- ======================================================= -->
</div>
<div id="regex-groups" class="section level3 unnumbered">
<h3>Regex groups</h3>
<p>UNDER CONSTRUCTION</p>
<!-- ======================================================= -->
</div>
</div>
<div id="special-characters" class="section level2" number="10.6">
<h2><span class="header-section-number">10.6</span> Special characters</h2>
<p><strong>Backslash <code>\</code> as escape</strong></p>
<p>The backslash <code>\</code> is used to “escape” the meaning of the next character. This way, a backslash can be used to have a quote mark display <em>within</em> other quote marks (<code>\"</code>) - the middle quote mark will not “break” the surrounding quote marks.</p>
<p>Note - thus, if you want to <em>display</em> a backslash, you must escape it’s meaning with <em>another</em> backslash. So you must write two backslashes <code>\\</code> to display one.</p>
<p><strong>Special characters</strong></p>
<table>
<thead>
<tr class="header">
<th>Special character</th>
<th>Represents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"\\"</code></td>
<td>backslash</td>
</tr>
<tr class="even">
<td><code>"\n"</code></td>
<td>a new line (newline)</td>
</tr>
<tr class="odd">
<td><code>"\""</code></td>
<td>double-quote <em>within</em> double quotes</td>
</tr>
<tr class="even">
<td><code>'\''</code></td>
<td>single-quote <em>within</em> single quotes</td>
</tr>
<tr class="odd">
<td><code>"\</code>“<code>| grave accent</code>”<code>| carriage return</code>“<code>| tab</code>”<code>| vertical tab</code>"`</td>
<td>backspace</td>
</tr>
</tbody>
</table>
<p>Run <code>?"'"</code> in the R Console to display a complete list of these special characters (it will appear in the RStudio Help pane).</p>
<!-- ======================================================= -->
</div>
<div id="regular-expressions-regex" class="section level2" number="10.7">
<h2><span class="header-section-number">10.7</span> Regular expressions (regex)</h2>
<!-- ======================================================= -->
</div>
<div id="regex-and-special-characters" class="section level2" number="10.8">
<h2><span class="header-section-number">10.8</span> Regex and special characters</h2>
<p>Regular expressions, or “regex”, is a concise language for describing patterns in strings. If you are not familiar with it, a regular expression can look like an alien language. Here we try to de-mystify this language a little bit.</p>
<p><em>Much of this section is adapted from <a href="https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432">this tutorial</a> and <a href="https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf">this cheatsheet</a></em>. We selectively adapt here knowing that this handbook might be viewed by people without internet access to view the other tutorials.</p>
<p>A regular expression is often applied to extract specific patterns from “unstructured” text - for example medical notes, chief complaints, patient history, or other free text columns in a data frame</p>
<p>There are four basic tools one can use to create a basic regular expression:</p>
<ol style="list-style-type: decimal">
<li>Character sets<br />
</li>
<li>Meta characters<br />
</li>
<li>Quantifiers<br />
</li>
<li>Groups</li>
</ol>
<p><strong>Character sets</strong></p>
<p>Character sets, are a way of expressing listing options for a character match, within brackets. So any a match will be triggered if any of the characters within the brackets are found in the string. For example, to look for vowels one could use this character set: “[aeiou]”. Some other common character sets are:</p>
<table>
<thead>
<tr class="header">
<th>Character set</th>
<th>Matches for</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"[A-Z]"</code></td>
<td>any single capital letter</td>
</tr>
<tr class="even">
<td><code>"[a-z]"</code></td>
<td>any single lowercase letter</td>
</tr>
<tr class="odd">
<td><code>"[0-9]"</code></td>
<td>any digit</td>
</tr>
<tr class="even">
<td><code>[:alnum:]</code></td>
<td>any alphanumeric character</td>
</tr>
<tr class="odd">
<td><code>[:digit:]</code></td>
<td>any numeric digit</td>
</tr>
<tr class="even">
<td><code>[:alpha:]</code></td>
<td>any letter (upper or lowercase)</td>
</tr>
<tr class="odd">
<td><code>[:upper:]</code></td>
<td>any uppercase letter</td>
</tr>
<tr class="even">
<td><code>[:lower:]</code></td>
<td>any lowercase letter</td>
</tr>
</tbody>
</table>
<p>Character sets can be combined within one bracket (no spaces!), such as <code>"[A-Za-z]"</code> (any upper or lowercase letter), or another example <code>"[t-z0-5]"</code> (lowercase t through z OR number 0 through 5).</p>
<p><strong>Meta characters</strong></p>
<p>Meta characters are shorthand for character sets. Some of the important ones are listed below:</p>
<table>
<thead>
<tr class="header">
<th>Meta character</th>
<th>Represents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"\\s"</code></td>
<td>a single space</td>
</tr>
<tr class="even">
<td><code>"\\w"</code></td>
<td>any single alphanumeric character (A-Z, a-z, or 0-9)</td>
</tr>
<tr class="odd">
<td><code>"\\d"</code></td>
<td>any single numeric digit (0-9)</td>
</tr>
</tbody>
</table>
<p><strong>Quantifiers</strong></p>
<p>Typically you do not want to search for a match on only one character. Quantifiers allow you to designate the length of letters/numbers to allow for the match.</p>
<p>Quantifiers are numbers written within curly brackets <code>{ }</code> <em>after</em> the character they are quantifying, for example,</p>
<ul>
<li><code>"A{2}"</code> will return instances of <strong>two</strong> capital A letters.<br />
</li>
<li><code>"A{2,4}"</code> will return instances of <strong>between two and four</strong> capital A letters <em>(do not put spaces!)</em>.<br />
</li>
<li><code>"A{2,}"</code> will return instances of <strong>two or more</strong> capital A letters.<br />
</li>
<li><code>"A+"</code> will return instances of <strong>one or more</strong> capital A letters (group extended until a different character is encountered).<br />
</li>
<li>Precede with an <code>*</code> asterisk to return <strong>zero or more</strong> matches (useful if you are not sure the pattern is present)</li>
</ul>
<p>Using the <code>+</code> plus symbol as a quantifier, the match will occur until a different character is encountered. For example, this expression will return all <em>words</em> (alpha characters: <code>"[A-Za-z]+"</code></p>
<p>When a quantifier of {2} is used, only pairs of consecutive A’s are returned. Two pairs are identified within <code>AAAA</code>.</p>
<p>When a quantifier of {2,4} is used, groups of consecutive A’s that are two to four in length are returned.</p>
<p>With the quantifier <code>+</code>, groups of <strong>one or more</strong> are returned:</p>
<p><strong>Relative position</strong></p>
<p>These express requirements for what precedes or follows a pattern. For example, to extract sentences, “two numbers that are followed by a period” (<code>""</code>). (?&lt;=\.)\s(?=[A-Z])</p>
<table>
<thead>
<tr class="header">
<th>Position statement</th>
<th>Matches to</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"(?&lt;=b)a"</code></td>
<td>“a” that <strong>is preceded</strong> by a “b”</td>
</tr>
<tr class="even">
<td><code>"(?&lt;!b)a"</code></td>
<td>“a” that <strong>is NOT preceded</strong> by a “b”</td>
</tr>
<tr class="odd">
<td><code>"a(?=b)"</code></td>
<td>“a” that <strong>is followed</strong> by a “b”</td>
</tr>
<tr class="even">
<td><code>"a(?!b)"</code></td>
<td>“a” that <strong>is NOT followed</strong> by a “b”</td>
</tr>
</tbody>
</table>
<p><strong>Groups</strong></p>
<p>Capturing groups in your regular expression is a way to have a more organized output upon extraction.</p>
<p><strong>Regex examples</strong></p>
<p>Below is a free text for the examples. We will try to extract useful information from it using a regular expression search term.</p>
<p>This expression matches to all words (any character until hitting non-character such as a space):</p>
<p>The expression <code>"[0-9]{1,2}"</code> matches to consecutive numbers that are 1 or 2 digits in length. It could also be written <code>"\\d{1,2}"</code>, or <code>"[:digit:]{1,2}"</code>.</p>
<!-- This expression will extract all sentences (assuming first letter is capitalized, and the sentence ends with a period). The pattern reads in English as: "A capital letter followed by some lowercase letters, a space, some letters, a space,     -->
<!-- ```{r} -->
<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->
<!-- ``` -->
<p>You can view a useful list of regex expressions and tips on page 2 of <a href="https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf">this cheatsheet</a></p>
<p>Also see this <a href="https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432">tutorial</a>.</p>
<!-- ======================================================= -->
</div>
<div id="resources-3" class="section level2" number="10.9">
<h2><span class="header-section-number">10.9</span> Resources</h2>
<p>A reference sheet for <strong>stringr</strong> functions can be found <a href="https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf">here</a></p>
<p>A vignette on <strong>stringr</strong> can be found <a href="https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html">here</a></p>

</div>
</div>
  </main>

  <div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page">
      <h2>On this page</h2>
      <div id="book-on-this-page"></div>

      <div class="book-extra">
        <ul class="list-unstyled">
          <li><a id="book-source" href="#">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="#">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
      </div>
    </nav>
  </div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5">
  <div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>The Epidemiologist R Handbook</strong>" was written by the handbook team. It was last built on 2021-05-30.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
