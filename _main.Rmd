---
knit: "bookdown::render_book"
title: "The Epidemiologist R Handbook"
author: "the handbook team"
description: "This is a R reference manual for applied epidemiologists and public health practitioners."  
date: "`r Sys.Date()`"
#url: 'https://github.com/nsbatra/Epi_R_handbook'
github-repo: nsbatra/Epi_R_handbook
#twitter-handle: 
#cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
---


#  {-}

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "R Handbook Logo.png"))
```



<span style="color: red;">**THIS IS A DRAFT**.</span>

<span style="color: orange;">**IF YOU ARE REVIEWING THIS BOOK, PLEASE PROVIDE FEEDBACK FOR EACH PAGE AT THIS [LINK](https://forms.gle/4RNdRRLGx67xW9yq9)**</span>


<!-- ======================================================= -->
## About this handbook {-}

<span style="color: brown;">**This is a free open-access R reference manual for applied epidemiologists and public health practitioners.**</span>

**This book strives to:**  

* Serve as a quick reference manual - not as a textbook or comprehensive R training  
* Address common epidemiological problems via task-centered examples  
* Be accessible in settings with low internet-connectivity via an [offline version](https://github.com/nsbatra/Epi_R_handbook/tree/master/offline_long) (instructions below)  

**What gaps does this book address?**  

* Many epidemiologists are transitioning to R from SAS, STATA, SPSS, Excel, or other software  
* Let's avoid hours of online searching and have a repository for best-practice code for the common epi user  
* Epidemiologists sometimes work in low internet-connectivity environments and have limited support  

**How is this different than other R books?**  

* It is written by epidemiologists, for epidemiologists - leveraging experience in local, national, academic, and emergency settings  
* It provides examples of epidemic curves, transmission chains, epidemic modeling and projections, age and sex pyramids and standardization, record matching, outbreak detection, survey analysis, causal diagrams, survival analysis, GIS basics, phylogenetic trees, automated reports, etc...  



<!-- ======================================================= -->
## How to read this handbook {-} 

**Online version**  

* Search via the search box above the Table of Contents 
* Click the "copy" icons to copy code  
* See the "Resources" section of each page for further resources  
* To download data and "follow-along", see the "Datasets used" page  

**To download the *offline version* follow these steps**:  

1) Click on [the html file](https://github.com/nsbatra/Epi_R_handbook/tree/master/offline_long) in our Github repository  
2) Click the "Download" button. A window will open with HTML source code.  
3) "Save As" the webpage, via right-click (windows) or Cmd-s (mac) - ensure the file type is "Webpage, Complete"  
4) The file is large (>40MB) so content may take time to appear. It displays as one long page, so search with Ctrl+f (Cmd-f).  


<!-- ======================================================= -->
## Edit or contribute {-}

We welcome your comments and suggestions. You can submit an issue or pull request at our [Github repository](https://github.com/nsbatra/R_epi_handbook), or provide feedback via this [Google survey](https://forms.gle/4RNdRRLGx67xW9yq9).  



<!-- ======================================================= -->
## Acknowledgements {-}  


### Contributors {-}  

This book is produced by a collaboration of epidemiologists from around the world, drawing upon experiences with organizations including local/state/provincial/national health departments and ministries, the World Health Organization (WHO), MSF (Medecins sans frontiers / Doctors without Borders), hospital systems, and academic institutions.

**Editor-in-Chief:** Neale Batra 

**Core team:** Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay Campbell  

**Authors**: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonny Polonski, Yurie Izawa, Daniel Molling, Sara Hollis, Isha Berry  

**Reviewers**:  

**Advisers**:     


### Funding and programmatic support {-}  

This handbook is **not** an approved product of any specific organization. Although we strive for accuracy, we provide no guarantee of the content in this book.  

The handbook project received funding via a COVID-19 emergency capacity-building grant from Training Programs in Epidemiology and Public Health Interventions Network ([TEPHINET](https://www.tephinet.org/)) (details below).  

This handbook was supported by Cooperative Agreement number NU2GGH001873, funded by the Centers for Disease Control and Prevention through TEPHINET, a program of The Task Force for Global Health. Its contents are solely the responsibility of the authors and do not necessarily represent the official views of the Centers for Disease Control and Prevention, the Department of Health and Human Services, The Task Force for Global Health, Inc. or TEPHINET.

Programmatic support was provided by the EPIET Alumni Network ([EAN](https://epietalumni.net/)) and also MSF's Manson Unit.  



### Inspiration {-}  

The multitude of tutorials and vignettes that provided knowledge for development of handbook content are credited within their respective pages.  

More generally, the following sources provided inspiration and laid the groundwork for this handbook:  
[The "R4Epis" project](https://r4epis.netlify.app/) (a collaboration between MSF and RECON)  
[R Epidemics Consortium (RECON)](https://www.repidemicsconsortium.org/)  
[R for Data Science book (R4DS)](https://r4ds.had.co.nz/)  
[bookdown: Authoring Books and Technical Documents with R Markdown](https://bookdown.org/yihui/bookdown/)  
[Netlify](https://www.netlify.com) hosts this website  


### Image credits {-}  

Logo (US CDC Public Health Image Library):  
[2013 Yemen looking for mosquito breeding sites](https://phil.cdc.gov/Details.aspx?pid=19623)  
[Ebola virus](https://phil.cdc.gov/Details.aspx?pid=23186)  
[Survey in Rajasthan](https://phil.cdc.gov/Details.aspx?pid=19838)  



### Terms of Use and License {-}  

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:index.Rmd-->

# (PART) Preview pages {-}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/cat_preview.Rmd-->

# Descriptive analysis { }


This page demonstrates the use of **base** R, **dplyr**, and **gtsummary** to produce tabulations and descriptive statistics, and to conduct simple statistical tests. Each of these tools have advantages and disadvantages in the areas of code simplicity, accessibility of outputs, quality of printed outputs. We hope one of these approaches will work for you.  

<!-- ======================================================= -->
## Preparation {  }


### Load packages {-}

This code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary and loads it for use. You can also load packages with `library()` from **base** R. See the page on [R basics] for more information on R packages.  


```{r}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics, 
  gtsummary,    # summary statistics and tests
  janitor,      # adding totals and percents to tables
  flextable,    # converting tables to HTML
  corrr         # correlation analayis for numeric variables
  )
```

### Import data {-}

We import the dataset of cases from a simulated Ebola epidemic. If you want to download the data to follow step-by-step, see instructions in the [Datasets used] page. The dataset is imported using the `import()` function from the **rio** package. See the page on [Import and export] for various ways to import data.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- rio::import("linelist_cleaned.xlsx")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Browse data {  }

### `skimr` package {-}

Using the **skimr** package you can get a detailed and aesthetically pleasing overview of each of the variables in your dataset. Read more about **skimr** at its [github page](https://github.com/ropensci/skimr).  

Below, the function `skim()` is applied to the entire `linelist` data frame. An overview of the data frame and a summary of every column (by class) is produced.    

```{r eval=F}
## get information about each variable in a dataset 
skim(linelist)
```

```{r eval=T, echo=F}
# sparkline histograms not showing correctly, so avoiding them.
skim_without_charts(linelist)
```

You can also use the `summary()` function, from **base** R, to get information about an entire data sets, but this output can be more difficult to read than using **skimr**.  

```{r, eval=F}
## get information about each column in a dataset 
summary(linelist)
```


### Summary statistics {-} 

You can use **base** R functions to return summary statistics on a numeric column. These functions are also often used within more complex code operations, for example if grouping and summarising columns, or referencing a `max()` value to calibrate plot height.  

See the [R Basics] page for a complete list of mathematical operators such as `max()`, `min()`, `median()`, `mean()`, `quantile()`, `sd()`, and `range()`.

<span style="color: orange;">**_CAUTION:_** If your data contain missing values, R wants you to know this and so will return `NA` unless you specify to the above mathematical functions that you want R to ignore missing values, via the argument `na.rm = TRUE`.</span>

You can return most of the useful summary statistics for a numeric column using `summary()`, as below. Note that the dataframe must also be specified as shown below.  

```{r}
summary(linelist$age_years)
```

You can access and save one specific part of it with index brackets [ ]:  

```{r}
summary(linelist$age_years)[[2]]
```


<!-- ======================================================= -->
## Descriptive tables {}

You have several choices when producing tabulation and cross-tabulation summary tables. Some of the factors to consider include code simplicity and ease, the desired output (printed to R console, or as pretty HTML), and what you can do with the data afterward. Consider the thoughts below as you choose the tool for your situation.  

* Use `tabyl()` from **janitor** to produce and "adorn" tabulations and cross-tabulations  
* Use `count()` and `summarise()` from **dplyr** within the context of a pipe chain or if preparing data for `ggplot()`  
* Use `tbl_summary()` from **gtsummary** to produce detailed publication-ready tables  
* You can also use `table()` from **base** R to produce tables  


### **janitor** {-}

The **janitor** packages offers the `tabyl()` function which produces clean tabulations and cross-tabulations, which can be "adorned" or modified with other functions to display percents, proportions, etc.  

Below, we pipe the `linelist` data frame to **janitor** functions and print the result. If desired, you can also save the resulting tables with the assignment operator `<-`.  

#### Simple tabyl {-}  

The default use of `tabyl()` on a specific column produces the unique values, counts, and column-wise "percents" (actually proportions). The proportions may have many digits. You can adjust this with `adorn_rounding()` as described below.   

```{r}
linelist %>% tabyl(age_cat)
```
As you can see above, if there are missing values they display in a row labeled `<NA>`. If there are no missing values, this row will not appear. If there are missing values, proportions are given as both raw (denominator inclusive of `NA` counts) and "valid" (denominator excludes `NA` counts).  

If the column is class Factor and only certain levels are present in your data, they will still appear in the table. You can suppress this feature with `show_missing_levels = FALSE`.  

#### Cross-tabulation {-}  

A two-way cross-tabulation (or three-way) is created by adding another column within `tabyl()`. Note that proportions did not appear automatically.   

```{r}
linelist %>% tabyl(age_cat, gender)
```
#### "Adorning" the tabyl {-}  

Use **janitor**'s "adorn" functions to add totals or convert to proportions, percents, or otherwise adjust the display. Often you will pipe the tabyl through multiple of these functions.  


Function           | Outcome                          
-------------------|--------------------------------
`adorn_totals()`   | Adds totals (`where = ` "row", "col", or "both"). Set `name =` for "Total".  
`adorn_percentages()` | Convert counts to proportions, with `denominator = ` "row", "col", or "all"  
`adorn_pct_formatting()` | Converts proportions to percents. Specify `digits =`. Remove "%" with `affix_sign = F`.  
`adorn_rounding()` | To round counts, proportions to `digits =` places. To round percents use `adorn_pct_formatting()` as above.  
`adorn_ns()` | Add counts (in parentheses) to a table with proportions or percents. Indicate `position =` "rear" or "front" of the percent/prop  
`adorn_title()` | add string `row_name = ` and/or `col_name = `  

Be conscious of the order you apply the above functions. Below are some examples.  

A simple one-way table with percents.  

```{r}
linelist %>%               # case linelist
  tabyl(age_cat) %>%       # tabulate counts and proportions by age category
  adorn_pct_formatting()   # convert proportions to percents
```
A cross-tabulation with a total row and row percents.  

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "row") %>%             # 
  adorn_percentages(denominator = "row") %>%  # convert counts to proportions
  adorn_pct_formatting(digits = 1)            # convert proportions to percents
```
A cross-tabulation adjusted so that both counts and percents are displayed.  

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions
  adorn_pct_formatting() %>%                  # convert to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```



#### Printing the tabyl {-}

By default, the tabyl will print to your R console. Alternatively, you can pass the tabyl to **flextable**  or other package to print as HTML in the RStudio Viewer. Note that if using `adorn_titles()`, you must specify `placement = "combined` in order to print in this manner.

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(row_name = "Age Category", col_name = "Gender", placement = "combined") %>% 
  flextable::flextable()

```
#### Use on other tables {-}  

You can use the `adorn_XXX()` functions on other tables, such as those created by `summarise()`, `count()`, or `table()`.  


#### Saving the tabyl {-}  

If you convert the table to HTML with a package like **flextable**, you can save it with functions `save_as_html()`, `save_as_word()`, `save_as_ppt`, and `save_as_image()`, as discussed more extensively in the [Tables] page. Below, the table is saved as a Word document in which it can be edited.  

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
  flextable::flextable() %>% 
  flextable::save_as_docx(path = "tabyl.docx")
```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

#### Statistics {-}  

You can apply statistical tests on tabyls, like `chisq.test()` or `fisher.test()` from **stats** as shown below. Note missing values are not allowed.  

```{r}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```
#### Other tips {-}  

* Include the argument `na.rm = TRUE` to exclude missing values from any of the above calculations.  
* If applying `adorn_XXX()` to tables not created by `tabyl()`, you can specify particular column(s) to apply to like  `adorn_percentage(,,,c(cases,deaths))`. The syntax is not simple. Consider using `summarise()` instead.  
* You can read more detail in the [janitor page](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) and the [tabyl vignette](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).  





### **gtsummary** package {-}  

If you want to print your summary statistics in a pretty, publication-ready graphic, you can use the **gtsummary** package and its function `tbl_summary()`. The code can seem complex at first, but the outputs look very nice and print to your RStudio Viewer panel as HTML. Read a [vignette here](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).    

To introduce `tbl_summary()` we will show the most basic behavior first, which actually produces a large and beautiful table. Then, we will examine in detail how to make adjustments and more tailored tables. 



#### Summary table {-}

The default behavior of `tbl_summary()` is quite incredible - it takes the columns you provide and creates a summary table. The function prints statistics appropriate to the column class: median and inter-quartile range (IQR) for numeric columns, and counts (%) for categorical or binary columns. Missing values are converted to "Unknown". Footnotes are added to the bottom to explain the statistics, while the total N is shown at the top.  

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # keep columns of interest
  tbl_summary()                                                  # default tbl_summary()
```


Now we will explain how the function works and how to make adjustments. The key arguments are detailed below: 

**`by = `**  
You can stratify your table by a column (e.g. by `outcome`), creating a 2-way table.  

**`statistic = `**  
Indicate which statistics to show and how to display them with an equation. There are two sides to the equation, separated by a tilde `~`. On the right in quotes is the statistical display desired, and on the left are the columns to which that display will apply.  

* The right side of the equation uses the syntax of `str_glue()` from **stringr** (see [Characters and Strings]), with the desired display string in quotes and the statistics themselves within curly brackets. You can include statistics like "n" (for counts), "N" (for denominator), "mean", "median", "sd", "max", "min", percentiles as "p##" like "p25", or percent of total as "p". See `?tbl_summary` for details.  
* For the left side of the equation, you can specify columns by name (e.g. `age` or `c(age, gender)`) or using helpers such as `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()`, etc.  

A simple example of a `statistic = ` equation might look like below, to only print the mean of column `age_years`:  

```{r}
linelist %>% 
  select(age_years) %>%         # keep only columns of interest 
  tbl_summary(                  # create summary table
    statistic = age_years ~ "{mean}") # print mean of age
```

A slightly more complex equation might look like this, incorporating the max and min values within parentheses and separated by a comma:  

```{r, eval=F}
statistic = age_years ~ "({min}, {max})"
```

You can also differentiate syntax for separate columns or types of columns. In the more complex example below, the value provided to `statistc = ` is a **list** indicating that for all continuous columns the table should print mean with standard deviation in parentheses, while for all categorical columns it should print the n, denominator, and percent.  

**`digits = `**  
Adjust the digits and rounding. Optionally, this can be specified to be for continuous columns only (as below).  

**`label = `**  
Adjust how the column name should be displayed. Provide the column name and its desired label separated by a tilde. The default is the column name.  

**`missing_text = `**  
Adjust how missing values are displayed. The default is "Unknown".  

**`type = `**  
This is used to adjust how many levels of the statistics are shown. The syntax is similar to `statistic = ` in that you provide an equation with columns on the left and a value on the right. Two common scenarios include:  

* `type = all_categorical() ~ "categorical"` Forces dichotomous columns (e.g. fever) to show all levels instead of only the “yes” row  
* `type = all_continuous() ~ "continuous2"` Allows multi-line statistics per variable, as shown in a later section  

In the example below, each of these arguments is used to modify the original summary table:  

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # keep only columns of interest
  tbl_summary(     
    by = outcome,                                               # stratify entire table by outcome
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # stats and format for continuous columns
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # stats and format for categorical columns
    digits = all_continuous() ~ 1,                              # rounding for continuous columns
    type   = all_categorical() ~ "categorical",                 # force all categorical levels to display
    label  = list(                                              # display labels for column names
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # how missing values should display
  )
```



#### Multi-line stats for continuous variables {-}  

If you want to print multiple lines of statistics for continuous variables, you can indicate this by setting the `type = ` to "continuous2".  You can combine all of the previously shown elements in one table by choosing which statistics you want to show. To do this you need to tell the function that you want to get a table back by entering the type as “continuous2”. The number of missing values is shown as "Unknown".

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # keep only columns of interest
  tbl_summary(                                     # create summary table
    type = all_continuous() ~ "continuous2",       # indicate that you want to print multiple statistics 
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # line 1: mean and SD
      "{median} ({p25}, {p75})",                   # line 2: median and IQR
      "{min}, {max}")                              # line 3: min and max
    )
```
There are many other ways to modify these tables, including adding p-values, adjusting color and headings, etc. Many of these are described in the documentation (enter `?tbl_summary` in Console), and some are given in the section on statistical tests.  




### **dplyr** package {-}  

**dplyr** is part of the **tidyverse** packages and is an extremely common data management tool. Creating tables with **dplyr** is useful if you are calculating more complex statistical summary measures, or passing the results to `ggplot()` (which expects "long" data).  

As explained in the [Grouping data] page, you can use the **dplyr** function `count()` to return tabulated counts on one or more columns. The output returned is in a "long" format with a column `n` to hold the counts.  

```{r}
linelist %>% 
  count(age_cat)
```

Tabulations of two or more columns are still returned in "long" format, with the counts in the `n` column.  

```{r}
linelist %>% 
  count(age_cat, gender)
```

To pipe this output to `ggplot()` is relatively straight-forward. See further examples in the pages [Plotting categorical data] and [ggplot tips].  

```{r, warning=F, message=F}
linelist %>% 
  count(outcome, age_cat) %>% 
  ggplot()+
    geom_bar(aes(x = outcome, fill = age_cat, y = n), stat = "identity")
```
Instead of mean, you can also use other **base** R statistical functions like  To return percentiles, use `quantile()` with the defaults or specify the value(s) you would like.

```{r descriptive_dplyr_percentile}
# get default percentile values of age (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(percentiles = quantile(age_years, na.rm = TRUE))

# get specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(percentiles = quantile(age_years,
                                   probs = c(.05, 0.5, 0.75, 0.98), 
                                   na.rm=TRUE))
```


#### Complex statistics {-}

One of the advantages of using **dplyr** to make your table is the flexibility to calculate statistics like `median()`, `max()`, `sd()`, etc. You can use the function `percent()` from the **scales** package to easily convert to percents. We also use `round()` from **base** R to specify the decimals. Note the use of argument `na.rm = TRUE` in the mathematical functions so `NA` is ignored in calculations.  

```{r}
summary_table <- linelist %>%                                       # begin with linelist, define out as new object
  group_by(hospital) %>%                                            # group. All calculations will be "by group"
  summarise(                                                        # only these summary columns will be returned
    cases       = n(),                                              # number of rows per group
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),             # number of rows with male gender
    pct_delay_3 = scales::percent(delay_3 / cases),                 # conversion of previously-defined column 
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1), # mean of delays column, by group and rounded
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1)  # standard deviation of delays column, by group and rounded
  )

summary_table  # print
```

You can also use `str_glue()` to combine column values into a new column. Below, the `summary_table` created above is mutated such that columns `delay_mean` and `delay_sd` are combined and their old columns removed. A total row is added with `adorn_totals()` from **janitor**, which ignores non-numeric columns. Lastly, we use `rename()` from **dplyr** to make the colum names nicer. Now you could pass to **flextable** and print to Word, HTML, Powerpoint, etc.!  

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # combine and format other values
  select(-c(delay_mean, delay_sd)) %>%                       # remove two old columns   
  adorn_totals(where = "row") %>%                            # add total row
  rename(                                                    # rename cols
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3,
    "Mean (sd)"       = delay)
```


#### Within-group proportions {-}  

You can calculate proportions *within groups* by having two levels of aggregation prior to using `mutate()`. The table below first groups the data frame by `outcome` and then groups again and counts by column `age_cat`, achieving the breakdown of age *by outcome*. Note that you can add more stratifications by adding columns to the `group_by()` command.  

```{r}
age_by_outcome <- linelist %>% 
  group_by(outcome) %>%                  # group first by outcome 
  count(age_cat) %>%                     # group again and count by gender (produces "n" column)
  mutate(percentage = n / sum(n) * 100)  # calculate proportion - note the denominator is by outcome group

age_by_outcome
```

#### Pivot wider {-}

If your **dplyr** table is in "long" format, you can "pivot" it to wide format using the **tidyr** `pivot_wider()` function. You will likely need to re-define the column names with `rename()`. For more information see the page on [Pivoting data].  

```{r}
age_by_outcome %>% 
  pivot_wider(names_from = age_cat, values_from = c(n, percentage))  
```







### **base** R {-}  

You can use the function `table()` to tabulate and cross-tabulate columns. Unlike the options above, you must specify the dataframe, as shown below.  

<span style="color: orange;">**_CAUTION:_** `NA` (missing) values will **not** be tabulated unless you include the argument `useNA = "always"` (which could also be set to "no" or "ifany").</span>

```{r}
table(linelist$outcome, useNA = "always")
```

Multiple columns can be cross-tabulated by listing them one after the other, separated by commas. Optionally, you can assign each column a "name" like `Outcome = linelist$outcome`.  

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # save table as object
age_by_outcome   # print table
```
To return proportions, passing the above table to the function `prop.table()`. Use the `margins = ` argument to specify whether you want the proportions to be of rows (1), of columns (2), or of the whole table (3). For clarity, we pipe the table to the `round()` function from **base** R, specifying 2 digits.   

```{r}
# get proportions of table defined above, by rows, rounded
prop.table(age_by_outcome, 1) %>% round(2)
```

To add row and column totals, pass the table to `addmargins()`. This works for both counts and proportions.  

```{r}
addmargins(age_by_outcome)
```

Converting a `table()` object directly to a data frame is not straight-forward. One approach is demonstrated below:  

1) Create the table, *without using* `useNA = "always"`. Instead convert `NA` values to "(Missing)" with `fct_explicit_na()` from **forcats**.  
2) Add totals (optional) by piping to `addmargins()`  
3) Pipe to the **base** R function `as.data.frame.matrix()`  
4) Pipe the table to the **dplyr** function `add_rownames()`, specifying the name for the first column  
5) Print, View, or export as desired. In this example we use `flextable()` from package **flextable** as described in the [Tables] page. This will print to the RStudio viewer pane as a pretty HTML.  

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  dplyr::add_rownames(var = "Age Category") %>% 
  flextable::flextable()
```





<!-- ======================================================= -->

## Statistical tests {  }


### **base** R {-}

You can use **base** R functions to produce the results of statistical tests. The commands are relatively simple and results will print to the R Console for simple viewing. However, the outputs are usually lists and so are harder to manipulate if you want to use the results in subsequent code operations. 

#### T-tests {-} 

**Syntax 1:** Best is your numeric and categorical columns are in the same data frame. Provide the numeric column on the left side of the equation and the categorical column on the right side. Specify the dataset to `data = `. Optionally, set `paired = TRUE`, and `conf.level = ` (0.95 default), and `alternative = ` (either "two.sided", "less", or "greater"). Enter `?t.test` for more details.  

```{r}
## compare mean age by outcome group with a t-test
t.test(age_years ~ outcome, data = linelist)
```

**Syntax 2:** You can compare two separate numeric vectors using this alternative syntax. For example, if the two columns are in different data sets.  

```{r, eval=F}
t.test(df1$age_years, df2$age_years)
```

Conduct a one-sample t-test with the known/hypothesized populaton mean on the right side of the equation:  

```{r, eval=F}
t.test(linelist$age_years, mu = 45)
```

#### Shapiro-Wilk's test {-}  

```{r, eval=F}
shapiro.test(linelist$age_years)
```

#### Wilcoxon rank sum test {-}

```{r wilcox_base}

## compare age distribution by outcome group with a wilcox test
wilcox.test(age_years ~ outcome, data = linelist)

```

#### Kruskal-wallis test {-}


```{r }

## compare age distribution by outcome group with a kruskal-wallis test
kruskal.test(age_years ~ outcome, linelist)

```

#### Chi-squared test {-} 

```{r}

## compare the proportions in each group with a chi-squared test
chisq.test(linelist$gender, linelist$outcome)

```





### `gtsummary` package {-}

Use **gtsummary** if you are looking to add the results of a statistical test to a pretty table (described in section above). 
Performing statistical tests of comparison with `tbl_summary` is done by adding the 
`add_p` function to a table and specifying which test to use. It is possible to get p-values corrected for multiple testing by using the
`add_q` function. Run `?tbl_summary` for details.  

#### Chi-squared test 

Compare the proportions of a categorical variable in two groups. The default statistical test for 
`add_p()` is to perform a chi-squared test of independence with continuity correction, but if 
any expected call count is below 5 then a Fisher's exact test is used. 

```{r chi_gt}
linelist %>% 
  select(gender, outcome) %>%    # keep variables of interest
  tbl_summary(by = outcome) %>%  # produce summary table and specify grouping variable
  add_p()                        # specify what test to perform
```


#### T-tests {-} 

Compare the difference in means for a continuous variable in two groups. 
For example, compare the mean age by patient outcome. 

```{r ttest_gt}

linelist %>% 
  select(age_years, outcome) %>%             # keep variables of interest
  tbl_summary(                               # produce summary table
    statistic = age_years ~ "{mean} ({sd})", # specify what statistics to show
    by = outcome) %>%                        # specify the grouping variable
  add_p(age_years ~ "t.test")                # specify what tests to perform


```

#### Wilcoxon rank sum test{-}

Compare the distribution of a continuous variable in two groups. The default 
is to use the Wilcoxon rank sum test and the median (IQR) when comparing two 
groups. However for non-normally distributed data or comparing multiple groups, 
the Kruskal-wallis test is more appropriate. 

```{r wilcox_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # keep variables of interest
  tbl_summary(                                         # produce summary table
    statistic = age_years ~ "{median} ({p25}, {p75})", # specify what statistic to show (this is default so could remove)
    by = outcome) %>%                                  # specify the grouping variable
  add_p(age_years ~ "wilcox.test")                     # specify what test to perform (default so could leave brackets empty)


```

#### Kruskal-wallis test {-}

Compare the distribution of a continuous variable in two or more groups, 
regardless of whether the data is normally distributed. 

```{r kruskal_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # keep variables of interest
  tbl_summary(                                         # produce summary table
    statistic = age_years ~ "{median} ({p25}, {p75})", # specify what statistic to show (default, so could remove)
    by = outcome) %>%                                  # specify the grouping variable
  add_p(age_years ~ "kruskal.test")                    # specify what test to perform


```




### `dplyr` package {-}

Performing statistical tests in `dplyr` alone is very dense, again because it 
does not fit within the tidy-data framework. It requires using `purrr` to create
a list of dataframes for each of the subgroups you want to compare. See the page on [Iteration and loops] to learn about **purrr**.  

An easier alternative may be the `rstatix` package. 

#### T-tests {-} 

```{r ttest_dplyr}

linelist %>% 
  ## only keep variables of interest
  select(age, outcome) %>% 
  ## drop those missing outcome 
  filter(!is.na(outcome)) %>% 
  ## specify the grouping variable
  group_by(outcome) %>% 
  ## create a subset of data for each group (as a list)
  nest() %>% 
  ## spread in to wide format
  pivot_wider(names_from = outcome, values_from = data) %>% 
  mutate(
    ## calculate the mean age for the death group
    Death_mean = map(Death, ~mean(.x$age, na.rm = TRUE)),
    ## calculate the sd among dead 
    Death_sd = map(Death, ~sd(.x$age, na.rm = TRUE)),
    ## calculate the mean age for the recover group
    Recover_mean = map(Recover, ~mean(.x$age, na.rm = TRUE)), 
    ## calculate the sd among recovered 
    Recover_sd = map(Recover, ~sd(.x$age, na.rm = TRUE)),
    ## using both grouped data sets compare mean age with a t-test
    ## keep only the p.value
    t_test = map2(Death, Recover, ~t.test(.x$age, .y$age)$p.value)
  ) %>% 
  ## drop datasets 
  select(-Death, -Recover) %>% 
  ## return a dataset with the medians and p.value (drop missing)
  unnest(cols = everything())

```


#### Wilcoxon rank sum test {-}

```{r wilcox_dplyr}

linelist %>% 
  ## only keep variables of interest
  select(age, outcome) %>% 
  ## drop those missing outcome 
  filter(!is.na(outcome)) %>% 
  ## specify the grouping variable
  group_by(outcome) %>% 
  ## create a subset of data for each group (as a list)
  nest() %>% 
  ## spread in to wide format
  pivot_wider(names_from = outcome, values_from = data) %>% 
  mutate(
    ## calculate the median age for the death group
    Death_median = map(Death, ~median(.x$age, na.rm = TRUE)),
    ## calculate the sd among dead 
    Death_iqr = map(Death, ~str_c(
      quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE), 
      collapse = ", "
      )),
    ## calculate the median age for the recover group
    Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)), 
    ## calculate the sd among recovered 
    Recover_iqr = map(Recover, ~str_c(
      quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE), 
      collapse = ", "
      )),
    ## using both grouped data sets compare age distribution with a wilcox test
    ## keep only the p.value
    wilcox = map2(Death, Recover, ~wilcox.test(.x$age, .y$age)$p.value)
  ) %>% 
  ## drop datasets 
  select(-Death, -Recover) %>% 
  ## return a dataset with the medians and p.value (drop missing)
  unnest(cols = everything())

```

#### Kruskal-wallis test {-}


```{r kruskal_dplyr}

linelist %>% 
  ## only keep variables of interest
  select(age, outcome) %>% 
  ## drop those missing outcome 
  filter(!is.na(outcome)) %>% 
  ## specify the grouping variable
  group_by(outcome) %>% 
  ## create a subset of data for each group (as a list)
  nest() %>% 
  ## spread in to wide format
  pivot_wider(names_from = outcome, values_from = data) %>% 
  mutate(
    ## calculate the median age for the death group
    Death_median = map(Death, ~median(.x$age, na.rm = TRUE)),
    ## calculate the sd among dead 
    Death_iqr = map(Death, ~str_c(
      quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE), 
      collapse = ", "
      )),
    ## calculate the median age for the recover group
    Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)), 
    ## calculate the sd among recovered 
    Recover_iqr = map(Recover, ~str_c(
      quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE), 
      collapse = ", "
      )),
    ## using the original data set compare age distribution with a kruskal test
    ## keep only the p.value
    kruskal = kruskal.test(linelist$age, linelist$outcome)$p.value
  ) %>% 
  ## drop datasets 
  select(-Death, -Recover) %>% 
  ## return a dataset with the medians and p.value (drop missing)
  unnest(cols = everything())

```

#### Chi-squared test {-} 


```{r}
linelist %>% 
  ## do everything by gender 
  group_by(outcome) %>% 
  ## count the variable of interest
  count(gender) %>% 
  ## calculate proportion 
  ## note that the denominator here is the sum of each gender
  mutate(percentage = n / sum(n) * 100) %>% 
  pivot_wider(names_from = outcome, values_from = c(n, percentage)) %>% 
  filter(!is.na(gender)) %>% 
  mutate(pval = chisq.test(linelist$gender, linelist$outcome)$p.value)
```


<!-- ======================================================= -->

## Correlations 

Correlation between numeric variables can be investigated using the tidyverse  
`corrr` package. It allows you to compute correlations using Pearson, Kendall
tau or Spearman rho. The package creates a table and also has a function to 
automatically plot the values. 

```{r, warning=F, message=F}

correlation_tab <- linelist %>% 
  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # keep numeric variables of interest
  correlate()      # create correlation table (using default pearson)

correlation_tab    # print

## remove duplicate entries (the table above is mirrored) 
correlation_tab <- correlation_tab %>% 
  shave()

## view correlation table 
correlation_tab

## plot correlations 
rplot(correlation_tab)
```


<!-- ======================================================= -->

## Resources {  }

Much of the information in this page is adapted from these resources and vignettes online:  

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)
[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
[corrr](https://corrr.tidymodels.org/articles/using-corrr.html)
[sthda correlation](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/descriptive_statistics.Rmd-->

