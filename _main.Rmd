---
knit: "bookdown::render_book"
title: "The Epidemiologist R Handbook"
author: "the handbook team"
description: "This is a R reference manual for applied epidemiology and public health."  
date: "`r Sys.Date()`"
#url: 'https://github.com/nsbatra/Epi_R_handbook'
github-repo: nsbatra/Epi_R_handbook
#twitter-handle: 
#cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
---


#  {-}

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "R Handbook Logo.png"))
```

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<span style="color: red;">**THIS IS A DRAFT**.</span>

<span style="color: orange;">**BOOK REVIEWERS: PLEASE PROVIDE FEEDBACK FOR EACH PAGE AT THIS [LINK](https://forms.gle/4RNdRRLGx67xW9yq9)**</span>

<span style="color: darkgreen;">**DO YOU LIKE THIS BOOK? LET US KNOW WITH [ONE CLICK HERE](https://docs.google.com/forms/d/e/1FAIpQLSdBkGN1CinGj9Vgbk_AznHUmWDa1CjdND5g603Q9-MU2KoTsA/formResponse?usp=pp_url&entry.1151211170=THIS+IS+AN+AUTOMATED+SUBMISSION+FROM+USER+CLICKING+LIKE+BUTTON&submit=Submit), OR PROVIDE [MORE FEEDBACK HERE](https://forms.gle/A5SnRVws7tPD15Js9)**</span>

<form target="_blank" action="https://docs.google.com/forms/d/e/1FAIpQLSdBkGN1CinGj9Vgbk_AznHUmWDa1CjdND5g603Q9-MU2KoTsA/formResponse?usp=pp_url&entry.1151211170=THIS+IS+AN+AUTOMATED+SUBMISSION+FROM+USER+CLICKING+LIKE+BUTTON&submit=Submit">
    <input type="submit" value="I like this book! (one-click)!" />
</form>

<form target="_blank" action="https://forms.gle/A5SnRVws7tPD15Js9">
    <input type="submit" value="Feedback survey" />
</form>

<!-- ======================================================= -->
## About this handbook {-}

<span style="color: brown;">**This is an open-access R reference manual for applied epidemiology and public health.**</span>

**This book strives to:**  

* Serve as a quick R code reference manual  
* Provide task-centered examples for addressing common epidemiological problems  
* Assist epidemiologists transitioning to R from SAS, STATA, SPSS, and Excel  
* Be accessible in settings with low internet-connectivity via an **offline version** ([instructions here][Download book and data])  

**How is this different than other R books?**  

* It is written by epidemiologists, for epidemiologists - leveraging experience in local, national, academic, and emergency settings  
* It provides examples of epidemic curves, transmission chains, epidemic modeling and projections, age and sex pyramids and standardization, record matching, outbreak detection, survey analysis, causal diagrams, survival analysis, GIS basics, phylogenetic trees, automated reports, etc...  



<!-- ======================================================= -->
## How to read this handbook {-} 

**Online version**  

* Search via the search box above the Table of Contents 
* Click the "copy" icons to copy code  
* See the "Resources" section of each page for further resources  
* To download data and "follow-along", see the [Download book and data] page  

**Offline version**  

To download the offline version, follow step-by-step instructions in the [Download book and data] page.  

**Languages**  

We are actively seeking to translate this book into languages other than English. If you can help, please contact us at **epiRhandbook@gmail.com**.  


<!-- ======================================================= -->
## Edit or contribute {-}

Want to share how you use this book? Want to offer a fix or addition?  
Email us at **epiRhandbook@gmail.com**. We welcome your comments and suggestions. 

You can also submit an issue or pull request at our [Github repository](https://github.com/nsbatra/R_epi_handbook), or provide structured feedback via this [Google survey](https://forms.gle/4RNdRRLGx67xW9yq9).  



<!-- ======================================================= -->
## Acknowledgements {-}  


### Contributors {-}  

This book is produced by a collaboration of epidemiologists from around the world, drawing upon experiences with organizations including local, state, provincial, and national health departments and ministries, the World Health Organization (WHO), MSF (Médecins Sans Frontières / Doctors without Borders), hospital systems, and academic institutions.

**Editor-in-Chief:** Neale Batra 

**Core team:** Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay Campbell  

**Authors**: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonny Polonski, Yurie Izawa, Daniel Molling, Sara Hollis, Isha Berry, Wen Lin  

**Reviewers**: 

### Funding and programmatic support {-}  

This handbook is **not** an approved product of any specific organization. Although we strive for accuracy, we provide no guarantee of the content in this book.  

The handbook project received funding via a COVID-19 emergency capacity-building grant from Training Programs in Epidemiology and Public Health Interventions Network ([TEPHINET](https://www.tephinet.org/)). *This handbook was supported by Cooperative Agreement number NU2GGH001873, funded by the Centers for Disease Control and Prevention through TEPHINET, a program of The Task Force for Global Health. Its contents are solely the responsibility of the authors and do not necessarily represent the official views of the Centers for Disease Control and Prevention, the Department of Health and Human Services, The Task Force for Global Health, Inc. or TEPHINET.*

Programmatic support was provided by the EPIET Alumni Network ([EAN](https://epietalumni.net/)).  



### Inspiration {-}  

The multitude of tutorials and vignettes that provided knowledge for development of handbook content are credited within their respective pages.  

More generally, the following sources provided inspiration and laid the groundwork for this handbook:  
[The "R4Epis" project](https://r4epis.netlify.app/) (a collaboration between MSF and RECON)  
[R Epidemics Consortium (RECON)](https://www.repidemicsconsortium.org/)  
[R for Data Science book (R4DS)](https://r4ds.had.co.nz/)  
[bookdown: Authoring Books and Technical Documents with R Markdown](https://bookdown.org/yihui/bookdown/)  
[Netlify](https://www.netlify.com) hosts this website  


### Image credits {-}  

Images in logo from US CDC Public Health Image Library) include [2013 Yemen looking for mosquito breeding sites](https://phil.cdc.gov/Details.aspx?pid=19623), [Ebola virus](https://phil.cdc.gov/Details.aspx?pid=23186), and [Survey in Rajasthan](https://phil.cdc.gov/Details.aspx?pid=19838).  


## Terms of Use and License {-}  

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.


Universities and academic courses are welcome to use this handbook with their students. If you have questions about your intended use, email **epirhandbook@gmail.com**.  
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=3)
```

<!--chapter:end:index.Rmd-->

# (PART) Preview pages {-}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=3)
```

<!--chapter:end:new_pages/cat_preview.Rmd-->


# R Markdown reports { }  

R Markdown is a fantastic tool for creating automated, reproducible, and share-worthy outputs. It can generate static or interactive outputs, in the form of html, word, pdf, powerpoint, and others. 

<!-- ======================================================= -->
## Overview {  }

Using R markdown will allow you easily recreate an entire formatted document, including tables/figures/text, using new data (e.g. daily surveillance reports) and/or subsets of data (e.g. reports for specific geographies). 

This guide will go through the basics. See Resources section for further info. Other pages in this handbook expand on this page:  

* The page [Organizing routine reports] demonstrates how to routinize your report production with auto-generated time-stamped folders.  
* The page [Dashboards with M Markdown] explains how to format a R Markdown report as a dashboard.  



<!-- ======================================================= -->
## Preparation {  }

**Background to R Markdown**

To explain some of the concepts and packages involved:

* **Markdown** is a “language” which uses syntax that allows design of a document using plain text, so that it can be converted to html and other formats. It is not specific to R, and usually a markdown file has an ‘.md’ extension.
* **R Markdown**: This is an extension of markdown that _is_ specific to R, with file extensions '.Rmd'. This allows R code to be embedded in 'chunks' so that the code itself can be run, rather than just having a text document. 
* **rmarkdown - the package**: This is used by R to render the .Rmd file into the desire output. However its focus is the markdown (text) syntax, so we also need...
* **knitr**: This R package will read the code chunks, execute it, and 'knit' it back into the document. This is how tables and graphs are included alongside the text.
* **Pandoc**: Finally, pandoc is needed to actually convert documents into e.g. word/pdf/powerpoint etc. It is a software separate from R.  

In sum, the process involves feeding the .Rmd file to **knitr**, which executes the R code chunks and creates a new .md (markdown) file which includes the R code and its rendered output. The .md file is the processed by pandoc to create the finished product: a Microsoft Word document, HTML file, powerpoint document, pdf, etc.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/0_rmd.png"))
```

(source: https://rmarkdown.rstudio.com/authoring_quick_tour.html):

**Installation**

To create a R Markdown output, you need to have the following installed:

* The **rmarkdown** package, as described above  
* Pandoc, which should come installed with RStudio. If you are not using RStudio, you can download it here: http://pandoc.org. 
* If you want to generate PDF output (a bit trickier), you will need to install LaTeX. For R Markdown users who have not installed LaTeX before, we recommend that you install TinyTeX (https://yihui.name/tinytex/). You can use the following commands: 

```{r, eval=F}
pacman::p_load(tinytex)     # install tinytex package
tinytex::install_tinytex()  # R command to install TinyTeX software
```

<!-- ======================================================= -->
## Getting started {  }

### Install rmarkdown R package {-}

Install the **rmarkdown** R package. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load packages with `library()` from **base** R. See the page on [R basics] for more information on R packages.  

```{r, eval=F}
pacman::p_load(rmarkdown)
```

### Starting a new Rmd file {-}

In RStudio, open a new R markdown file, starting with ‘File’, then ‘New file’ then ‘R markdown…’. 

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstarted.png"))
```

R Studio will give you some output options to pick from. In the example below we select "HTML" because we want to create an html document. The title and the author names are not important. If the output document type you want is not one of these, don't worry - you can just pick any one and change it in the script later. 

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstartedB.png"))
```

This will open up a new .Rmd script.

### Important to know {-}
 
**The working directory**

The working directory of a markdown file is wherever the Rmd file itself is saved. For instance, if the R project is within `~/Documents/projectX ` and the Rmd file itself is in a subfolder `~/Documents/projectX/markdownfiles/markdown.Rmd`, the code `read.csv(“data.csv”)` within the markdown will look for a csv file in the `markdownfiles` folder, and not the root project folder where scripts within projects would normally automatically look.

To refer to files elsewhere, you will either need to use the full file path or use the **here** package. The **here** package sets the working directory to the root folder of the R project and is explained in detail in the [R projects] and [Import and export] pages of this handbook. For instance, to import a file called "data.csv" from within the `projectX` folder, the code would be `import(here(“data.csv”))`. 

Note that use of `setwd()` in R Markdown scripts is not recommended – it only applies to the code chunk that it is written in. 

**Working on a drive vs your computer**

Because R Markdown can run into pandoc issues when running on a shared network drive, it is recommended that your folder is on your local machine, e.g. in a project within ‘My Documents’. If you use Git (much recommended!), this will be familiar. For more details, see the handbook pages on [R on network drives] and [Errors and help].  


<!-- ======================================================= -->
## The R Markdown file {  }

An R Markdown document can be edited in RStudio just like a standard R script. When you start a new R Markdown script, RStudio tries to be helpful by showing a template which explains the different section of an R Markdown script. 

The below is what appears when starting a new Rmd script intended to produce an html output (as per previous section). 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_defaultRMD.png"))
```

As you can see, there are three basic components to an Rmd file.

### YAML metadata {-}

Referred to as the ‘YAML metadata’ or just ‘YAML’, this is at the top of the R Markdown document. This section of the script will tell your Rmd file what type of output to produce, formatting preferences, and other metadata such as document title, author, and date. There are other uses not mentioned here (but referred to in ‘Producing an output’). Note that indentation matters; tabs are not accepted but spaces are. 

This section must begin with a line containing just three dashes `---` and must close with a line containing just three dashes `---`. YAML parameters comes in `key:value` pairs. The placement of colons in YAML is important - the `key:value` pairs are separated by colons (not equals signs!).  

The YAML should begin with metadata for the document. The order of these primary YAML parameters (not indented) does not matter. For example:  

```yaml
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```

You can use R code in YAML values by writing it as in-line code (preceded by `r` within back-ticks) but also within quotes (see above example for `date: `).  

In the image above, because we clicked that our default output would be an html file, we can see that the YAML says `output: html_document`. However we can also change this to say `powerpoint_presentation` or `word_document` or even `pdf_document`.  


### Text {-}

This is the narrative of your document, including the titles and headings. It is written in the "markdown" language, which is used across many different software.  

Below are the core ways to write this text. See more extensive documentation available on R Markdown "cheatsheet" at the [RStudio website](https://rstudio.com/resources/cheatsheets/).  

#### New lines {-}  

Uniquely in R Markdown, to initiate a new line, enter *two spaces** at the end of the previous line and then Enter/Return.  



#### Case {-}  

Surround your normal text with these character to change how it appears in the output.  

* Underscores (`_text_`) or single asterisk (`*text*`) to _italicise_
* Double asterisks (`**text**`) for **bold text**
* Back-ticks (````text````) to display text as code  

The actual appearance of the font can be set by using specific templates (specified in the YAML metadata; see example tabs).  

#### Color {-}  

There is no simple mechanism to change the color of text in R Markdown. One work-around, *IF your output is an HTML file*, is to add an HTML line into the markdown text. The below HTML code will print a line of text in bold red.  

```md
<span style="color: red;">**_DANGER:_** This is a warning.</span>  
```

#### Titles and headings {-}  

A hash symbol in a text portion of a R Markdown script creates a heading. This is different than in a chunk of R code in the script, in which a hash symbol is a mechanism to comment/annotate/de-activate, as in a normal R script.  

Different heading levels are established with different numbers of hash symbols at the start of a new line. One hash symbol is a title or primary heading. Two hash symbols are a second-level heading. Third- and fourth-level headings can be made with successively more hash symbols.

```md
# First-level heading / title

## Second level heading  

### Third-level heading
```


#### Bullets and numbering {-}  

Use asterisks (`*`) to created a bullets list. Finish the previous sentence, enter two spaces, Enter/Return *twice*, and then start your bullets. Include a space between the asterisk and your bullet text. After each bullet enter two spaces and then Enter/Return. Sub-bullets work the same way but are indented. Numbers work the same way but instead of an asterisk, write 1), 2), etc. Below is how your R Markdown script text might look.  


```md
Here are my bullets (there are two spaces after this colon):  

* Bullet 1 (followed by two spaces and Enter/Return)  
* Bullet 2 (followed by two spaces and Enter/Return)  
  * Sub-bullet 1 (followed by two spaces and Enter/Return)  
  * Sub-bullet 2 (followed by two spaces and Enter/Return)  
  
```

#### In-line R code {-}  

You can also include minimal R code within back-ticks. Within the back-ticks, begin the code with "r" and a space, so RStudio knows to evaluate the code as R code. See the example below.  

#### Example {-}  

The example below shows multiple heading levels, bullets, and uses R code for the current date (`Sys.Date()`) to evaluate into a printed date.

```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_text.png"))
```


### Code chunks {-}

Sections of the script that are dedicated to running R code are called "chunks". This is where you may load packages, import data, and perform the actual data management and visualisation. There may be many code chunks, so they can help you organize your R code into parts, perhaps interspersed with text. To note:
These ‘chunks’ will appear to have a slightly different background colour from the narrative part of the document.  

Each chunk is opened with a line that starts with three back-ticks, and curly brackets that contain parameters for the chunk (`{ }`). The chunk ends with three more back-ticks.  

You can create a new chunk by typing it out yourself, by using the keyboard shortcut "Ctrl + Alt + i" (or Cmd + Shift + r in Mac), or by clicking the green 'insert a new code chunk' icon at the top of your script editor.

Some notes about the contents of the curly brackets `{ }`:

*	They start with ‘r’ to indicate that the language name within the chunk is R
*	After the r you can optionally write a chunk "name" – these are not necessary but can help you organise your work. Note that if you name your chunks, you should ALWAYS use unique names or else R will complain when you try to render.  
*	The curly brackets can include other options too, written as `tag=value`, such as:  
  * `eval = FALSE` to not run the R code  
  * `echo = FALSE` to not print the chunk's R source code in the output document  
  * `warning = FALSE` to not print warnings produced by the R code  
  * `message = FALSE` to not print any messages produced by the R code  
  * `include =` either TRUE/FALSE whether to include chunk outputs (e.g. plots) in the document
  * `fig.width = ` and `fig.height =` - provide in style `fig.width = "75%"`  
  * `fig.align = "center"` adjust how a figure is aligned across the page  
  * `fig.show='hold'` if your chunk prints multiple figures and you want them printed next to each other (pair with `fig.width = c("33%", "67%")`. Can also set as `fig.show='asis'` to show them below the code that generates them, `'hide'` to hide, or `'animate'` to concatenate multiple into an animation.  
* A chunk header must be written in *one line*  
* Try to avoid periods, underscores, and spaces. Use hyphens ( - ) instead if you need a separator.  

Read more extensively about the **knitr** options [here](https://yihui.org/knitr/options/).  

Some of the above options can be configured with point-and-click using the setting buttons at the top right of the chunk. Here, you can specify which parts of the chunk you want the rendered document to include, namely the code, the outputs, and the warnings. This will come out as written preferences within the curly brackets, e.g. ‘echo=FALSE’ if you specify you want to ‘Show output only’.  


```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunk.png"))
```

There are also two arrows at the top right of each chunk, which are useful to run code within a chunk, or all code in prior chunks. Hover over them to see what they do.


For global options to be applied to all chunks in the script, you can set this up within your very first R code chunk in the script. For instance, so that only the outputs are shown for each code chunk and not the code itself, you can include this command in the R code chunk:  

```{r, eval=F}
knitr::opts_chunk$set(echo = FALSE) 
```




### Combining code and text {-}

Above we showed how you can integrate dynamic values such as today's date into the text. You can also use short functions (e.g. to calculate the min, median, max of a column) in the text, or integrate objects created within code chunks. 

The following calculates the proportion of cases that are aged less than 18 years old, using tidyverse code, and feeds it into the text. We see how it looks when knitted to a word document.

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunktext.png"))
```

<!-- ======================================================= -->
## Producing an R markdown output {  }

### R Markdown workflow {-}

Production of an R Markdown will depend on how you design it. We describe these options below: 

* **“Self-contained” R markdown**: This is when everything you need to run the R markdown is contained within the Rmd file, including all the code chunks and package loading. This can also include sourcing other scripts, but they will still be run during the course of knitting your Rmd file. These are appropriate when you do not need to do much data processing (e.g. it brings in a clean or semi-clean data file) and the running of the file will not take too long.  

* **R markdown combined with pre-processing**: This is when you pre-process objects that feed into your R markdown. For instance, you can load the packages, load and clean the data, and even create the graphs of interest. As long as this occurs in the same RStudio session and objects are saved to the environment, they can be called within the Rmd content. Then the R markdown itself will only be used for the final step, to produce the output with all the pre-processed objects. This is much easier to de-bug if something goes wrong.

Generally, we recommend splitting up your code into different files, as it is horrible having to debug extremely long script, and especially horrible to debug an extremely long Rmd file. For example if there is an error within a code chunk, R will tell you which chunk had a problem, but will not tell you which line. 
The workflow also concerns the overall folder structure, such as having an 'output' folder for created documents and an 'input' folder for cleaned data. We do not go into further detail of further structure here, but the [Organizing routine reports] page discusses this further. 

### Producing a complete document {-} 

Now that you know the above, you can produce the document in the following ways:

#### Option 1: Render command {-}

One way to produce your R Markdown output is to run the `render()` function from the **rmarkdown** package. You would do this from the R Console or from a separate R script. In the example below, we have a separate R script in which we pre-process a `data` object into the R Environment and then render the "create_output.Rmd" using `render()`.  

```{r, eval=F}
data <- import("datafile.csv") %>%       # Load data and save to environment
  select(age, hospital, weight)          # Select limited columns

rmarkdown::render(input = "create_output.Rmd")   # Create Rmd file
```

In its simplest form, this approach will save the Rmd output to the same folder as your Rmd script, with the same file name aside from the file extension. For instance “create_output.Rmd” when knitted will create “create_output.docx” if you are knitting to a word document. 

For better version control, you can add further options to `render()` for the file name and save location. For instance, the following command will save the output file within an ‘outputs’ sub-folder, with the current date in the file name. We use the `str_glue()` function from **stringr** to do this, which will 'glue' together different character strings (written plainly) with R code (written in curly brackets). For instance if it is April 10th 2021, the file name from below will be “Report_2021-04-10.docx”. See the page on [Characters and strings] for more details.  

```{r, eval=F}
rmarkdown::render(
  input = "create_output.Rmd",
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx")) 
```

As this file renders, the RStudio console will show you the rendering progress up to 100%, and a final message to indicate that the rendering is complete. 


#### Option 2: Knit button within R markdown  

When you have the Rmd file open, press the 'Knit' icon/button at the top of the file. This is RStudio’s shortcut button for the `render` function of **rmarkdown**. This is only compatible with a self-contained R markdown, where all the needed components are within the file.  It will not work to pre-process data or graphs and save them to the environment - the knitting will ignore these 'external' objects. 

Just like knitting with a separate script, R Studio will you show the progress of the Rmd file. Except this time, this will appear within an ‘R Markdown’ tab in the same panel as your console. A complete document will automatically open when complete and this document will be saved in the same folder as your markdown, and with the same file name aside from the file extension. This is obviously not ideal for version control, as you will then rename the file yourself.


```{r out.width = "90%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/4_progress.png"))
```



<!-- ======================================================= -->
## Parameterised reports {  }

We can use parameterisation to make our report dynamic, such that it can be run for a specific date or place or with certain knitting options. We focus on the basics here but there is a good amount of detail online: https://bookdown.org/yihui/rmarkdown/parameterized-reports.html.

Using the Ebola linelist as an example, let’s say we want to run a standard surveillance report for each hospital each day. We show how one can do this using parameters.

**Important: it is possible to do this using simple R objects rather than using the parameter structure, which we explain at the end of this section (Parameterisation without the params object). **

### Using parameters {-}

#### Option 1: Declare parameters within the YAML {-}

Edit the YAML to specify that `hospital` and `date` are parameters that are subject to change each time the report is run.

```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: Central Hospital
---
```

#### Option 2: Use parameters within the .Rmd text and code {-}

These parameters are contained within a read-only list called `params`. To use these parameters in the code, you refer to them with the object name. Continuing the example, `params$hospital` will load “Central Hospital”. 

Note that the `params$date` example saves the date as a string. You will need to use a function such as `as.Date` to change this to a date class. 

#### Option 3: Run the Rmd file - basic {-}  

As mentioned above, to produce the output we can Knit from within the document by simply clicking the ‘Knit’ button, or we can use the `render()` function from a separate script. In this later case, you can specify the parameters to be used in that rendering to the `params = ` arguement of `render()`. 

Note than any parameter values provided here will *overwrite* the default values written within the YAML. We write the values in quotation marks as in this case they should be defined as character/string values.

```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = list(date = "2021-04-10", hospital  = "Central Hospital"))
```

#### Option 4: Run the Rmd file - using the graphical user interface {-}  

For a more interactive feel, we can also use the graphical user interface (GUI). To do this we can click the drop-down menu next to ‘knit’ and choose ‘knit with parameters’, or we can specify `params = "ask" within the `render()` function.  

```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = “ask”)
```

Either way a pop-up will appear allowing us to type in the date and hospital of interest. 

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUI.png"))
```

However, as this is subject to error and spelling mistakes, you may prefer to add restrictions to the parameters that can be selected. For instance we can introduce a drop-down so that only the possible hospitals can be selected. We do this again in the YAML:

```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: 
  label: “Town:”
  value: Central Hospital
  input: select
  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]
---
```

When knitting with the 'knit parameters' dropdown button or by running the render function, a window with a drop-down will then pop up:

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUIB.png"))
```

**5) Example** 

The following code uses basic parameters. We can see how the data is filtered to the specific hospital, and the titles refer to the correct hospital and date. We use the linelist_cleaned.rds file here, but it would be particularly appropriate if the linelist itself also had a datestamp within it to align with paramterised date. 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_Rmdexample.png"))
```

Knitting this produces the final output with the default font and layout.

```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_RmdexampleB.png"))
```

### Parameterisation without the params object

If rendering a Rmd file from a separate script, it is not actually essential to use the parameterisation options to run the Rmd file for subsets of data. 

For instance, we can simply specify the hospital and date as two objects before rendering the Rmd file. Within the Rmd file, we would not need to have a params section in the YAML, and we would refer to the `date` object rather than `params$date` and `hospital` rather than `params$hospital`. 

```md
hospital <- "Central Hospital"
date <- "2021-04-10"

rmarkdown::render(("create_output.Rmd"),  
                        output_file = paste0("outputs/Report_", Sys.Date(), ".docx")) 
```

This means you will not be able to “knit with parameters” and use the GUI, or to include knitting options within the parameters. However it allows for simpler code which may be sufficient.

<!-- ======================================================= -->

## Looping reports  {  }

We may want to run all options of a report at once, for instance a surveillance report for all hospital of interest within a single run, rather than specifying each hospital one by one. For this we need to work in a separate script outside the Rmd, and create a objects for today’s date and the list of hospital names to loop through.  

```md
hospital_list <- c(“Central Hospital”, 
                   “Military Hospital”, 
                   “Port Hospital”, “
                   St. Mark's Maternity Hospital (SMMH)”) 

refdate <- Sys.Date() # today’s date


```
We then feed this into the markdown using a loop, where we go through each item of the list. The letter `i` represents which item of the list is currently being iterated, such that `hospital_list[1]` would be “Central Hospital”. This information is also fed into the file name, such that the file name of the first iteration produced on April 10th 2021 would be “Report_Central Hospital2021-04-10.docx”, saved in the ‘output’ subfolder. In our examples, four files would be created for each day.

For instance, using the parameterisation discussed earlier: 

```md
for(i in 1:length(hospital_list)){
rmarkdown::render("surveillance_report.Rmd",
                  output_file = paste0("output/Report_", hospital_list[i], refdate, ".docx"),
                  params = list(date = refdate, hospital  = hospital_list[i]))
}       
```

The text and code within the Rmd itself will again refer to `params$date` and `params$hospital` to bring in the date and hospital name. The list items would not need to be referred to again within an interation. 

If not using this strict form of parameterisation but saving objects to the environment, as discussed at the end of the parameterisation section, the render function would look like this:

```md
for(i in 1:length(hospital_list)){
rmarkdown::render("surveillance_report.Rmd",
                  output_file = paste0("output/Report_", hospital_list[i], refdate, ".docx")
}       
```
The text within the markdown would then need to refer to `hospital_list[i]` and `refdate`. 

<!-- ======================================================= -->
## Formatting and aesthetics {  }

For easy aesthetics, create a template file which contains the desired formatting. You can create for instance an MS word or power point document which contains pages with the desired dimensions, watermarks, backgrounds, and fonts. 

### Word documents

To create a template, start a new word document (or use an existing output with  formatting the suits you), and edit fonts by defining the Styles. In Style,Headings 1, 2, and 3 refer to the various markdown header levels (`# Header 1`, `## Header 2` and `### Header 3` respectively). Right click on the style and click 'modify' to change the font formatting as well as the paragraph (e.g. you can introduce page breaks before certain styles which can help with spacing). Other aspects of the word document such as margins, page size, headers etc, can be changed like a usual word document you are working directly within. 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/7_template.png"))
```

### Powerpoint documents

As above, create a new slideset or use an existing powerpoint file with the desired formatting. For further editing, click on 'View' and 'Slide Master'. From here you can change the 'master' slide appearance by editing the text formatting in the text boxes, as well as the background/page dimensions for the overall page. 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/8_ppttemplate.png"))
```

Unfortunately, editing powerpoint files is slightly less flexible:

* A first level header (`# Header 1`) will automatically become the title of a new slide,
* A `## Header 2` text will not come up as a subtitle but text within the slide's main textbox (unless you find a way to maniuplate the Master view). 
* Outputted plots and tables will automatically go into new slides. You will need to combine them, for instance the the **patchwork** function to combine ggplots, so that they show up on the same page.

### Integrating templates into the YAML

Once a template is prepared, the detail of this can be added in the YAML of the Rmd underneath the 'output' line and underneath where the document type is specified (which goes to a separate line itself). Note `reference_doc` can be used for powerpoint slide templates.

It is easiest to save the template in the same folder as where the Rmd file is (as in the example below), or in a subfolder within. 

```yaml
---
title: Surveillance report
output: 
 word_document:
  reference_docx: "template.docx"
params:
 date: 2021-04-10
 hospital: Central Hospital
template:
 
---
```

### Formatting HTML files

HTML files do not use templates, but can have the styles configured within the YAML. HTMLs are interactive documents, and are particularly flexible. We cover some basic options here. 

* Table of contents: We can add a table of contents with `toc: true` below, and also specify that it remains viewable ("floats") as you scroll, with `toc_float: true`.

* Themes: We can refer to some pre-made themes, which come from a Bootswatch theme library. In the below example we use cerulean. Other options include: journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti. 

* Highlight: Configuring this changes the look of highlighted text (e.g. code within chunks that are shown). Supported styles include default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark, and textmate. 

Here is an example of how to integrate the above options into the YAML.

```yaml
---
title: "HTML example"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cerulean
    highlight: kate
    
---
```

Below are two examples of HTML outputs which both have floating tables of contents, but different theme and highlight styles selected:


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/9_html.png"))
```


<!-- ======================================================= -->
## Resources {  }

Further information can be found via:

* https://bookdown.org/yihui/rmarkdown/
* https://rmarkdown.rstudio.com/articles_intro.html

A good explainer of markdown vs knitr vs Rmarkdown is here: https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=3)
```

<!--chapter:end:new_pages/rmarkdown.Rmd-->


# Dashboards with R Markdown { }

THIS PAGE IS UNDER CONSTRUCTION

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_output.png"))
```

This page will cover the basic use of the **flexdashboard** package. This package allows you to easily format R Markdown output as a dashboard with panels and pages. The dashboard content can be text, static images or interactive graphics.  

Advantages of **flexdashboard**:  

* Very little User Interface (UI) or non-standard R coding required  
* Requires minimal up-front knowledge - an hour of practice and you can likely create a dashboard  
* The outputs can be emailed as an HTML report - no server required  
* You can combine **flexdashboard** with **shiny**, **ggplotly**, and other *htmlwidgets* to add interactivity to a static report dashboard  

Disadvantages of **flexdashboard**:  

* Interactivity can be constrained  
* Less customization less possible than if using Shiny directly  

Very comprehensive tutorials on using **flexdashboard** that informed this page can be found in the Resources section. Below we describe the core features and give an example of building a dashboard to explore an outbreak, using the case `linelist` data.  


## Preparation

### Load packages {-}  

In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary and loads it for use. You can also load packages with `library()` from **base** R. See the page on [R basics] for more information on R packages.  

```{r}
pacman::p_load(
  rio,            
  here,
  tidyverse,
  flexdashboard,   # dashboard versions of R Markdown reports
  shiny,           # interactive 
  plotly 
)
```

### Import data {-}

We import the dataset of cases from a simulated Ebola epidemic. If you want to download the data to follow step-by-step, see instructions in the [Download book and data] page. The dataset is imported using the `import()` function from the **rio** package. See the page on [Import and export] for various ways to import data.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.xlsx")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


## New R Markdown  

After you have installed the package, create a new R Markdown file by clicking through to *File > New file > R Markdown*. 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new1.png"))
```


In the window that opens, select "From Template" and select the "Flex Dashboard" template. You will then be prompted to name the document. In this page's example, we will name our R Markdown as "outbreak_dashboard.Rmd".  
  

```{r out.width = "100%", out.height="75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new2.png"))
```




## The script  

The script is a R Markdown script, and so has the same components and organization:  

### YAML {-}  

At the top, the "YAML" header must begin with three dashes `---` and must close with three dashes `---`. YAML parameters comes in `key:value` pairs. The placement of colons in YAML is important - the `key:value` pairs are separated by colons (not equals signs!). 

The YAML should begin with metadata for the document. The order of these primary YAML parameters (not indented) does not matter. For example:  

```yaml
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```

You can use R code in YAML values by putting it like in-line code (preceeded by `r` within backticks) but also within quotes (see above for Date).  

A required YAML parameter is `output: `, which specifies the type of file to be produced (e.g. `html_document`, `pdf_document`, `word_document`, or `powerpoint_presentation`). For **flexdashboard** this parameter value is a bit confusing - it must be set as `output:flexdashboard::flex_dashboard`. Not the single and double colons. It is often followed by an additional colon and indented sub-parameters.  

```yaml
title: "My dashboard"
author: "Me"
date: "`r Sys.Date()`"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
```

As shown above, indentations (2 spaces) are used for sub-parameters. In this case, do not forget to put an additional colon after the primary, like `key:value:`.  

If appropriate, logical values should be given in lowercase (`true`, `false`, `null`). If a colon is part of your value (e.g. in the title) put it the value in quotes. See the examples in sections below.  


### Narrative text {-}  

Outside of an R code "chunk", you can write narrative text as described in the page on [R Markdown reports]. You can italicize text by surrounding it with one asterisk (*), or bold by surrounding it with two asterisks (**). Recall that bullets and numbering schemes are sensitive newlines, indentation, and finishing a line with two spaces.  

You can also insert in-line R code into text as described in the [R Markdown reports] page, by surrounding the code with backticks and starting the command with r (see example scripts below).  

### Headings {-}  

Different heading levels are established with different numbers of hash symbols, as described in the [R Markdown reports] page. One hash symbol is a primary heading (in **flexdashboard** this represents a "page" of the dashboard). Two hash symbols are a second-level heading, and will reflect with a column or a row depending on your `orientation:` parameter (see details below). Third- and fourth-level headings can be made with successively more hash symbols.  

```md
# First-level heading (page)

## Second level heading (row or column)  

### Third-level heading (plot, chart, etc.)
```

### Code chunks {-}  

"Chunks" of R code work just like R scripts. They are created with three back-ticks and curly brackets with a lowercase r within. The chunk is closed with three backticks. See the examples below, or the page on [R Markdown reports] for more information.  





## Attributes 

As in a normal R markdown, you can specify attributes to apply to parts of your dashboard by including specifications with curly brackets `{ }` after a heading. For example, in a typical HTML R Markdown report you might organize content into tabs with `## My heading {.tabset}`. 

Attributes specific to **flexdashboard** include:  

* `{data-width = }` and `{data-height = }` set relative size of charts, columns, rows laid out in the same dimension (horizontal or vertical). Absolute sizes are adjusted to best fill the space on any display device thanks to the [flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes) engine.  
     * Height of charts also depends on whether you set the YAML parameter `vertical_layout: fill` or `vertical_layout: scroll`. If set to scroll, height will reflect the traditional `fig.height = ` option in the R code chunk.  
     * See complete size documentation at the [flexdashboard site](https://rmarkdown.rstudio.com/flexdashboard/using.html#sizing)  
     
* `{data-orientation=}` Set to either `rows` or `columns`. If your dashboard has multiple pages, add this attribute to each page to indicate orientation.  
* `{.hidden}` Use this to exclude a specific page from the navigation bar  
* `{data-navbar=}` Use this in a page-level heading to nest it within a navigation bar drop-down menu. Provide the name (in quotes) of the drop-down menu. See example below.  


## Layout {}  

Adjust the layout of your dashboard in the following ways:  

* Add pages, columns/rows, and charts with R Markdown headings (e.g. #, ##, or ###)  
* Adjust the YAML parameter `orientation:` to either `rows` or `columns`  
* Specify whether the layout fills the browser or allows scrolling  
* Add tabs to a particular section heading  


### Pages {-}  

First-level headings (#) in the R Markdown will represent "pages" of the dashboard. By default pages will appear in a navigation bar along the top of the dashboard.  

```{r, echo=F}
#knitr::include_graphics(here::here("images", "flexdashboard_pages_top_script.png"))
knitr::include_graphics(here::here("images", "flexdashboard_pages_top_view.png"))
```



You can group pages into a "menu" within the navigaton bar by adding the attribute `{data-navmenu=}` to the page heading. Be careful - do not include spaces around the equals sign otherwise it will not work!  

```{r, out.width = c('100%'), out.height = c('200%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_script.png"))
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_view.png"))
```

You can also transfer the navigation bar into a "sidebar" on the left side of the dashboard. 

```{r, out.width = c('100%'), echo=F}
#knitr::include_graphics(here::here("images", "flexdashboard_sidebar_script.png"))
knitr::include_graphics(here::here("images", "flexdashboard_sidebar_view.png"))
```

```md
---
title: "Outbreak dashboard"
date: "`r Sys.Date()`"
output: 
  flexdashboard::flex_dashboard
---

# Outbreak dashboard

This dashboard is produced for the leadership of Tenaya County.
It aims to advise them on the status of the COVID-19 pandemic. 

## Epidemic Curve

# Overview {.sidebar}

This is a sidebar that can be viewed from all pages.  

You could just have text here. 

Or if using **shiny** within **flexdashboard**, you might put your input controls here (e.g. via `selectInput()` or `sliderInput()`).  


# Health indicators {data-navmenu="Indicators"} 


# Economic indicators {data-navmenu="Indicators"}  


# Appleville {data-navmenu="Towns"}


# Orangetown {data-navmenu="Towns"}


# New Kiwi {data-navmenu="Towns"}

```



### Orientation {-}  

Set the `orientation:` yaml parameter to indicate how your R Markdown headings should be interpreted - as either `orientation: columns` or `orientation: rows`. 

Second-level headings (##) will be interpreted as new columns or rows based on this `orientation` setting.  

#### Column orientation {-} 

If you set `orientation: columns`, second-level headers will create new columns in the dashboard. The below dashboard has:  

* Code chunks at the beginning to load packages and data - these are not under any header and do not appear in the dashboard  
* Three columns:  
     * The first is named "Intro text" and has no panels. It does have R Markdown narrative text including an example of dynamic text that includes R code to display the  has no 

Below is the output  


```{r, echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_columns_script.png"))
knitr::include_graphics(here::here("images", "flexdashboard_columns_view.png"))
```


## Interactive

### Add plotly {-}

### Add shiny {-}  



htmlwidgets
shiny embedded
visNetwork


## Resources  

Excellent tutorials that informed this page can be found below. If you review these, most likely within an hour you can have your own dashboard.  

https://bookdown.org/yihui/rmarkdown/dashboards.html

https://rmarkdown.rstudio.com/flexdashboard/

https://rmarkdown.rstudio.com/flexdashboard/using.html

https://rmarkdown.rstudio.com/flexdashboard/examples.html
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=3)
```

<!--chapter:end:new_pages/flexdashboard.Rmd-->


# Phylogenetic trees {}  


<!-- ======================================================= -->

## Overview {}


**Phylogenetic trees** are used to visualize and describe the relatedness and evolution of organisms based on the sequence of their genetic code.  

They can be constructed from genetic sequences using distance-based methods (such as neighbor-joining method) or character-based methods (such as maximum likelihood and Bayesian Markov Chain Monte Carlo method). Next-generation sequencing (NGS) has become more affordable and is becoming more widely used in public health to describe pathogens causing infectious diseases. Portable sequencing devices decrease the turn around time and hold promises to make data available for the support of outbreak investigation in real-time. NGS data can be used to identify the origin or source of an outbreak strain and its propagation, as well as determine presence of antimicrobial resistance genes. To visualize the genetic relatedness between samples a phylogenetic tree is constructed.  

In this page we will learn how to use the **ggtree** package, which allows for combined visualization of phylogenetic trees with additional sample data in form of a dataframe. This will enable us to observe patterns and improve understanding of the outbreak dynamic.

```{r, phylogenetic_trees_overview_graph, out.width=c('80%'), fig.align='center', fig.show='hold', echo = FALSE}

pacman::p_load(here, ggplot2, dplyr, ape, ggtree, treeio, ggnewscale)

tree <- ape::read.tree(here::here("data", "phylo", "Shigella_tree.txt"))

sample_data <- read.csv(here::here("data","phylo", "sample_data_Shigella_tree.csv"),sep=",", na.strings=c("NA"), head = TRUE, stringsAsFactors=F)


ggtree(tree, layout="circular", branch.length='none') %<+% sample_data + # the %<+% is used to add your dataframe with sample data to the tree
  aes(color=I(Belgium))+ # color the branches according to a variable in your dataframe
  scale_color_manual(name = "Sample Origin", # name of your color scheme (will show up in the legend like this)
                    breaks = c("Yes", "No"), # the different options in your variable
                   labels = c("NRCSS Belgium", "Other"), # how you want the different options named in your legend, allows for formatting
                 values= c("blue", "black"), # the color you want to assign to the variable 
                 na.value = "black") + # color NA values in black as well
  new_scale_color()+ # allows to add an additional color scheme for another variable
     geom_tippoint(aes(color=Continent), size=1.5)+ # color the tip point by continent, you may change shape adding "shape = "
scale_color_brewer(name = "Continent",  # name of your color scheme (will show up in the legend like this)
                       palette="Set1", # we choose a set of colors coming with the brewer package
                   na.value="grey")+ # for the NA values we choose the color grey
  theme(legend.position= "bottom")

```

<!-- ======================================================= -->

## Preparation {}

### Load packages {-}  

This code chunk shows the loading of required packages. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary and loads it for use. You can also load packages with `library()` from **base** R. See the page on [R basics] for more information on R packages.  

```{r, phylogenetic_trees_loading_packages}
pacman::p_load(
  rio,             # import/export
  here,            # relative file paths
  tidyverse,       # general data management and visualization
  ape,             # to import and export phylogenetic files
  ggtree,          # to visualize phylogenetic files
  treeio,          # to visualize phylogenetic files
  ggnewscale)      # to vadd additional layers of color schemes

```

### Import data {-}  

There are several different formats in which a phylogenetic tree can be stored (eg. Newick, NEXUS, Phylip). A common one is the Newick file format (.nwk), which is the standard for representing trees in computer-readable form. This means an entire tree can be expressed in a string format such as  "((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59); ", listing all nodes and tips and their relationship (branch length) to each other.  

Note: It is important to understand that the phylogenetic tree file in itself does not contain sequencing data, but is merely the result of the genetic distances between the sequences. We therefore cannot extract sequencing data from a tree file.

First, we use the `read.tree()` function from **ape** package to import a Newick phylogenetic tree file in .txt format, and store it in a list object of class "phylo". We use the  `here()` function from the **here** package to specify the relative file path.

Note: In this case the newick tree is saved as a .txt file for easier handling and downloading from Github.
```{r, echo=F}
tree <- ape::read.tree(here::here("data", "phylo", "Shigella_tree.txt"))
```

We inspect our tree object and see it contains 299 tips (or samples) and 236 nodes.  

```{r}
tree
```

Second, we import a table stored as a .csv file with additional information for each sequenced sample, such as gender, country of origin and attributes for antimicrobial resistance, using the `import()` function from the **rio** package:

```{r, echo=F}
sample_data <- import(here("data", "phylo", "sample_data_Shigella_tree.csv"))
```

Below are the first 50 rows of the data:  

```{r message=FALSE, echo=F}
DT::datatable(head(sample_data,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Clean and inspect {-}  

We clean and inspect our data: In order to assign the correct sample data to the phylogenetic tree, the values in the column `Sample_ID` in the `sample_data` data frame need to match the `tip.labels` values in the `tree` file: 

We check the formatting of the `tip.labels` in the `tree` file by looking at the first 6 entries using with `head()` from **base** R.
```{r, phylogenetic_trees_inspect_sampledata}
head(tree$tip.label) 
```

We also make sure the first column in our `sample_data` data frame is `Sample_ID`. We look at the column names of our dataframe using  `colnames()` from **base** R.

```{r}
colnames(sample_data)   
```

We look at the `Sample_IDs` in the data frame to make sure the formatting is the same than in the `tip.label` (eg. letters are all capitals, no extra underscores `_` between letters and numbers, etc.)

```{r}
head(sample_data$Sample_ID) # we again inspect only the first 6 using head()
```

We can also compare if all samples are present in the `tree` file and vice versa by generating a logical vector of TRUE or FALSE where they do or do not match. These are not printed here, for simplicity.  

```{r, eval=F}
sample_data$Sample_ID %in% tree$tip.label

tree$tip.label %in% sample_data$Sample_ID
```

We can use these vectors to show any sample IDs that are not on the tree (there are none).  

```{r}
sample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]
```

Upon inspection we can see that the format of `Sample_ID` in the dataframe corresponds to the format of sample names at the `tip.labels`. These do not have to be sorted in the same order to be matched.

We are ready to go!




<!-- ======================================================= -->

## Simple tree visualization {}


### Different tree layouts {-}  

**ggtree** offers many different layout formats and some may be more suitable for your specific purpose than others. Below are a few demonstrations. For other options see this [online book](http://yulab-smu.top/treedata-book/chapter4.html).  

Here are some example tree layouts:
```{r, phylogenetic_trees_example_formats, out.width=c('50%'), fig.show='hold'}

ggtree(tree)                                            # simple linear tree
ggtree(tree,  branch.length = "none")                   # simple linear tree with all tips aligned
ggtree(tree, layout="circular")                         # simple circular tree
ggtree(tree, layout="circular", branch.length = "none") # simple circular tree with all tips aligned

```

### Simple tree plus sample data {-}  

The **%<+%** operator is used to connect the `sample_data` data frame to the `tree` file.
The most easy annotation of your tree is the addition of the sample names at the tips, as well as coloring of tip points and if desired the branches:

Here is an example of a circular tree: 
```{r, phylogenetic_trees_adding_sampledata, fig.align='center', warning=F, message=F}

ggtree(tree, layout = "circular", branch.length = 'none') %<+% sample_data + # %<+% adds dataframe with sample data to tree
  aes(color = I(Belgium))+                       # color the branches according to a variable in your dataframe
  scale_color_manual(
    name = "Sample Origin",                      # name of your color scheme (will show up in the legend like this)
    breaks = c("Yes", "No"),                     # the different options in your variable
    labels = c("NRCSS Belgium", "Other"),        # how you want the different options named in your legend, allows for formatting
    values = c("blue", "black"),                  # the color you want to assign to the variable 
    na.value = "black") +                        # color NA values in black as well
  new_scale_color()+                             # allows to add an additional color scheme for another variable
    geom_tippoint(
      mapping = aes(color = Continent),          # tip color by continent. You may change shape adding "shape = "
      size = 1.5)+                               # define the size of the point at the tip
  scale_color_brewer(
    name = "Continent",                    # name of your color scheme (will show up in the legend like this)
    palette = "Set1",                      # we choose a set of colors coming with the brewer package
    na.value = "grey") +                    # for the NA values we choose the color grey
  geom_tiplab(                             # adds name of sample to tip of its branch 
    color = 'black',                       # (add as many text lines as you wish with + , but you may need to adjust offset value to place them next to each other)
    offset = 1,
    size = 1,
    geom = "text",
    align = TRUE)+    
  ggtitle("Phylogenetic tree of Shigella sonnei")+       # title of your graph
  theme(
    axis.title.x = element_blank(), # removes x-axis title
    axis.title.y = element_blank(), # removes y-axis title
    legend.title = element_text(    # defines font size and format of the legend title
      face = "bold",
      size = 12),   
    legend.text=element_text(       # defines font size and format of the legend text
      face = "bold",
      size = 10),  
    plot.title = element_text(      # defines font size and format of the plot title
      size = 12,
      face = "bold"),  
    legend.position = "bottom",     # defines placement of the legend
    legend.box = "vertical",        # defines placement of the legend
    legend.margin = margin())   
```

You can export your tree plot with `ggsave()` as you would any other ggplot object. Written this way, `ggsave()` saves the last image produced to the file path you specify. Remember that you can use `here()` and relative file paths to easily save in subfolders, etc.  

```{r, eval=F}
ggsave("example_tree_circular_1.png", width = 12, height = 14)

```


<!-- ======================================================= -->

## Tree manipulation {}

Sometimes you may have a very large phylogenetic tree and you are only interested in one part of the tree. For example, if you produced a tree including historical or international samples to get a large overview of where your dataset might fit in the bigger picture. But then to look closer at your data you want to inspect only that portion of the bigger tree.

Since the phylogenetic tree file is just the output of sequencing data analysis, we can not manipulate the order of the nodes and branches in the file itself. These have already been determined in previous analysis from the raw NGS data. We are able though to zoom into parts, hide parts and even subset part of the tree. 

### Zoom in {-}  

If you don't want to "cut" your tree, but only inspect part of it more closely you can zoom in to view a specific part.

First, we plot the entire tree in linear format and add numeric labels to each node in the tree.
```{r, phylogenetic_trees_zoom_in, out.width=c('50%'), fig.show='hold', fig.align='center'}

p <- ggtree(tree,) %<+% sample_data +
  geom_tiplab(size = 1.5) +                # labels the tips of all branches with the sample name in the tree file
  geom_text2(
    mapping = aes(subset = !isTip,
                  label = node),
    size = 5,
    color = "darkred",
    hjust = 1,
    vjust = 1)                            # labels all the nodes in the tree

p  # print

```

To zoom in to one particular branch (sticking out to the right), use `viewClade()` on the ggtree object `p` and provide the node number to get a closer look:
```{r phylogenetic_trees_zoom_in_452, out.width=c('50%'), fig.show='hold', fig.align='center'}

viewClade(p, node = 452)

```

### Collapsing branches {-} 

However, we may want to ignore this branch and can collapse it at that same node (node nr. 452) using `collapse()`. This tree is defined as `p_collapsed`. 

```{r phylogenetic_trees_collapse_452, out.width=c('50%'), fig.show='hold', fig.align='center'}

p_collapsed <- collapse(p, node = 452)
p_collapsed
```

For clarity, when we print `p_collapsed`, we add a `geom_point2()` (a blue diamond) at the node of the collapsed branch.  
```{r}
p_collapsed + 
geom_point2(aes(subset = (node == 452)),  # we assign a symbol to the collapsed node
            size = 5,                     # define the size of the symbol
            shape = 23,                   # define the shape of the symbol
            fill = "steelblue")           # define the color of the symbol
```

### Subsetting a tree {-} 

If we want to make a more permanent change and create a new, reduced tree to work with we can subset part of it with `tree_subset()`. Then you can save it as new newick tree file or .txt file. 

First, we inspect the tree nodes and tip labels in order to decide what to subset.  

```{r, phylogenetic_trees_subsetting, out.width=c('50%'), fig.show='hold', fig.align='center'}
ggtree(
  tree,
  branch.length = 'none',
  layout = 'circular') %<+% sample_data +               # we add the asmple data using the %<+% operator
  geom_tiplab(size = 1)+                                # label tips of all branches with sample name in tree file
  geom_text2(
    mapping = aes(subset = !isTip, label = node),
    size = 3,
    color = "darkred") +                                # labels all the nodes in the tree
 theme(
   legend.position = "none",                            # removes the legend all together
   axis.title.x = element_blank(),
   axis.title.y = element_blank(),
   plot.title = element_text(size = 12, face="bold"))
```

Now, say we have decided to subset the tree at node 528 (keep only tips within this branch after node 528) and we save it as a new `sub_tree1` object:

```{r}
sub_tree1 <- tree_subset(
  tree,
  node = 528)                                            # we subset the tree at node 528
```

Lets have a look at the subset tree 1:

```{r}
ggtree(sub_tree1) +
  geom_tiplab(size = 3) +
  ggtitle("Subset tree 1")
```

You can also subset based on one particular sample, specifying how many nodes "backwards" you want to include. Let's subset the same part of the tree based on a sample, in this case S17BD07692, going back 9 nodes and we save it as a new `sub_tree2` object:

```{r}
sub_tree2 <- tree_subset(
  tree,
  "S17BD07692",
  levels_back = 9) # levels back defines how many nodes backwards from the sample tip you want to go
```

Lets have a look at the subset tree 2:

```{r}
ggtree(sub_tree2) +
  geom_tiplab(size =3)  +
  ggtitle("Subset tree 2")

```

You can also save your new tree either as a Newick type or even a text file using the `write.tree()` function from **ape** package:

```{r, eval=F, phylogenetic_trees_write_tree}
# to save in .nwk format
ape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')

# to save in .txt format
ape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')

```

### Rotating nodes in a tree {-} 


As mentioned before we cannot change the order of tips or nodes in the tree, as this is based on their genetic relatedness and is not subject to visual manipulation. But we can rote branches around nodes if that eases our visualization.

First, we plot our new subset tree 2 with node labels to choose the node we want to manipulate and store it an a ggtree plot object `p`.

```{r, phylogenetic_trees_rotating_1, out.width=c('50%'), fig.show='hold', fig.align='center'}

p <- ggtree(sub_tree2) +  
  geom_tiplab(size = 4) +
  geom_text2(aes(subset=!isTip, label=node), # labels all the nodes in the tree
             size = 5,
             color = "darkred", 
             hjust = 1, 
             vjust = 1) 
p
```

We can then manipulate nodes by applying **ggtree::rotate()** or **ggtree::flip()**: 
Note: to illustrate which nodes we are manipulating we first apply the **geom_hilight()** function from **ggtree** to highlight the samples in the nodes we are interested in and store that ggtree plot object in a new object `p1`.

```{r, phylogenetic_trees_rotating_2, eval=F, out.width=c('50%'), fig.show='hold', fig.align='center'}

p1 <- p + geom_hilight(  # highlights node 39 in blue, "extend =" allows us to define the length of the color block
  node = 39,
  fill = "steelblue",
  extend = 0.0017) +  
geom_hilight(            # highlights the node 37 in yellow
  node = 37,
  fill = "yellow",
  extend = 0.0017) +               
ggtitle("Original tree")
p1
```

Now we can rotate node 37 in object `p1` so that the samples on node 38 move to the top. We store the rotated tree in a new object `p2`.
```{r}
p2 <- rotate(p1, 37) + 
      ggtitle("Rotated Node 37")
p2
```

Or we can use the flip command to rotate node 36 in object `p1` and switch node 37 to the top and node 39 to the bottom. We store the flipped tree in a new object `p3`.
```{r}

p3 <-  flip(p1, 39, 37) +
      ggtitle("Rotated Node 36")
p3

```

### Example subtree with sample data annotation {-} 

Lets say we are investigating the cluster of cases with clonal expansion which occurred in 2017 and 2018 at node 39 in our sub-tree. We add the year of strain isolation as well as travel history and color by country to see origin of other closely related strains:

```{r, phylogenetic_trees_inspect_subset_example, out.width=c('80%'), fig.show='hold', fig.align='center'}

ggtree(sub_tree2) %<+% sample_data +     # we use th %<+% operator to link to the sample_data
  geom_tiplab(                          # labels the tips of all branches with the sample name in the tree file
    size = 2.5,
    offset = 0.001,
    align = TRUE) + 
  theme_tree2()+
  xlim(0, 0.015)+                       # set the x-axis limits of our tree
  geom_tippoint(aes(color=Country),     # color the tip point by continent
                size = 1.5)+ 
  scale_color_brewer(
    name = "Country", 
    palette = "Set1", 
    na.value = "grey")+
  geom_tiplab(                          # add isolation year as a text label at the tips
    aes(label = Year),
    color = 'blue',
    offset = 0.0045,
    size = 3,
    linetype = "blank" ,
    geom = "text",
    align = TRUE)+ 
  geom_tiplab(                          # add travel history as a text label at the tips, in red color
    aes(label = Travel_history),
    color = 'red',
    offset = 0.006,
    size = 3,
    linetype = "blank",
    geom = "text",
    align = TRUE)+ 
  ggtitle("Phylogenetic tree of Belgian S. sonnei strains with travel history")+  # add plot title
  xlab("genetic distance (0.001 = 4 nucleotides difference)")+                    # add a label to the x-axis 
  theme(
    axis.title.x = element_text(size = 10),
    axis.title.y = element_blank(),
    legend.title = element_text(face = "bold", size = 12),
    legend.text = element_text(face = "bold", size = 10),
    plot.title = element_text(size = 12, face = "bold"))

```

Our observation points towards an import event of strains from Asia, which then circulated in Belgium over the years and seem to have caused our latest outbreak.

<!-- ======================================================= -->

## More complex trees: adding heatmaps of sample data {-}


We can add more complex information, such as categorical presence of antimicrobial resistance genes and numeric values for actually measured resistance to antimicrobials in form of a heatmap using the **ggtree::gheatmap()** function.

First we need to plot our tree (this can be either linear or circular) and store it in a new ggtree plot object `p`: We will use the sub_tree from part 3.)
```{r, phylogenetic_trees_sampledata_heatmap, out.width=c('60%'), fig.align='center', fig.show='hold'}

p <- ggtree(sub_tree2, branch.length='none', layout='circular') %<+% sample_data +
  geom_tiplab(size =3) + 
 theme(
   legend.position = "none",
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(
      size = 12,
      face = "bold",
      hjust = 0.5,
      vjust = -15))
p

```

Second, we prepare our data. To visualize different variables with new color schemes, we subset our dataframe to the desired variable. It is important to add the `Sample_ID` as rownames otherwise it cannot match the data to the tree `tip.labels`:

In our example we want to look at gender and mutations that could confer resistance to Ciprofloxacin, an important first line antibiotic used to treat Shigella infections.

We create a dataframe for gender: 
```{r, phylogenetic_trees_sampledata_heatmap_data}
gender <- data.frame("gender" = sample_data[,c("Gender")])
rownames(gender) <- sample_data$Sample_ID
```

We create a dataframe for mutations in the gyrA gene, which confer Ciprofloxacin resistance:
```{r}
cipR <- data.frame("cipR" = sample_data[,c("gyrA_mutations")])
rownames(cipR) <- sample_data$Sample_ID

```
We create a dataframe for the measured minimum inhibitory concentration (MIC) for Ciprofloxacin from the laboratory:
```{r}
MIC_Cip <- data.frame("mic_cip" = sample_data[,c("MIC_CIP")])
rownames(MIC_Cip) <- sample_data$Sample_ID
```

We create a first plot adding a binary heatmap for gender to the phylogenetic tree and storing it in a new ggtree plot object `h1`:
```{r, phylogenetic_trees_sampledata_heatmap_gender, out.width=c('70%'), fig.show='hold', fig.align='center'}

h1 <-  gheatmap(p, gender,                                 # we add a heatmap layer of the gender dataframe to our tree plot
                offset = 10,                               # offset shifts the heatmap to the right,
                width = 0.10,                              # width defines the width of the heatmap column,
                color = NULL,                              # color defines the boarder of the heatmap columns
         colnames = FALSE) +                               # hides column names for the heatmap
  scale_fill_manual(name = "Gender",                       # define the coloring scheme and legend for gender
                    values = c("#00d1b1", "purple"),
                    breaks = c("Male", "Female"),
                    labels = c("Male", "Female")) +
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h1

```

Then we add information on mutations in the gyrA gene, which confer resistance to Ciprofloxacin:

Note: The presence of chromosomal point mutations in WGS data was prior determined using the PointFinder tool developed by Zankari et al. (see reference in the additional references section)

First, we assign a new color scheme to our existing plot object `h1` and store it in a now object `h2`. This enables us to define and change the colors for our second variable in the heatmap.
```{r}
h2 <- h1 + new_scale_fill() 
```

Then we add the second heatmap layer to `h2` and store the combined plots in a new object `h3`:

```{r, phylogenetic_trees_sampledata_heatmap_cip_genes, out.width=c('80%'), fig.show='hold', fig.align='center'}

h3 <- gheatmap(h2, cipR,         # adds the second row of heatmap describing Ciprofloxacin resistance mutations
               offset = 12, 
               width = 0.10, 
               colnames = FALSE) +
  scale_fill_manual(name = "Ciprofloxacin resistance \n conferring mutation",
                    values = c("#fe9698","#ea0c92"),
                    breaks = c( "gyrA D87Y", "gyrA S83L"),
                    labels = c( "gyrA d87y", "gyrA s83l")) +
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())+
  guides(fill = guide_legend(nrow = 2,byrow = TRUE))
h3
```

We repeat the above process, by first adding a new color scale layer to our existing object `h3`, and then adding the continuous data on the minimum inhibitory concentration (MIC) of Ciprofloxacin for each strain to the resulting object `h4` to produce the final object `h5`:
```{r, phylogenetic_trees_sampledata_heatmap_cip_MIC, out.width=c('90%'), fig.show='hold', fig.align='center'}
# First we add the new coloring scheme:
h4 <- h3 + new_scale_fill()

# then we combine the two into a new plot:
h5 <- gheatmap(h4, MIC_Cip,  
               offset = 14, 
               width = 0.10,
                colnames = FALSE)+
  scale_fill_continuous(name = "MIC for Ciprofloxacin",  # here we define a gradient color scheme for the continuous variable of MIC
                      low = "yellow", high = "red",
                      breaks = c(0, 0.50, 1.00),
                      na.value = "white") +
   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h5

```

We can do the same exercise for a linear tree:
```{r, phylogenetic_trees_sampledata_heatmap_linear_1, out.width=c('80%'), fig.show='hold', fig.align='center'}

p <- ggtree(sub_tree2) %<+% sample_data +
  geom_tiplab(size = 3) + # labels the tips
  theme_tree2()+
  xlab("genetic distance (0.001 = 4 nucleotides difference)")+
  xlim(0, 0.015)+
 theme(legend.position = "none",
      axis.title.y = element_blank(),
      plot.title = element_text(size = 12, 
                                face = "bold",
                                hjust = 0.5,
                                vjust = -15))
p
```

# First we add gender:
```{r, phylogenetic_trees_sampledata_heatmap_linear_2, out.width=c('80%'), fig.show='hold', fig.align='center'}

h1 <-  gheatmap(p, gender, 
                offset = 0.003,
                width = 0.1, 
                color="black", 
         colnames = FALSE)+
  scale_fill_manual(name = "Gender",
                    values = c("#00d1b1", "purple"),
                    breaks = c("Male", "Female"),
                    labels = c("Male", "Female"))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h1
```
Then we add Ciprofloxacin resistance mutations after adding another color scheme layer:
```{r, phylogenetic_trees_sampledata_heatmap_linear_3, out.width=c('80%'), fig.show='hold', fig.align='center'}

h2 <- h1 + new_scale_fill()
h3 <- gheatmap(h2, cipR,   
               offset = 0.004, 
               width = 0.1,
               color = "black",
                colnames = FALSE)+
  scale_fill_manual(name = "Ciprofloxacin resistance \n conferring mutation",
                    values = c("#fe9698","#ea0c92"),
                    breaks = c( "gyrA D87Y", "gyrA S83L"),
                    labels = c( "gyrA d87y", "gyrA s83l"))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())+
  guides(fill = guide_legend(nrow = 2,byrow = TRUE))
 h3
```

Then we add the minimum inhibitory concentration determined by the laboratory (MIC):
```{r, phylogenetic_trees_sampledata_heatmap_linear_4, out.width=c('80%'), fig.show='hold', fig.align='center'}

h4 <- h3 + new_scale_fill()
h5 <- gheatmap(h4, MIC_Cip, 
               offset = 0.005,  
               width = 0.1,
               color = "black", 
                colnames = FALSE)+
  scale_fill_continuous(name = "MIC for Ciprofloxacin",
                      low = "yellow", high = "red",
                      breaks = c(0,0.50,1.00),
                      na.value = "white")+
   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        legend.box = "horizontal", legend.margin = margin())+
  guides(shape = guide_legend(override.aes = list(size = 2)))
h5

```


<!-- ======================================================= -->
## Resources {}

http://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors
https://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html
https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html
https://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.html

Ea Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: a novel web tool for WGS-based detection of antimicrobial resistance associated with chromosomal point mutations in bacterial pathogens, Journal of Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=3)
```

<!--chapter:end:new_pages/phylogenetic_trees.Rmd-->

