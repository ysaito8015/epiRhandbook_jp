---
knit: "bookdown::render_book"
title: "The Epidemiologist R Handbook"
author: "the handbook team"
description: "This is a R reference manual for applied epidemiologists and public health practitioners."  
date: "`r Sys.Date()`"
#url: 'https://github.com/nsbatra/Epi_R_handbook'
github-repo: nsbatra/Epi_R_handbook
#twitter-handle: 
#cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
---


# The Epidemiologist R Handbook {-}

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "R Handbook Logo.png"))
```



<span style="color: red;">**THIS IS A DRAFT**.</span>

<span style="color: orange;">**IF YOU ARE REVIEWING THIS BOOK, PLEASE PROVIDE FEEDBACK FOR EACH PAGE AT THIS [LINK](https://forms.gle/4RNdRRLGx67xW9yq9)**</span>


<!-- ======================================================= -->
## About this handbook {-}

<span style="color: brown;">**This is a free open-access R reference manual for applied epidemiologists and public health practitioners.**</span>

**This book strives to:**  

* Serve as a quick reference manual - not as a textbook or comprehensive R training  
* Address common epidemiological problems via task-centered examples  
* Be accessible in settings with low internet-connectivity via this (**[downloadable version**](https://github.com/nsbatra/Epi_R_handbook/tree/master/offline_long))  

**What gaps does this book address?**  

* Many epidemiologists are transitioning to R from SAS, STATA, SPSS, Excel, or other software  
* Let's avoid hours of online searching and have a repository for best-practice code for the common epi user  
* Epidemiologists sometimes work in low internet-connectivity environments and have limited support  

**How is this different than other R books?**  

* It is written by epidemiologists, for epidemiologists - leveraging experience in local, national, academic, and emergency settings  
* It provides examples of epidemic curves, transmission chains, epidemic modeling and projections, age and sex pyramids and standardization, record matching, outbreak detection, survey analysis, causal diagrams, survival analysis, GIS basics, phylogenetic trees, automated reports, etc...  



<!-- ======================================================= -->
## How to read this handbook {-} 

* Search via the search box above the Table of Contents 
* Click the "copy" icons to copy code  
* See the "Resources" section of each page for further resources  


<!-- ======================================================= -->
## Edit or contribute {-}

We welcome your feedback or comments at this survey LINK.

If you want to directly contribute or modify content, please post an issue or submit a pull request at this [github repository](https://github.com/nsbatra/R_epi_handbook).  




<!-- ======================================================= -->
## Acknowledgements {-}  


### Contributors {-}  

This book has been conceived, written, and edited by a collaboration of epidemiologists from around the world who draw upon experiences with a constellation of organizations including local/state/provincial/national health departments and ministries, the World Health Organization (WHO), MSF (Medecins sans frontiers / Doctors without Borders), hospital systems, and academic institutions.

**Editor-in-Chief:** Neale Batra 

**Core team:** Neale Batra, Alex Spina, Amrish Baidjoe, Henry Laurenson-Schafer, Finlay Campbell, Pat Keating  

**Authors** *(in order of contributions)*: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Daniel Molling, Liza Coyer, Jonny Polonski, Yurie Izawa, Sara Hollis, Isha Berry  

**Reviewers:** ...(list)...  

**Advisers**  ...(list)...  


### Funding and programmatic support {-}  

The handbook received funding via a COVID-19 emergency capacity-building grant from Training Programs in Epidemiology and Public Health Interventions Network ([TEPHINET](https://www.tephinet.org/)).  

Programmatic support was provided by the EPIET Alumni Network ([EAN](https://epietalumni.net/)).  



### Inspiration {-}  

The multitude of tutorials and vignettes that provided foundational knowledge for development of handbook content are credited within their respective pages.  

More generally, the following sources provided inspiration and laid the groundwork for this handbook:  
[The "R4Epis" project](https://r4epis.netlify.app/) (a collaboration between MSF and RECON)  
[R Epidemics Consortium (RECON)](https://www.repidemicsconsortium.org/)  
[R for Data Science book (R4DS)](https://r4ds.had.co.nz/)  
[bookdown: Authoring Books and Technical Documents with R Markdown](https://bookdown.org/yihui/bookdown/)  
[Netlify](https://www.netlify.com) hosts this website  

### Image credits {-}  


Logo (US CDC Public Health Image Library):  
[2013 Yemen looking for mosquito breeding sites](https://phil.cdc.gov/Details.aspx?pid=19623)  
[Ebola virus](https://phil.cdc.gov/Details.aspx?pid=23186)  
[Survey in Rajasthan](https://phil.cdc.gov/Details.aspx?pid=19838)  



### License and Terms of Use {-}  

This handbook is **not** an approved product of any specific organization.  

Although we strive for accuracy, we provide no guarantee of the content in this book.  

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:index.Rmd-->

# (PART) Preview pages {-}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/cat_preview.Rmd-->


# Iteration and loops { }  







<!-- ======================================================= -->
## Preparation {  }


**Load packages**  

```{r}
pacman::p_load(
     rio,
     here, 
     purrr,
     tidyverse
)
```


**Load data**  

```{r, echo=F, message=F}
linelist <- import(here("data", "linelist_cleaned.rds"))
```

```{r eval=F}
linelist <- rio::import("linelist_cleaned.xlsx")
```

The first 50 rows are displayed:  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```




<!-- ======================================================= -->
## *for loops* {  }

As an epidemiologist, it is a common need to repeat analyses on sub-groups (e.g. jurisdictions or sub-populations). Iterating with a *for loop* is one method to automate this process.

A *for loop* has three core parts:  

1) The **container** for the results  
2) The **sequence** of items to iterate through  
3) The **operations** to conduct per item in the sequence  

The basic syntax is: `for (item in sequence) {do operations using item}`. Note the parentheses and the curly brackets. The results could be printed to console, or stored in the container.   


### Container {-}

It is most efficient to create the container for the results before even beginning the *for loop*. In practice, this means creating an empty vector, data frame, or list. These can be created with the functions `vector()` for vectors or lists, or `data.frame()` for a data frame. 

**Vector example**  
Say you want to store the median delay-to-admission for each hospital in a new vector. Use `vector()` and specify the class as either "double" (to hold numbers), "character", or "logical". In this case we would use "double" and set the length to be the number of unique hospitals in the dataset (6).  

```{r}
delays <- vector(mode = "double",
                 length = length(unique(linelist$hospital))) # this is the number of unique hospitals in the dataset
```

**Data frame example**  

```{r, eval=F}
delays <- data.frame(matrix(ncol = 2, nrow = 3))
```

```{r, out.height='300%', fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "loops_empty_dataframe.png"))
```

**List example**  

Say you want to store some plots created by a *for loop* in a list. You actually initialize the container using the same `vector()` command as above, but with `mode = "list"`.  

```{r, eval=F}
plots <- vector(mode = "list", length = 16)
```

### Sequence {-}  

This is the "for" part of a *for loop* - the operations will run for each item in the sequence. The sequence can be a series of character names (e.g. of jurisdictions, diseases, etc) or it can be a series of numbers (e.g. 1,2,3,4,5). Each has their own utilities described below.  

**Sequence of character items**  

```{r}
# make vector of the hospital names
hospital_names <- unique(linelist$hospital)
hospital_names # print
```

```{r, eval=F}
# 'for loop'
for (hosp in hospital_names){       # sequence of cha
  
  # OPERATIONS HERE
  
}
```

**Sequence of names**  

This is a variation on the above which can be used to loop through the columns in a dataframe, or elements in a list. Below, the sequence is the names (column names) of `linelist`. Inside the *for loop* there is an *if* condition - if the column is numeric then the mean of the column is printed to the console. If the column is not class Numeric then another statement is printed to the console.  

Of note - whenever referencing the column itself (e.g. within `mean()`) *do not just write "col"! `col` is just the character column name! To refer to the entire column you use the column name as an *index* on `linelist` via `linelist[[col]]`.  

```{r}
for (col in names(linelist)){ 
  
  # if column is class Numeric, print the mean value
  if(is.numeric(linelist[[col]])) {
    print(mean(linelist[[col]], na.rm=T))     # don't forget to index with [[col]]
    } else {        
    print("Column not numeric")            # if column is not numeric, print this
  }
  
}
```

**Sequence of numbers**  

Use this approach if you plan to do more complicated operations or to store the results of the *for loop*. This is achieved by having a the loop iterate over a numeric sequence. You can then use that number *indexing* other objects in the operations code.  

Say for example you want to loop over every row in your data frame. Your items would be numeric rownumbers. The sequence could be explained as "for every item in a sequence of numbers from 1 to the total number of rows in my data frame, do X".  

Whew, that was a mouthful of words! Here is what it looks like in code: `for (i in seq_len(nrow(linelist)) {}` where `i` represents the itemans `seq_len()` produces a sequence of consecutive numbers from 1 to the number of rows in linelist.  

If using this on a named vector (not a data frame) use `seq_along()`, like `for (i in seq_along(hospital_names) {}`.  

```{r}
seq_along(hospital_names)  # on a named vector
```

The first iteration of the loop, `i` would be 1. For the second iteration, `i` would be 2. Etc.  




### Operations  {-}  

This is code within the *for loop*. You want this to run for each item in the *sequence*. Therefore, be careful that every part of your code that changes by the item is correctly coded such that it changes! Remember to use [[]] for indexing. For example, 

Below, we use `seq_len()` on the linelist. The gender and age of each row is pasted together and stored the container character vector `cases_demographics`.  

```{r, eval=F}
# create container to store results - a character vector
cases_demographics <- vector(mode = "character", length = nrow(linelist))

# the for loop
for (i in seq_len(nrow(linelist))){
  
  # OPERATIONS
  # extract values from linelist for i using indexing
  row_gender  <- linelist$gender[[i]]
  row_age     <- linelist$age_years[[i]]    # don't forget to index!
  
  # store the gender-age in container
  cases_demographics[i] <- str_c(row_gender, row_age, sep = ", ") 

}  # end for loop

# display first 10 rows of container
head(cases_demographics, 10)
```


### Printing {-}  

Note that to print from within a *for loop* you will likely need to explicitly wrap with the function `print()`.  

In this example below, the sequence is an explicit character vector, which is used to subset the linelist by hospital.The results are not stored in a container, but rather print to console with the `print()` function.    

```{r}
for (hosp in hospital_names){ 
  hospital_cases <- linelist %>% filter(hospital == hosp)
  print(nrow(hospital_cases))
}
```


### Testing your for loop {-}

To test your loop, you can make a temporarily assignment of the item, such as `i <- 10` or `hosp <- "Central Hospital"` and run your operations code to see if the expected results are produced.  




### Looping plots {-}

To put all three components together (container, sequence, and operations) let's try to plot an epicurve for each hospital (see page on [Epidemic curves].  

Of course, we can make an epicurve of all the cases using the **incidence2** package as below:  

```{r, warning=F, message=F}
# create 'incidence' object
outbreak <- incidence2::incidence(   
     x = linelist,                   # dataframe - complete linelist
     date_index = date_onset,        # date column
     interval = "week",              # aggregate counts weekly
     groups = gender,                # group values by gender
     na_as_group = TRUE)             # missing gender is own group

# plot epi curve
plot(outbreak,                       # name of incidence object
     fill = "gender",                # color bars by gender
     color = "black",                # outline color of bars
     title = "Outbreak of ALL cases" # title
     )
```

To produce a separate plot for each hospital's cases, we can put this epicurve code within a *for loop*. 

First, we save a named vector of the unique hospital names, `hospital_names`. The *for loop* will run once for each of these names (`for (hosp in hospital_names)`). Each iteration of the *for loop*, the current hospital name from the vector will be represented as "hosp" for use within the loop.  

Within the loop, you can write R code as normal, but use the item (`hosp` in this case) knowing that its value will be changing. Within this loop:  

* A `filter()` is applied to `linelist`, such that column `hospital` must equal the current value of `hosp`  
* The incidence object is created on the filtered linelist  
* The plot for the current hospital is created, with an auto-adjusting title  
* The plot for the current hospital is temporarily saved and then printed  
* The loop then moves onward to repeat with the next hospital in `hospital_names`  

```{r, out.width='50%', message = F}
# make vector of the hospital names
hospital_names <- unique(linelist$hospital)

# for each name ("hosp") in hospital_names, create and print the epi curve
for (hosp in hospital_names) {
     
     # create incidence object specific to the current hospital
     outbreak_hosp <- incidence2::incidence(
                    x = linelist %>% filter(hospital == hosp),   # linelist is filtered to the current hospital
                    date_index = date_onset,
                    interval = "week", 
                    groups = gender,
                    na_as_group = TRUE
     )
     
     # Create and save the plot. Title automatically adjusts to the current hospital
     plot_hosp <- plot(outbreak_hosp,
                       fill = "gender",
                       color = "black",
                       title = stringr::str_glue("Epidemic of cases admitted to {hosp}")
                       )
     
     # print the plot for the current hospital
     print(plot_hosp)

} # end the for loop when it has been run for every hospital in hospital_names 
```



### Tracking progress of a loop {-} 

A loop with many iterations can run for many minutes or even hours. Thus, it can be helpful to print the progress to the R console. This code can be placed *within* the loop to print every 100th number.  

```{r, eval=F}
# loop with code to print progress every 100 iterations
for (row in 1:nrow(linelist)){

  # print progress
  if(row %% 100==0){    # The %% operator is the remainder
    print(row)

}
```







<!-- ======================================================= -->
## **purrr** { }

One approach to iterative operations is the **purrr** package. If you are using a *for loop*, you can probably do it with **purrr**! For example, applying a model to different datasets, producing plots or maps for various jurisdictions, or iterating data management tasks (across columns or subsets).  

Here is the **purrr** online [cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png)  

### Load packages {-}  

**purrr** is part of the **tidyverse**, so there is no need to install/load another package.  

```{r}
pacman::p_load(
  rio,            # import/export
  here,           # relative filepaths
  tidyverse,      # data mgmt and viz
  writexl,        # write Excel file with multiple sheets
  readxl          # import Excel with multiple sheets
  )
```


One core **purrr** function is `map()`, which "maps" (applies) a function to each input element. There are several variations on `map()` for specific use cases, as detailed below.  

The key arguments are: 

* `.x = ` this is the input - e.g. a vector, data frame, or list  
* `.f = ` this is a function to apply to each element of the input  

You will often encounter the syntax `.`, which is a placeholder for the primary input - it could be a vector in a dataframe, or an element in a list.  


### Mapping a function across columns  

Below, we `map()` the function `t.test()` across numeric columns, comparing genders. Recall from the page on [Descriptive analysis] that `t.test()` can take inputs in a formula format, such as NUMERIC_COLUMN ~ BINARY COLUMN. In this example, we do the following:    

* The numeric columns of interest are selected from `linelist`  
* The function `t.test()` is supplied as the `.f` function mapped to each numeric column (note tilde `~` in front)  
* Within the parentheses of `t.test()`:  
  * the `.` represents the current column being mapped  
  * the second `~` is part of the t-test equation  
  * the `linelist$gender` is the binary column for t-test comparison, not is a separate column not included in `select()` so that it is not included on the left side of the t.test equation.  
  
The result is a list of t-test results - one element for each numeric column. The first one is shown for demonstration purposes.   

```{r}
# Results are saved as a list
t.test_results <- linelist %>% 
  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # keep only the numeric columns to map across
  map(~t.test(. ~ linelist$gender))              # t.test function, with equation NUMERIC ~ CATEGORICAL

t.test_results[[1]] # show first result 
```

If you wanted the p-values only, you can append `$p.value` on to the `t.test()` output.  

```{r}
linelist %>% 
  select(age, wt_kg, ht_cm, ct_blood, temp) %>% 
  map(~t.test(. ~ linelist$gender)$p.value)
```



Remember that if you want to apply a function to only certain columns in a data frame, you can also use `mutate()` and `across()`, as explained in the [Grouping data] page. Below is an example of applying `as.character()` to only the "age" columns. Note the placement of the parentheses and commas.  

```{r, eval=F}
# convert columns with column name containing "age" to class Character
linelist <- linelist %>% 
  mutate(across(contains("age"), as.character))  
```




#### Custom functions {-}  

While `t.test()` was an existing function, you will often want to create your own function to provide to `map()`. One example may be to iteratively plot (as demonstrated in the *for loop* section).  

Let's say we want to create simple epicurves for each hospital. To do this using **purrr**, our `.f` function can be `ggplot()` and extensions with `+` as usual. The plots are stored in a list by `map()`. They can be extracted and plotted easily with the `ggarrange()` function from the **ggpubr** package ([documentation](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html).  


```{r, message = F, warning=F}

# load package for plotting elements from list
pacman::p_load(ggpubr)

# map across the vector of 6 hospital "names" (created earlier)
# use the ggplot function specified
# output is a list with 6 ggplots

my_plots <- map(.x = hospital_names,
             .f = ~ggplot(data = linelist %>% filter(hospital == .x))+
                    geom_histogram(aes(x = date_onset)) +
                    labs(title = .x)
)

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

If this code style looks too messy, you can achieve the same result by saving your specific `ggplot()` command as a custom user-defined function `make_epicurve())`. This function is then used within the `map()`. `.x` will be iteratively replaced by the hospital name, and used as `hosp_name` in the `make_epicurve()` function. See the page on [Writing functions].

```{r, eval=F}
make_epicurve <- function(hosp_name){
  
  ggplot(data = linelist %>% filter(hospital == hosp_name)) +
    geom_histogram(aes(x = date_onset)) +
    theme_classic()+
    labs(title = hosp_name)
  
}
```

```{r, eval=F}
# mapping
my_plots <- map(hospital_names, ~make_epicurve(.x))

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```



### Split datasets {-}  

#### Split dataset and export CSV files {-}  

Here is a more complex **purrr** `map()` example. Let's say that we want to create a separate linelist for each hospital and export each as a separate CSV file. This is a task that would be arduous if done copy-paste by hand in Excel, and involve a lot of code if each `filter()` and `export()` was a distinct command (imagine if we wanted to make a linelist for each hospital-gender!).  

Below, we do the following steps:  

Use `group_split()` (from **dplyr**) to split the `linelist` by hospital of admission - the output is a list with one "element" per hospital subset (in this case, each element is a dataframe)  

```{r}
linelist_split <- linelist %>% 
  group_split(hospital)
```

You can `View(linelsit_split)` and see that this list contains 6 dataframe each representing the cases from one hospital. 

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split.png"))
```

However, note that the dataframes in the list do not have names! This is standard behavior of `map()`, but we want each to have a name, and to use that name when saving the CSV file. So, we use `pull()` (from **purrr**) to extract the 'hospital` column from each data frame in the list. Then, to be safe, we convert the values to character and then use `unique()` to get the name for the dataset.  


```{r}
names(linelist_split) <- linelist_split %>%
  purrr::map(~pull(.,hospital)) %>% # Pull out Species variable
  purrr::map(~as.character(.)) %>% # Convert factor to character
  purrr::map(~unique(.))
```

We can now see that each of the list elements has a name. These names can be access via `names(linelist_split)`.  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split_named.png"))
```

```{r}
names(linelist_split)
```

Lastly, we take the vector of names (shown above) and will use `map()` to iterate through them, applying `export()` function on that element of the list `linelist_split` and saving the correct name. Here is how it works:  

* We begin with the vector of character names, passed to `map()`  
* The function is `export()` (**rio** package, see [Import and export] page), which needs a dataframe and a filepath to write to  
* The dataframe provided is the element of `linelist_split` being currently named as `map()` proceedes through `names(linelist_split)`  
  * For example, at "Military Hospital", then `linelist_split[[.]]` is actually `linelist_split[["Military Hospital"]]`, thus returning the second element of `linelist_split` - all the cases from that hospital.  
* The filepath provided is dynamic via use of `str_glue()` (see [Characters and strings] page):  
  * `here()` is used to get the base of the filepath and specify the "data" folder (note single quotes to not interrupt the `str_glue()` double quotes)  
  * Then a slash `/`, and then again the `.` which prints the current hospital name  
  * Finally the extension ".csv" which `export()` uses to create a CSV file  
  
```{r, eval=F, message = F, warning=F}
names(linelist_split) %>%
  map(~export(linelist_split[[.]], file= str_glue("{here('data')}/{.}.csv")))
```
Now you can see that each file is saved in the "data" folder of the R Project "Epi_R_handbook"!  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_csv.png"))
```



#### Split dataset and export as Excel sheets {-}  

To export the hospital linelists as *an Excel workbook with one linelist per sheet*, we can just provide the named list `linelist_split` to the `write_xlsx()` function from the **writexl** package. This has the ability to save one Excel workbook with multiple sheets. The list element names are automatically applied as the sheet names.  

```{r, eval=F}
linelist_split %>% 
  writexl::write_xlsx(path = here("data", "hospital_linelists.xlsx"))
```

You can now open the Excel file and see that each hospital has its own sheet.  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_sheets.png"))
```

#### More than one `group_split()` column {-}  

If you wanted to split the linelist by *more than one grouping column*, such as to produce subset linelist by intersection of hospital AND gender, you will need a different approach to naming the list elements. This involves collecting the unique "group keys" using `group_keys()` from **dplyr** - they are returned as a data frame. Then you can combine the group keys into values with `unite()` as shown below, and assign these conglomerate names to `linelist_split`.  


```{r}
# split linelist by unique hospital-gender combinations
linelist_split <- linelist %>% 
  group_split(hospital, gender)

# extract group_keys() as a dataframe
groupings <- linelist %>% 
  group_by(hospital, gender) %>%       
  group_keys()

groupings      # show unique groupings 
```

Now we combine the groupings together, separated by dashes, and assign them as the names of list elements in `linelist_split`. This takes some extra lines as we replace `NA` with "Missing", use `unite()` from **dplyr** to combine the column values together (separated by dashes), and then convert into an un-named vector so it can be used as names of `linelist_split`.  

```{r, eval=F}
# Combine into one name value 
names(linelist_split) <- groupings %>% 
  mutate(across(everything(), replace_na, "Missing")) %>%  # replace NA with "Missing" in all columns
  unite("combined", sep = "-") %>%                         # Unite all column values into one
  setNames(NULL) %>% 
  as_vector() %>% 
  as.list()
```


#### Reading in multiple Excel sheets {-}  

For reference, if you want to use **purrr** to import multiple Excel workbook sheets and combine them (the reverse of above), you can use the package **readxl** as demonstrated below.  

First, extract the sheet names from the Excel workbook. Use `excel_sheets()` from the **readxl** package. You provide the filepath within the parentheses.  

```{r}
sheet_names <- readxl::excel_sheets(here("data", "hospital_linelists.xlsx"))

sheet_names
```



Now we can use this vector of sheet names to iteratively `import()` the sheets. The argument used to import a specific Excel workbook sheet is given `.x`, which is the sheet name currently being mapped on. Finally, because we have used `map()`, the sheets have been saved as in a list - each data frame is one element in the list.   

```{r}
sheets_as_list <- sheet_names %>% 
  map(~rio::import(here("data", "hospital_linelists.xlsx"), which = .x))
```


Assuming each data frame has the same columns, we can combine the six data frames with a simple `bind_rows()` command (from **dplyr**). Optionally, add `.id = "sheet_name"` to have a column specifying which sheet each row came from originally.  


```{r}
combined_sheets <- bind_rows(sheets_as_list)
```





<!-- ======================================================= -->
## Resources { }

[for loops with Data Carpentry](https://datacarpentry.org/semester-biology/materials/for-loops-R/)  

The [R for Data Science page on iteration](https://r4ds.had.co.nz/iteration.html#iteration)  

[Vignette on write/read Excel files](https://martinctc.github.io/blog/vignette-write-and-read-multiple-excel-files-with-purrr/)  

A purrr [tutorial](https://jennybc.github.io/purrr-tutorial/index.html ) 

[purrr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png)



TO DO
group_split
collapse
pluck

set_names()
vars = linelist %>%
     select_if(is.numeric) %>%
     select(-cyl, - year) %>%
     names() %>%
     set_names()

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/iteration.Rmd-->


# Directory interactions { }  

In this page we cover common scenarios where you interact with, save, and import with directories (folders).  


## Preparation  

### **fs** package {-}  

The **fs** package is a **tidyverse** package that facilitate directory interactions, improving on some of the **base** R functions. In the sections below we will often use functions from **fs**.  

```{r}
pacman::p_load(fs)
```


### Print directory as a dendrogram tree
Use the function `dir_tree()` from **fs**.  

Provide the folder filepath to `path = ` and decide whether you want to show only one level (`recurse = FALSE`) or all files in all sub-levels (`recurse = TRUE`). Below we use `here("data)` as shorthand for the R project and it's sub-folder "data", which contains all the data used for this R handbook. We use set it to display all files within "data" and its sub-folders (e.g. "cache", "epidemic models", "population", "shp", and "weather").  


```{r}
fs::dir_tree(path = here("data"), recurse = TRUE)
```


## Accessing files in the directory



## Running other files  

### `source()` {-}  

To run one R script from another R script, you can use the `source()` command (from **base** R).

```{r, eval=F}
source(here("scripts", "cleaning_scripts", "clean_testing_data.R"))
```

This is equivalent to viewing the above R script and clicking the "Source" button in the upper-right of the script. This will execute the script but will do it silently (no output to the R console) unless specifically intended. See the page on [Interactive console] for examples of using `source()` to interact with a user via the R console in question-and-answer mode.  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "source_button.png"))
```


### `render()` {-}  

`render()` is a variation on `source()` most often used for R markdown scripts. You provide the `input = ` which is the R markdown file, and also the `output_format = ` (typically either "html_document", "pdf_document", "word_document", "") 

See the page on [R markdown] for more details. Also see the documentation for `render()` [here](https://rmarkdown.rstudio.com/docs/reference/render.html) or by entering `?render`.  



### Run files in a directory {-}

You can create a *for loop* and use it to `source()` every file in a directory, as identified with `dir()`. 

```{r, eval=F}
for(script in dir(here("scripts"), pattern = ".R$")) {   # for each script name in the R Project's "scripts" folder (with .R extension)
  source(here("scripts", script))                        # source the file with the matching name that exists in the scripts folder
}
```

If you only want to run certain scripts, you can identify them by name like this:  

```{r, eval=F}

scripts_to_run <- c(
     "epicurves.R",
     "demographic_tables.R",
     "survival_curves.R"
)

for(script in scripts_to_run) {
  source(here("scripts", script))
}

```



Here is a [comparison](https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html) of the **fs** and **base** R functions.  

### Import files in a directory  {-}

See the page on [Import and export] for importing and exporting individual files.  
See the page on [Iteration and loops] for an example with the package **purrr** demonstrating:  

* Splitting a dataframe and saving it as multiple CSV files  
* Splitting a dataframe and saving each part as a separate sheet within one Excel workbook  
* Importing multiple CSV files and combining them into one dataframe  
* Importing an Excel workbook with multiple sheets and combining them into one dataframe  




## **base** R  

See below the functions `list.files()` and `dir()`, which perform the same operation of listing files within a specified directory. You can specify `ignore.case =` or a specific patter to look for. 

```{r, eval=F}
list.files(path = here("data"))

list.files(path = here("data"), pattern = ".csv")
# dir(path = here("data"), pattern = ".csv")

list.files(path = here("data"), pattern = "evd", ignore.case = TRUE)

```

If a file is currently "open", it will display with a tilde in front, like "~$hospital_linelists.xlsx".  


<!-- ======================================================= -->
## Resources {  }

https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/directories.Rmd-->

