---
knit: "bookdown::render_book"
title: "R Handbook for Epidemiologists"
author: "the handbook team"
description: "Description here......................"
date: "`r Sys.Date()`"
#url: 'https://github.com/nsbatra/Epi_R_handbook'
#github-repo: nsbatra/Epi_R_handbook
#twitter-handle: 
cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
---

<!-- ---  -->
<!-- title: "A Minimal Book Example" -->
<!-- author: "Yihui Xie" -->
<!-- date: "`r Sys.Date()`" -->
<!-- site: bookdown::bookdown_site -->
<!-- output: bookdown::gitbook -->
<!-- documentclass: book -->
<!-- bibliography: [book.bib, packages.bib] -->
<!-- biblio-style: apalike -->
<!-- link-citations: yes -->
<!-- github-repo: rstudio/bookdown-demo -->
<!-- description: "This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." -->
<!-- --- -->

# Welcome - THIS IS A DRAFT {-}

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "R Handbook Logo.png"))
```


<!-- ======================================================= -->
## About this handbook {-}

**This is a free open-access R reference book for applied epidemiologists and public health practitioners.**  

**This book strives to:**  

* Serve as a quick reference guide - not a textbook  
* Address common epidemiological problems via task-centered examples  
* Be accessible in settings with limited technical support and low internet-connectivity (downloadable version)  
* Contain clear and simple language, with step-by-step instructions and helpful code annotation  
* Be a living document, growing and adapting to new best practices  

**What gaps does this book address?**  

* Many epidemiologists lack formal R training or are transitioning from SAS, STATA, or other statistical software.  
* The R universe changes frequently - there should be a place for best practice code catered toward the common epidemiologist user.  
* Epidemiologists often search dozens of online forums for answers, most of which are not epidemiology-oriented.  
* Some epidemiologists work in low internet-connectivity environments and have limited technical support.  

**How is this different than other R books?**  

* This handbook is written by epidemiologists, for epidemiologists. It is **not** an approved product of any specific organization. Examples and techniques are adapted from the authors lived experience in local, national, academic, and emergency settings.  
* The book is offered in a download-able format for settings with unreliable internet.  
* In addition to core R skills this book uses epidemiology-centered examples to cover tasks like *epidemic curves, transmission chains and epidemic modeling, age and sex pyramids, age and sex standardization, probabilistic matching of records, outbreak detection methods, survey analysis, causal diagrams, survival analysis, GIS basics, phylogenetic trees, missing data imputation, automated routine reports with Rmarkdown*, etc...  



<!-- ======================================================= -->
## How to read this handbook {-} 

* Search via the search box above the Table of Contents 
* Click the "clipboard" or "copy" icon to copy code  
* See the "Resources" section of each page for links to further training  
* Click HERE to download the offline version  
* If you use this handbook or have suggestions, let us know at THIS SURVEY LINK!  


<!-- ======================================================= -->
## Edit or contribute {-}

If you have suggestions or want to contribute content, please post an issue or submit a pull request to this [github repository](https://github.com/nsbatra/R_epi_handbook).  




<!-- ======================================================= -->
## Acknowledgements {-}  


### Contributors {-}  

This handbook is a collaborative team production. It has been conceived, written, and edited by epidemiologists and public health practitioners from around the world, who have drawn upon their experiences within a constellation of organizations including local/state/provincial/national health departments and ministries, the World Health Organization (WHO), MSF (Medecins sans frontiers / Doctors without Borders), UNHCR, WFP, hospital systems, and academic institutions.

Here are the team members:  

**Editor-in-Chief:** Neale Batra 

**Editorial core team:** Alex Spina, Amrish Baidjoe, Henry Laurenson-Schafer, Finlay Campbell, Pat Keating  

**Authors** *(in order of contributions)*: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Daniel Molling, Liza Coyer, Jonny Polonski, Yurie Izawa, Sara Hollis  

**Reviewers:** ...(list)...  

**Advisers**  ...(list)...  


### Funding and programmatic support {-}  

The handbook received funding via a COVID-19 emergency capacity-building grant from Training Programs in Epidemiology and Public Health Interventions Network ([TEPHINET](https://www.tephinet.org/)).  

Programmatic support was provided by the EPIET Alumni Network ([EAN](https://epietalumni.net/)).  



### Inspiration {-}  

The multitude of tutorials and vignettes that provided foundational knowledge for development of handbook content are credited within their respective pages.  

More generally, the following sources provided inspiration and laid the groundwork for this handbook:  
[The "R4Epis" project](https://r4epis.netlify.app/) (a collaboration between MSF and RECON)  
[R Epidemics Consortium (RECON)](https://www.repidemicsconsortium.org/)  
[R for Data Science book (R4DS)](https://r4ds.had.co.nz/)  
[bookdown: Authoring Books and Technical Documents with R Markdown](https://bookdown.org/yihui/bookdown/)  


### Image credits {-}  


Logo: [CDC Public Health Image library](https://phil.cdc.gov/), [R Graph Gallery](https://www.r-graph-gallery.com/)  

[2013 Yemen looking for mosquito breeding sites](https://phil.cdc.gov/Details.aspx?pid=19623)  
[Ebola virus](https://phil.cdc.gov/Details.aspx?pid=23186)  
[Survey in Rajasthan](https://phil.cdc.gov/Details.aspx?pid=19838)  
[Network](https://www.r-graph-gallery.com/257-input-formats-for-network-charts.html)  



### License and Terms of Use {-}  

This handbook is **not** an approved product of any specific organization.  

Although we strive for accuracy, we provide no guarantee of the content in this book.  

This book is licensed under a [Creative Commons license](https://creativecommons.org/licenses/) TBD... 


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:index.Rmd-->

# (PART) Preview pages {-}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/cat_preview.Rmd-->

# R Basics {}

<!-- ======================================================= -->
## Overview

**This page is not intended to be a comprehensive "learn R" tutorial**. However, it does cover some fundamentals that can be useful for reference or for refreshing your memory. See the section on recommended training for more comprehensive tutorials.  

```{r, echo=F}
# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))
pacman::p_load(apyramid)
```

<!-- ======================================================= -->
## Why use R?

As stated on the [R project website](https://www.r-project.org/about.html), R is a programming language and environment for statistical computing and graphics. It is highly versatile, extensible, and community-driven.  

**Cost**

R is free to use! There is a strong ethic in the community of free and open-source material.  

**Reproducibility**  

Conducting your data management and analysis through a programming language (compared to Excel or another primarily point-click/manual tool) enhances **reproducibility**, makes **error-detection** easier, and eases your workload.  

**Community**  

The R community of users is enormous and collaborative. New packages and tools to address real-life problems are developed daily, and vetted by the community of users. As one example, [R-Ladies](https://rladies.org/) is a worldwide organization whose mission is to promote gender diversity in the R community, and is one of the largest organizations of R users. It likely has a chapter near you!  




<!-- ======================================================= -->
## Installation {#install}

**How to install R**  

Visit this website [https://www.r-project.org/](https://www.r-project.org/) and download the latest version of R suitable for your computer.  

**How to install R Studio**  

Visit this website [https://rstudio.com/products/rstudio/download/](https://rstudio.com/products/rstudio/download/) and download the latest free Desktop version of RStudio suitable for your computer.

**How to update R and RStudio**  

Your version of R is printed to the R Console at start-up. You can also run `sessionInfo()`.  

To update R, go to the website mentioned above and re-install R. Alternatively, you can use the **installr** package (on Windows) by running `installr::updateR()`. This will open dialog boxes to help you download the latest R version and update your packages to the new R version. More details can be found in the **installr** [documentation](https://www.r-project.org/nosvn/pandoc/installr.html).  

Be aware that the old R version will still exist in your computer. You can temporarily run an older version (older "installation") of R by clicking "Tools" -> "Global Options" in RStudio and choosing an R version. This can be useful if you want to use a package that has not been updated to work on the newest version of R.  



To update RStudio, you can go to the website above and re-download RStudio. Another option is to click "Help" -> "Check for Updates" within RStudio, but this may not show the very latest updates.  


### Other software you *may* need to install  

* TinyTeX (*for compiling an RMarkdown document to PDF*)  
* Pandoc  (*for compiling RMarkdown documents*)  
* RTools  (*for building packages for R*)  
* phantomjs (*for saving still images of animated networks, such as transmission chains*)  


#### TinyTex  

TinyTex is a custom LaTeX distribution, useful when trying to produce PDFs from R.  
See [https://yihui.org/tinytex/](https://yihui.org/tinytex/) for more informaton.  

To install TinyTex from R:  

```{r, eval=F}
install.packages('tinytex')
tinytex::install_tinytex()
# to uninstall TinyTeX, run tinytex::uninstall_tinytex()
```


#### Pandoc {-}

Pandoc is a document converter, a separate software from R. **It comes bundled with RStudio and should not need to be downloaded.** It helps the process of converting Rmarkdown documents to formats like .pdf and adding complex functionality.  


#### RTools {-}  

RTools is a collection of software for building packages for R

Install from this website: [https://cran.r-project.org/bin/windows/Rtools/](https://cran.r-project.org/bin/windows/Rtools/)  


#### phantomjs {-}  

This is often used to take "screenshots" of webpages. For example when you make a transmission chain with **epicontacts** package, an HTML file is produced that is interactive and dynamic. If you want a static image, if can be useful to use the [**webshot**](https://wch.github.io/webshot/articles/intro.html) package to automate this process. This will require the external program "phantomjs". You can install phantomjs via the **webshot** package with the command `webshot::install_phantomjs()`.  





<!-- ======================================================= -->
## RStudio {#rstudio  }


### RStudio Orientation
**First, open RStudio.** As their icons can look very similar, be sure you are opening *RStudio* and not R.  


For RStudio to function you must also have R installed on the computer (see [this section](#install) for installation instructions).  

**RStudio** is an interface (GUI) for easier use of **R**. You can think of R as being the engine of a vehicle, doing the crucial work, and RStudio as the body of the vehicle (with seats, accessories, etc.) that helps you actually use the engine to move forward!  

By default RStudio displays four rectangle panes. 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```


<span style="color: black;">**_TIP:_** If your RStudio displays only one left pane it is because you have no scripts open yet.</span>


**The R Console Pane**  

The R Console, by default the left or lower-left pane in R Studio, is the home of the R "engine". This is where the commands are actually run and non-graphic outputs and error/warning messages appear. You can directly enter and run commands in the R Console, but realize that these commands are not saved as they are when running commands from a script.  

If you are familiar with Stata, the R Console is like the Command Window and also the Results Window.

**The Source Pane**  
This pane, by default in the upper-left, is space to edit and run your scripts. This pane can also display datasets (data frames) for viewing.  

For Stata users, this pane is similar to your Do-file and Data Editor windows.


**The Environment Pane**  
This pane, by default the upper-right, is most often used to see brief summaries of objects in the R Environment in the current session. These [objects](#objects) could include imported, modified, or created datasets, parameters you have defined (e.g. a specific epi week for the analysis), or vectors or lists you have defined during analysis (e.g. names of regions). Click on the arrow next to a dataframe name to see its variables.  

In Stata, this is most similar to Variables Manager window.

This pane also contains *History* where can see commands that you can previously. It also has a "Tutorial" tab where you can complete interactive R tutorials if you have the **learnr** package installed.  


**Plots, Packages, and Help Pane**  
The lower-right pane includes several tabs including plots (display of graphics including maps), help, a file library, and available R packages (including installation/update options).  

This pane contains the Stata equivalents of the Plots Manager and Project Manager windows.

### RStudio settings  

Change RStudio settings and appearance in the *Tools* drop-down menu, by selecting *Global Options*. There you can change the default settings, including appearance/background color.  

```{r basics_RStudio, out.width = "75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_tools_options.png"))
```



<!-- ======================================================= -->
## Scripts {#scripts}

Scripts are a fundamental part of programming. Storing your code in a script (vs. typing in the console) has many advantages:  

* Reproducibility  
* Version control  
* Commenting  


<!-- ======================================================= -->
### Rmarkdown {-}

Rmarkdown is a type of script in which the script itself *becomes* a document (PDF, Word, HTML, Powerpoint, etc.). See the handbook page on [Rmarkdown](#rmarkdown) documents. [R Markdown] documents.   [R Markdown](#R Markdown) documents.   


<!-- ======================================================= -->
### R notebooks {-}

There is no difference between writing in a Rmarkdown vs an R notebook. However the execution of the document differs slightly. See this [site](http://uc-r.github.io/r_notebook) for more details.

<!-- ======================================================= -->
### R Shiny {-}

Shiny apps are contained within one script, which must be named `app.R`. This file has three components:  

1) A user interface (ui)  
2) A server function  
3) A call to the `shinyApp` function  

See the handbook page on Shiny basics, or this online tutorial: [Shiny tutorial](https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/)

*In older times, the above file was split into two files (`ui.R` and `server.R`)*




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Working directory {#workingdirectory}

**The working directory is the root folder location used by R for your work - where R looks for and saves files by default.**  

By default, it will save new files and outputs to this location, and will look for files to import (e.g. datasets) here as well.  

The working directory appears in grey text at the top of the RStudio Console pane. You can also return the current working directory with `getwd()` (do not put anything in the parentheses).  

*NOTE: If using an R project, the working directory will default to the R project root folder **IF** you open RStudio by clicking open the R project (the file with .rproj extension))*



<!-- ======================================================= -->
### Filepaths  

Perhaps the most common source of frustration for an R beginner on a Windows machine - typing in a filepath to import data.  

1) Use **here** - Avoid these problems altogether by using relative pathways from the root of an R project that uses the **here** package. See the **here** tab in this Basics page for more details.  

2) **Slashes** - If typing in a filepath, beware the direction of the slashes. Enter them using *forward slashes* to separate components ("data/provincial.csv"). For Windows users, the default way that filepaths are displayed and copied is with *backslashes* ("\\") - so this means you must go change the direction of each slash. Or just use **here** and an R project as noted above.  

3) Avoid using "absolute" paths - these are "full address" paths that direct to the same place regardless of the user's working directory. For example:  

```
C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  
```
This path **will break** if the script is sent to someone on another computer! Instead, consider using an R project and having the filepath begin at that root directory (i.e. the working directory of the R project).  

One possible exception is if working in a larger organization where you need to pull data from across several networked drives and don't have permission to re-save the data in your R project. This can get tenuous, but it may be best to use these full absolute filepaths.  




<!-- ======================================================= -->
### Set by command

Use the command `setwd()` with the filepath in quotations, for example: `setwd("C:/Documents/R Files")`


<span style="color: orange;">**_CAUTION:_** If using an RMarkdown script be aware of the following:</span>

In an [R Markdown](#rmarkdown) script, the default working directory is the folder the Rmarkdown file (`.Rmd`) is saved to. If you want to change this, you can use `setwd()` as above, but know the change will only apply to that specific code chunk.  

To change the working directory for all code chunks in an R markdown, edit the setup chunk to add the `root.dir = ` parameter, such as below:

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/filepath/here')
```


<!-- ======================================================= -->
### Set Manually

Setting your working directory manually (point-and-click)  

From RStudio click: Session / Set Working Directory / Choose Directory (you will have to do this each time you open RStudio)


<!-- ======================================================= -->
### In an R project

If you are working in an R project, your working directory will by default be the root folder. This is convenient to maximize with the **here** package (LINK).  





<!-- ======================================================= -->
## Objects {#objects  }

Everything in R is an object. These sections will explain:  

* How to create objects (`<-`) 
* Types of objects (e.g. data frames, vectors..)  
* How to access subparts of objects (e.g. variables in a dataset)  
* Classes of objects (e.g. numeric, logical, integer, double, character, factor)  



<!-- ======================================================= -->
### Everything is an object 

Everything you store in R - datasets, variables, a list of village names, a total population number, even outputs such as graphs - are **objects** which are **assigned a name** and **can be referenced** in later commands.  

An object exists when you have assigned it a value (see the assignment section below). When it is assigned a value, the object appears in the Environment (see the upper right pane of RStudio). It can then be operated upon, manipulated, changed, and re-defined.



<!-- ======================================================= -->
### Defining objects (`<-`)

**Create objects *by assigning them a value* with the <- operator.**  
You can think of the assignment operator `<-` as the words "is defined as". Assignment commands generally follow a standard order:
 
**object_name**  <-  **value** (or process/calculation that produce a value)

> **EXAMPLE:** You may want to record the current epidemiological reporting week as an object for reference in later code. In this example, the object `reporting_week` is created when it is assigned the character value `"2018-W10"` (the quote marks make these a character value).  
The object `reporting_week` will then appear in the RStudio Environment pane (upper-right) and can be referenced in later commands.  


See the R commands and their output in the boxes below. 

```{r basics_objects_assignment}
reporting_week <- "2018-W10"   # this command creates the object reporting_week by assigning it a value
reporting_week                 # this command prints the current value of reporting_week object in the console
```

<span style="color: black;">**_NOTE:_** Note the `[1]` in the R console output is simply indicating that you are viewing the first item of the output</span>


<span style="color: orange;">**_CAUTION:_** **An object's value can be over-written** at any time by running an assignment command to re-define its value. Thus, the **order of the commands run is very important**.</span>

The following command will re-define the value of `reporting_week`: 

```{r basics_objects_reassignment}
reporting_week <- "2018-W51"   # assigns a NEW value to the object reporting_week
reporting_week                 # prints the current value of reporting_week in the console
```

**Datasets are also objects ("dataframes") and must be assigned names when they are imported.**  

In the code below, the object `linelist` is created and assigned the value of a CSV file imported with the **rio** package.  

```{r basics_objects_dataframes, eval=FALSE}
# linelist is created and assigned the value of the imported CSV file
linelist <- rio::import("my_linelist.csv")
```

You can read more about importing and exporting datasets with the section on [importing data](#importdata).

<span style="color: orange;">**_CAUTION:_** A quick note on naming of objects:</span>

  * Object names must not contain spaces, but you should use underscore (_) or a period (.) instead of a space.  
  * Object names are case-sensitive (meaning that Dataset_A is different from dataset_A). 
  * Object names must begin with a letter (cannot begin with a number like 1, 2 or 3). 

 

<!-- ======================================================= -->
### Object structure {#objectstructure}  

**Objects can be a single piece of data (e.g. `my_number <- 24`), or they can consist of structured data.**  

The graphic below, sourced from [this online R tutorial](http://venus.ifca.unican.es/Rintro/dataStruct.html) shows some common data structures and their names. Not included in this image is spatial data, which is discussed in the [GIS section](#gis).  


```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```  

In epidemiology (and particularly field epidemiology), you will *most commonly* encounter data frames and vectors:  


Common structure | Explanation | Example
------------------- | ------------------------------------ | ------------------------  
Vectors | A container for a sequence of singular objects, all of the same class (e.g. numeric, character). | **"Variables" (columns) in data frames are vectors** (e.g. the variable `age_years`).  
Data Frames | Vectors (e.g. columns) that are bound together that all have the same number of rows. | `linelist` is a data frame.  

Note that to create a vector that "stands alone", or is not part of a data frame (such as a list of location names), the function `c()` is often used:  

`list_of_names <- c("Ruhengeri", "Gisenyi", "Kigali", "Butare")`  


<!-- ======================================================= -->
### Object classes  {#objectclasses}

All the objects stored in R have a *class* which tells R how to handle the object. There are many possible classes, but common ones include:

Class |	Explanation | Examples
------ | ------------------------------------------ |  -----------------------------
Character	| These are text/words/sentences **"within quotation marks"**. Math cannot be done on these objects.	| "Character objects are in quotation marks"  
Integer | Numbers that are **whole only** (no decimals) | -5, 14, or 2000  
Numeric	| These are numbers and **can include decimals**. If within quotation marks the will be considered character. | 23.1 or 14  
Factor | These are vectors that have a **specified order** or hierarchy of values | Variable `msf_involvement` with ordered values N, S, SUB, and U.  
Date | **Once R is told that certain data are Dates**, these data can be manipulated and displayed in special ways. See the page on Dates for more information. | 2018-04-12 or 15/3/1954 or Wed 4 Jan 1980  
Logical | Values must be one of the two special values TRUE or FALSE (note these are **not** "TRUE" and "FALSE" in quotation marks) | TRUE or FALSE  
data.frame | A data frame is how R stores a **typical dataset**. It consists of vectors (columns) of data bound together, that all have the same number of observations (rows). | The example AJS dataset named `linelist_raw` contains 68 variables with 300 observations (rows) each.  

**You can test the class of an object by feeding it to the function `class()`**. Note: you can reference a specific column within a dataset using the `$` notation to separate the name of the dataset and the name of the column.

```{r basics_objects_class, echo=TRUE, eval=T}
class(linelist$age)     # class should be numeric

class(linelist$gender)  # class should be character
```

Sometimes, a column will be converted to a different class automatically by R. Watch out for this! For example, if you have a vector or column of numbers, but a character value is substituted in... the entire column will change to class character.  

One common example is when working with a dataframe to print a table - if you make a total row and try paste/glue together percents in the same cell as numbers the entire columns above them will convert to character and can no longer be used for mathematical calculations.

```{r}
num_vector <- c(1,2,3,4,5) # define vector as all numbers
class(num_vector)          # vector is numeric class
num_vector[3] <- "three"   # convert the third element to a character
class(num_vector)          # vector is now character class
```


**Sometimes, you will need to convert objects or columns to another class.**

Function | Action  
----------------- | --------------------------------------------------------------    
`as.character()` | Converts to character class  
`as.numeric()` | Converts to numeric class  
`as.integer()` | Converts to integer class
`as.Date()` | Converts to Date class - Note: see section on [dates](#dates) for details  
`as.factor()` | Converts to factor - Note: re-defining order of value levels requires extra arguments

likewise, there are **base** R functions to check whether an object IS of a specific class, such as `is.numeric()`, `is.character()`, `is.double()`, `is.factor()`, `is.integer()`

Here is [more online material on classes and data structures in R](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/).


<!-- ======================================================= -->
### Columns/Variables (`$`) {#dollarsign}  

A column in a dataframe is known as a "vector", or a sequence of values that must all the same class
**Vectors within a data frame (variables in a dataset) can be called, referenced, or created using the `$` symbol.** The `$` symbol connects the name of the column to the name of its data frame. The `$` symbol must be used, otherwise R will not know where to look for or create the column.  

In this handbook, we use the word "column" instead of "variable".  


```{r basics_objects_call, eval=F}
# Retrieve the length of the vector age_years
length(linelist$age) # (age is a variable in the linelist data frame)

```

By typing the name of the data frame followed by `$` you will also see a list of all variables in the data frame. You can scroll through them using your arrow key, select one with your Enter key, and avoid spelling mistakes!  

```{r basics_objects_callGIF, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```  



<span style="color: darkgreen;">**_ADVANCED TIP:_** Some more complex objects (e.g. an `epicontacts` object may have multiple levels which can be accessed through multiple dollar signs. For example `epicontacts$linelist$date_onset`) .</span>



<!-- ======================================================= -->
### Access/index with brackets (`[]`) {#brackets}  

You may need to view parts of objects, also called "indexing", which is often done using the square brackets `[ ]`. Note: using `$` on a dataframe to access a column is also a type of indexing.  

```{r}
my_vector <- c("a", "b", "c", "d", "e", "f")  # define the vector
my_vector[5]                                  # print the 5th element
```

Square brackets also work to return specific parts of an returned output, such as output of a `summary()` function: 

```{r}
# All of the summary
summary(linelist$age)

#Just one part
summary(linelist$age)[2]  
```

To view specific rows and columns of a dataset, you can do this using the syntax `dataframe[rows, columns]`:  

```{r basics_objects_access, eval=F}
# View a specific row (2) from dataset, with all columns
linelist[2,]

# View all rows, but just one column
linelist[, "date_onset"]

# View values from row 2 and columns 5 through 10
linelist[2, 5:10] 

# View values from row 2 and columns 5 through 10 and 18
linelist[2, c(5:10, 18)] 

# View rows 2 through 20, and specific columns
linelist[2:20, c("date_onset", "outcome", "age")]

# View rows and columns based on criteria
# *** Note the dataframe must still be names in the criteria!
linelist[linelist$age > 25 , c("date_onset", "date_birth", "age")]

# Use View() to see the outputs in the RStudio Viewer pane (easier to read) 
# *** Note the capital "V" in View() function
View(linelist[2:20, "date_onset"])

# Save as a new object
new_table <- linelist[2:20, c("date_onset")] 
```

When indexing an object of class **list**, single brackets always return with with class list, even if only a single object is returned. Double brackets, however, can be used to access a single element and return a different class than list.  
Brackets can also be written after one another, as demonstrated below.  

This [visual explanation with pepper shakers](https://r4ds.had.co.nz/vectors.html#lists-of-condiments) is humorous and helpful.

```{r}
# define demo list
my_list <- list(
  # First element in the list is a character vector
  hospitals = c("Central", "Empire", "Santa Anna"),
  
  # second element in the list is a dataframe of addresses
  address   = data.frame(
    street = c("145 Medical Way", "1048 Brown Ave", "999 El Camino"),
    city   = c("Andover", "Hamilton", "El Paso")
    )
  )


my_list[1] # this returns the element in class "list"

my_list[[1]] # this is a character vector

my_list[["hospitals"]] # you can also index by name of the list element

my_list[[1]][3] # this returns the third element of the "hospitals" character vector

my_list[[2]][1] # This returns the first column ("street") of the address dataframe

```



<!-- ======================================================= -->
### Remove objects  

You can remove individual objects by putting the name in the `rm()` function (no quote marks):  

```{r, eval=F}
rm(object_name)
```

You can remove all objects (clear your workspace) by running:  

```{r, eval=F}
rm(list = ls(all = TRUE))
```


<!-- ======================================================= -->
## Functions {#functions  }


This section on functions explains:  

* What a function is and how they work  
* What arguments are  
* What packages are  
* How to get help understanding a function  


<!-- ======================================================= -->
### Simple functions  

**A function is like a machine that receives inputs, does some action with those inputs, and produces an output.**  
What the output is depends on the function.    

**Functions typically operate upon some object placed within the function's parentheses**. 
For example, the function `sqrt()` calculates the square root of a number:  

```{r basics_function_sqrt}
sqrt(49)
```

Functions can also be applied to variables in a dataset. For example, when the function `summary()` is applied to the numeric variable `age` in the dataset `linelist` ([what's the `$` symbol?](#objects)), the output is a summary of the variable's numeric and missing values.

```{r basics_functions_summary}
summary(linelist$age)
```

<span style="color: black;">**_NOTE:_** Behind the scenes, a function represents complex additional code that has been wrapped up for the user into one easy command.</span>



<!-- ======================================================= -->
### Functions with multiple arguments  

Functions often ask for several inputs, called ***arguments***, located within the parentheses of the function, usually separated by commas. 

* Some arguments are required for the function to work correctly, others are optional.  
* Optional arguments have default settings if they are not specified.
* Arguments can take character, numeric, logical (TRUE/FALSE), and other inputs.  


```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```


**For example**, this `age_pyramid()` command produces an age pyramid graphic based on defined age groups and a binary split column, such as `gender`. The function is given three arguments within the parentheses, separated by commas. The values supplied to the arguments establish `linelist` as the data frame to use, `age_cat5` as the column to count, and `gender` as the binary column to use for splitting the pyramid by color.

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE, eval=T}
## create an age group variable by specifying categorical breaks
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

<span style="color: black;">**_NOTE:_** For this example, linelist comes with a pre-created column called "age_cat5". To learn how to create new variable see [that section of this handbook](#newvars) </span>


```{r basics_functions_pyramid, message=FALSE, warning=FALSE, eval=T, out.width = "75%", out.height="75%"}
# Creates an age pyramid by specifying the dataframe, age group variable, and a variable to split the pyramid
apyramid::age_pyramid(data = linelist, age_group = "age_cat5", split_by = "gender")
```

The first half of an argument assignment (e.g. `data = `) does not need to be specified if the arguments are written in a specific order (specified in the function's documentation). The below code produces the exact same pyramid as above, because the function expects the argument order: data frame, `age_group` variable, `split_by` variable.  

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# This command will produce the exact same graphic as above
apyramid::age_pyramid(linelist, "age_cat5", "gender")
```

**A more complex `age_pyramid()` command might include the *optional* arguments to:**  

* Show proportions instead of counts (set `proportional = TRUE` when the default is `FALSE`)  
* Specify the two colors to use (`pal = ` is short for "palette" and is supplied with a vector of two color names. See the [objects](#objectstructure) page for how the function `c()` makes a vector)  


<span style="color: black;">**_NOTE:_** For arguments specified with an equals symbol (e.g. `coltotals = ...`), their order among the arguments is not important (must still be within the parentheses and separated by commas).</span>


```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
apyramid::age_pyramid(linelist, "age_cat5", "gender", proportional = TRUE, pal = c("orange", "purple"))
```







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Packages {#packages}  

**Packages contain functions.**  

An R package is a shareable bundle of code and documentation that contains pre-defined functions. Users in the R community develop and share packages all the time, so chances are likely that a solution exists for you! You will install and use hundreds of packages in your use of R.  

On installation, R contains **"base"** functions that perform common elementary tasks. But many R users create specialized functions, which are verified by the R community and which you can download as a **package** for your own use. In this handbook, package names are written in **bold**. One of the more challenging aspects of R is that there are often many functions or packages to choose from to complete a given task.  


**Install packages**  

*Functions* are contained within **packages** which can be downloaded ("installed") to your computer from the internet. Once a package is downloaded, you access its functions by loading the package with the `library()` command at the beginning of each R session.

Think of R as your personal library: When you download a package your library gains a book of functions, but each time you want to use a function in that book, you must borrow that book from your library.  


**CRAN**  

CRAN (Comprehensive R Archive Network) is a public warehouse of R packages that have been published by R community members. Most often, R users download packages from CRAN.  



**Install vs. Load**

To use a package, 2 steps must be implemented:  

1) The package must be **installed** (once), *and*  
2) The package must be **loaded** (each R session)  

The basic function for installing a package is `install.packages()`, where the name of the package is provided *in quotes*. This can also be accomplished point-and-click by going to the RStudio "Packages" pane and clicking "Install". 

```{r, eval=F}
install.packages("tidyverse")
```

The basic function to **load** a package for use (after it has been installed) is `library()`, with the name of the package *NOT in quotes*.  

```{r, eval=F}
library(tidyverse)
```



**Using pacman**  

This handbook uses the package **pacman** (abbreviation for "package manager"), which offers the useful function `p_load()`. This function combines the above two steps into one -  it *installs and/or loads packages*, depending on what is needed. If the package has not yet been installed, it will attempt to install from CRAN, and then load it.  

Below, we load some of the packages used in this R basics page:  

```{r}
pacman::p_load(tidyverse, rio, here)
```

The function `p_isinstalled()` will test whether packages are installed already.  




**Install from github**

Sometimes, you need to install the *development version* of a package, from a github repository. You can use `p_load_gh()` from **pacman** (this function is a wrapper around `install_github()` from **devtools**).  

The first name listed in the quotation marks is the Github ID of the repository owner, and after the slash is the name of the repository. If you want to install from a branch other than the main/master branch, add it after an "@".  


```{r, eval=F}
# install development version of package from github repository
p_install_gh("reconhub/epicontacts")

# load development version of package which you had downloaded from github repository
p_load_gh("reconhub/epicontacts")
```

Read more about **pacman** [here](http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html)


**Install from ZIP or TAR**

You could get the package from a URL:  

```{r, eval=F}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

Or download it to your computer in a zipped file:  

Option 1:  

```{r, eval=F}
library(devtools)
install_local("~/Downloads/dplyr-master.zip")
```

Option 2:  

```{r, eval=F}
install.packages(path_to_source, repos = NULL, type="source")

install.packages("~/Downloads/dplyr-master.zip", repos=NULL, type="source")
```




**Delete packages**

Use `p_delete()` from **pacman**, or `remove.packages()` from **base** R. Alternatively, go find the folder which contains your library and manually delete the folder.



**Dependencies**  

Packages often depend on other packages to work. These are called dependencies. If a dependency fails to install, then the package depending on it may also fail to install.  

See the dependencies of a package with `p_depends()`, and see which packages depend on it with `p_depends_reverse()`  



**Masked functions**  

It is not uncommon that two or more packages contain the same function name. For example, the package **dplyr** has a `filter()` function, but so does the package **stats**. The default `filter()` function depends on the order these packages are first loaded in the R session - the later one will be the default for the command `filter()`. 

You can check the order in your Environment pane of R Studio - click the drop-down for "Global Environment" and see the order of the packages. Functions from packages *lower* on that drop-down list will mask functions of the same name in packages that appear highest in the drop-down list. When first loading a package, R will warn you in the console if masking is occurring, but this can be easy to miss.  

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "masking_functions.png"))
```

Here are ways you can fix masking:  

1) Specify the package name in the command. For example, use `dplyr::filter()`  
2) Re-arrange the order in which the packages are loaded (e.g. within `library()` or `p_load()`), and start a new R session  




**Detach / unload**  

To detach a package, use this command, with the correct package name:  

```{r, eval=F}
detach(package:PACKAGE_NAME_HERE, unload=TRUE)
```



**Packages in code**  

For clarity in this handbook, functions are usually preceeded by the name of their package using the `::` symbol in the following way:  
`package_name::function_name()`  

Once a package is loaded for a session, this explicit style is not necessary. One can just use `function_name()`. However giving the package name is useful when a function name is common and may exist in multiple packages (e.g. `plot()`).  
Using the package name will also load the package if it is not already loaded.
 
```{r eval=FALSE}
# This command uses the package "rio" and its function "import()" to import a dataset
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```




**Installing older versions of packages**  

See this [guide](https://support.rstudio.com/hc/en-us/articles/219949047-Installing-older-versions-of-packages)  






**Function help**  

To read more about a function, you can search for it in the Help tab of the lower-right RStudio. You can also run a command like  `?thefunctionname` (put the name of the function after a question mark) and the Help page will appear in the Help pane. Finally, try searching online for resources.  




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Piping (`%>%`) {#piping }

**Two general approaches to working with objects are:**  

1) **Tidyverse/piping** - sends an object from function to function - emphasizes the *action*, not the object  
2) **Define intermediate objects** - emphasis the object, as it is re-defined again and again  


<!-- ======================================================= -->
### **Pipes** 

**Simply explained, the pipe operator (`%>%`) passes an intermediate output from one function to the next.**  
You can think of it as saying "then". Many functions can be linked together with `%>%`.  

* **Piping emphasizes a sequence of actions, not the object the actions are being performed on**  
* Best when a sequence of actions must be performed on one object  
* Pipes come from the package **magrittr**, which is automatically included in packages **dplyr** and **tidyverse**
* Makes code more clean and easier to read, intuitive

Read more on this approach in the tidyverse [style guide](https://style.tidyverse.org/pipes.html)  

Example:

```{r piping_example_pipe, eval=F}
# A fake example of how to bake a care using piping syntax

cake <- flour %>%       # to define cake, start with flour, and then...
  left_join(eggs) %>%   # add eggs
  left_join(oil) %>%    # add oil
  left_join(water) %>%  # add water
  mix_together(utensil = spoon, minutes = 2) %>%                # mix together
  bake(degrees = 350, system = "fahrenheit", minutes = 35) %>%  # bake
  let_cool()            # let it cool down
```

Here is another [link](https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations) describing the utility of pipes.  

Piping is not a **base** function. To use piping, the **magrittr** package must be installed and loaded (this is typically done by loading **tidyverse** or **dplyr** package). You can [read more about piping in the magrittr documentation](https://magrittr.tidyverse.org/).

<span style="color: orange;">**_CAUTION:_** Remember that even when using piping to link functions, if the assignment operator (`<-`) is present, the object to the left will still be over-written (re-defined) by the right side.</span>


**`%<>%`**  
This is an "assignment pipe" from the **magritter** package, which pipes an object forward and also re-defines the object. It must be the first pipe operator in the chain. It is shorthand, so `object %<>% function() %>% function()` is the same as `object <- object %>% function() %>% function()`.  


<!-- ======================================================= -->
### Define intermediate objects

This approach to changing objects/dataframes may be better if:  

* You need to manipulate multiple objects  
* There are intermediate steps that are meaningful and deserve separate object names


**Risks:**  

* Creating new objects for each step means creating lots of objects. If you use the wrong one you might not realize it!  
*Naming all the objects can be confusing  
* Errors may not be easily detectable  

Either name each intermediate object, or overwrite the original, or combine all the functions together. All come with their own risks.  

Below are some examples:  


```{r piping_example_redefine, eval=F}
# a fake example of how to bake a cake using this method (defining intermediate objects)
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

Combine all functions together - also difficult to read  

```{r piping_example_wide, eval=F}
# an example of combining/nesting mutliple functions together - difficult to read
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```



<!-- ======================================================= -->
## Key operators and functions {#operators  }

This section details operators in R, such as:  

* Definitional operators  
* Relational operators (less than, equal too..)  
* Logical operators (and, or...)  
* Handling missing values  
* Mathematical operators and functions (+/-, >, sum(), median(), ...)  
* The `%in%` operator  



<!-- ======================================================= -->
### Assignment operators  

**`<-`**  

The basic assignment operator in R is `<-`. Such that `object_name <- value` (see R Basics tab on "Defining an Object").  
This assignment operator can also be written as `=`. We advise use of `<-` for general R use.  
We also advise surrounding operators with spaces, for readability.  


**`<<-`**  

If writing functions (LINK TO PAGE), or using R in an interactive way with sourced scripts (LINK TO PAGE), then you may need to use this assignment operator `<<-` (**base** R). This operator is used to define an object in a higher 'parent' R `Environment` (LINK to tab on R environments). Also see this [online reference](https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html).


**`%<>%`**  

This is an "assignment pipe" from the **magritter** package, which pipes an object forward and also re-defines the object. It must be the first pipe operator in the chain. It is shorthand, so `object %<>% function() %>% function()` is the same as `object <- object %>% function() %>% function()`.  


**`%<+%`**

Used to add data to phylogenetic trees with the **ggtree** package. See the (LINK TO PAGE) or this online [resource book](https://yulab-smu.top/treedata-book/).  


 

<!-- ======================================================= -->
### Relational and logical operators  

**Relational operators compare values** and are often used when defining new variables and subsets of datasets. Here are the common relational operators in R:  

Function                |Operator     |Example       |Example Result
------------------------|-------------|--------------|---------------------------
Equal to                |`==`         |`"A" == "a"`  |`FALSE` (because R is case sensitive) *Note that == (double equals) is different from = (single equals), which acts like the assignment operator `<-`*
Not equal to            |`!=`         |`2 != 0`      |`TRUE`
Greater than            |`>`          |`4 > 2`       |`TRUE`
Less than               |`<`          |`4 < 2`       |`FALSE`
Greater than or equal to|`>=`         |`6 >= 4`      |`TRUE`
Less than or equal to   |`<=`         |`6 <= 4`      |`FALSE`
Value is missing        |`is.na()`    |`is.na(7)`    |`FALSE` (see section on missing values)
Value is not missing    |`!is.na()`   |`!is.na(7)`   |`TRUE`

**Logical operators, such as AND and OR, are often used to connect relational operators and create more complicated criteria**. Complex statements might require parentheses ( ) for grouping and order of application.  

Function   |Operator
-----------|------------------------
AND        |`&`
OR         |`|` (vertical bar)
Parentheses|`( )` Used to group criteria together and clarify order


For example, below, we have a linelist with two variables we want to use to create our case definition, `hep_e_rdt`, a test result and `other_cases_in_hh`, which will tell us if there are other cases in the household. The command below uses the function `case_when()` to create the new variable `case_def` such that:

```{r basics_operators_casewhen, eval=FALSE}
linelist_cleaned <- linelist_cleaned %>%
  mutate(case_def = case_when(
    is.na(hep_e_rdt) & is.na(other_cases_in_hh)           ~ NA_character_,
    hep_e_rdt == "Positive"                               ~ "Confirmed",
    hep_e_rdt != "Positive" & other_cases_in_hh == "Yes"  ~ "Probable",
    TRUE                                                  ~ "Suspected"
  ))
```

Criteria in example above               | Resulting value in new variable "case_def"
----------------------------------------|-------------------------------------
If the value for variables `hep_e_rdt` and `other_cases_in_hh` are missing | `NA` (missing)  
If the value in `hep_e_rdt` is "Positive" | "Confirmed"  
If the value in `hep_e_rdt` is NOT "Positive" AND the value in `other_cases_in_hh` is "Yes" | "Probable"  
If one of the above criteria are not met | "Suspected"  


*Note that R is case-sensitive, so "Positive" is different than "positive"...*  

 
<!-- ======================================================= -->
### Missing values

**In R, missing values are represented by the special value `NA` (a "reserved" value)** (capital letters N and A - not in quotation marks). If you import data that records missing data in another way (e.g. 99, "Missing", or .), you may want to re-code those values to `NA`.
  
**To test whether a value is `NA`, use the special function `is.na()`**, which returns `TRUE` or `FALSE`.

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # two positive cases, one suspected, and one unknown
is.na(rdt_result)  # Tests whether the value of rdt_result is NA
```

Here is the [R documentation on missing values](https://stat.ethz.ch/R-manual/R-devel/library/base/html/NA.html)  

**Variations on `NA`**  

`NA` is actually a logical value of length 1. You may also encounter `NA_character_`, `NA_real_`, `NA_complex_`, and `NA_integer_`, which correspond to specific classes.  

The most prominent application of one of these variants in common epidemiology work is using `case_when()`. The Right-Hand Side (RHS) values must all be of the same class. Thus, if you have character outcomes on the RHS like "Confirmed", "Suspect", "Probable" and `NA` - you will get an error. Instead of `NA` you must have `NA_character_`. Likewise for integers, use `NA_integer_`.  


**`NULL`**  

`NULL` is the null object in R, often used to represent a list of 0 length. Use `is.null()` to evaluate this status.  

More detail on the difference between `NA` and `NULL` is [here](https://www.r-bloggers.com/2010/04/r-na-vs-null/)  




<!-- ======================================================= -->
### Mathematics and statistics  

All the operators and functions in this page is automatically available using **base** R.  

#### Mathematical operators  

These are often used to perform addition, division, to create new columns, etc. Below are common mathematical operators in R. Whether you put spaces around the operators is not important.  


Objective          |Example in R
-------------------|-------------
addition           | 2 + 3
subtraction        | 2 - 3
multiplication     | 2 * 3
division           | 30 / 5
exponent           | 2^3
order of operations| ( )



#### Mathematical functions

Objective          |Function
-------------------|-------------
rounding           | round(x, digits = n)  
rounding           | janitor::round_half_up(x, digits = n)
ceiling (round up) | ceiling(x)
floor (round down) | floor(x)
absolute value     | abs(x)
square root        | sqrt(x)
exponent           | exponent(x)
natural logarithm  | log(x)

<span style="color: red;">**_DANGER:_** `round()` uses "banker's rounding" which rounds up from a .5 only if the upper number is even. Use `round_half_up()` from **janitor** to consistently round halves up to the nearest whole number. See [this](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes) </span>  

```{r}
# use the appropriate rounding function for your work
round(c(2.5, 3.5))

janitor::round_half_up(c(2.5, 3.5))
```


#### Statistical functions:  

<span style="color: orange;">**_CAUTION:_** The functions below will by default include missing values in calculations. Missing values will result in an output of NA, unless the argument `na.rm=TRUE` is specified</span>


Objective                |Function
-------------------------|----------------------
mean (average)           | mean(x, na.rm=T)
median                   | median(x, na.rm=T)
standard deviation       | sd(x, na.rm=T)
quantiles*               | quantile(x, probs)
sum                      | sum(x, na.rm=T)
minimum value            | min(x, na.rm=T)
maximum value            | max(x, na.rm=T)
range of numeric values  | range(x, na.rm=T)
summmary**               | summary(x)

<span style="color: red;">**_DANGER:_** If providing a vector of numbers to one of the above functions, be sure to wrap the numbers within `c()` .</span>

```{r}
# If supplying raw numbers to a function, wrap them in c()
mean(1, 6, 12, 10, 5, 0)    # !!! INCORRECT !!!  

mean(c(1, 6, 12, 10, 5, 0)) # CORRECT
```

* `quantile()`: x is the numeric vector to examine, and probs is a numeric vector with probabilities within 0 and 1.0, e.g `c(0.5, 0.8, 0.85)`
** `summary()`: gives a summary on a numeric vector including mean, median, and common percentiles



#### Other useful functions:  


Objective                   |Function            |Example
----------------------------|--------------------|-----------------------------------------------
create a sequence           | seq(from, to, by)  |`seq(1, 10, 2)`
repeat x, n times           | rep(x, ntimes)     |`rep(1:3, 2)` or `rep(c("a", "b", "c"), 3)` 
subdivide a numeric vector  | cut(x, n)          |`cut(linelist$age, 5)`




<!-- ======================================================= -->
### `%in%`  

A very useful operator for matching values, and quickly assessing if a value is within a vector or dataframe.   

```{r}
my_vector <- c("a", "b", "c", "d")

"a" %in% my_vector
"h" %in% my_vector
```

To ask if a value is **not** `%in%`, put an exclamation mark (!) **in front** of the logic statement:  

```{r}
# to negate, put an exclamation in front
!"a" %in% my_vector
!"h" %in% my_vector
```

`%in%` is very useful when using the **dplyr** function `case_when()` to recode values in a column. For example:  

```{r eval=F}
linelist <- linelist %>% 
  mutate(hospital = case_when(
    hospital %in% c("St. Fr.", "Saint Francis") ~ "St. Francis")) # convert to correct spelling
```








<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Errors & Warnings { }

This section explains:  

* General syntax for writing R code  
* Code assists  
* the difference between errors and warnings  

Common errors and warnings and their solutions can be found in X section (TODO).
See the handbook page on common errors and warnings.  





<!-- ======================================================= -->
### Error versus Warning  

When a command is run, the R Console may show you warning or error messages in red text.  

* A **warning** means that R has completed your command, but had to take additional steps or produced unusual output that you should be aware of.  

* An **error** means that R was not able to complete your command.  

Look for clues: 

* The error/warning message will often include a line number for the problem.  

* If an object "is unknown" or "not found", perhaps you spelled it incorrectly, forgot to call a package with library(), or forgot to re-run your script after making changes.  

If all else fails, copy the error message into Google along with some key terms - chances are that someone else has worked through this already!


<!-- ======================================================= -->
### General syntax tips

A few things to remember when writing commands in R, to avoid errors and warnings:  

* Always close parentheses - tip: count the number of opening "(" and closing parentheses ")" for each code chunk
* Avoid spaces in column and object names. Use underscore ( _ ) or periods ( . ) instead
* Keep track of and remember to separate a function's arguments with commas
* R is case-sensitive, meaning `Variable_A` is *different* from `variable_A`


<!-- ======================================================= -->
### Code assists  

Any script (RMarkdown or otherwise) will give clues when you have made a mistake. For example, if you forgot to write a comma where it is needed, or to close a parentheses, RStudio will raise a flag on that line, on the right side of the script, to warn you.  

(/images/Warnings_and_Errors.png)





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Recommended training { }


### Resources within RStudio  

**Help documentation**  

Search the RStudio "Help" tab for documentation on packages and specific functions. This is within the pane that also contains Files, Plots, and Packages (typically in the lower-right pane). As a shortcut, you can also type the name of a package or function into the R console after a question-mark to open the relevant Help page. For example:  `?filter`  or `?diagrammeR`.  

**Interactive tutorials**  

RStudio has built-in interative tutorials via the **learnr** package. If this package is installed, you can go through these tutorials via the "Tutorial" tab in the upper-right RStudio pane (which also contains Environment and History tabs).  



### Cheatsheets

This is an online R resource specifically for [Excel users](https://jules32.github.io/r-for-excel-users/vlookup.html)  

There are many cheatsheets available on the [RStudio website](https://rstudio.com/resources/cheatsheets/), for example:  

* Factors with **forcats** package  
* Dates and times with **lubridate** package  
* Strings with **stringr** pacage  
* "apply" functions with **purrr** package  
* Data import cheatsheet  
* Data transformation cheatsheet with **dplyr** package  
* R Markdown  
* Shiny  
* Data viz with **ggplot2** package  
* Cartography  
* **leaflet** package
* Python with R (**reticulate** package)  


### Free online books  

A definitive text is the [R for Data Science](https://r4ds.had.co.nz/) book by Garrett Grolemund and Hadley Wickham


<!-- ======================================================= -->
### Courses




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/basics.Rmd-->

# R Markdown {.tabset .tabset-fade}  

R Markdown is a fantastic tool for creating automated, reproducible, and share-worthy outputs. It can generate static or interactive outputs, in the form of html, word, pdf, powerpoint, and others. 

<!-- ======================================================= -->
## Overview {.tabset .tabset-fade .tabset-pills}

Using markdown will allow you easily recreate an entire formatted document, including tables/figures/text, using new data (e.g. daily surveillance reports) and/or subsets of data (e.g. reports for specific geographies). 

This guide will go through the basics. See 'resources' tab for further info.

<!-- ======================================================= -->
## Preparation {.tabset .tabset-fade .tabset-pills}

**Background to Markdown**

To explain some of the concepts and packages involved:

* **Markdown** is a lightweight markup language, with syntax that allows for plain text formatting so that it can be converted to html and other formats. It is not specific to R, and usually a markdown file has an '.md' extension. 
* **R Markdown - the language**: This is an extension of markdown that _is_ specific to R, with file extensions '.Rmd'. This allows R code to be embedded in 'chunks' so that the code itself can be run, rather than just having a text document. 
* **Rmarkdown - the package**: This is used by R to render the .Rmd file into the desire output. However its focus is the markdown (text) syntax, so we also need...
* **Knitr**: This package will read the code chunks, execute it, and 'knit' it back into the document. This is how tables and graphs are included alongside the text.
* **Pandoc**: Finally, pandoc is needed to actually convert documents into e.g. word/pdf/powerpoint etc. It is separate from R. 

The R Studio website describes how these all link in together (https://rmarkdown.rstudio.com/authoring_quick_tour.html): 

>Creating documents with R Markdown starts with an .Rmd file that contains a combination of markdown (content with simple text formatting) and R code chunks. The .Rmd file is fed to knitr, which executes all of the R code chunks and creates a new markdown (.md) document which includes the R code and its output.
>
>The markdown file generated by knitr is then processed by pandoc which is responsible for creating a finished web page, PDF, MS Word document, slide show, handout, book, dashboard, package vignette or other format.
>
>This may sound complicated, but R Markdown makes it extremely simple by encapsulating all of the above processing into a single render function. Better still, RStudio includes a “Knit” button that enables you to render an .Rmd and preview it using a single click or keyboard shortcut.

![](../images/markdown/0_rmd.png)

**Installation**

To create R Markdown, you need to have the following installed:

* The Rmarkdown package, as described above: `install.packages('rmarkdown')`
* Pandoc, which should come with RStudio. If you are not using RStudio, you can download it here: http://pandoc.org. 
* If you want to generate PDF output (a bit trickier), you will need to install LaTeX. For R Markdown users who have not installed LaTeX before, we recommend that you install TinyTeX (https://yihui.name/tinytex/): 

```
install.packages('tinytex')
tinytex::install_tinytex()  # install TinyTeX
```

**Workflow**

Preparation of an R Markdown workflow involves ensuring you have set up an R project and have a folder structure that suits the desired workflow. 

For instance, you may want an 'output' folder for your rendered documents, an 'input' folder for new cleaned data files, as well as subfolders within them which are date-stamped or reflect the subgeographies of interest. The markdown itself can go in a 'rmd' subfolder, particularly if you have multiple Rmd files within the same project. 

You can set code up to create output subfolders for you each time you run reports (see "Producing an output"), but you should have the overall design in mind. 

Because R Markdown can run into pandoc issues when running on a shared network drive, it is recommended that your folder is on your local machine, e.g. in a project within 'My Documents'. If you use Git (much recommended!), this will be familiar. 


<!-- ======================================================= -->
## The R Markdown file {.tabset .tabset-fade .tabset-pills}

An R Markdown document looks like and can be edited just like a standard R script, in R Studio. However, it contains more than just the usual R code and hashed comments. There are three basic components:

**1. Metadata**: This is referred to as the ‘YAML metadata’ and is at the top of the R Markdown document between two ‘- - -‘s. It will tell your Rmd file what type of output to produce, formatting preferences, and other metadata sucsh as document title, author, and date. There are other uses not mentioned here (but referred to in ‘Producing an output’). Note that indentation matters. 

![](../images/markdown/1_yaml.png)

**2. Text**: This is the narrative of your document, including the titles. It is written in the markdown language, used across many different programmes. This means you can add basic formatting, for instance:

* `_text_` or `*text*` to _italicise_
* `**text**` for **bold text**
* `#` at the start of a new line for a title (and `##` for second-level title, `##` for third-level title etc)
* `*` at the start of a new line for bullet points 
* ```text``` to display text as code (as above)

The actual appearance of the font can be set by using specific templates (specified in the YAML metadata; see example tabs).  

You can also include minimal R code within backwards ticks, for within-text values. See example below.

![](../images/markdown/2_text.png)

**3. Code chunks**: This is where the R code goes, for the actual data management and visualisation. To note:
These ‘chunks’ will appear to have a slightly different background colour from the narrative part of the document. 

Each chunk always starts with three backticks and chunk information within squiggly brackets, and ends with three more backticks.

Some notes about the content of the squiggly brackets:

*	They start with ‘r’ to indicate that the language name within the chunk is r
*	Followed by the chunk name - note this should ALWAYS be a unique name or else R will complain when you try to render. 
*	It can include other options too, but many of these can be configured with point-and-click using the setting buttons at the top right of the chunk. Here, you can specify which parts of the chunk you want the rendered document to include, namely the code, the outputs, and the warnings. This will come out as written preferences within the squiggly brackets, e.g. ‘echo=FALSE’ if you specify you want to ‘Show output only’. 

There are also two arrows at the top right of each chunk, which are useful to run code within a chunk, or all code in prior chunks. 
![](../images/markdown/3_chunk.png)

<!-- ======================================================= -->
## Producing an output {.tabset .tabset-fade .tabset-pills}

**General notes**

Everything used by this markdown must be referenced within the Rmd file. For instance, you need to load any required packages or data. 

**A single or test run from within R Markdown**

To render a single document, for instance if you are testing it or if you only need to produce one rendered document at a time, you can do it from within the open R Markdown file. Click the ![](../images/markdown/4_knitbutton.png) button at the top of the document. 

The 'R Markdown' tab will start processing to show you the overall progress, and a complete document will automatically open when complete. This document will also be saved in the same folder as your markdown, and with the same file name aside from the file extension. This is obviously not ideal for version control, as you will then rename the file yourself.

**A single run from an separate script**

To run the markdown so that a date-stamped file is produced, you can create a separate script and call the Rmd file from within it. You can also specify the folder and file name, and include a dynamic date and time, so that file will be date stamped on production. 


```
rmarkdown::render(("rmd_reports/create_RED_report.Rmd"),  
                        output_file = paste0("outputs/Report_", Sys.Date, ".docx")) # Use 'paste0' to combine text and code for a dynamic file name
``` 
**Routine runs into newly created date-stamped sub folders**

Add a couple lines of code to define the date you are running the report (e.g. using Sys.Date as in the example above) and create new sub folders. If you want the date to reflect a specific date rather than the current date, you can also enter it as an object. 

```
# Set the date of report
refdate <- as.Date("2020-12-21")

# Create the folders
outputfolder <- paste0("outputs/", refdate) # This is the new folder name
dir.create(outputfolder) # Creates the folder (in this case assumed 'outputs' already exists)

#Run the loop
rmarkdown::render(("rmd_reports/create_report.Rmd"),  
                        output_file = paste0(outputfolder, "/Report_", refdate, ".docx")) #Dyanmic folder name now included
``` 

You may want some dynamic information to be included in the markdown itself. This is addressed in the next section. 

<!-- ======================================================= -->
## Parametrised reports {.tabset .tabset-fade .tabset-pills}

Parameterised reports are the next step so that the content of the R Markdown itself can also be dynamic. For example, the title can change according to the subgeography you are running, and the data can filter to that subgeography of interest. 

Let's say you want to run the markdown to produce a report with surveillance data for Area1 and Area2. You will:

1. Edit your R Markdown:
  a) Change your YAML metadata to include a 'params' section, which specifies the dynamic object. 
  b) Refer to this parameterised object within the code as needed. E.g. `filter(area == params$areanumber)` rather than `filter(area=="Area1")`. 
  
For instance (simplified version which does not include setup code such as library/data loading):

![](../images/markdown/5_parameterized.png)

You can change the content by editing the YAML as needed, or set up a loop in a separate script to iterate through the areas. As with the previous section, you can set up the folders as well. 

As you can see below, you set up a list which includes all areas of interest (`arealist`), and when rendering the markdown you specify that the parameterized `areanumber` for a specific iteration is the Nth value of the arealist. For instance, for the first iteration, areanumber will equate to "Area1". The code below also specifies that the Nth area name will be included in the output file name. 

Note that this will work even if an area or date are specified within the YAML itself - that YAML information will get overwritten by the loop. 

```
# Set the date of report
refdate <- as.Date("2020-12-21")

# Set the list (note that this can also be an imported list)
arealist <- c("Area1", "Area2", "Area3", "Area4", "Area5")

# Create the folders
outputfolder <- paste0("outputs/", refdate) # This is the new folder name
dir.create(outputfolder) # Creates the folder (in this case assumed 'outputs' already exists)

#Run the loop

for(i in 1:length(arealist))  { # This will loop through from the first value to the last value in 'arealist'

rmarkdown::render(here("rmd_reports/create_report.Rmd"), 
                        params = list(areanumber = arealist[1], #Assigns the nth value of arealist to the current areanumber
                                      refdate = refdate),
                        output_file = paste0(outputfolder, "/Report_", arealist[1], refdate, ".docx")) 
                        
}


``` 


<!-- ======================================================= -->
## Resources {.tabset .tabset-fade .tabset-pills}

Further information can be found via:

* https://bookdown.org/yihui/rmarkdown/
* https://rmarkdown.rstudio.com/articles_intro.html

A good explainer of markdown vs knitr vs Rmarkdown is here: https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))
```

<!--chapter:end:new_pages/rmarkdown.Rmd-->

