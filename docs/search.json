[{"path":"index.html","id":"welcome","chapter":"1 Welcome","heading":"1 Welcome","text":"","code":""},{"path":"index.html","id":"about-this-handbook","chapter":"1 Welcome","heading":"1.1 About this handbook","text":"ObjectiveA free open-access digital R reference book catered epidemiologists public health practitioners usable offline addresses common epidemiological tasks via clear text explanations, step--step instructions, best practice R code examplesEpis using R must often Google search read dozens forum pages complete common data manipulation visualization epi tasks. However, field epidemiologists often work low internet-connectivity environments limited technical support. handbook aims fill gap.read handbook:HTML file can viewed offline, best viewed Google Chrome.HTML file can viewed offline, best viewed Google Chrome.Search via search box Table Contents. Ctrl+f search across current page.Search via search box Table Contents. Ctrl+f search across current page.Click “clipboard” icon upper-right code chunk copy .Click “clipboard” icon upper-right code chunk copy .Version\r\nlatest version handbook can found github repository.","code":""},{"path":"index.html","id":"acknowledgements","chapter":"1 Welcome","heading":"1.2 Acknowledgements","text":"","code":""},{"path":"index.html","id":"contributors","chapter":"1 Welcome","heading":"1.2.1 Contributors","text":"Editor--Chief: Neale Batra (neale.batra@gmail.com)Editorial core team: …Authors: …Reviewers: …Advisers …","code":""},{"path":"index.html","id":"funding-and-programmatic-support","chapter":"1 Welcome","heading":"1.2.2 Funding and programmatic support","text":"TEPHINET\r\nEAN","code":""},{"path":"index.html","id":"data-sources","chapter":"1 Welcome","heading":"1.2.3 Data sources","text":"outbreaks R package","code":""},{"path":"index.html","id":"inspiration-and-templates","chapter":"1 Welcome","heading":"1.2.4 Inspiration and templates","text":"R4Epis\r\nRECON packages\r\nR4DS book (Hadley)\r\nBookdown book (Yihui)\r\nRmarkdown book (Yihui)","code":""},{"path":"index.html","id":"image-credits","chapter":"1 Welcome","heading":"1.2.5 Image credits","text":"Logo: CDC Public Image gallery; R Graph Gallery","code":""},{"path":"style-and-editorial-notes.html","id":"style-and-editorial-notes","chapter":"2 Style and editorial notes","heading":"2 Style and editorial notes","text":"","code":""},{"path":"style-and-editorial-notes.html","id":"style","chapter":"2 Style and editorial notes","heading":"2.1 Style","text":"","code":""},{"path":"style-and-editorial-notes.html","id":"text-style","chapter":"2 Style and editorial notes","heading":"2.1.1 Text style","text":"Package function namesPackage names written bold (e.g. dplyr) functions written like : mutate(). Packages referenced either text within code like : dplyr::mutate()Types notesNOTE: noteTIP: tip.CAUTION: cautionary note.DANGER: warning.","code":""},{"path":"style-and-editorial-notes.html","id":"tidyverse","chapter":"2 Style and editorial notes","heading":"2.1.2 tidyverse","text":"handbook generally uses tidyverse R coding style. Read ","code":""},{"path":"style-and-editorial-notes.html","id":"code-readability","chapter":"2 Style and editorial notes","heading":"2.1.3 Code readability","text":"chose frequently write code new lines, order offer understandable comments. result, code written like :…often written like :","code":"\nobs %>% \n  group_by(name) %>%                    # group the rows by 'name'\n  slice_max(date, n = 1, with_ties = F) # if there's a tie (of date), take the first row\nobs %>% \n  group_by(name) %>%   # group the rows by 'name'\n  slice_max(\n    date,              # keep row per group with maximum date value \n    n = 1,             # keep only the single highest row \n    with_ties = F)     # if there's a tie (of date), take the first row"},{"path":"style-and-editorial-notes.html","id":"editorial-decisions","chapter":"2 Style and editorial notes","heading":"2.2 Editorial decisions","text":", track significant editorial decisions around package function choice. disagree want offer new tool, please join/start conversation Github page.Table package, function, editorial decisions","code":""},{"path":"datasets-used.html","id":"datasets-used","chapter":"3 Datasets used","heading":"3 Datasets used","text":"datasets used handbook described downloadableLinelist (…)Aggregated case counts (…)GIS shapefile (…)modeling dataset? (…)","code":""},{"path":"cleaning-data.html","id":"cleaning-data","chapter":"4 Cleaning data","heading":"4 Cleaning data","text":"","code":""},{"path":"cleaning-data.html","id":"overview","chapter":"4 Cleaning data","heading":"4.1 Overview","text":"page demonstrates common steps necessary clean dataset. uses simulated Ebola case linelist, used throughout handbook.Dealing character case (upper, lower, title, etc.)Factor columnsreplace missing \r\ndealing cases (lower, etc)\r\ncase_when()\r\nfactors","code":""},{"path":"cleaning-data.html","id":"preparation","chapter":"4 Cleaning data","heading":"4.2 Preparation","text":"","code":""},{"path":"cleaning-data.html","id":"load-packages","chapter":"4 Cleaning data","heading":"4.2.1 Load packages","text":"","code":"\npacman::p_load(tidyverse,  # data manipulation and visualization\n               janitor,    # data cleaning\n               rio,        # importing data\n               epikit)     # age_categories() function  "},{"path":"cleaning-data.html","id":"load-data","chapter":"4 Cleaning data","heading":"4.2.2 Load data","text":"Import raw dataset using import() function package rio. (LINK IMPORT PAGE)can view first 50 rows original “raw” dataset :","code":"## New names:\r\n## * `` -> ...28\nlinelist_raw <- import(\"linelist_raw.xlsx\")"},{"path":"cleaning-data.html","id":"cleaning-pipeline","chapter":"4 Cleaning data","heading":"4.3 Cleaning pipeline","text":"epidemiological analysis data processing, cleaning steps often performed together sequentially. R often manifests cleaning “pipeline”, raw dataset passed “piped” one cleaning step another. chain utilizes dplyr verbs magrittr pipe operator (see handbook page dplyr tidyverse coding style (LINK ). pipe begins “raw” data (linelist_raw) ends “clean” dataset (linelist).cleaning pipeline order steps important. Cleaning steps might include:Importing dataColumn names cleaned changedRows filtered, added, de-duplicatedColumns selected, added, transformed, re-orderedValues re-coded, cleaned, grouped","code":""},{"path":"cleaning-data.html","id":"column-names","chapter":"4 Cleaning data","heading":"4.4 Column names","text":"Column names used often need “clean” syntax. suggest following:Short namesNo spaces (replaced underscores (_),unusual characters (&, #…)Similar style nomenclature (e.g. date columns named like date_onset, date_report, date_death…)columns names linelist_raw . can see spaces. also different naming patterns dates (‘date onset’ ‘infection date’).Also note raw data, two final columns names two merged cells one name. import() function used name first two columns, assigned second column name “…23” empty (referring 23rd column).","code":"\nnames(linelist_raw)##  [1] \"row_num\"         \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"      \"hosp date\"       \"date_of_outcome\"\r\n##  [8] \"outcome\"         \"gender\"          \"hospital\"        \"lon\"             \"lat\"             \"infector\"        \"source\"         \r\n## [15] \"age\"             \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"age_unit\"        \"fever\"           \"chills\"         \r\n## [22] \"cough\"           \"aches\"           \"vomit\"           \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\"Note: For a column name that include spaces, surround the name with back-ticks, for example: linelist$`infection date`. On a keyboard, the back-tick (`) is different from the single quotation mark ('), and is sometimes on the same key as the tilde (~)."},{"path":"cleaning-data.html","id":"automatic-colummn-name-cleaning","chapter":"4 Cleaning data","heading":"4.4.1 Automatic colummn name cleaning","text":"function clean_names() package janitor standardizes column names makes unique following:Converts names consist underscores, numbers, lettersAccented characters transliterated ASCII (e.g. german o umlaut becomes “o”, spanish “enye” becomes “n”)Capitalization preference can specified using case = argument (“snake” default, alternatives include “sentence”, “title”, “small_camel”…)can designate specific name replacements replace = argument (e.g. replace = c(onset = “date_of_onset”))online vignetteBelow, cleaning pipeline begins using clean_names() raw linelist.NOTE: column name “…28” changed “x28”.","code":"\n# send the dataset through the function clean_names()\nlinelist <- linelist_raw %>% \n  janitor::clean_names()\n\n# see the new names\nnames(linelist)##  [1] \"row_num\"         \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"      \"hosp_date\"       \"date_of_outcome\"\r\n##  [8] \"outcome\"         \"gender\"          \"hospital\"        \"lon\"             \"lat\"             \"infector\"        \"source\"         \r\n## [15] \"age\"             \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"age_unit\"        \"fever\"           \"chills\"         \r\n## [22] \"cough\"           \"aches\"           \"vomit\"           \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\""},{"path":"cleaning-data.html","id":"manual-column-name-cleaning","chapter":"4 Cleaning data","heading":"4.4.2 Manual column name cleaning","text":"Re-naming columns manually often necessary. , re-naming performed using rename() function dplyr package, part pipe chain. rename() uses style “NEW = OLD”, new column name given old column name., re-name command added cleaning pipeline:Now can see columns names changed:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)"},{"path":"cleaning-data.html","id":"rename-by-column-position","chapter":"4 Cleaning data","heading":"4.4.2.1 Rename by column position","text":"can also rename column position, instead column name, example:","code":"\nrename(newNameForFirstColumn = 1,\n       newNameForSecondColumn = 2)"},{"path":"cleaning-data.html","id":"empty-excel-column-names","chapter":"4 Cleaning data","heading":"4.4.2.2 Empty Excel column names","text":"importing Excel sheet missing column name, depending import function used, R likely create column name value like “…1” “…2”. can clean names manually referencing position number (see ), name (linelist_raw$...1).","code":""},{"path":"cleaning-data.html","id":"merged-excel-column-names","chapter":"4 Cleaning data","heading":"4.4.3 Merged Excel column names","text":"Merged cells Excel file common occurrence receiving data field level. Merged cells can nice human reading data, cause many problems machine reading data. R accommodate merged cells.Remind people data entry human-readable data machine-readable data. Strive train users princiles tidy data. possible, try change procedures data arrive tidy format without merged cells.variable must column.observation must row.value must cell.using rio’s import() function, value merged cell assigned first cell subsequent cells empty.One solution deal merged cells import data function readWorkbook() package openxlsx. Set argument fillMergedCells = TRUE. gives value merged cell cells within merge range.DANGER: column names merged, end duplicate column names, need fix manually - R work well duplicate column names! can re-name referencing position (e.g. column 5), explained section manual column name cleaning..","code":"\nlinelist_raw <- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)"},{"path":"cleaning-data.html","id":"skip-import-of-rows","chapter":"4 Cleaning data","heading":"4.4.4 Skip import of rows","text":"Sometimes, may want avoid importing row data (e.g. column names, row 1).\r\ncan argument skip = using import() rio package .xlsx .csv file. Provide number rows want skip.Unfortunately skip = accepts one integer value, range (e.g. “2:10”). skip import specific rows consecutive top, consider importing multiple times using bind_rows() dplyr. See example skipping row 2.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\", skip = 1)  # does not import header row"},{"path":"cleaning-data.html","id":"removing-a-second-header-row","chapter":"4 Cleaning data","heading":"4.4.4.1 Removing a second header row","text":"data may second row data, example “data dictionary” row (see example ).situation can problematic can result columns imported class “character”. solve , likely need import data twice.Import data order store correct column namesImport data , skipping first two rows (header second rows)Bind correct names onto reduced dataframeThe exact arguments used bind correct column names depends type data file (.csv, .tsv, .xlsx, etc.). using rio’s import() function, understand function rio uses import data, give appropriate argument skip lines /designate column names. See handbook page importing data (LINK) details rio.Excel files:CSV files:Backup option - changing column names separate commandBonus! second row data dictionary, can easily create proper data dictionary using gather() command tidyr package.\r\nsource: https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/","code":"\n# For excel files (remove 2nd row)\nlinelist_raw_names <- import(\"linelist_raw.xlsx\") %>% names()  # save true column names\n\n# import, skip row 2, assign to col_names =\nlinelist_raw <- import(\"linelist_raw.xlsx\", skip = 2, col_names = linelist_raw_names) \n# For csv files\nlinelist_raw_names <- import(\"linelist_raw.csv\") %>% names() # save true column names\n\n# note argument is 'col.names ='\nlinelist_raw <- import(\"linelist_raw.csv\", skip = 2, col.names = linelist_raw_names) \n# assign/overwrite headers using the base 'colnames()' function\ncolnames(linelist_raw) <- linelist_raw_names\nlibrary(tidyr)\nstickers_dict <- import(\"linelist_raw.xlsx\") %>% \n  clean_names() %>% \n  gather(variable_name, variable_description)\nstickers_dict"},{"path":"cleaning-data.html","id":"combine-two-header-rows","chapter":"4 Cleaning data","heading":"4.4.5 Combine two header rows","text":"cases, may want combine two header rows one. command define column names combination (pasting together) existing column names value underneath first row. Replace “df” name dataset.","code":"\nnames(df) <- paste(names(df), df[1, ], sep = \"_\")"},{"path":"cleaning-data.html","id":"select-or-re-order-columns","chapter":"4 Cleaning data","heading":"4.5 Select or re-order columns","text":"CAUTION: tab may follow previous tabs.Often first step cleaning data selecting columns want work , set order dataframe. dplyr chain verbs, done select(). Note examples modify linelist select(), assign/overwrite. just display resulting new column names, purpose example.CAUTION: examples , linelist modified select() -written. New column names displayed purpose example.column names linelist:","code":"\nnames(linelist)##  [1] \"row_num\"              \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"          \r\n##  [6] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"              \"gender\"               \"hospital\"            \r\n## [11] \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \r\n## [16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"age_unit\"             \"fever\"               \r\n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"                \"temp\"                \r\n## [26] \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"cleaning-data.html","id":"select-re-order","chapter":"4 Cleaning data","heading":"4.5.1 Select & re-order","text":"Select columns want remain, order appearanceIndicate columns remove placing minus symbol “-” front column name (e.g. select(-outcome)), vector column names (). columns retained. Inside select() can use normal operators c() list several columns, : consecutive columns, ! opposite, & , | .Re-order columns - use everything() signify columns specified select() command:well everything() several special functions work within select(), namely:everything() - columns mentionedlast_col() - last columnwhere() - applies function columns selects TRUEstarts_with() - matches specified prefix. Example: select(starts_with(\"date\"))ends_with() - matches specified suffix. Example: select(ends_with(\"_end\"))contains() - columns containing character string. Example: select(contains(\"time\"))matches() - apply regular expression (regex). Example: select(contains(\"[pt]al\"))num_range() -any_of() - matches column named. Useful name might exist. Example: select(any_of(date_onset, date_death, cardiac_arrest))example using ():","code":"\n# linelist dataset is piped through select() command, and names() prints just the column names\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, fever) %>% \n  names() # display the column names## [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\" \"fever\"\nlinelist %>% \n  select(-c(date_onset, fever:vomit)) %>% # remove onset and all symptom columns\n  names()##  [1] \"row_num\"              \"case_id\"              \"generation\"           \"date_infection\"       \"date_hospitalisation\"\r\n##  [6] \"date_outcome\"         \"outcome\"              \"gender\"               \"hospital\"             \"lon\"                 \r\n## [11] \"lat\"                  \"infector\"             \"source\"               \"age\"                  \"wt_kg\"               \r\n## [16] \"ht_cm\"                \"ct_blood\"             \"age_unit\"             \"temp\"                 \"time_admission\"      \r\n## [21] \"merged_header\"        \"x28\"\n# move case_id, date_onset, date_hospitalisation, and gender to beginning\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, gender, everything()) %>% \n  names()##  [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\" \"gender\"               \"row_num\"             \r\n##  [6] \"generation\"           \"date_infection\"       \"date_outcome\"         \"outcome\"              \"hospital\"            \r\n## [11] \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \r\n## [16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"age_unit\"             \"fever\"               \r\n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"                \"temp\"                \r\n## [26] \"time_admission\"       \"merged_header\"        \"x28\"\n# select columns containing certain characters\nlinelist %>% \n  select(contains(\"date\")) %>% \n  names()## [1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"\n# searched for multiple character matches\nlinelist %>% \n  select(matches(\"onset|hosp|fev\")) %>%   # note the OR symbol \"|\"\n  names()## [1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"             \"fever\""},{"path":"cleaning-data.html","id":"select-as-a-stand-alone-command","chapter":"4 Cleaning data","heading":"4.5.2 select() as a stand-alone command","text":"Select can also used independent command (pipe chain). case, first argument original dataframe operated upon.","code":"\n# Create a new linelist with id and age-related columns\nlinelist_age <- select(linelist, case_id, contains(\"age\"))\n\n# display the column names\nnames(linelist_age)## [1] \"case_id\"  \"age\"      \"age_unit\""},{"path":"cleaning-data.html","id":"add-to-the-pipe-chain","chapter":"4 Cleaning data","heading":"4.5.3 Add to the pipe chain","text":"linelist, columns need: row_num, merged_header, x28. Remove adding select() command cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28))"},{"path":"cleaning-data.html","id":"Classes","chapter":"4 Cleaning data","heading":"4.6 Modify class","text":"CAUTION: tab may follow previous tabs.See section object classesOften need set correct class column. common approach use mutate() define column , different class. Generally, looks like :","code":"\n# Examples of modifying class\nlinelist <- linelist %>% \n  mutate(date_var      = as.Date(date_var, format = \"MM/DD/YYYY\"),  # format should be the format of the raw data\n         numeric_var   = as.numeric(numeric_var),\n         character_var = as.character(character_var),\n         factor_var    = factor(factor_var, levels = c(), labels = c())\n         )"},{"path":"cleaning-data.html","id":"pre-checks-and-errors","chapter":"4 Cleaning data","heading":"4.6.1 Pre-checks and errors","text":"First run checks classes important columns.class “age” column character. perform analysis, need numbers recognized numeric!class “date_onset” column also character! perform analysis, dates must recognized dates!However, try classify date_onset column date, get error. Use table() sort another method examine values identify different one. example dataset see see one date_onset value entered different format (15th April 2014) values!can classify “date_onset” date, value must fixed format others. can fix date source data, , can cleaning pipeline via mutate() recode(). must done commands convert class Date. (LINK DATE SECTION).mutate() line can read : “mutate date_onset equal date_onset recoded OLD VALUE changed NEW VALUE”. Note pattern (OLD = NEW) recode() opposite R patterns (new = old). R development community working revising recoding.Especially converting class date, check data visually table() confirm converted correctly! .Date(), format = argument often source errors.","code":"\nclass(linelist$age)## [1] \"character\"\nclass(linelist$date_onset)## [1] \"character\"## \r\n## 15th April 2014      2012-04-21      2012-05-09      2012-05-14      2012-05-27      2012-06-22 \r\n##               1               1               1               1               2               1\n# fix incorrect values                 # old value       # new value\nmutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\"))"},{"path":"cleaning-data.html","id":"modify-multiple-columns","chapter":"4 Cleaning data","heading":"4.6.2 Modify multiple columns","text":"can use dplyr function across() mutate() convert several columns new class. across() allows specify columns want function apply . , want mutate columns .POSIXct() (type date/time class shows unnecessary timestamps) TRUE, apply function .Date() , order convert class “date”.Note within across() also use function ().Note .POSIXct package lubridate. similar functions (.character(), .numeric(), .logical()) base RNote functions across() written without empty parentheses (), described cleaning steps added pipe chain.","code":"\nlinelist <- linelist %>% \n  mutate(across(where(lubridate::is.POSIXct), as.Date))\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n\n  \n# ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n  ###################################################\n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n  \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) "},{"path":"cleaning-data.html","id":"add-columns-and-rows","chapter":"4 Cleaning data","heading":"4.7 Add columns and rows","text":"See tabs add columns rows","code":""},{"path":"cleaning-data.html","id":"add-columns","chapter":"4 Cleaning data","heading":"4.7.1 Add columns","text":"","code":""},{"path":"cleaning-data.html","id":"mutate","chapter":"4 Cleaning data","heading":"4.7.1.1 mutate()","text":"advise creating new columns dplyr functions part chain verb functions (e.g. filter, mutate, etc.)\r\nneed stand-alone command, can use mutate() base R style create new column (see ).verb mutate() used add new column, modify existing one. example creating new columns mutate(). syntax : new_column_name = value function.best practice separate new column comma new line. , practice columns created:Scroll right see new columns (first 50 rows):TIP: verb transmute() adds new columns just like mutate() also drops/removes columns mention.","code":"\nlinelist <- linelist %>% \n  mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset))\nlinelist <- linelist %>%                       # creating new, or modifying old dataset\n  mutate(new_var_dup    = case_id,             # new column = duplicate/copy another column\n         new_var_static = 7,                   # new column = all values the same\n         new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables\n         new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # new column = pasting together values from other columns\n         ) "},{"path":"cleaning-data.html","id":"new-columns-using-base-r","chapter":"4 Cleaning data","heading":"4.7.1.2 New columns using base R","text":"define new column (re-define column) using base R, just use assignment operator .\r\nRemember using base R must specify dataframe writing column name (e.g. dataframe$column). two dummy examples:","code":"\nlinelist$old_var <- linelist$old_var + 7\nlinelist$new_var <- linelist$old_var + linelist$age"},{"path":"cleaning-data.html","id":"add-rows","chapter":"4 Cleaning data","heading":"4.7.2 Add rows","text":"DORemember column must contain values one class (either character, numeric, logical, etc.). adding row requires nuance maintain .use ... .= 3 put 3rd row. Default add end. columns specified let empty.\r\nnew row number may look strange (“…23”) row numbers changed. using command twice examine/test carefully.class see error like : Error: Can’t combine ..1$infection date  ..2$infection date .\r\n(date value remember wrap date functionas.Date() like .Date(\"2020-10-10\"))","code":"\nlinelist <- linelist %>% \n  add_row(row_num = 666, case_id = \"abc\", generation = 4, `infection date` = as.Date(\"2020-10-10\"), .before = 2)"},{"path":"cleaning-data.html","id":"new-columns-using-grouped-values","chapter":"4 Cleaning data","heading":"4.7.3 New columns using grouped values","text":"CAUTION: tab may follow previous tabs.Using mutate GROUPED dataframes\r\nhttps://dplyr.tidyverse.org/reference/mutate.htmlTaken website :","code":"#Because mutating expressions are computed within groups, they may yield different results on grouped tibbles. This will be the case as #soon as an aggregating, lagging, or ranking function is involved. Compare this ungrouped mutate:\r\n\r\nstarwars %>%\r\n  select(name, mass, species) %>%\r\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\r\nWith the grouped equivalent:\r\n\r\nstarwars %>%\r\n  select(name, mass, species) %>%\r\n  group_by(species) %>%\r\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\r\nThe former normalises mass by the global average whereas the latter normalises by the averages within species levels."},{"path":"cleaning-data.html","id":"add-to-pipe-chain","chapter":"4 Cleaning data","heading":"4.7.4 Add to pipe chain","text":"","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n\n  # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n  ###################################################\n\n  # create column: delay to hospitalisation\n  mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset))"},{"path":"cleaning-data.html","id":"recode","chapter":"4 Cleaning data","heading":"4.8 Recoding values","text":"example, linelist values column “hospital” must cleaned. several different spellings (often word “Hospital” missing “s” written “Hopital”), many missing values.","code":"\ntable(linelist$hospital, useNA = \"always\")## \r\n##                      Central Hopital                     Central Hospital                           Hospital A \r\n##                                   11                                  454                                  289 \r\n##                           Hospital B                     Military Hopital                    Military Hospital \r\n##                                  289                                   31                                  802 \r\n##                     Mitylira Hopital                    Mitylira Hospital                                Other \r\n##                                    1                                   82                                  902 \r\n##                         Port Hopital                        Port Hospital St. Mark's Maternity Hospital (SMMH) \r\n##                                   47                                 1760                                  426 \r\n##   St. Marks Maternity Hopital (SMMH)                                 <NA> \r\n##                                   11                                 1504"},{"path":"cleaning-data.html","id":"manual-recoding","chapter":"4 Cleaning data","heading":"4.8.1 Manual recoding","text":"tabs demonstrate re-coding values manually b providing specific spellings corrected:Using replace() specific rowsUsing recode() entire columnsUsing base R","code":""},{"path":"cleaning-data.html","id":"replace","chapter":"4 Cleaning data","heading":"4.8.1.1 replace()","text":"manually change values specific rows within dataframe (within pipe chain), use replace() within mutate().\r\nUse logic condition specify rows, example ID value one row. general syntax :mutate(col_to_change = replace(col_to_change, criteria rows, new value)).first example , gender value, row id “2195”, changed “Female”.","code":"# Example: change gender of one specific observation to \"Female\" \r\nmutate(gender = replace(gender, id == \"2195\", \"Female\")\r\n\r\n# Example: chance gender of one specific observation to NA \r\nmutate(gender = replace(gender, id == \"2195\", NA)"},{"path":"cleaning-data.html","id":"recode-1","chapter":"4 Cleaning data","heading":"4.8.1.2 recode()","text":"change spellings manually, one--one, can use recode() function *within mutate() function. code saying column “hospital” defined current column “hospital”, certain changes (syntax OLD = NEW). Don’t forget commas!Now see values hospital column corrected:TIP: number spaces equals sign matter. Make code easier read aligning = rows. Also, consider adding hashed comment row clarify future readers side OLD side NEW. TIP: Sometimes blank character value exists dataset (recognized R’s value missing - NA). can reference value two quotation marks space inbetween (\"\").","code":"\nlinelist <- linelist %>% \n  mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\ntable(linelist$hospital, useNA = \"always\")## \r\n##                     Central Hospital                           Hospital A                           Hospital B \r\n##                                  465                                  289                                  289 \r\n##                    Military Hospital                                Other                        Port Hospital \r\n##                                  916                                  902                                 1807 \r\n## St. Mark's Maternity Hospital (SMMH)                                 <NA> \r\n##                                  437                                 1504"},{"path":"cleaning-data.html","id":"base-r","chapter":"4 Cleaning data","heading":"4.8.1.3 base R","text":"necessary, make manual changes specific value dataframe referencing row number case ID. remember better can make changes permanently underlying data!fake example. reads “Change value dataframe linelist‘s column onset_date (row linelist’s column case_id value ’9d4019’) .Date(\"2020-10-24\")”.","code":"\nlinelist$date_onset[linelist$case_id == \"9d4019\"] <- as.Date(\"2020-10-24\")"},{"path":"cleaning-data.html","id":"recoding-by-logic","chapter":"4 Cleaning data","heading":"4.8.2 Recoding by logic","text":"tabs demonstrate re-coding values column using logic conditions:Using case_when()Using ifelse() if_else()Using special dplyr recoding functions like:\r\nreplace_na()\r\nna_if()\r\ncoalesnce()\r\nreplace_na()na_if()coalesnce()","code":""},{"path":"cleaning-data.html","id":"case_when","chapter":"4 Cleaning data","heading":"4.8.2.1 case_when()","text":"need use logic statements recode values, want use operators like %%, use dplyr’s case_when() instead. use case_when() please read thorough explanation LINK, important differences recode() syntax logic order!Note Right-hand side (RHS) inputs must class (e.g. character, numeric, logical). Notice use special value NA_real_ instead just NA.","code":"\nlinelist <- linelist %>% \n  dplyr::mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # if age is given in years\n            age_unit == \"months\" ~ age/12,    # if age is given in months\n            is.na(age_unit)      ~ age,       # if age unit is missing, assume years\n            TRUE                 ~ NA_real_)) # Any other circumstance"},{"path":"cleaning-data.html","id":"ifelse-and-if_else","chapter":"4 Cleaning data","heading":"4.8.2.2 ifelse() and if_else()","text":"simple uses logical re-coding new variable creationgyou can use ifelse() if_else(). Though cases better use case_when().commands simplified versions else statement. general syntax ifelse(condition, value condition evaluates TRUE, value condition evaluates FALSE). used mutate(), row evaluated. if_else() special version dplyr handles dates condition.can tempting string together many ifelse commands… resist use case_when() instead! much simple, easier read, easier identify errors.IMAGE ifelse string X across .can reference columns ifelse() function within mutate():Example ifelse():Example if_else() (using dates):\r\nNote ‘true’ value date, ‘false’ value must also qualify date, hence using special character NA_real_ instead just NA.Note: want alternate value used code based circumstances, consider using switch() base R. example … . See section using switch() page R interactive console.","code":"\nlinelist <- linelist %>% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\nlinelist <- linelist %>% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))"},{"path":"cleaning-data.html","id":"recoding-using-special-dplyr-functions","chapter":"4 Cleaning data","heading":"4.8.3 Recoding using special dplyr functions","text":"","code":""},{"path":"cleaning-data.html","id":"using-replace_na","chapter":"4 Cleaning data","heading":"4.8.3.1 Using replace_na()","text":"change missing values (NA) specific character value, “Missing”, use function replace_na() within mutate(). Note used manner recode - name variable must repeated within replace_na().","code":"\nlinelist <- linelist %>% \n  mutate(hospital = replace_na(hospital, \"Missing\"))"},{"path":"cleaning-data.html","id":"using-na_if","chapter":"4 Cleaning data","heading":"4.8.3.2 Using na_if()","text":"Likewise can quickly convert specific character value NA using na_if(). command opposite one . converts values “Missing” NA.","code":"\nlinelist <- linelist %>% \n  mutate(hospital = na_if(hospital, \"Missing\"))"},{"path":"cleaning-data.html","id":"using-coalesce","chapter":"4 Cleaning data","heading":"4.8.3.3 Using coalesce()","text":"dplyr function finds first non-missing value position. , provide columns row fill value first non-missing value columns provided.example, might use thiscoalesce()` create “location” variable hypothetical variables “patient_residence” “reporting_jurisdiction”, prioritize patient residence information, exists.\r\nlead(), lag()\r\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall(),","code":"\nlinelist <- linelist %>% \n  mutate(location = coalesce(patient_residence, reporting_jurisdiction))"},{"path":"cleaning-data.html","id":"recoding-using-cleaning-dictionaries","chapter":"4 Cleaning data","heading":"4.8.4 Recoding using cleaning dictionaries","text":"CAUTION: tab may follow previous tabs.","code":"\n## load cleaning rules and only keep columns in mll\nmll_cleaning_rules <- import(here(\"dictionaries/mll_cleaning_rules.xlsx\")) %>%\n  filter(column %in% c(names(mll_raw), \".global\"))\n\n## define columns that are not cleand\nunchanged <- c(\n  \"epilink_relationship\",\n  \"narratives\",\n  \"epilink_relationship_detail\"\n)\n\nmll_clean <- mll_raw %>%\n  ## convert to tibble\n  as_tibble() %>%\n  ## clean columns using cleaning rules\n  clean_data(\n    wordlists = mll_cleaning_rules,\n    protect = names(.) %in% unchanged\n  )"},{"path":"cleaning-data.html","id":"add-to-pipe-chain-1","chapter":"4 Cleaning data","heading":"4.8.5 Add to pipe chain","text":"add described cleaning steps pipe chain.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n  \n    # create column: delay to hospitalisation\n  mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n\n# ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n  ###################################################\n\n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))"},{"path":"cleaning-data.html","id":"filter-rows","chapter":"4 Cleaning data","heading":"4.9 Filter rows","text":"CAUTION: tab may follow previous tabs.typical early cleaning step filter dataframe specific rows using dplyr verb filter(). Within filter(), give logic must TRUE row dataset kept.tabs show filter rows based simple complex logical conditions, filter/subset rows stand-alone command base R","code":""},{"path":"cleaning-data.html","id":"a-simple-filter","chapter":"4 Cleaning data","heading":"4.9.1 A simple filter()","text":"simple example re-defines dataframe linelist , filtered rows meet logical condition. rows logical statement within parentheses TRUE kept.case, logical statement !.na(case_id), asking whether value column case_id missing (NA). Thus, rows case_id missing kept.filter applied, number rows linelist 6609.filter applied, number rows linelist 6605.","code":"\nlinelist <- linelist %>% \n  filter(!is.na(case_id))  # keep only rows where case_id is not missing"},{"path":"cleaning-data.html","id":"a-complex-filter","chapter":"4 Cleaning data","heading":"4.9.2 A complex filter()","text":"complex example using filter():","code":""},{"path":"cleaning-data.html","id":"examine-the-data","chapter":"4 Cleaning data","heading":"4.9.2.1 Examine the data","text":"simple one-line command create histogram onset dates. See second smaller outbreak 2012-2013 also included dataset. analyses, want remove entries earlier outbreak.","code":"\nhist(linelist$date_onset, breaks = 50)"},{"path":"cleaning-data.html","id":"how-filters-handle-missing-numeric-and-date-values","chapter":"4 Cleaning data","heading":"4.9.2.2 How filters handle missing numeric and date values","text":"Can just filter date_onset rows June 2013? Caution! Applying code filter(date_onset > .Date(\"2013-06-01\"))) accidentally remove rows later epidemic missing date onset!DANGER: Filtering greater (>) less (<) date number can remove rows missing values (NA)! NA treated infinitely large small.","code":""},{"path":"cleaning-data.html","id":"design-the-filter","chapter":"4 Cleaning data","heading":"4.9.2.3 Design the filter","text":"Examine cross-tabulation make sure exclude correct rows:criteria can filter remove first outbreak dataset? see :first epidemic occurred Hospital , Hospital B, also 10 cases Port Hospital.Hospitals & B cases second epidemic, Port Hospital .want exclude:586 rows onset 2012 2013 either hospital , B, Port:\r\nExclude 549 rows onset 2012 2013\r\nExclude 37 rows Hospitals & B missing onset dates\r\nexclude 252 rows missing onset dates.\r\nExclude 549 rows onset 2012 2013Exclude 37 rows Hospitals & B missing onset datesDo exclude 252 rows missing onset dates.start linelist nrow(linelist). filter statement:re-make cross-tabulation, see Hospitals & B removed completely, 10 Port Hospital cases 2012 & 2013 removed, values - just wanted.Multiple statements can included within one filter command (separated commas), can always pipe separate filter() command clarity.Note: readers may notice easier just filter date_hospitalisation 100% complete. true. pdate_onset used purposes complex filter example.","code":"\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2012 2013 2014 2015 <NA>\r\n##   Central Hospital                        0    0  351   99   15\r\n##   Hospital A                            231   41    0    0   16\r\n##   Hospital B                            228   40    0    0   21\r\n##   Military Hospital                       0    0  679  204   33\r\n##   Missing                                 0    0 1119  322   60\r\n##   Other                                   0    0  685  173   44\r\n##   Port Hospital                           7    2 1368  344   86\r\n##   St. Mark's Maternity Hospital (SMMH)    0    0  330   93   14\r\n##   <NA>                                    0    0    0    0    0\nlinelist <- linelist %>% \n  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B\n  filter(date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)## [1] 6019\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2014 2015 <NA>\r\n##   Central Hospital                      351   99   15\r\n##   Military Hospital                     679  204   33\r\n##   Missing                              1119  322   60\r\n##   Other                                 685  173   44\r\n##   Port Hospital                        1368  344   86\r\n##   St. Mark's Maternity Hospital (SMMH)  330   93   14\r\n##   <NA>                                    0    0    0"},{"path":"cleaning-data.html","id":"filter-as-a-stand-alone-command","chapter":"4 Cleaning data","heading":"4.9.3 Filter as a stand-alone command","text":"Filtering can also done stand-alone command (part pipe chain). Like dplyr verbs, case first argument must dataset .can also use base R subset using square brackets reflect [rows, columns] want retain.TIP: Use bracket-subset syntax View() quickly review records.","code":"\n# dataframe <- filter(dataframe, condition(s) for rows to keep)\n\nlinelist <- filter(linelist, !is.na(case_id))\n# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist <- linelist[!is.na(case_id), ]"},{"path":"cleaning-data.html","id":"filtering-to-quickly-review-data","chapter":"4 Cleaning data","heading":"4.9.4 Filtering to quickly review data","text":"base R syntax can handy want quickly view subset rows columns. Use base R View() command (note capital “V”) around [] subset want see. result appear dataframe RStudio viewer panel. example, want review onset hospitalization dates 3 specific cases:View linelist viewer panel:View specific data three cases:Note: command can also written dplyr verbs filter() select() :","code":"\nView(linelist)\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\nView(linelist %>%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %>%\n       select(date_onset, date_hospitalisation))"},{"path":"cleaning-data.html","id":"add-to-pipe-chain-2","chapter":"4 Cleaning data","heading":"4.9.5 Add to pipe chain","text":"","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n        select(-c(row_num, merged_header, x28)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n  \n    \n    # create column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n\n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\"  ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit)      ~ age,\n          TRUE                 ~ NA_real_)) %>% \n    \n  # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))"},{"path":"cleaning-data.html","id":"num_cats","chapter":"4 Cleaning data","heading":"4.10 Numeric categories","text":"CAUTION: tab may follow previous tabs.Special approaches creating numeric categoriesCommon examples include age categories, groups lab values, etc.several ways create categories numeric column age. discuss:age_categories(), epikit packagecut(), base Rusing percentiles break numbersnatural break points… ? DOcase_when()Sometimes, numeric variables import class “character”. occurs non-numeric characters values, example entry “2 months” age, (depending R locale settings) comma used decimals place (e.g. “4,5” mean four one half years).example create age_cat column using age_years column.","code":"\n#check the class of the linelist variable age\nclass(linelist$age_years)## [1] \"numeric\""},{"path":"cleaning-data.html","id":"age_categories","chapter":"4 Cleaning data","heading":"4.10.1 age_categories()**","text":"epikit package, can use age_categories() function easily categorize label numeric columns (note: can applied non-age numeric variables ). output ordered factor.break values specified included higher group, groups open lower/left side. shown , can add 1 break value achieve groups open top/right.optional arguments:lower = Default 0). lowest number want considered.upper = highest number want considered.= number years groups.separator = Default “-”. Character ages labels.ceiling = Default FALSE. TRUE, highest break value ceiling category “XX+” included. values highest break upper (defined) categorized NA.See function’s Help page details (enter ?age_categories R console).","code":"\nlibrary(epikit)\n\n# Simple example\n################\nlinelist <- linelist %>% \n  mutate(age_cat = age_categories(age_years,\n                                  breakers = c(0, 5, 10, 15, 20, 30, 50, 70)))\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-69   70+  <NA> \r\n##  1097  1177  1006   855  1108   639    46     0    91\n# With ceiling set to TRUE\n##########################\nlinelist <- linelist %>% \n  mutate(age_cat = age_categories(age_years, \n                                  breakers = c(0, 5, 10, 15, 20, 30, 50, 70),\n                                  upper = max(linelist$age_years, na.rm=T),\n                                  ceiling = TRUE)) # 70 is the ceiling\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-70  <NA> \r\n##  1097  1177  1006   855  1108   639    46    91\n# Include upper ends for the same categories\n############################################\nlinelist <- linelist %>% \n  mutate(age_cat = age_categories(age_years, \n                                  upper = max(linelist$age_years, na.rm=T),\n                                  breakers = c(0, 6, 11, 16, 21, 31, 51, 71, 76)))\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-5  6-10 11-15 16-20 21-30 31-50 51-70 71-75   76+  <NA> \r\n##  1338  1160   976   809  1029   579    37     0     0    91"},{"path":"cleaning-data.html","id":"cut","chapter":"4 Cleaning data","heading":"4.10.2 cut()","text":"can use base R function cut(), creates categories numeric variable. differences age_categories() :need install/load another packageYou can specify whether groups open/closed right/leftYou must provide labels (ensure accurate groups)want 0 included lowest group must specify thisThe basic syntax within cut() first provide numeric variable cut (age_years), breaks argument, numeric vector (c()) break points. Using cut(), resulting column ordered factor.used within mutate() (dplyr verb) necessary specify dataframe column name (e.g. linelist$age_years).","code":""},{"path":"cleaning-data.html","id":"simple-cut-example","chapter":"4 Cleaning data","heading":"4.10.2.1 Simple cut() example","text":"Create new column age categories (age_cat) cutting numeric age_year column specified break points. example replicates first age_categories() example.Specify numeric vector break points c(0, 5, 10, 15, ...)Default behavior cut() lower break values excluded category, upper break values included. opposite behavior age_categories() function.Include 0 lowest category adding include.lowest = TRUEAdd vector customized labels using labels = argumentCheck work cross-tabulation numeric category columns - aware missing values","code":"\nlinelist <- linelist %>% \n  mutate(age_cat = cut(age_years,                                       # numeric column\n                        breaks = c(0, 5, 10, 15, 20, 30, 50, 70,        # break points...\n                                   max(linelist$age_years, na.rm=T)),   # ... with dynamic last break as column max value\n                        right = TRUE,                                   # lower breaks included and upper excluded [a,b)\n                        include.lowest = TRUE,                          # 0 included in lowest category\n                        labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",      # manual labels - be careful!\n                                   \"20-29\", \"30-49\", \"50-69\", \"70+\")))       \n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-69   70+  <NA> \r\n##  1338  1160   976   809  1029   579    37     0    91"},{"path":"cleaning-data.html","id":"cut-details","chapter":"4 Cleaning data","heading":"4.10.2.2 cut() details","text":"detailed description behavior using cut() make age_cat column. Key points:Inclusion/exclusion behavior break pointsCustom category labelsHandling missing valuesCheck work!simple command cut() applied age_years make new variable age_cat :default, categorization occurs right/upper side “open” inclusive (left/lower side “closed” exclusive). default labels use notation “(, B]”, means group include (lower break value), includes B (upper break value). Reverse behavior providing right = TRUE argument.default, categorization occurs right/upper side “open” inclusive (left/lower side “closed” exclusive). default labels use notation “(, B]”, means group include (lower break value), includes B (upper break value). Reverse behavior providing right = TRUE argument.Thus, default “0” values excluded lowest group, categorized NA. “0” values infants coded age 0. change add argument include.lowest = TRUE. , “0” values included lowest group. automatically-generated label lowest category change “(0,B]” “[0,B]”, signifies 0 values included.Thus, default “0” values excluded lowest group, categorized NA. “0” values infants coded age 0. change add argument include.lowest = TRUE. , “0” values included lowest group. automatically-generated label lowest category change “(0,B]” “[0,B]”, signifies 0 values included.Check work!!! Verify age value assigned correct category cross-tabulating numeric category columns. Examine assignment boundary values (e.g. 15, neighboring categories 10-15 15-20).Check work!!! Verify age value assigned correct category cross-tabulating numeric category columns. Examine assignment boundary values (e.g. 15, neighboring categories 10-15 15-20).Read cut() Help page entering ?cut R console.Reversing break inclusion behavior cut()Lower break values included category (upper break values excluded) argument right = included set TRUE. applied - note values shifted among categories.NOTE: include include.lowest = TRUE argument right = TRUE, include.lowest now apply highest break point value category, lowest.Re-labeling NA values cut()cut() automatically label NA values, may want assign label “Missing”. requires extra steps cut() automatically classified new column age_cat Factor (rigid column class specific value labels).First, convert age_cut Factor Character class, flexibility add new character values (e.g. “Missing”). Otherwise encounter error. , use dplyr verb replace_na() replace NA values character value like “Missing”. steps can combined one step, shown .Note Missing added, order categories now wrong (alphabetical).fix , re-convert age_cat factor, define order levels correctly.want fast way make breaks labels, can use something like (adjust specific situation). See page using seq() rep() c() ","code":"\n# Create new variable, by cutting the numeric age variable\n# by default, upper break is excluded and lower break excluded from each category\nlinelist <- linelist %>% \n  mutate(age_cat = cut(age_years, breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100)))\n\n# tabulate the number of observations per group\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    (0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100]     <NA> \r\n##     1223     1160      976      809     1029      579       37        0      206\n# Cross tabulation of the numeric and category columns. \ntable(\"Numeric Values\" = linelist$age_years,   # names specified in table for clarity.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # don't forget to examine NA values##                     Categories\r\n## Numeric Values       (0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] (70,100] <NA>\r\n##   0                      0      0       0       0       0       0       0        0  115\r\n##   0.0833333333333333     1      0       0       0       0       0       0        0    0\r\n##   0.166666666666667      1      0       0       0       0       0       0        0    0\r\n##   0.333333333333333      3      0       0       0       0       0       0        0    0\r\n##   0.416666666666667      1      0       0       0       0       0       0        0    0\r\n##   0.5                    2      0       0       0       0       0       0        0    0\r\n##   0.583333333333333      2      0       0       0       0       0       0        0    0\r\n##   0.666666666666667      6      0       0       0       0       0       0        0    0\r\n##   0.75                   1      0       0       0       0       0       0        0    0\r\n##   0.833333333333333      2      0       0       0       0       0       0        0    0\r\n##   1                    259      0       0       0       0       0       0        0    0\r\n##   1.5                    3      0       0       0       0       0       0        0    0\r\n##   2                    250      0       0       0       0       0       0        0    0\r\n##   3                    229      0       0       0       0       0       0        0    0\r\n##   4                    222      0       0       0       0       0       0        0    0\r\n##   5                    241      0       0       0       0       0       0        0    0\r\n##   6                      0    228       0       0       0       0       0        0    0\r\n##   7                      0    231       0       0       0       0       0        0    0\r\n##   8                      0    231       0       0       0       0       0        0    0\r\n##   9                      0    246       0       0       0       0       0        0    0\r\n##   10                     0    224       0       0       0       0       0        0    0\r\n##   11                     0      0     208       0       0       0       0        0    0\r\n##   12                     0      0     209       0       0       0       0        0    0\r\n##   13                     0      0     191       0       0       0       0        0    0\r\n##   14                     0      0     174       0       0       0       0        0    0\r\n##   15                     0      0     194       0       0       0       0        0    0\r\n##   16                     0      0       0     198       0       0       0        0    0\r\n##   17                     0      0       0     179       0       0       0        0    0\r\n##   18                     0      0       0     141       0       0       0        0    0\r\n##   19                     0      0       0     143       0       0       0        0    0\r\n##   20                     0      0       0     148       0       0       0        0    0\r\n##   21                     0      0       0       0     137       0       0        0    0\r\n##   22                     0      0       0       0     129       0       0        0    0\r\n##   23                     0      0       0       0      99       0       0        0    0\r\n##   24                     0      0       0       0     101       0       0        0    0\r\n##   25                     0      0       0       0     108       0       0        0    0\r\n##   26                     0      0       0       0     111       0       0        0    0\r\n##   27                     0      0       0       0      95       0       0        0    0\r\n##   28                     0      0       0       0      97       0       0        0    0\r\n##   29                     0      0       0       0      83       0       0        0    0\r\n##   30                     0      0       0       0      69       0       0        0    0\r\n##   31                     0      0       0       0       0      57       0        0    0\r\n##   32                     0      0       0       0       0      76       0        0    0\r\n##   33                     0      0       0       0       0      71       0        0    0\r\n##   34                     0      0       0       0       0      28       0        0    0\r\n##   35                     0      0       0       0       0      43       0        0    0\r\n##   36                     0      0       0       0       0      46       0        0    0\r\n##   37                     0      0       0       0       0      44       0        0    0\r\n##   38                     0      0       0       0       0      30       0        0    0\r\n##   39                     0      0       0       0       0      20       0        0    0\r\n##   40                     0      0       0       0       0      16       0        0    0\r\n##   41                     0      0       0       0       0      24       0        0    0\r\n##   42                     0      0       0       0       0      30       0        0    0\r\n##   43                     0      0       0       0       0      15       0        0    0\r\n##   44                     0      0       0       0       0      16       0        0    0\r\n##   45                     0      0       0       0       0      17       0        0    0\r\n##   46                     0      0       0       0       0      11       0        0    0\r\n##   47                     0      0       0       0       0      11       0        0    0\r\n##   48                     0      0       0       0       0      12       0        0    0\r\n##   49                     0      0       0       0       0       3       0        0    0\r\n##   50                     0      0       0       0       0       9       0        0    0\r\n##   51                     0      0       0       0       0       0       4        0    0\r\n##   52                     0      0       0       0       0       0       6        0    0\r\n##   53                     0      0       0       0       0       0       3        0    0\r\n##   54                     0      0       0       0       0       0       4        0    0\r\n##   55                     0      0       0       0       0       0       4        0    0\r\n##   56                     0      0       0       0       0       0       6        0    0\r\n##   57                     0      0       0       0       0       0       2        0    0\r\n##   58                     0      0       0       0       0       0       2        0    0\r\n##   59                     0      0       0       0       0       0       1        0    0\r\n##   61                     0      0       0       0       0       0       1        0    0\r\n##   63                     0      0       0       0       0       0       1        0    0\r\n##   65                     0      0       0       0       0       0       1        0    0\r\n##   66                     0      0       0       0       0       0       1        0    0\r\n##   67                     0      0       0       0       0       0       1        0    0\r\n##   <NA>                   0      0       0       0       0       0       0        0   91\nlinelist <- linelist %>% \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),     # same breaks\n                          right = FALSE,                                     # include each *lower* break point            \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")))  # now the labels must change\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    0-4    5-9  10-14  15-19  20-29  30-49  50-69 70-100   <NA> \r\n##   1097   1177   1006    855   1108    639     46      0     91\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n                          right = FALSE,                                                      \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n         # convert to class Character, and replace NA with \"Missing\"\n         age_cat = replace_na(as.character(age_cat), \"Missing\"))\n\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##     0-4   10-14   15-19   20-29   30-49     5-9   50-69 Missing    <NA> \r\n##    1097    1006     855    1108     639    1177      46      91       0\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n                          right = FALSE,                                                      \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n         # convert to class Character, and replace NA with \"Missing\"\n         age_cat = replace_na(as.character(age_cat), \"Missing\"),\n         \n         # re-classify age_cat as Factor, with correct level order and new \"Missing\" level\n         age_cat = factor(age_cat, levels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\",\n                                              \"30-49\", \"50-69\", \"70-100\", \"Missing\")))    \n  \n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##     0-4     5-9   10-14   15-19   20-29   30-49   50-69  70-100 Missing    <NA> \r\n##    1097    1177    1006     855    1108     639      46       0      91       0\n# Make break points from 0 to 90 by 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Make labels for the above categories, assuming default cut() settings\nage_labels = paste0(age_seq+1, \"-\", age_seq + 5)\nage_labels\n\n# check that both vectors are the same length\nlength(age_seq) == length(age_labels)\n\n# # Use them in the cut() command\n# cut(linelist$age, breaks = age_seq, labels = age_labels)"},{"path":"cleaning-data.html","id":"case_when-1","chapter":"4 Cleaning data","heading":"4.10.3 case_when()","text":"dplyr function case_when() can also used create numeric categories.Allows explicit setting break point inclusion/exclusionAllows designation label NA values one stepMore complicated code, arguably prone errorAllow flexibility include variables logicIf using case_when() please review -depth page , logic order assignment important understand avoid errors.CAUTION: case_when() right-hand side values must class. Thus, categories character values (e.g. “20-30 years”) designated outcome NA age values must also character (“Missing”, special NA_character_ instead NA).need designate column factor (wrapping case_when() function factor()) provide ordering factor levels using levels = argument close case_when() function. using cut(), factor ordering levels done automatically.","code":"\nlinelist <- linelist %>% \n  mutate(age_cat = factor(case_when(\n          # provide the case_when logic and outcomes\n          age_years >= 0 & age_years < 5     ~ \"0-4\",          # logic by age_year value\n          age_years >= 5 & age_years < 10    ~ \"5-9\",\n          age_years >= 10 & age_years < 15   ~ \"10-14\",\n          age_years >= 15 & age_years < 20   ~ \"15-19\",\n          age_years >= 20 & age_years < 30   ~ \"20-29\",\n          age_years >= 30 & age_years < 50   ~ \"30-49\",\n          age_years >= 50 & age_years < 70   ~ \"50-69\",\n          age_years >= 45 & age_years <= 100 ~ \"70-100\",\n          is.na(age_years)                   ~ \"Missing\",  # if age_years is missing\n          TRUE                               ~ \"Check value\"   # catch-all alarm to trigger review\n          ), levels = c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\", \"Missing\", \"Check value\"))\n         )\n\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##         0-4         5-9       10-14       15-19       20-29       30-49       50-69      70-100     Missing Check value        <NA> \r\n##        1097        1177        1006         855        1108         639          46           0          91           0           0"},{"path":"cleaning-data.html","id":"add-to-pipe-chain-3","chapter":"4 Cleaning data","heading":"4.10.4 Add to pipe chain","text":", code create two categorical age columns added cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n        select(-c(row_num, merged_header, x28)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n  \n    \n    # create column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n\n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n    \n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\"))) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################   \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))"},{"path":"cleaning-data.html","id":"rowwise-dplyr","chapter":"4 Cleaning data","heading":"4.11 rowwise() dplyr()","text":"https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html","code":"\nlinelist <- linelist %>%\n  rowwise() %>%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\"))"},{"path":"cleaning-data.html","id":"transforming-multiple-variables-at-once","chapter":"4 Cleaning data","heading":"4.12 Transforming multiple variables at once","text":"CAUTION: tab may follow previous tabs.transformation can applied multiple variables using across() function package dplyr (contained within tidyverse package).across() can used dplyr verb, commonly mutate(), filter(), summarise(). examples get started.Example one change columns character classChange numeric columnsHere online resources using across(): Hadley Wickham’s thoughts/rationale","code":"\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(everything(), as.character))"},{"path":"cleaning-data.html","id":"deduplication","chapter":"4 Cleaning data","heading":"4.13 Deduplication","text":"CAUTION: tab may follow previous tabs.package dplyr offers distinct() function reduce dataframe unique rows - removing duplicates.\r\ncase just want remove rows complete duplicates, just add simple command distinct().complex deduplications see page deduplicating.begin 6019 rows linelist.deduplication 5889 rows., distinct() command added cleaning pipe chain:","code":"\nlinelist <- linelist %>% \n  distinct()\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n        select(-c(row_num, merged_header, x28)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n  \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # create column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n\n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n    \n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\"))) %>% \n  \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% \n  \n    distinct()"},{"path":"charactersstrings.html","id":"charactersstrings","chapter":"5 Characters/strings","heading":"5 Characters/strings","text":"","code":""},{"path":"charactersstrings.html","id":"overview-1","chapter":"5 Characters/strings","heading":"5.1 Overview","text":"tab demonstrates use stringr package evaluate manage character (strings).Evaluate subset/extract - str_length(), str_sub(), word()Combine, order, arrange - str_c(), str_glue(), str_order()Modify replace - str_sub(), str_replace_all()Adjust length - str_pad(), str_trunc(), str_wrap()Change case - str_to_upper(), str_to_title(), str_to_lower(), str_to_sentence()Search patterns - str_detect(), str_subset(), str_match()ease display examples shown acting short defined character vector, however can easily applied/adapted column within dataset.Much page adapted online vignette","code":""},{"path":"charactersstrings.html","id":"preparation-1","chapter":"5 Characters/strings","heading":"5.2 Preparation","text":"Install load stringr package.reference sheet stringr functions can found ","code":"\n# install or load the stringr package\npacman::p_load(stringr,   # many functions for handling strings\n               tidyverse,  # for optional data manipulation\n               tools      # alternative for converting to title case\n               )"},{"path":"charactersstrings.html","id":"evaluate-and-subset","chapter":"5 Characters/strings","heading":"5.3 Evaluate and subset","text":"Evaluate length stringAlternatively, use nchar() base RSubset/extract string positionUse str_sub() return part string. function takes three main arguments:character vector(s)start positionend positionA notes position numbers:position number positive, position counted starting left end string.position number negative, counted starting right end string.Position numbers inclusive.Positions extending beyond string truncated (removed).examples applied string “pneumonia”:Subset string word positionTo extract nth ‘word’, use word(), also stringr. Provide string(s), first word position extract, last word position extract.default, separator ‘words’ assumed space, unless otherwise indicated sep = (e.g. sep = \"_\" words separated underscores.","code":"\nstr_length(\"abc\")## [1] 3\n# third from left\nstr_sub(\"pneumonia\", 3, 3)## [1] \"e\"\n# 0 is not present\nstr_sub(\"pneumonia\", 0, 0)## [1] \"\"\n# 6th from right, to the first from right\nstr_sub(\"pneumonia\", 6, -1)## [1] \"onia\"\n# fifth from right, to the first from right\nstr_sub(\"pneumonia\", -5, -1)## [1] \"monia\"\n# positions outside the string\nstr_sub(\"pneumonia\", 4, 15)## [1] \"umonia\"\n# strings to evaluate\nchief_complaints <- c(\"I just got out of the hospital 2 days ago, but still can barely breathe.\",\n                      \"My stomach hurts\",\n                      \"Severe ear pain\")\n\n# extract 1st-3rd words of each string\nword(chief_complaints, start = 1, end = 3, sep = \" \")## [1] \"I just got\"       \"My stomach hurts\" \"Severe ear pain\""},{"path":"charactersstrings.html","id":"combine-order-and-arrange","chapter":"5 Characters/strings","heading":"5.4 Combine, order, and arrange","text":"section covers using str_c(), str_glue(), str_order(), combine, arrange, paste together strings.","code":""},{"path":"charactersstrings.html","id":"combine-strings","chapter":"5 Characters/strings","heading":"5.4.1 Combine strings","text":"common see base R functions paste() paste0(), concatenate vectors converting parts character. act similarly str_c() syntax differs - parts (either text code/pre-defined objects) separated commas, example: paste(\"Regional hospital needs\", n_beds, \"beds \", n_masks, \"masks.\"). sep collapse arguments can adjusted. default sep space, unless using paste0() space parts.combine multiple strings one string, can use str_c(), stringr version c() (concatenate).argument sep = inserts characters input vectors (e.g. comma newline \"\\n\")argument collapse = relevant producing multiple elements. example shows combination first last names. sep value goes first last name, collapse value goes people.","code":"\nstr_c(\"String1\", \"String2\", \"String3\")## [1] \"String1String2String3\"\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")## [1] \"String1, String2, String3\"\nfirst_names <- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  <- c(\"hussein\", \"akinleye\", \"musa\")\n\n# sep is between the respective strings, while collapse is between the elements produced\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")## [1] \"abdul hussein;  fahruk akinleye;  janice musa\"\n# For newlines to print correctly, the phrase may need to be wrapped in cat()\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))## abdul hussein;\r\n## fahruk akinleye;\r\n## janice musa"},{"path":"charactersstrings.html","id":"glueing-strings-and-other-values","chapter":"5 Characters/strings","heading":"5.4.2 Glueing strings and other values","text":"str_glue()can also combine strings pre-defined values characters str_glue(). useful function creating dynamic plot captions, demonstrated .content goes quotation marks (\"\").dynamic code calls pre-defined objects must within curly brackets {}. can many curly brackets.Within outer quotation marks, use single quotes necessary (e.g. providing date format)can provide newlines (\\n), use format() display dates, use Sys.Date() display current date.using %>% pipe operator, ensure tidyverse package loaded.simple example:alternative format use placeholders within brackets define code separate arguments end str_glue() function, . can improve code readability codes long.Sometimes, useful pull data dataframe pasted together sequence. example using dataset make summary output jurisdictions new total cases:Use str_c() dataframe column names (example first & last names). Provide sep collapse arguments.add text “New Cases:” beginning summary using wrapping separate str_c(). “New Cases” added within original str_c(), appear multiple times.can achieve similar result str_glue(), newlines added automatically:use str_glue() control (e.g. use double newlines), wrap within str_c() adjust collapse value. may need print using cat() correctly print newlines.","code":"\nstr_glue(\"The linelist is current to {format(Sys.Date(), '%d %b %Y')} and includes {nrow(linelist)} cases.\")## The linelist is current to 31 Jan 2021 and includes 5889 cases.\nstr_glue(\"Data source is the confirmed case linelist as of {current_date}.\\nThe last case was reported hospitalized on {last_hospital}.\\n{n_missing_onset} cases are missing date of onset and not shown\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))\n         )## Data source is the confirmed case linelist as of 31 Jan 2021.\r\n## The last case was reported hospitalized on 30 Apr 2015.\r\n## 248 cases are missing date of onset and not shown\nDT::datatable(case_table, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\nstr_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \")## [1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\nstr_c(\"New Cases: \", str_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \"))## [1] \"New Cases: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\nstr_glue(\"{case_table$zone}: {case_table$new_cases} new cases ({case_table$total_cases} total cases)\")## Zone 1: 3 new cases (40 total cases)\r\n## Zone 2: 0 new cases (4 total cases)\r\n## Zone 3: 7 new cases (25 total cases)\r\n## Zone 4: 0 new cases (10 total cases)\r\n## Zone 5: 15 new cases (103 total cases)\ncase_summary <- str_c(str_glue(\"{case_table$zone}: {case_table$new_cases} new cases ({case_table$total_cases} total cases)\"), collapse = \"\\n\\n\")\n\ncat(case_summary) # print## Zone 1: 3 new cases (40 total cases)\r\n## \r\n## Zone 2: 0 new cases (4 total cases)\r\n## \r\n## Zone 3: 7 new cases (25 total cases)\r\n## \r\n## Zone 4: 0 new cases (10 total cases)\r\n## \r\n## Zone 5: 15 new cases (103 total cases)"},{"path":"charactersstrings.html","id":"sorting","chapter":"5 Characters/strings","heading":"5.4.3 Sorting","text":"Several strings can sorted alphabetical order. str_order() returns order, str_sort() returns strings order.use different alphabet, add argument locale =. See full list locales entering stringi::stri_locale_list() R console.","code":"\n# strings\nhealth_zones <- c(\"Alba\", \"Takota\", \"Delta\")\n\n# return the alphabetical order\nstr_order(health_zones)## [1] 1 3 2\n# return the strings in alphabetical order\nstr_sort(health_zones)## [1] \"Alba\"   \"Delta\"  \"Takota\""},{"path":"charactersstrings.html","id":"base-r-functions","chapter":"5 Characters/strings","heading":"5.4.4 base R functions","text":"common see base R functions paste() paste0(), concatenate vectors converting parts character. act similarly str_c() syntax differs - parts (either text code/pre-defined objects) separated commas, example: paste(\"Regional hospital needs\", n_beds, \"beds \", n_masks, \"masks.\"). sep collapse arguments can adjusted. default sep space, unless using paste0() space parts.","code":""},{"path":"charactersstrings.html","id":"modify-and-replace","chapter":"5 Characters/strings","heading":"5.5 Modify and replace","text":"Replace specific character positionsstr_sub() paired assignment operator (<-) can used modify part string:example applied multiple strings (e.g. column). Note expansion length “HIV”.Replace patternsUse str_replace_all() “find replace” tool. First, provide strings evaluated, pattern replaced, replacement value. example replaces instances “dead” “deceased”. Note, case sensitive.replace pattern NA, use str_replace_na(). function str_replace() replaces first instance pattern within evaluated string.","code":"\nword <- \"pneumonia\"\n\n# convert the third and fourth characters to X \nstr_sub(word, 3, 4) <- \"XX\"\n\nword## [1] \"pnXXmonia\"\nwords <- c(\"pneumonia\", \"tubercolosis\", \"HIV\")\n\n# convert the third and fourth characters to X \nstr_sub(words, 3, 4) <- \"XX\"\n\nwords## [1] \"pnXXmonia\"    \"tuXXrcolosis\" \"HIXX\"\noutcome <- c(\"Karl: dead\",\n            \"Samantha: dead\",\n            \"Marco: not dead\")\n\nstr_replace_all(outcome, \"dead\", \"deceased\")## [1] \"Karl: deceased\"      \"Samantha: deceased\"  \"Marco: not deceased\""},{"path":"charactersstrings.html","id":"adjust-length","chapter":"5 Characters/strings","heading":"5.6 Adjust length","text":"Increase minimum length (pad)Use str_pad() add characters string, minimum length.default spaces added, can also pad characters using pad = argument.example, pad numbers leading zeros (hours minutes), can pad number minimum length 2 pad = \"0\".Truncate/shortenstr_trunc() sets maximum length string. string exceeds length, truncated (shortened) ellipsis (…) included indicate string previously longer. Note ellipsis counted length. ellipsis characters can changed argument ellipsis =. optional side = argument specifies ellipsis appear within truncated string (“left”, “right”, “center”).ensure value lengthUse str_trunc() set maximum length, use str_pad() expand short strings truncated length. example , 6 set maximum length (one value truncated), short value padded achieve length 6.Remove leading/trailing whitespaceUse str_trim() remove spaces, newlines (\\n) tabs (\\t) sides string input.\r\nAdd \"right\" \"left\", \"\" command specify side trim (e.g. str_trim(x, \"right\").Remove repeated whitespace within stringsUse str_squish() remove repeated spaces appear inside string. example, convert double spaces single spaces. also removes spaces, newlines, tabs outside string like str_trim().Enter ?str_trim, ?str_pad R console see details.Wrap lines paragraphsUse str_wrap() wrap long unstructured text structured paragraph fixed line length. Provide ideal character length line, applies algorithm insert newlines (\\n) within paragraph, seen example .base function cat() can wrapped around command order print output, displaying new lines added.","code":"\n# ICD codes of differing length\nICD_codes <- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# ICD codes padded to 7 characters on the right side\nstr_pad(ICD_codes, 7, \"right\")## [1] \"R10.13 \" \"R10.819\" \"R17    \"\n# Pad with periods instead of spaces\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")## [1] \"R10.13.\" \"R10.819\" \"R17....\"\n# Add leading zeros to two digits (e.g. for times minutes/hours)\nstr_pad(\"4\", 2, pad = \"0\") ## [1] \"04\"\n# example using a numeric column named \"hours\"\n# hours <- str_pad(hours, 2, pad = \"0\")\noriginal <- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")## [1] \"Symp...ing\"\n# ICD codes of differing length\nICD_codes   <- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# truncate to maximum length of 6\nICD_codes_2 <- str_trunc(ICD_codes, 6)\nICD_codes_2## [1] \"R10.13\" \"R10...\" \"R17\"\n# expand to minimum length of 6\nICD_codes_3 <- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3## [1] \"R10.13\" \"R10...\" \"R17   \"\n# ID numbers with excess spaces on right\nIDs <- c(\"provA_1852  \", # two excess spaces\n         \"provA_2345\",   # zero excess spaces\n         \"provA_9460 \")  # one excess space\n\n# IDs trimmed to remove excess spaces on right side only\nstr_trim(IDs)## [1] \"provA_1852\" \"provA_2345\" \"provA_9460\"\n# original contains excess spaces within string\nstr_squish(\"  Pt requires   IV saline\\n\") ## [1] \"Pt requires IV saline\"\npt_course <- \"Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020.\"\n\nstr_wrap(pt_course, 40)## [1] \"Symptom onset 1/4/2020 vomiting chills\\nfever. Pt saw traditional healer in\\nhome village on 2/4/2020. On 5/4/2020\\npt symptoms worsened and was admitted\\nto Lumta clinic. Sample was taken and pt\\nwas transported to regional hospital on\\n6/4/2020. Pt died at regional hospital\\non 7/4/2020.\"\ncat(str_wrap(pt_course, 40))## Symptom onset 1/4/2020 vomiting chills\r\n## fever. Pt saw traditional healer in\r\n## home village on 2/4/2020. On 5/4/2020\r\n## pt symptoms worsened and was admitted\r\n## to Lumta clinic. Sample was taken and pt\r\n## was transported to regional hospital on\r\n## 6/4/2020. Pt died at regional hospital\r\n## on 7/4/2020."},{"path":"charactersstrings.html","id":"change-case","chapter":"5 Characters/strings","heading":"5.7 Change case","text":"Often one must alter case/capitalization string value, example names jursidictions. Use str_to_upper(), str_to_upper(), str_to_title(), shown :Using *base** R, can also achieved toupper(), tolower().Title case\r\nTransforming string word capitalized can achieved str_to_title():Use toTitleCase() tools package achieve nuanced capitalization (words like “”, “”, “” capitalized).can also use str_to_sentence(), capitalizes first letter string.","code":"\nstr_to_upper(\"California\")## [1] \"CALIFORNIA\"\nstr_to_lower(\"California\")## [1] \"california\"\nstr_to_title(\"go to the US state of california \")## [1] \"Go To The Us State Of California \"\ntools::toTitleCase(\"This is the US state of california\")## [1] \"This is the US State of California\"\nstr_to_sentence(\"the patient must be transported\")## [1] \"The patient must be transported\""},{"path":"charactersstrings.html","id":"patterns","chapter":"5 Characters/strings","heading":"5.8 Patterns","text":"Many stringr functions work detect, locate, extract, match, replace, split based specified pattern.","code":""},{"path":"charactersstrings.html","id":"detect-presenceabsence-of-a-pattern","chapter":"5 Characters/strings","heading":"5.8.1 Detect presence/absence of a pattern","text":"Use str_detect() . Note default search case sensitive!argument negate = can included set TRUE want know pattern present.ignore case/capitalization, wrap pattern within regex() within regex() add argument ignore_case = T.str_detect() applied character vector/column, return TRUE/FALSE values vector.need count , apply sum() output. counts number TRUE.search inclusive multiple terms, include separated bars (|) within pattern, shown :need make long list search terms, can combine using str_c() sep = |, define character object, reference later succinctly. example includes possible occupation search terms frontline medical providers.command returns number occupations contain one search terms front-line medical providers (occupation_med_frontline):Base R string search functionsThe base function grepl() works similarly str_detect(), searches matches pattern returns logical vector. basic syntax grepl(pattern, strings_to_search, ignore.case = FALSE, ...). One advantage ignore.case argument easier write (need involve regex() function).Likewise, base functions sub() gsub() act similarly str_replace(). basic syntax : gsub(pattern, replacement, strings_to_search, ignore.case = FALSE). sub() replace first instance pattern, whereas gsub() replace instances pattern.","code":"\nstr_detect(\"primary school teacher\", \"teach\")## [1] TRUE\nstr_detect(\"primary school teacher\", \"teach\", negate = TRUE)## [1] FALSE\nstr_detect(\"Teacher\", regex(\"teach\", ignore_case = T))## [1] TRUE\n# a vector/column of occupations \noccupations <- c(\"field laborer\",\n                 \"university professor\",\n                 \"primary school teacher & tutor\",\n                 \"tutor\",\n                 \"nurse at regional hospital\",\n                 \"lineworker at Amberdeen Fish Factory\",\n                 \"physican\",\n                 \"cardiologist\",\n                 \"office worker\",\n                 \"food service\")\n\n# Detect presence of pattern \"teach\" in each string - output is vector of TRUE/FALSE\nstr_detect(occupations, \"teach\")##  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\nsum(str_detect(occupations, \"teach\"))## [1] 1\nsum(str_detect(occupations, \"teach|professor|tutor\"))## [1] 3\n# search terms\noccupation_med_frontline <- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline## [1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\nsum(str_detect(occupations, occupation_med_frontline))## [1] 2"},{"path":"charactersstrings.html","id":"detects-patterns-in-conditional-logic","chapter":"5 Characters/strings","heading":"5.8.2 Detects patterns in conditional logic","text":"Within case_when()str_detect() often used within case_when() (dplyr). Let’s say occupations column linelist called occupations. mutate() creates new column called is_educator using conditional logic via case_when(). See page data cleaning learn case_when().reminder, may important add exclusion criteria conditional logic (negate = F):","code":"\ndf <- df %>% \n  mutate(is_educator = case_when(\n    # term search within occupation, not case sensitive\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\",\n                     ignore_case = TRUE))              ~ \"Educator\",\n    # all others\n    TRUE                                               ~ \"Not an educator\"))df <- df %>% \r\n  # value in new column is_educator is based on conditional logic\r\n  mutate(is_educator = case_when(\r\n    \r\n    # occupation column must meet 2 criteria to be assigned \"Educator\":\r\n    # it must have a search term AND NOT any exclusion term\r\n    \r\n    # Must have a search term AND\r\n    str_detect(occupations,\r\n               regex(\"teach|prof|tutor|university\", ignore_case = T)) &              \r\n    # Must NOT have an exclusion term\r\n    str_detect(occupations,\r\n               regex(\"admin\", ignore_case = T),\r\n               negate = T)                          ~ \"Educator\"\r\n    \r\n    # All rows not meeting above criteria\r\n    TRUE                                            ~ \"Not an educator\"))"},{"path":"charactersstrings.html","id":"locate-pattern-position","chapter":"5 Characters/strings","heading":"5.8.3 Locate pattern position","text":"locate first position pattern, use str_locate(). outputs start end position.Like str functions, \"_all\" version (str_locate_all()) return positions instances pattern within string. outputs list.","code":"\nstr_locate(\"I wish\", \"sh\")##      start end\r\n## [1,]     5   6\nphrases <- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # position of *first* instance of the pattern##      start end\r\n## [1,]     6   6\r\n## [2,]     3   3\r\n## [3,]     1   1\r\n## [4,]     4   4\nstr_locate_all(phrases, \"h\" ) # position of *every* instance of the pattern## [[1]]\r\n##      start end\r\n## [1,]     6   6\r\n## \r\n## [[2]]\r\n##      start end\r\n## [1,]     3   3\r\n## \r\n## [[3]]\r\n##      start end\r\n## [1,]     1   1\r\n## [2,]     4   4\r\n## \r\n## [[4]]\r\n##      start end\r\n## [1,]     4   4"},{"path":"charactersstrings.html","id":"extract-a-match","chapter":"5 Characters/strings","heading":"5.8.4 Extract a match","text":"str_extract_all() returns matching patterns , useful offered several patterns via “” conditions. example, looking string vector occupations (see previous tab) either “teach”, “prof”, “tutor”.str_extract_all() returns list contains matches evaluated string. See occupation 3 two pattern matches within .str_extract() extracts first match evaluated string, producing character vector one element evaluated string. returns NA match. NAs can removed wrapping returned vector na.exclude(). Note second occupation 3’s matches shown.","code":"\nstr_extract_all(occupations, \"teach|prof|tutor\")## [[1]]\r\n## character(0)\r\n## \r\n## [[2]]\r\n## [1] \"prof\"\r\n## \r\n## [[3]]\r\n## [1] \"teach\" \"tutor\"\r\n## \r\n## [[4]]\r\n## [1] \"tutor\"\r\n## \r\n## [[5]]\r\n## character(0)\r\n## \r\n## [[6]]\r\n## character(0)\r\n## \r\n## [[7]]\r\n## character(0)\r\n## \r\n## [[8]]\r\n## character(0)\r\n## \r\n## [[9]]\r\n## character(0)\r\n## \r\n## [[10]]\r\n## character(0)\nstr_extract(occupations, \"teach|prof|tutor\")##  [1] NA      \"prof\"  \"teach\" \"tutor\" NA      NA      NA      NA      NA      NA"},{"path":"charactersstrings.html","id":"subset-and-count","chapter":"5 Characters/strings","heading":"5.8.5 Subset and Count","text":"Subset, CountAligned functions include str_subset() str_count().str_subset() returns actual values contained pattern:`str_count() returns vector numbers: number times search term appears evaluated value.","code":"\nstr_subset(occupations, \"teach|prof|tutor\")## [1] \"university professor\"           \"primary school teacher & tutor\" \"tutor\"\nstr_count(occupations, regex(\"teach|prof|tutor\", ignore_case = TRUE))##  [1] 0 1 2 1 0 0 0 0 0 0"},{"path":"charactersstrings.html","id":"splitting","chapter":"5 Characters/strings","heading":"5.8.6 Splitting","text":"split string based pattern, use str_split(). evaluates strings returns list character vectors consisting newly-split values.simple example evaluates one string, produces list one element - character vector three values:can assign named object, access nth symptom:multiple strings evaluated, one element returned list.access specific symptom can use syntax like : the_split_return_object[[2]][1], access first symptom second evaluated string (“chills”). See R basics page detail accessing elements.return “character matrix” instead, may useful creating dataframe columns, set argument simplify = TRUE shown :can also adjust number splits create n = argument. example, restricts number splits (left side) 2 splits. commas remain within second split.Note - outputs can achieved str_split_fixed(), * give simplify argument, must instead designate number columns (n).*Splitting column within dataframeWithin dataframe, split one character column columns use use separate() dplyr.simple dataframe df consisting case ID column, one character column symptoms, one outcome column:First provide column separated, provide vector (c()) new columns names argument =, shown . argument sep = can character, number (interpreted character position split ).Optional arguments include remove = (FALSE default, removes input column) convert = (FALSE default, cause string “NA”s become NA).extra = control happens many values created separation new columns named. Setting extra equal \"warn\" means R return warning proceed drop values (default). \"drop\" means values dropped warning.Setting extra = \"merge\" split number new columns listed - setting preserve data.CAUTION: provide enough values new columns, data may truncated.One solution automatically make many columns needed :unite()Within dataframe, bringing together multiple columns (opposite separate()) can achieved unite() tidyr.Provide name new united column. provide names columns wish unite. default separator used united column \"_\", can changed sep argument. optional arguments include remove = (TRUE default, removes input columns data frame), na.rm = (FALSE default, removes missing values uniting)., re-unite dataframe separated .","code":"\nstr_split(\"jaundice, fever, chills\", \",\", simplify = T)##      [,1]       [,2]     [,3]     \r\n## [1,] \"jaundice\" \" fever\" \" chills\"\npt1_symptoms <- str_split(\"jaundice, fever, chills\", \",\", simplify = T)\n\npt1_symptoms[2]## [1] \" fever\"\nsymptoms <- c(\"jaundice, fever, chills\",     # patient 1\n              \"chills, aches, pains\",        # patient 2 \n              \"fever\",                       # patient 3\n              \"vomiting, diarrhoea\",         # patient 4\n              \"bleeding from gums, fever\",   # patient 5\n              \"rapid pulse, headache\")       # patient 6\n\nstr_split(symptoms, \",\")                     # split each patient's symptoms## [[1]]\r\n## [1] \"jaundice\" \" fever\"   \" chills\" \r\n## \r\n## [[2]]\r\n## [1] \"chills\" \" aches\" \" pains\"\r\n## \r\n## [[3]]\r\n## [1] \"fever\"\r\n## \r\n## [[4]]\r\n## [1] \"vomiting\"   \" diarrhoea\"\r\n## \r\n## [[5]]\r\n## [1] \"bleeding from gums\" \" fever\"            \r\n## \r\n## [[6]]\r\n## [1] \"rapid pulse\" \" headache\"\nstr_split(symptoms, \",\", simplify = T)##      [,1]                 [,2]         [,3]     \r\n## [1,] \"jaundice\"           \" fever\"     \" chills\"\r\n## [2,] \"chills\"             \" aches\"     \" pains\" \r\n## [3,] \"fever\"              \"\"           \"\"       \r\n## [4,] \"vomiting\"           \" diarrhoea\" \"\"       \r\n## [5,] \"bleeding from gums\" \" fever\"     \"\"       \r\n## [6,] \"rapid pulse\"        \" headache\"  \"\"\nstr_split(symptoms, \",\", simplify = T, n = 2)##      [,1]                 [,2]            \r\n## [1,] \"jaundice\"           \" fever, chills\"\r\n## [2,] \"chills\"             \" aches, pains\" \r\n## [3,] \"fever\"              \"\"              \r\n## [4,] \"vomiting\"           \" diarrhoea\"    \r\n## [5,] \"bleeding from gums\" \" fever\"        \r\n## [6,] \"rapid pulse\"        \" headache\"\nstr_split_fixed(symptoms, \",\", n = 2)\n# third symptoms combined into second new column\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].##   case_ID              sym_1          sym_2 outcome\r\n## 1       1           jaundice  fever, chills Success\r\n## 2       2             chills   aches, pains Failure\r\n## 3       3              fever           <NA> Failure\r\n## 4       4           vomiting      diarrhoea Success\r\n## 5       5 bleeding from gums          fever Success\r\n## 6       6        rapid pulse       headache Success\n# third symptoms are lost\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), sep=\",\")## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 4 rows [3, 4, 5, 6].##   case_ID              sym_1      sym_2   sym_3 outcome\r\n## 1       1           jaundice      fever  chills Success\r\n## 2       2             chills      aches   pains Failure\r\n## 3       3              fever       <NA>    <NA> Failure\r\n## 4       4           vomiting  diarrhoea    <NA> Success\r\n## 5       5 bleeding from gums      fever    <NA> Success\r\n## 6       6        rapid pulse   headache    <NA> Success\n# third symptoms given their own column\nseparated <- df %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), sep=\",\")## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 4 rows [3, 4, 5, 6].\nseparated##   case_ID              sym_1      sym_2   sym_3 outcome\r\n## 1       1           jaundice      fever  chills Success\r\n## 2       2             chills      aches   pains Failure\r\n## 3       3              fever       <NA>    <NA> Failure\r\n## 4       4           vomiting  diarrhoea    <NA> Success\r\n## 5       5 bleeding from gums      fever    <NA> Success\r\n## 6       6        rapid pulse   headache    <NA> Success\nseparated %>% \n  unite(\n    col = \"all_symptoms\",         # name of the new united column\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # columns to unite\n    sep = \", \",                   # separator to use in united column\n    remove = TRUE,                # if TRUE, removes input cols from the data frame\n    na.rm = TRUE                  # if TRUE, missing values are removed before uniting\n  )##   case_ID               all_symptoms outcome\r\n## 1       1  jaundice,  fever,  chills Success\r\n## 2       2     chills,  aches,  pains Failure\r\n## 3       3                      fever Failure\r\n## 4       4       vomiting,  diarrhoea Success\r\n## 5       5 bleeding from gums,  fever Success\r\n## 6       6     rapid pulse,  headache Success"},{"path":"charactersstrings.html","id":"regex-groups","chapter":"5 Characters/strings","heading":"5.8.7 Regex groups","text":"Groups within stringsstr_match() TBD","code":""},{"path":"charactersstrings.html","id":"regex-and-special-characters","chapter":"5 Characters/strings","heading":"5.9 Regex and special characters","text":"Regular expressions, “regex”, concise language describing patterns strings.Much tab adapted tutorial cheatsheet","code":""},{"path":"charactersstrings.html","id":"special-characters","chapter":"5 Characters/strings","heading":"5.9.1 Special characters","text":"Backslash \\ escapeThe backslash \\ used “escape” meaning next character. way, backslash can used quote mark display within quote marks (\\\") - middle quote mark “break” surrounding quote marks.Note - thus, want display backslash, must escape ’s meaning *another backslash. must write two backslashes \\\\ display one.Special charactersRun ?\"'\" R Console display complete list special characters (appear RStudio Help pane).","code":""},{"path":"charactersstrings.html","id":"regular-expressions-regex","chapter":"5 Characters/strings","heading":"5.9.2 Regular expressions (regex)","text":"familiar , regular expression can look like alien language:regular expression applied extract specific patterns unstructured text - example medical notes, chief complaint, matient history, free text columns dataset.four basic tools one can use create basic regular expression:Character setsMeta charactersQuantifiersGroupsCharacter setsCharacter sets, way expressing listing options character match, within brackets. match triggered characters within brackets found string. example, look vowels one use character set: “[aeiou]”. common character sets :Character sets can combined within one bracket (spaces!), \"[-Za-z]\" (upper lowercase letter), another example \"[t-z0-5]\" (lowercase t z number 0 5).Meta charactersMeta characters shorthand character sets. important ones listed :QuantifiersTypically want search match one character. Quantifiers allow designate length letters/numbers allow match.Quantifiers numbers written within curly brackets { } character quantifying, example,\"{2}\" return instances two capital letters.\"{2,4}\" return instances two four capital letters (put spaces!).\"{2,}\" return instances two capital letters.\"+\" return instances one capital letters (group extended different character encountered).Precede * asterisk return zero matches (useful sure pattern present)Using + plus symbol quantifier, match occur different character encountered. example, expression return words (alpha characters: \"[-Za-z]+\"quantifier {2} used, pairs consecutive ’s returned. Two pairs identified within AAAA.quantifier {2,4} used, groups consecutive ’s two four length returned.quantifier +, groups one returned:Relative positionThese express requirements precedes follows pattern. example, extract sentences, “two numbers followed period” (\"\"). (?<=\\.)\\s(?=[-Z])GroupsCapturing groups regular expression way organized output upon extraction.Regex examplesBelow free text examples. try extract useful information using regular expression search term.expression matches words (character hitting non-character space):expression \"[0-9]{1,2}\" matches consecutive numbers 1 2 digits length. also written \"\\\\d{1,2}\", \"[:digit:]{1,2}\".expression extract sentences (assuming first letter capitalized, sentence ends period). pattern reads English : \"capital letter followed lowercase letters, space, letters, space,can view useful list regex expressions tips page 2 cheatsheetAlso see tutorial.","code":"\n# test string for quantifiers\ntest <- \"A-AA-AAA-AAAA\"\nstr_extract_all(test, \"A{2}\")## [[1]]\r\n## [1] \"AA\" \"AA\" \"AA\" \"AA\"\nstr_extract_all(test, \"A{2,4}\")## [[1]]\r\n## [1] \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"A+\")## [[1]]\r\n## [1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"\")## [[1]]\r\n##  [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\npt_note <- \"Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute.\"\nstr_extract_all(pt_note, \"[A-Za-z]+\")## [[1]]\r\n##  [1] \"Patient\"     \"arrived\"     \"at\"          \"Broward\"     \"Hospital\"    \"emergency\"   \"ward\"        \"at\"          \"on\"         \r\n## [10] \"Patient\"     \"presented\"   \"with\"        \"radiating\"   \"abdominal\"   \"pain\"        \"from\"        \"LR\"          \"quadrant\"   \r\n## [19] \"Patient\"     \"skin\"        \"was\"         \"pale\"        \"cool\"        \"and\"         \"clammy\"      \"Patient\"     \"temperature\"\r\n## [28] \"was\"         \"degrees\"     \"farinheit\"   \"Patient\"     \"pulse\"       \"rate\"        \"was\"         \"bpm\"         \"and\"        \r\n## [37] \"thready\"     \"Respiratory\" \"rate\"        \"was\"         \"per\"         \"minute\"\nstr_extract_all(pt_note, \"[0-9]{1,2}\")## [[1]]\r\n##  [1] \"18\" \"00\" \"6\"  \"12\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\"\nstr_split(pt_note, \".\")## [[1]]\r\n##   [1] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\r\n##  [44] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\r\n##  [87] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\r\n## [130] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\r\n## [173] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\r\n## [216] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\r\n## [259] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\r\n## [302] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\nstr_extract_all(pt_note, \"[A-Z][a-z]+\\\\s\\\\w+\\\\s\\\\d{1,2}\\\\s\\\\w+\\\\s*\\\\w*\")## [[1]]\r\n## character(0)"},{"path":"charactersstrings.html","id":"resources","chapter":"5 Characters/strings","heading":"5.10 Resources","text":"reference sheet stringr functions can found hereA vignette stringr can found ","code":""},{"path":"de-duplication.html","id":"de-duplication","chapter":"6 De-duplication","heading":"6 De-duplication","text":"","code":""},{"path":"de-duplication.html","id":"overview-2","chapter":"6 De-duplication","heading":"6.1 Overview","text":"page covers following subjects:Identifying removing duplicate rows“Slicing” keeping certain rows (min, max, random…), also group“Rolling-”, combining values multiple rows one","code":""},{"path":"de-duplication.html","id":"preparation-2","chapter":"6 De-duplication","heading":"6.2 Preparation","text":"Load packagesExample datasetFor demonstration, use fake dataset . record COVID-19 phone encounters, including contacts cases.first two records 100% complete duplicates including duplicate recordID (computer glitch)second two rows duplicates, columns except recordIDSeveral people multiple phone encounters, various dates/times contacts casesAt encounter, person asked ever symptoms, information missing.","code":"\npacman::p_load(tidyverse,   # deduplication, grouping, and slicing functions\n               janitor,     # function for reviewing duplicates\n               stringr      # for string searches, can be used in \"rolling-up\" values\n               )     "},{"path":"de-duplication.html","id":"deduplication-1","chapter":"6 De-duplication","heading":"6.3 Deduplication","text":"tab uses dataset Preparation tab describe review remove duplicate rows dataframe. also show handle duplicate elements vector.","code":""},{"path":"de-duplication.html","id":"examine-duplicate-rows","chapter":"6 De-duplication","heading":"6.3.1 Examine duplicate rows","text":"quickly review rows duplicates, can use get_dupes() janitor package. default, columns considered duplicates evaluated - rows returned 100% duplicates considering values columns.obs dataframe, first two rows 100% duplicates - value every column (including recordID column, supposed unique - must computer glitch). returned dataframe automatically includes new column dupe_count, showing number rows combination duplicate values.However, choose ignore recordID, 3rd 4th rows rows also duplicates. , values columns except recordID. can specify specific columns ignored function using - minus symbol.can also positively specify columns consider. , rows values name purpose columns returned. Notice “amrish” now dupe_count equal 3 reflect three “contact” encounters.*Scroll left rows**See ?get_dupes details, see online reference","code":"\n# 100% duplicates across all columns\nobs %>% \n  janitor::get_dupes()\n# Duplicates when column recordID is not considered\nobs %>% \n  janitor::get_dupes(-recordID)         # if multiple columns, wrap them in c()\n# duplicates based on name and purpose columns ONLY\nobs %>% \n  janitor::get_dupes(name, purpose)"},{"path":"de-duplication.html","id":"keep-only-unique-rows","chapter":"6 De-duplication","heading":"6.3.2 Keep only unique rows","text":"keep unique rows dataframe, use distinct() dplyr. Rows duplicates removed first rows kept. default, “first” means highest rownumber (order rows top--bottom). unique rows kept. example , one duplicate row (first row, “adam”) removed (n now 18, 19 rows).Scroll left see entire dataframeCAUTION: using distinct() grouped data, function apply group.Deduplicate based specific columnsYou can also specify columns basis de-duplication. way, de-duplication applies rows duplicates within specified columns. Unless specified .keep_all = TRUE, columns mentioned dropped.example , de-duplication applies rows identical values name purpose columns. Thus, “brian” 2 rows instead 3 - first “contact” encounter “case” encounter. adjust brian’s latest encounter purpose kept, see tab Slicing within groups.Scroll left see entire dataframe","code":"\n# added to a chain of pipes (e.g. data cleaning)\nobs %>% \n  distinct(across(-recordID), # reduces dataframe to only unique rows (keeps first one of any duplicates)\n           .keep_all = TRUE) \n\n# if outside pipes, include the data as first argument \n# distinct(obs)\n# added to a chain of pipes (e.g. data cleaning)\nobs %>% \n  distinct(name, purpose, .keep_all = TRUE) %>%  # keep rows unique by name and purpose, retain all columns\n  arrange(name)                                  # arrange for easier viewing"},{"path":"de-duplication.html","id":"duplicate-elements-in-a-vector","chapter":"6 De-duplication","heading":"6.3.3 Duplicate elements in a vector","text":"function duplicated() base R evaluate vector (column) return logical vector length (TRUE/FALSE). first time value appears, return FALSE (duplicate), subsequent times value appears return TRUE. Note NA treated value.return duplicated elements, can use brackets subset original vector:return unique elements, use unique() base R. remove NAs output, nest na.omit() within unique().","code":"\nx <- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)##  [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nx[duplicated(x)]## [1]  1 NA  4  4  1  2\nunique(x)           # alternatively, use x[!duplicated(x)]## [1]  1  2 NA  4  5\nunique(na.omit(x))  # remove NAs ## [1] 1 2 4 5"},{"path":"de-duplication.html","id":"with-base-r","chapter":"6 De-duplication","heading":"6.3.4 with base R","text":"return duplicate rowsIn base R, can also see rows 100% duplicates dataframe df command duplicated(df) (returns logical vector rows).Thus, can also use base subset [ ] dataframe see duplicated rows df[duplicated(df),] (don’t forget comma, meaning want see columns!).return unique rowsSee notes . see unique rows add logical negator ! front duplicated() function:df[!duplicated(df),]return rows duplicates certain columnsSubset df within duplicated() parentheses, function operate certain columns df.specify columns, provide column numbers names comma (remember, within duplicated() function).sure keep comma , outside duplicated() function well!example, evaluate columns 2 5 duplicates: df[!duplicated(df[, 2:5]),]\r\nevaluate columns name purpose duplicates: df[!duplicated(df[, c(\"name\", \"purpose)]),]","code":""},{"path":"de-duplication.html","id":"slicing","chapter":"6 De-duplication","heading":"6.4 Slicing","text":"“slice” dataframe useful de-duplication multiple rows per functional group (e.g. per “person”) want analyze one . Think slicing filter rows, row number/position.basic slice() function accepts number n. positive, nth row returned. negative, rows except nth returned.Variations include:slice_min() slice_max() - keep row minimium maximum value specified column. Also worked ordered factors.slice_head() slice_tail - keep first last rowslice_sample() - keep random sample rowsUse arguments n = prop = specify number proportion rows keep. using function pipe chain, provide data argument first (e.g. slice(df, n = 2)). See ?slice information.arguments:.order_by = - used slice_min() slice_max() column order slicing.with_ties = - TRUE default, meaning ties kept..preserve = - FALSE default. TRUE grouping structure re-calculated slicing.weight_by = - Optional, numeric column weight (bigger number likely get sampled). Also replace = whether sampling done /without replacement.TIP: using slice_max() slice_min(), sure specify/write n = (e.g. n = 2, just 2). Otherwise may get error Error:…empty. NOTE: may encounter function top_n(), superseded slice functions., basic slice() function used keep 4th row:","code":"\nobs %>% \n  slice(4)  # keeps the 4th row only"},{"path":"de-duplication.html","id":"slice-with-groups","chapter":"6 De-duplication","heading":"6.4.1 Slice with groups","text":"slice_*() functions can useful applied grouped dataframe, slice operation performed group separately. Use function group_by() conjunction slice() group data take slice group.\r\nhelpful de-duplication multiple rows per person want keep one . first use group_by() key columns , use slice function column differ among grouped rows.example , keep latest encounter per person, group rows name use slice_max() n = 1 date column. aware! apply function like slice_max() dates, date column must class Date.default, “ties” (e.g. date scenario) kept, still get multiple rows people (e.g. adam). avoid set with_ties = FALSE. get back one row per person.CAUTION: using arrange(), specify .by_group = TRUE data arranged within group.DANGER: with_ties = FALSE, first row tie kept. may deceptive. See Mariah, two encounters latest date (6 Jan) first (earliest) one kept. Likely, want keep later encounter day. See “break” ties next example. Breaking “ties”Multiple slice statements can run “break ties”. case, person multiple encounters latest date, encounter latest time kept (lubridate::hm() used convert character times sortable time class).\r\nNote now, one row kept “Mariah” 6 Jan encounter 3 08:32, encounter 2 07:25.example , also possible slice encounter number, showed slice date time example purposes.TIP: use slice_max() slice_min() “character” column, mutate ordered factor class!","code":"\nobs %>% \n  group_by(name) %>%       # group the rows by 'name'\n  slice_max(date,          # keep row per group with maximum date value \n            n = 1,         # keep only the single highest row \n            with_ties = F) # if there's a tie (of date), take the first row\n# Example of multiple slice statements to \"break ties\"\nobs %>%\n  group_by(name) %>%\n  \n  # FIRST - slice by latest date\n  slice_max(date, n = 1, with_ties = TRUE) %>% \n  \n  # SECOND - if there is a tie, select row with latest time; ties prohibited\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)"},{"path":"de-duplication.html","id":"keep-all-but-mark-them","chapter":"6 De-duplication","heading":"6.4.2 Keep all but mark them","text":"want keep records mark analysis, consider two-step approach utilizing unique recordID/encounter number:Reduce/slice orginal dataframe rows analysis. Save/retain reduced dataframe.original dataframe, mark rows appropriate case_when(), based whether record unique identifier (recordID example) present reduced dataframe.","code":"\n# 1. Define dataframe of rows to keep for analysis\nobs_keep <- obs %>%\n  group_by(name) %>%\n  slice_max(encounter, n = 1, with_ties = FALSE) # keep only latest encounter per person\n\n\n# 2. Mark original dataframe\nobs_marked <- obs %>%\n\n  # make new dup_record column\n  mutate(dup_record = case_when(\n    \n    # if record is in obs_keep dataframe\n    recordID %in% obs_keep$recordID ~ \"For analysis\", \n    \n    # all else marked as \"Ignore\" for analysis purposes\n    TRUE                            ~ \"Ignore\"))\n\n# print\nobs_marked"},{"path":"de-duplication.html","id":"calculate-row-completeness","chapter":"6 De-duplication","heading":"6.4.3 Calculate row completeness","text":"Create column contains metric row’s completeness (non-missingness). helpful deciding rows prioritize others de-duplicating/slicing.example, “key” columns want measure completeness saved vector column names.new column key_completeness created mutate(). new value row defined calculated fraction: number non-missing values row among key columns, divided number key columns.involves function rowSums() base R. Also used ., within piping refers dataframe point pipe (case, subset brackets []).*Scroll right see rows**","code":"\n# create a \"key variable completeness\" column\n# this is a *proportion* of the columns designated as \"key_vars\" that have non-missing values\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %>% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) "},{"path":"de-duplication.html","id":"roll-up-values","chapter":"6 De-duplication","heading":"6.5 Roll-up values","text":"tab describes:“roll-” values multiple rows just one row, variationsOnce “rolled-” values, overwrite/prioritize values cellThis tab uses example dataset Preparation tab.","code":""},{"path":"de-duplication.html","id":"roll-up-values-into-one-row","chapter":"6 De-duplication","heading":"6.5.1 Roll-up values into one row","text":"code example uses group_by() summarise() group rows person, paste together unique values within grouped rows. Thus, get one summary row per person. notes:suffix appended new columns (\"_roll\" example)want show unique values per cell, wrap na.omit() unique()na.omit() removes NA values, desired can removed paste0(.x)…Scroll left see rowsThe result one row per group (ID), entries arranged date pasted together.variation shows unique values :variation appends suffix column.\r\ncase \"_roll\" signify rolled:","code":"\n# \"Roll-up\" values into one row per group (per \"personID\") \ncases_rolled <- obs %>% \n  \n  # create groups by name\n  group_by(personID) %>% \n  \n  # order the rows within each group (e.g. by date)\n  arrange(date, .by_group = TRUE) %>% \n  \n  # For each column, paste together all values within the grouped rows, separated by \";\"\n  summarise(\n    across(everything(),                           # apply to all columns\n           ~paste0(na.omit(.x), collapse = \"; \"))) # function is defined which combines non-NA values\n# Variation - show unique values only \ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(),                                   # apply to all columns\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # function is defined which combines unique non-NA values\n# Variation - suffix added to column names \ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll is appended to column names"},{"path":"de-duplication.html","id":"overwrite-valueshierarchy","chapter":"6 De-duplication","heading":"6.5.2 Overwrite values/hierarchy","text":"want evaluate rolled values, keep specific value (e.g. “best” “maximum” value), can use mutate() across desired columns, implement case_when(), uses str_detect() stringr package sequentially look string patterns overwrite cell content.Now can see column symptoms_ever person EVER said “Yes” symptoms, “Yes” displayed.","code":"\n# CLEAN CASES\n#############\ncases_clean <- cases_rolled %>% \n    \n    # clean Yes-No-Unknown vars: replace text with \"highest\" value present in the string\n    mutate(across(c(contains(\"symptoms_ever\")),                     # operates on specified columns (Y/N/U)\n             list(mod = ~case_when(                                 # adds suffix \"_mod\" to new cols; implements case_when()\n               \n               str_detect(.x, \"Yes\")       ~ \"Yes\",                 # if \"Yes\" is detected, then cell value converts to yes\n               str_detect(.x, \"No\")        ~ \"No\",                  # then, if \"No\" is detected, then cell value converts to no\n               str_detect(.x, \"Unknown\")   ~ \"Unknown\",             # then, if \"Unknown\" is detected, then cell value converts to Unknown\n               TRUE                        ~ as.character(.x)))),   # then, if anything else if it kept as is\n      .keep = \"unused\")                                             # old columns removed, leaving only _mod columns"},{"path":"de-duplication.html","id":"resources-1","chapter":"6 De-duplication","heading":"6.6 Resources","text":"Much information page adapted resources vignettes online:datanoviadplyr tidyverse referencecran janitor vignette","code":""},{"path":"age-pyramids.html","id":"age-pyramids","chapter":"7 Age pyramids","heading":"7 Age pyramids","text":"Age pyramids can useful show patterns age group. can show gender, distribution characteristics.\r\ntabs demonstrate produce age pyramids using:Fast & easy: Using apyramid packageMore flexible: Using ggplot()baseline demographics displayed background pyramidUsing pyramid-style plots show types data (e.g responses Likert-style questions)","code":""},{"path":"age-pyramids.html","id":"overview-3","chapter":"7 Age pyramids","heading":"7.1 Overview","text":"Age/gender demographic pyramids R generally made ggplot() creating two barplots (one gender), converting one’s values negative values, flipping x y axes display barplots vertically.offer quick approach apyramid package:customizable code using raw ggplot() commandsHow combine case demographic data compare baseline population (shown )Application methods show types data (e.g. responses Likert-style survey questions)","code":""},{"path":"age-pyramids.html","id":"preparation-3","chapter":"7 Age pyramids","heading":"7.2 Preparation","text":"tab use linelist dataset cleaned Cleaning tab.make traditional age/sex demographic pyramid, data must first cleaned following ways:gender column must cleaned.Age age category column, class Factor (correctly ordered levels)Load packagesFirst, load packages required analysis:Load dataCheck class variablesEnsure age variable class Numeric, check class order levels age_cat age_cat5","code":"\npacman::p_load(rio,       # to import data\n               here,      # to locate files\n               tidyverse, # to clean, handle, and plot the data (includes ggplot2 package)\n               apyramid,  # a package dedicated to creating age pyramids\n               stringr)   # working with strings for titles, captions, etc.\nlinelist <- rio::import(\"linelist_cleaned.csv\")\nclass(linelist$age_years)## [1] \"numeric\"\nclass(linelist$age_cat)## [1] \"factor\"\nclass(linelist$age_cat5)## [1] \"factor\"\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-69   70+  <NA> \r\n##  1081  1148   971   837  1091   628    45     0    88\ntable(linelist$age_cat5, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54 55-59 60-64 65-69 70-74 75-79 80-84   85+  <NA> \r\n##  1081  1148   971   837   600   491   295   181    98    54    26    14     2     3     0     0     0     0    88"},{"path":"age-pyramids.html","id":"apyramid-package","chapter":"7 Age pyramids","heading":"7.3 apyramid package","text":"package apyramid allows quickly make age pyramid. nuanced situations, see tab using ggplot() make age pyramids. can read apyramid package Help page entering ?age_pyramid R console.","code":""},{"path":"age-pyramids.html","id":"linelist-data","chapter":"7 Age pyramids","heading":"7.3.1 Linelist data","text":"Using cleaned linelist dataset, can create age pyramid just one simple command. need help cleaning data, see handbook page Cleaning data (LINK). command:data argument set linelist dataframeThe age_group argument set name (quotes) numeric category variable (case age_cat5)split_by argument (bar colors) binary column (case “gender”)\r\nusing agepyramid package, split_by column binary (e.g. male/female, yes/), result appear pyramid. However two values split_by column (including NA), pyramid appears faceted barplot empty bars background indicating range un-faceted data set age group. Values split_by appear labels top facet. example split_by variable “hospital”.Missing values\r\nRows missing values split_by age_group columns, coded NA, trigger faceting shown . default rows shown. However can specify appear, adjacent barplot separate age group top, specifying na.rm = FALSE.Proportions, colors, & aestheticsBy default, bars display counts (%), dashed mid-line group shown, colors green/purple. parameters can adjusted, shown :can also add additional ggplot() commands plot using standard ggplot() “+” syntax, aesthetic themes label adjustments:","code":"\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\")## Warning: 283 missing rows were removed (88 values from `age_cat5` and 283 values from `gender`).\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"hospital\",\n                      na.rm = FALSE)        # show a bar for patients missing age, (note: this changes the pyramid into a faceted barplot)\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      na.rm = FALSE)         # show patients missing age or gender\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      proportional = TRUE,                  # show percents, not counts\n                      show_midpoint = FALSE,                # remove bar mid-point line\n                      #pal = c(\"orange\", \"purple\")          # can specify alt. colors here (but not labels, see below)\n                      )+                 \n  \n  # additional ggplot commands\n  theme_minimal()+                                          # simplify the background\n  scale_fill_manual(values = c(\"orange\", \"purple\"),         # to specify colors AND labels\n                     labels = c(\"Male\", \"Female\"))+\n  labs(y = \"Percent of all cases\",                          # note that x and y labels are switched (see ggplot tab)\n       x = \"Age categories\",                          \n       fill = \"Gender\", \n       caption = \"My data source and caption here\",\n       title = \"Title of my plot\",\n       subtitle = \"Subtitle with \\n a second line...\")+\n  theme(\n    legend.position = \"bottom\",                             # move legend to bottom\n    axis.text = element_text(size = 10, face = \"bold\"),     # fonts/sizes, see ggplot tips page\n    axis.title = element_text(size = 12, face = \"bold\"))## Warning: 283 missing rows were removed (88 values from `age_cat5` and 283 values from `gender`).## Scale for 'fill' is already present. Adding another scale for 'fill', which will replace the existing scale."},{"path":"age-pyramids.html","id":"aggregated-data","chapter":"7 Age pyramids","heading":"7.3.2 Aggregated data","text":"examples assume data linelist-like format, one row per observation. data already aggregated counts age category, can still use apyramid package, shown .Let’s say dataset looks like , columns age category, male counts, female counts, missing counts.\r\n(see handbook page Transforming data tips)ggplot() perfers data “long” format, first pivot data “long” pivot_longer() function dplyr.use split_by count arguments age_pyramid() specify respective columns:Note , factor order “m” “f” different (pyramid reversed). adjust order must re-define gender aggredated data Factor order levels desired.","code":"## `summarise()` has grouped output by 'age_cat5'. You can override using the `.groups` argument.\n# View the aggregated data\nDT::datatable(demo_agg, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\n# pivot the aggregated data into long format\ndemo_agg_long <- demo_agg %>% \n  pivot_longer(c(f, m, missing_gender),            # cols to elongate\n               names_to = \"gender\",                # name for new col of categories\n               values_to = \"counts\") %>%           # name for new col of counts\n  mutate(gender = na_if(gender, \"missing_gender\")) # convert \"missing_gender\" to NA\n# View the aggregated data\nDT::datatable(demo_agg_long, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\napyramid::age_pyramid(data = demo_agg_long,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      count = \"counts\")      # give the column name for the aggregated counts## Warning: Removed 19 rows containing missing values (position_stack).## Warning: Removed 19 rows containing missing values."},{"path":"age-pyramids.html","id":"ggplot","chapter":"7 Age pyramids","heading":"7.4 ggplot()","text":"Using ggplot() build age pyramid allows flexibility, requires effort understanding ggplot() works. also easier accidentally make mistakes.apyramid uses ggplot() background (accepts ggplot() commands added), page shows adjust recreate pyramid using ggplot(), wish.","code":""},{"path":"age-pyramids.html","id":"constructing-the-plot","chapter":"7 Age pyramids","heading":"7.4.1 Constructing the plot","text":"First, understand make pyramid using ggplot() approach :Within ggplot(), create two graphs age category. Create one two grouping values (case gender). See filters applied data arguments geom_histogram() commands .Within ggplot(), create two graphs age category. Create one two grouping values (case gender). See filters applied data arguments geom_histogram() commands .using geom_histogram(), graphs operate numeric column (e.g. age_years), whereas using geom_barplot() graphs operate ordered Factor (e.g. age_cat5).using geom_histogram(), graphs operate numeric column (e.g. age_years), whereas using geom_barplot() graphs operate ordered Factor (e.g. age_cat5).One graph positive count values, counts converted negative values - allows graphs seen compared plot.One graph positive count values, counts converted negative values - allows graphs seen compared plot.command coord_flip() switches X Y axes, resulting graphs turning vertical creating pyramid.command coord_flip() switches X Y axes, resulting graphs turning vertical creating pyramid.Lastly, counts-axis labels must specified appear “positive” counts sides pyramid (despite underlying values one side negative).Lastly, counts-axis labels must specified appear “positive” counts sides pyramid (despite underlying values one side negative).simple version , using geom_histogram(), :DANGER: limits counts axis set low, counts bar exceeds , bar disappear entirely artificially shortened! Watch analyzing data routinely updated. Prevent count-axis limits auto-adjust data, .many things can change/add simple version, including:Auto adjust counts-axis count scale data (avoid errors discussed warning )Manually specify colors legend labels","code":"\n  # begin ggplot\n  ggplot(data = linelist, aes(x = age, fill = gender)) +\n  \n  # female histogram\n  geom_histogram(data = filter(linelist, gender == \"f\"),\n                 breaks = seq(0,85,5),\n                 colour = \"white\") +\n  \n  # male histogram (values converted to negative)\n  geom_histogram(data = filter(linelist, gender == \"m\"),\n                 breaks = seq(0,85,5),\n                 aes(y=..count..*(-1)),\n                 colour = \"white\") +\n  \n  # flip the X and Y axes\n  coord_flip() +\n  \n  # adjust counts-axis scale\n  scale_y_continuous(limits = c(-600, 900),\n                     breaks = seq(-600,900,100),\n                     labels = abs(seq(-600, 900, 100)))\n# create dataset with proportion of total\npyramid_data <- linelist %>%\n  group_by(age_cat5, gender) %>% \n  summarize(counts = n()) %>% \n  ungroup() %>% \n  mutate(percent = round(100*(counts / sum(counts, na.rm=T)),1), \n         percent = case_when(\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,\n            TRUE          ~ NA_real_))## `summarise()` has grouped output by 'age_cat5'. You can override using the `.groups` argument.\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n\n\n# begin ggplot\n  ggplot()+  # default x-axis is age in years;\n\n  # case data graph\n  geom_bar(data = pyramid_data,\n           stat = \"identity\",\n           aes(x = age_cat5,\n               y = percent,\n               fill = gender),        # \n           colour = \"white\")+         # white around each bar\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n\n  # adjust the axes scales (remember they are flipped now!)\n  #scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +\n  scale_y_continuous(limits = c(min_per, max_per),\n                     breaks = seq(floor(min_per), ceiling(max_per), 2),\n                     labels = paste0(abs(seq(floor(min_per), ceiling(max_per), 2)), \"%\"))+\n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",\n               \"m\" = \"darkgreen\"),\n    labels = c(\"Female\", \"Male\"),\n  ) +\n  \n  # label values (remember X and Y flipped now)\n  labs(\n    x = \"Age group\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), '%d %b %Y')}\")) +\n  \n  # optional aesthetic themes\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0.5), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\")) + \n  \n  ggtitle(paste0(\"Age and gender of cases\"))## Warning: Removed 12 rows containing missing values (position_stack)."},{"path":"age-pyramids.html","id":"compare-to-baseline","chapter":"7 Age pyramids","heading":"7.4.2 Compare to baseline","text":"flexibility ggplot(), can second layer bars background represent true population pyramid. can provide nice visualization compare observed counts baseline.Import view population dataFirst data management steps:record order age categories want appear. Due quirks way ggplot() implemented, easiest store character vector use later plotting function.Combine population case data dplyr function bind_rows():First, ensure exact column names, age categories values, gender valuesMake data structure: columns age category, gender, counts, percent totalBind together, one -top (bind_rows())Review changed population datasetNow implement case linelist. Slightly different begins case-rows, counts.Review changed case datasetNow two datasets combined, one top (column names)Store maximum minimum percent values, used plotting funtion define extent plot (cut bars!)Now plot made ggplot():One bar graph population data (wider, transparent bars)One bar graph case data (small, solid bars)","code":"\n# import the population demographics data\npop <- rio::import(\"country_demographics.csv\")\n# display the linelist data as a table\nDT::datatable(pop, rownames = FALSE, filter=\"top\", options = list(pageLength = 10, scrollX=T) )\n# record correct age cat levels\nage_levels <- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n# create/transform populaton data, with percent of total\n########################################################\npop_data <- pivot_longer(pop, c(m, f), names_to = \"gender\", values_to = \"counts\") %>% # pivot gender columns longer\n  mutate(data = \"population\",                                                         # add column designating data source\n         percent  = round(100*(counts / sum(counts, na.rm=T)),1),                     # calculate % of total\n         percent  = case_when(                                                        # if male, convert % to negative\n                            gender == \"f\" ~ percent,\n                            gender == \"m\" ~ -percent,\n                            TRUE          ~ NA_real_))\n# display the linelist data as a table\nDT::datatable(pop_data, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\n# create case data by age/gender, with percent of total\n#######################################################\ncase_data <- linelist %>%\n  group_by(age_cat5, gender) %>%  # aggregate linelist cases into age-gender groups\n  summarize(counts = n()) %>%     # calculate counts per age-gender group\n  ungroup() %>% \n  mutate(data = \"cases\",                                          # add column designating data source\n         percent = round(100*(counts / sum(counts, na.rm=T)),1),  # calculate % of total for age-gender groups\n         percent = case_when(                                     # convert % to negative if male\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,\n            TRUE          ~ NA_real_))## `summarise()` has grouped output by 'age_cat5'. You can override using the `.groups` argument.\n# display the linelist data as a table\nDT::datatable(case_data, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\n# combine case and population data (same column names, age_cat values, and gender values)\npyramid_data <- bind_rows(case_data, pop_data)\n# Define extent of percent axis, used for plot limits\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n# begin ggplot\n##############\nggplot()+  # default x-axis is age in years;\n\n  # population data graph\n  geom_bar(data = filter(pyramid_data, data == \"population\"),\n           stat = \"identity\",\n           aes(x = age_cat5,\n               y = percent,\n               fill = gender),        \n           colour = \"black\",                               # black color around bars\n           alpha = 0.2,                                    # more transparent\n           width = 1)+                                     # full width\n  \n  # case data graph\n  geom_bar(data = filter(pyramid_data, data == \"cases\"), \n           stat = \"identity\",                              # use % as given in data, not counting rows\n           aes(x = age_cat5,                               # age categories as original X axis\n               y = percent,                                # % as original Y-axis\n               fill = gender),                             # fill of bars by gender\n           colour = \"black\",                               # black color around bars\n           alpha = 1,                                      # not transparent \n           width = 0.3)+                                   # half width\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n  # adjust axes order, scale, and labels (remember X and Y axes are flipped now)\n  # manually ensure that age-axis is ordered correctly\n  scale_x_discrete(limits = age_levels)+ \n  \n  # set percent-axis \n  scale_y_continuous(limits = c(min_per, max_per),                                          # min and max defined above\n                     breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # from min% to max% by 2 \n                     labels = paste0(                                                       # for the labels, paste together... \n                       abs(seq(floor(min_per), ceiling(max_per), by = 2)),                  # ...rounded absolute values of breaks... \n                       \"%\"))+                                                               # ... with \"%\"\n                                                                                            # floor(), ceiling() round down and up \n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",         # assign colors to values in the data\n               \"m\" = \"darkgreen\"),\n    labels = c(\"f\" = \"Female\",\n               \"m\"= \"Male\"),      # change labels that appear in legend, note order\n  ) +\n\n  # plot labels, titles, caption    \n  labs(\n    title = \"Case age and gender distribution,\\nas compared to baseline population\",\n    subtitle = \"\",\n    x = \"Age category\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}\")) +\n  \n  # optional aesthetic themes\n  theme(\n    legend.position = \"bottom\",                             # move legend to bottom\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\"))## Warning: Removed 12 rows containing missing values (position_stack)."},{"path":"age-pyramids.html","id":"likert-scale","chapter":"7 Age pyramids","heading":"7.5 Likert scale","text":"techniques used make population pyramid ggplot() can also used make plots Likert-scale survey data.Import dataStart data looks like , categorical classification respondent (status) answers 8 questions 4-point Likert-type scale (“poor”, “Poor”, “Good”, “good”).First, data management steps:Pivot data longerCreate new column direction depending whether response generally “positive” “negative”Set Factor level order status column Response columnStore max count value limits plot appropriateNow make plot:","code":"\n# import the likert survey response data\nlikert_data <- rio::import(\"likert_data.csv\")\n# display the linelist data as a table\nDT::datatable(likert_data, rownames = FALSE, filter=\"top\", options = list(pageLength = 10, scrollX=T) )\nmelted <- pivot_longer(likert_data, Q1:Q8, names_to = \"Question\", values_to = \"Response\") %>% \n     mutate(direction = case_when(\n               Response %in% c(\"Poor\",\"Very Poor\") ~ \"Negative\",\n               Response %in% c(\"Good\", \"Very Good\") ~ \"Positive\",\n               TRUE ~ \"Unknown\"),\n            status = factor(status, levels = rev(c(\n                 \"Senior\", \"Intermediate\", \"Junior\"))),\n            Response = factor(Response, levels = c(\"Very Good\", \"Good\",\n                                             \"Very Poor\", \"Poor\"))) # must reverse Very Poor and Poor for ordering to work\n\nmelted_max <- melted %>% \n   group_by(status, Question) %>% \n   summarize(n = n())## `summarise()` has grouped output by 'status'. You can override using the `.groups` argument.\nmelted_max <- max(melted_max$n, na.rm=T)\n# make plot\nggplot()+\n     # bar graph of the \"negative\" responses \n     geom_bar(data = filter(melted,\n                            direction == \"Negative\"), \n              aes(x = status,\n                        y=..count..*(-1),    # counts inverted to negative\n                        fill = Response),\n                    color = \"black\",\n                    closed = \"left\", \n                    position = \"stack\")+\n     \n     # bar graph of the \"positive responses\n     geom_bar(data = filter(melted, direction == \"Positive\"),\n              aes(x = status, fill = Response),\n              colour = \"black\",\n              closed = \"left\",\n              position = \"stack\")+\n     \n     # flip the X and Y axes\n     coord_flip()+\n  \n     # Black vertical line at 0\n     geom_hline(yintercept = 0, color = \"black\", size=1)+\n     \n    # convert labels to all positive numbers\n    scale_y_continuous(limits = c(-ceiling(melted_max/10)*11, ceiling(melted_max/10)*10),   # seq from neg to pos by 10, edges rounded outward to nearest 5\n                       breaks = seq(-ceiling(melted_max/10)*10, ceiling(melted_max/10)*10, 10),\n                       labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),\n                                            seq(0, ceiling(melted_max/10)*10, 10))))) +\n     \n    # color scales manually assigned \n    scale_fill_manual(values = c(\"Very Good\"  = \"green4\", # assigns colors\n                                  \"Good\"      = \"green3\",\n                                  \"Poor\"      = \"yellow\",\n                                  \"Very Poor\" = \"red3\"),\n                       breaks = c(\"Very Good\", \"Good\", \"Poor\", \"Very Poor\"))+ # orders the legend\n     \n    \n     \n    # facet the entire plot so each question is a sub-plot\n    facet_wrap(~Question, ncol = 3)+\n     \n    # labels, titles, caption\n    labs(x = \"Respondent status\",\n          y = \"Number of responses\",\n          fill = \"\")+\n     ggtitle(str_glue(\"Likert-style responses\\nn = {nrow(likert_data)}\"))+\n\n     # aesthetic settings\n     theme_minimal()+\n     theme(axis.text = element_text(size = 12),\n           axis.title = element_text(size = 14, face = \"bold\"),\n           strip.text = element_text(size = 14, face = \"bold\"),  # facet sub-titles\n           plot.title = element_text(size = 20, face = \"bold\"),\n           panel.background = element_rect(fill = NA, color = \"black\")) # black box around each facet## Warning: Ignoring unknown parameters: closed\r\n\r\n## Warning: Ignoring unknown parameters: closed"},{"path":"age-pyramids.html","id":"resources-2","chapter":"7 Age pyramids","heading":"7.6 Resources","text":"tab stay name “Resources”.\r\nLinks online tutorials resources.","code":""}]
